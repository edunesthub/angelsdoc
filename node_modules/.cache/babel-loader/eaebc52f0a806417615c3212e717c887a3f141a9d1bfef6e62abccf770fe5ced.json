{"ast":null,"code":"'use client';\n\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useEffect, useMemo } from 'react';\nimport clsx from 'clsx';\nimport makeCancellable from 'make-cancellable-promise';\nimport makeEventProps from 'make-event-props';\nimport invariant from 'tiny-invariant';\nimport warning from 'warning';\nimport OutlineContext from './OutlineContext.js';\nimport OutlineItem from './OutlineItem.js';\nimport useDocumentContext from './shared/hooks/useDocumentContext.js';\nimport useResolver from './shared/hooks/useResolver.js';\nimport { cancelRunningTask } from './shared/utils.js';\n/**\n * Displays an outline (table of contents).\n *\n * Should be placed inside `<Document />`. Alternatively, it can have `pdf` prop passed, which can be obtained from `<Document />`'s `onLoadSuccess` callback function.\n */\nexport default function Outline(props) {\n  const documentContext = useDocumentContext();\n  const mergedProps = {\n    ...documentContext,\n    ...props\n  };\n  const {\n    className,\n    inputRef,\n    onItemClick,\n    onLoadError: onLoadErrorProps,\n    onLoadSuccess: onLoadSuccessProps,\n    pdf,\n    ...otherProps\n  } = mergedProps;\n  invariant(pdf, 'Attempted to load an outline, but no document was specified. Wrap <Outline /> in a <Document /> or pass explicit `pdf` prop.');\n  const [outlineState, outlineDispatch] = useResolver();\n  const {\n    value: outline,\n    error: outlineError\n  } = outlineState;\n  /**\n   * Called when an outline is read successfully\n   */\n  function onLoadSuccess() {\n    if (typeof outline === 'undefined' || outline === false) {\n      return;\n    }\n    if (onLoadSuccessProps) {\n      onLoadSuccessProps(outline);\n    }\n  }\n  /**\n   * Called when an outline failed to read successfully\n   */\n  function onLoadError() {\n    if (!outlineError) {\n      // Impossible, but TypeScript doesn't know that\n      return;\n    }\n    warning(false, outlineError.toString());\n    if (onLoadErrorProps) {\n      onLoadErrorProps(outlineError);\n    }\n  }\n  // biome-ignore lint/correctness/useExhaustiveDependencies: useEffect intentionally triggered on pdf change\n  useEffect(function resetOutline() {\n    outlineDispatch({\n      type: 'RESET'\n    });\n  }, [outlineDispatch, pdf]);\n  useEffect(function loadOutline() {\n    if (!pdf) {\n      // Impossible, but TypeScript doesn't know that\n      return;\n    }\n    const cancellable = makeCancellable(pdf.getOutline());\n    const runningTask = cancellable;\n    cancellable.promise.then(nextOutline => {\n      outlineDispatch({\n        type: 'RESOLVE',\n        value: nextOutline\n      });\n    }).catch(error => {\n      outlineDispatch({\n        type: 'REJECT',\n        error\n      });\n    });\n    return () => cancelRunningTask(runningTask);\n  }, [outlineDispatch, pdf]);\n  // biome-ignore lint/correctness/useExhaustiveDependencies: Omitted callbacks so they are not called every time they change\n  useEffect(() => {\n    if (outline === undefined) {\n      return;\n    }\n    if (outline === false) {\n      onLoadError();\n      return;\n    }\n    onLoadSuccess();\n  }, [outline]);\n  const childContext = useMemo(() => ({\n    onItemClick\n  }), [onItemClick]);\n  const eventProps = useMemo(() => makeEventProps(otherProps, () => outline),\n  // biome-ignore lint/correctness/useExhaustiveDependencies: FIXME\n  [otherProps, outline]);\n  if (!outline) {\n    return null;\n  }\n  function renderOutline() {\n    if (!outline) {\n      return null;\n    }\n    return _jsx(\"ul\", {\n      children: outline.map((item, itemIndex) => _jsx(OutlineItem, {\n        item: item,\n        pdf: pdf\n      }, typeof item.dest === 'string' ? item.dest : itemIndex))\n    });\n  }\n  return _jsx(\"div\", {\n    className: clsx('react-pdf__Outline', className),\n    ref: inputRef,\n    ...eventProps,\n    children: _jsx(OutlineContext.Provider, {\n      value: childContext,\n      children: renderOutline()\n    })\n  });\n}","map":{"version":3,"names":["jsx","_jsx","useEffect","useMemo","clsx","makeCancellable","makeEventProps","invariant","warning","OutlineContext","OutlineItem","useDocumentContext","useResolver","cancelRunningTask","Outline","props","documentContext","mergedProps","className","inputRef","onItemClick","onLoadError","onLoadErrorProps","onLoadSuccess","onLoadSuccessProps","pdf","otherProps","outlineState","outlineDispatch","value","outline","error","outlineError","toString","resetOutline","type","loadOutline","cancellable","getOutline","runningTask","promise","then","nextOutline","catch","undefined","childContext","eventProps","renderOutline","children","map","item","itemIndex","dest","ref","Provider"],"sources":["/Users/gabrielakpagli/Documents/GitHub/angelsdoc/node_modules/react-pdf/dist/Outline.js"],"sourcesContent":["'use client';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useEffect, useMemo } from 'react';\nimport clsx from 'clsx';\nimport makeCancellable from 'make-cancellable-promise';\nimport makeEventProps from 'make-event-props';\nimport invariant from 'tiny-invariant';\nimport warning from 'warning';\nimport OutlineContext from './OutlineContext.js';\nimport OutlineItem from './OutlineItem.js';\nimport useDocumentContext from './shared/hooks/useDocumentContext.js';\nimport useResolver from './shared/hooks/useResolver.js';\nimport { cancelRunningTask } from './shared/utils.js';\n/**\n * Displays an outline (table of contents).\n *\n * Should be placed inside `<Document />`. Alternatively, it can have `pdf` prop passed, which can be obtained from `<Document />`'s `onLoadSuccess` callback function.\n */\nexport default function Outline(props) {\n    const documentContext = useDocumentContext();\n    const mergedProps = { ...documentContext, ...props };\n    const { className, inputRef, onItemClick, onLoadError: onLoadErrorProps, onLoadSuccess: onLoadSuccessProps, pdf, ...otherProps } = mergedProps;\n    invariant(pdf, 'Attempted to load an outline, but no document was specified. Wrap <Outline /> in a <Document /> or pass explicit `pdf` prop.');\n    const [outlineState, outlineDispatch] = useResolver();\n    const { value: outline, error: outlineError } = outlineState;\n    /**\n     * Called when an outline is read successfully\n     */\n    function onLoadSuccess() {\n        if (typeof outline === 'undefined' || outline === false) {\n            return;\n        }\n        if (onLoadSuccessProps) {\n            onLoadSuccessProps(outline);\n        }\n    }\n    /**\n     * Called when an outline failed to read successfully\n     */\n    function onLoadError() {\n        if (!outlineError) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        warning(false, outlineError.toString());\n        if (onLoadErrorProps) {\n            onLoadErrorProps(outlineError);\n        }\n    }\n    // biome-ignore lint/correctness/useExhaustiveDependencies: useEffect intentionally triggered on pdf change\n    useEffect(function resetOutline() {\n        outlineDispatch({ type: 'RESET' });\n    }, [outlineDispatch, pdf]);\n    useEffect(function loadOutline() {\n        if (!pdf) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        const cancellable = makeCancellable(pdf.getOutline());\n        const runningTask = cancellable;\n        cancellable.promise\n            .then((nextOutline) => {\n            outlineDispatch({ type: 'RESOLVE', value: nextOutline });\n        })\n            .catch((error) => {\n            outlineDispatch({ type: 'REJECT', error });\n        });\n        return () => cancelRunningTask(runningTask);\n    }, [outlineDispatch, pdf]);\n    // biome-ignore lint/correctness/useExhaustiveDependencies: Omitted callbacks so they are not called every time they change\n    useEffect(() => {\n        if (outline === undefined) {\n            return;\n        }\n        if (outline === false) {\n            onLoadError();\n            return;\n        }\n        onLoadSuccess();\n    }, [outline]);\n    const childContext = useMemo(() => ({\n        onItemClick,\n    }), [onItemClick]);\n    const eventProps = useMemo(() => makeEventProps(otherProps, () => outline), \n    // biome-ignore lint/correctness/useExhaustiveDependencies: FIXME\n    [otherProps, outline]);\n    if (!outline) {\n        return null;\n    }\n    function renderOutline() {\n        if (!outline) {\n            return null;\n        }\n        return (_jsx(\"ul\", { children: outline.map((item, itemIndex) => (_jsx(OutlineItem, { item: item, pdf: pdf }, typeof item.dest === 'string' ? item.dest : itemIndex))) }));\n    }\n    return (_jsx(\"div\", { className: clsx('react-pdf__Outline', className), ref: inputRef, ...eventProps, children: _jsx(OutlineContext.Provider, { value: childContext, children: renderOutline() }) }));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}