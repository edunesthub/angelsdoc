{"ast":null,"code":"/**\n * @licstart The following is the entire license notice for the\n * JavaScript code in this page\n *\n * Copyright 2023 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @licend The above is the entire license notice for the\n * JavaScript code in this page\n */var e = {\n    d: (t, i) => {\n      for (var a in i) e.o(i, a) && !e.o(t, a) && Object.defineProperty(t, a, {\n        enumerable: !0,\n        get: i[a]\n      });\n    },\n    o: (e, t) => Object.prototype.hasOwnProperty.call(e, t)\n  },\n  __webpack_exports__ = globalThis.pdfjsWorker = {};\ne.d(__webpack_exports__, {\n  WorkerMessageHandler: () => WorkerMessageHandler\n});\nconst t = !(\"object\" != typeof process || process + \"\" != \"[object process]\" || process.versions.nw || process.versions.electron && process.type && \"browser\" !== process.type),\n  i = [1, 0, 0, 1, 0, 0],\n  a = [.001, 0, 0, .001, 0, 0],\n  s = 1.35,\n  r = .35,\n  n = .25925925925925924,\n  g = 1,\n  o = 2,\n  c = 4,\n  C = 8,\n  h = 16,\n  l = 64,\n  Q = 256,\n  E = \"pdfjs_internal_editor_\",\n  u = 3,\n  d = 9,\n  f = 13,\n  p = 15,\n  m = {\n    PRINT: 4,\n    MODIFY_CONTENTS: 8,\n    COPY: 16,\n    MODIFY_ANNOTATIONS: 32,\n    FILL_INTERACTIVE_FORMS: 256,\n    COPY_FOR_ACCESSIBILITY: 512,\n    ASSEMBLE: 1024,\n    PRINT_HIGH_QUALITY: 2048\n  },\n  y = 0,\n  w = 4,\n  D = 1,\n  b = 2,\n  F = 3,\n  S = 1,\n  k = 2,\n  R = 3,\n  N = 4,\n  G = 5,\n  x = 6,\n  U = 7,\n  M = 8,\n  L = 9,\n  H = 10,\n  J = 11,\n  Y = 12,\n  v = 13,\n  K = 14,\n  T = 15,\n  q = 16,\n  O = 17,\n  W = 20,\n  j = \"Group\",\n  X = \"R\",\n  Z = 1,\n  V = 2,\n  z = 4,\n  _ = 16,\n  $ = 32,\n  AA = 128,\n  eA = 512,\n  tA = 1,\n  iA = 2,\n  aA = 4096,\n  sA = 8192,\n  rA = 32768,\n  nA = 65536,\n  gA = 131072,\n  oA = 1048576,\n  IA = 2097152,\n  cA = 8388608,\n  CA = 16777216,\n  hA = 1,\n  BA = 2,\n  lA = 3,\n  QA = 4,\n  EA = 5,\n  uA = {\n    E: \"Mouse Enter\",\n    X: \"Mouse Exit\",\n    D: \"Mouse Down\",\n    U: \"Mouse Up\",\n    Fo: \"Focus\",\n    Bl: \"Blur\",\n    PO: \"PageOpen\",\n    PC: \"PageClose\",\n    PV: \"PageVisible\",\n    PI: \"PageInvisible\",\n    K: \"Keystroke\",\n    F: \"Format\",\n    V: \"Validate\",\n    C: \"Calculate\"\n  },\n  dA = {\n    WC: \"WillClose\",\n    WS: \"WillSave\",\n    DS: \"DidSave\",\n    WP: \"WillPrint\",\n    DP: \"DidPrint\"\n  },\n  fA = {\n    O: \"PageOpen\",\n    C: \"PageClose\"\n  },\n  pA = {\n    ERRORS: 0,\n    WARNINGS: 1,\n    INFOS: 5\n  },\n  mA = {\n    NONE: 0,\n    BINARY: 1\n  },\n  yA = 1,\n  wA = 2,\n  DA = 3,\n  bA = 4,\n  FA = 5,\n  SA = 6,\n  kA = 7,\n  RA = 8,\n  NA = 9,\n  GA = 10,\n  xA = 11,\n  UA = 12,\n  MA = 13,\n  LA = 14,\n  HA = 15,\n  JA = 16,\n  YA = 17,\n  vA = 18,\n  KA = 19,\n  TA = 20,\n  qA = 21,\n  OA = 22,\n  PA = 23,\n  WA = 24,\n  jA = 25,\n  XA = 26,\n  ZA = 27,\n  VA = 28,\n  zA = 29,\n  _A = 30,\n  $A = 31,\n  Ae = 32,\n  ee = 33,\n  te = 34,\n  ie = 35,\n  ae = 36,\n  se = 37,\n  re = 38,\n  ne = 39,\n  ge = 40,\n  oe = 41,\n  Ie = 42,\n  ce = 43,\n  Ce = 44,\n  he = 45,\n  Be = 46,\n  le = 47,\n  Qe = 48,\n  Ee = 49,\n  ue = 50,\n  de = 51,\n  fe = 52,\n  pe = 53,\n  me = 54,\n  ye = 55,\n  we = 56,\n  De = 57,\n  be = 58,\n  Fe = 59,\n  Se = 60,\n  ke = 61,\n  Re = 62,\n  Ne = 63,\n  Ge = 64,\n  xe = 65,\n  Ue = 66,\n  Me = 67,\n  Le = 68,\n  He = 69,\n  Je = 70,\n  Ye = 71,\n  ve = 72,\n  Ke = 73,\n  Te = 74,\n  qe = 75,\n  Oe = 76,\n  Pe = 77,\n  We = 80,\n  je = 81,\n  Xe = 83,\n  Ze = 84,\n  Ve = 85,\n  ze = 86,\n  _e = 87,\n  $e = 88,\n  At = 89,\n  et = 90,\n  tt = 91,\n  it = 1,\n  at = 2;\nlet st = pA.WARNINGS;\nfunction getVerbosityLevel() {\n  return st;\n}\nfunction info(e) {\n  st >= pA.INFOS && console.log(`Info: ${e}`);\n}\nfunction warn(e) {\n  st >= pA.WARNINGS && console.log(`Warning: ${e}`);\n}\nfunction unreachable(e) {\n  throw new Error(e);\n}\nfunction assert(e, t) {\n  e || unreachable(t);\n}\nfunction createValidAbsoluteUrl(e, t = null, i = null) {\n  if (!e) return null;\n  try {\n    if (i && \"string\" == typeof e) {\n      if (i.addDefaultProtocol && e.startsWith(\"www.\")) {\n        const t = e.match(/\\./g);\n        t?.length >= 2 && (e = `http://${e}`);\n      }\n      if (i.tryConvertEncoding) try {\n        e = stringToUTF8String(e);\n      } catch {}\n    }\n    const a = t ? new URL(e, t) : new URL(e);\n    if (function _isValidProtocol(e) {\n      switch (e?.protocol) {\n        case \"http:\":\n        case \"https:\":\n        case \"ftp:\":\n        case \"mailto:\":\n        case \"tel:\":\n          return !0;\n        default:\n          return !1;\n      }\n    }(a)) return a;\n  } catch {}\n  return null;\n}\nfunction shadow(e, t, i, a = !1) {\n  Object.defineProperty(e, t, {\n    value: i,\n    enumerable: !a,\n    configurable: !0,\n    writable: !1\n  });\n  return i;\n}\nconst rt = function BaseExceptionClosure() {\n  function BaseException(e, t) {\n    this.constructor === BaseException && unreachable(\"Cannot initialize BaseException.\");\n    this.message = e;\n    this.name = t;\n  }\n  BaseException.prototype = new Error();\n  BaseException.constructor = BaseException;\n  return BaseException;\n}();\nclass PasswordException extends rt {\n  constructor(e, t) {\n    super(e, \"PasswordException\");\n    this.code = t;\n  }\n}\nclass UnknownErrorException extends rt {\n  constructor(e, t) {\n    super(e, \"UnknownErrorException\");\n    this.details = t;\n  }\n}\nclass InvalidPDFException extends rt {\n  constructor(e) {\n    super(e, \"InvalidPDFException\");\n  }\n}\nclass MissingPDFException extends rt {\n  constructor(e) {\n    super(e, \"MissingPDFException\");\n  }\n}\nclass UnexpectedResponseException extends rt {\n  constructor(e, t) {\n    super(e, \"UnexpectedResponseException\");\n    this.status = t;\n  }\n}\nclass FormatError extends rt {\n  constructor(e) {\n    super(e, \"FormatError\");\n  }\n}\nclass AbortException extends rt {\n  constructor(e) {\n    super(e, \"AbortException\");\n  }\n}\nfunction bytesToString(e) {\n  \"object\" == typeof e && void 0 !== e?.length || unreachable(\"Invalid argument for bytesToString\");\n  const t = e.length,\n    i = 8192;\n  if (t < i) return String.fromCharCode.apply(null, e);\n  const a = [];\n  for (let s = 0; s < t; s += i) {\n    const r = Math.min(s + i, t),\n      n = e.subarray(s, r);\n    a.push(String.fromCharCode.apply(null, n));\n  }\n  return a.join(\"\");\n}\nfunction stringToBytes(e) {\n  \"string\" != typeof e && unreachable(\"Invalid argument for stringToBytes\");\n  const t = e.length,\n    i = new Uint8Array(t);\n  for (let a = 0; a < t; ++a) i[a] = 255 & e.charCodeAt(a);\n  return i;\n}\nfunction string32(e) {\n  return String.fromCharCode(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e);\n}\nfunction objectSize(e) {\n  return Object.keys(e).length;\n}\nclass FeatureTest {\n  static get isLittleEndian() {\n    return shadow(this, \"isLittleEndian\", function isLittleEndian() {\n      const e = new Uint8Array(4);\n      e[0] = 1;\n      return 1 === new Uint32Array(e.buffer, 0, 1)[0];\n    }());\n  }\n  static get isEvalSupported() {\n    return shadow(this, \"isEvalSupported\", function isEvalSupported() {\n      try {\n        new Function(\"\");\n        return !0;\n      } catch {\n        return !1;\n      }\n    }());\n  }\n  static get isOffscreenCanvasSupported() {\n    return shadow(this, \"isOffscreenCanvasSupported\", \"undefined\" != typeof OffscreenCanvas);\n  }\n  static get platform() {\n    return \"undefined\" != typeof navigator && \"string\" == typeof navigator?.platform ? shadow(this, \"platform\", {\n      isMac: navigator.platform.includes(\"Mac\")\n    }) : shadow(this, \"platform\", {\n      isMac: !1\n    });\n  }\n  static get isCSSRoundSupported() {\n    return shadow(this, \"isCSSRoundSupported\", globalThis.CSS?.supports?.(\"width: round(1.5px, 1px)\"));\n  }\n}\nconst nt = Array.from(Array(256).keys(), e => e.toString(16).padStart(2, \"0\"));\nclass Util {\n  static makeHexColor(e, t, i) {\n    return `#${nt[e]}${nt[t]}${nt[i]}`;\n  }\n  static scaleMinMax(e, t) {\n    let i;\n    if (e[0]) {\n      if (e[0] < 0) {\n        i = t[0];\n        t[0] = t[2];\n        t[2] = i;\n      }\n      t[0] *= e[0];\n      t[2] *= e[0];\n      if (e[3] < 0) {\n        i = t[1];\n        t[1] = t[3];\n        t[3] = i;\n      }\n      t[1] *= e[3];\n      t[3] *= e[3];\n    } else {\n      i = t[0];\n      t[0] = t[1];\n      t[1] = i;\n      i = t[2];\n      t[2] = t[3];\n      t[3] = i;\n      if (e[1] < 0) {\n        i = t[1];\n        t[1] = t[3];\n        t[3] = i;\n      }\n      t[1] *= e[1];\n      t[3] *= e[1];\n      if (e[2] < 0) {\n        i = t[0];\n        t[0] = t[2];\n        t[2] = i;\n      }\n      t[0] *= e[2];\n      t[2] *= e[2];\n    }\n    t[0] += e[4];\n    t[1] += e[5];\n    t[2] += e[4];\n    t[3] += e[5];\n  }\n  static transform(e, t) {\n    return [e[0] * t[0] + e[2] * t[1], e[1] * t[0] + e[3] * t[1], e[0] * t[2] + e[2] * t[3], e[1] * t[2] + e[3] * t[3], e[0] * t[4] + e[2] * t[5] + e[4], e[1] * t[4] + e[3] * t[5] + e[5]];\n  }\n  static applyTransform(e, t) {\n    return [e[0] * t[0] + e[1] * t[2] + t[4], e[0] * t[1] + e[1] * t[3] + t[5]];\n  }\n  static applyInverseTransform(e, t) {\n    const i = t[0] * t[3] - t[1] * t[2];\n    return [(e[0] * t[3] - e[1] * t[2] + t[2] * t[5] - t[4] * t[3]) / i, (-e[0] * t[1] + e[1] * t[0] + t[4] * t[1] - t[5] * t[0]) / i];\n  }\n  static getAxialAlignedBoundingBox(e, t) {\n    const i = this.applyTransform(e, t),\n      a = this.applyTransform(e.slice(2, 4), t),\n      s = this.applyTransform([e[0], e[3]], t),\n      r = this.applyTransform([e[2], e[1]], t);\n    return [Math.min(i[0], a[0], s[0], r[0]), Math.min(i[1], a[1], s[1], r[1]), Math.max(i[0], a[0], s[0], r[0]), Math.max(i[1], a[1], s[1], r[1])];\n  }\n  static inverseTransform(e) {\n    const t = e[0] * e[3] - e[1] * e[2];\n    return [e[3] / t, -e[1] / t, -e[2] / t, e[0] / t, (e[2] * e[5] - e[4] * e[3]) / t, (e[4] * e[1] - e[5] * e[0]) / t];\n  }\n  static singularValueDecompose2dScale(e) {\n    const t = [e[0], e[2], e[1], e[3]],\n      i = e[0] * t[0] + e[1] * t[2],\n      a = e[0] * t[1] + e[1] * t[3],\n      s = e[2] * t[0] + e[3] * t[2],\n      r = e[2] * t[1] + e[3] * t[3],\n      n = (i + r) / 2,\n      g = Math.sqrt((i + r) ** 2 - 4 * (i * r - s * a)) / 2,\n      o = n + g || 1,\n      c = n - g || 1;\n    return [Math.sqrt(o), Math.sqrt(c)];\n  }\n  static normalizeRect(e) {\n    const t = e.slice(0);\n    if (e[0] > e[2]) {\n      t[0] = e[2];\n      t[2] = e[0];\n    }\n    if (e[1] > e[3]) {\n      t[1] = e[3];\n      t[3] = e[1];\n    }\n    return t;\n  }\n  static intersect(e, t) {\n    const i = Math.max(Math.min(e[0], e[2]), Math.min(t[0], t[2])),\n      a = Math.min(Math.max(e[0], e[2]), Math.max(t[0], t[2]));\n    if (i > a) return null;\n    const s = Math.max(Math.min(e[1], e[3]), Math.min(t[1], t[3])),\n      r = Math.min(Math.max(e[1], e[3]), Math.max(t[1], t[3]));\n    return s > r ? null : [i, s, a, r];\n  }\n  static #A(e, t, i, a, s, r, n, g, o, c) {\n    if (o <= 0 || o >= 1) return;\n    const C = 1 - o,\n      h = o * o,\n      l = h * o,\n      Q = C * (C * (C * e + 3 * o * t) + 3 * h * i) + l * a,\n      E = C * (C * (C * s + 3 * o * r) + 3 * h * n) + l * g;\n    c[0] = Math.min(c[0], Q);\n    c[1] = Math.min(c[1], E);\n    c[2] = Math.max(c[2], Q);\n    c[3] = Math.max(c[3], E);\n  }\n  static #e(e, t, i, a, s, r, n, g, o, c, C, h) {\n    if (Math.abs(o) < 1e-12) {\n      Math.abs(c) >= 1e-12 && this.#A(e, t, i, a, s, r, n, g, -C / c, h);\n      return;\n    }\n    const l = c ** 2 - 4 * C * o;\n    if (l < 0) return;\n    const Q = Math.sqrt(l),\n      E = 2 * o;\n    this.#A(e, t, i, a, s, r, n, g, (-c + Q) / E, h);\n    this.#A(e, t, i, a, s, r, n, g, (-c - Q) / E, h);\n  }\n  static bezierBoundingBox(e, t, i, a, s, r, n, g, o) {\n    if (o) {\n      o[0] = Math.min(o[0], e, n);\n      o[1] = Math.min(o[1], t, g);\n      o[2] = Math.max(o[2], e, n);\n      o[3] = Math.max(o[3], t, g);\n    } else o = [Math.min(e, n), Math.min(t, g), Math.max(e, n), Math.max(t, g)];\n    this.#e(e, i, s, n, t, a, r, g, 3 * (3 * (i - s) - e + n), 6 * (e - 2 * i + s), 3 * (i - e), o);\n    this.#e(e, i, s, n, t, a, r, g, 3 * (3 * (a - r) - t + g), 6 * (t - 2 * a + r), 3 * (a - t), o);\n    return o;\n  }\n}\nconst gt = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];\nfunction stringToPDFString(e) {\n  if (e[0] >= \"ï\") {\n    let t;\n    if (\"þ\" === e[0] && \"ÿ\" === e[1]) {\n      t = \"utf-16be\";\n      e.length % 2 == 1 && (e = e.slice(0, -1));\n    } else if (\"ÿ\" === e[0] && \"þ\" === e[1]) {\n      t = \"utf-16le\";\n      e.length % 2 == 1 && (e = e.slice(0, -1));\n    } else \"ï\" === e[0] && \"»\" === e[1] && \"¿\" === e[2] && (t = \"utf-8\");\n    if (t) try {\n      const i = new TextDecoder(t, {\n          fatal: !0\n        }),\n        a = stringToBytes(e),\n        s = i.decode(a);\n      return s.includes(\"\u001b\") ? s.replaceAll(/\\x1b[^\\x1b]*(?:\\x1b|$)/g, \"\") : s;\n    } catch (e) {\n      warn(`stringToPDFString: \"${e}\".`);\n    }\n  }\n  const t = [];\n  for (let i = 0, a = e.length; i < a; i++) {\n    const s = e.charCodeAt(i);\n    if (27 === s) {\n      for (; ++i < a && 27 !== e.charCodeAt(i););\n      continue;\n    }\n    const r = gt[s];\n    t.push(r ? String.fromCharCode(r) : e.charAt(i));\n  }\n  return t.join(\"\");\n}\nfunction stringToUTF8String(e) {\n  return decodeURIComponent(escape(e));\n}\nfunction utf8StringToString(e) {\n  return unescape(encodeURIComponent(e));\n}\nfunction isArrayEqual(e, t) {\n  if (e.length !== t.length) return !1;\n  for (let i = 0, a = e.length; i < a; i++) if (e[i] !== t[i]) return !1;\n  return !0;\n}\nfunction getModificationDate(e = new Date()) {\n  return [e.getUTCFullYear().toString(), (e.getUTCMonth() + 1).toString().padStart(2, \"0\"), e.getUTCDate().toString().padStart(2, \"0\"), e.getUTCHours().toString().padStart(2, \"0\"), e.getUTCMinutes().toString().padStart(2, \"0\"), e.getUTCSeconds().toString().padStart(2, \"0\")].join(\"\");\n}\nlet ot = null,\n  It = null;\nconst ct = 0,\n  Ct = 1,\n  ht = 2,\n  Bt = 3,\n  lt = 4,\n  Qt = 5,\n  Et = 6,\n  ut = 7,\n  dt = 8,\n  ft = Symbol(\"CIRCULAR_REF\"),\n  pt = Symbol(\"EOF\");\nlet mt = Object.create(null),\n  yt = Object.create(null),\n  wt = Object.create(null);\nclass Name {\n  constructor(e) {\n    this.name = e;\n  }\n  static get(e) {\n    return yt[e] ||= new Name(e);\n  }\n}\nclass Cmd {\n  constructor(e) {\n    this.cmd = e;\n  }\n  static get(e) {\n    return mt[e] ||= new Cmd(e);\n  }\n}\nconst Dt = function nonSerializableClosure() {\n  return Dt;\n};\nclass Dict {\n  constructor(e = null) {\n    this._map = Object.create(null);\n    this.xref = e;\n    this.objId = null;\n    this.suppressEncryption = !1;\n    this.__nonSerializable__ = Dt;\n  }\n  assignXref(e) {\n    this.xref = e;\n  }\n  get size() {\n    return Object.keys(this._map).length;\n  }\n  get(e, t, i) {\n    let a = this._map[e];\n    if (void 0 === a && void 0 !== t) {\n      a = this._map[t];\n      void 0 === a && void 0 !== i && (a = this._map[i]);\n    }\n    return a instanceof Ref && this.xref ? this.xref.fetch(a, this.suppressEncryption) : a;\n  }\n  async getAsync(e, t, i) {\n    let a = this._map[e];\n    if (void 0 === a && void 0 !== t) {\n      a = this._map[t];\n      void 0 === a && void 0 !== i && (a = this._map[i]);\n    }\n    return a instanceof Ref && this.xref ? this.xref.fetchAsync(a, this.suppressEncryption) : a;\n  }\n  getArray(e, t, i) {\n    let a = this._map[e];\n    if (void 0 === a && void 0 !== t) {\n      a = this._map[t];\n      void 0 === a && void 0 !== i && (a = this._map[i]);\n    }\n    a instanceof Ref && this.xref && (a = this.xref.fetch(a, this.suppressEncryption));\n    if (Array.isArray(a)) {\n      a = a.slice();\n      for (let e = 0, t = a.length; e < t; e++) a[e] instanceof Ref && this.xref && (a[e] = this.xref.fetch(a[e], this.suppressEncryption));\n    }\n    return a;\n  }\n  getRaw(e) {\n    return this._map[e];\n  }\n  getKeys() {\n    return Object.keys(this._map);\n  }\n  getRawValues() {\n    return Object.values(this._map);\n  }\n  set(e, t) {\n    this._map[e] = t;\n  }\n  has(e) {\n    return void 0 !== this._map[e];\n  }\n  forEach(e) {\n    for (const t in this._map) e(t, this.get(t));\n  }\n  static get empty() {\n    const e = new Dict(null);\n    e.set = (e, t) => {\n      unreachable(\"Should not call `set` on the empty dictionary.\");\n    };\n    return shadow(this, \"empty\", e);\n  }\n  static merge({\n    xref: e,\n    dictArray: t,\n    mergeSubDicts: i = !1\n  }) {\n    const a = new Dict(e),\n      s = new Map();\n    for (const e of t) if (e instanceof Dict) for (const [t, a] of Object.entries(e._map)) {\n      let e = s.get(t);\n      if (void 0 === e) {\n        e = [];\n        s.set(t, e);\n      } else if (!(i && a instanceof Dict)) continue;\n      e.push(a);\n    }\n    for (const [t, i] of s) {\n      if (1 === i.length || !(i[0] instanceof Dict)) {\n        a._map[t] = i[0];\n        continue;\n      }\n      const s = new Dict(e);\n      for (const e of i) for (const [t, i] of Object.entries(e._map)) void 0 === s._map[t] && (s._map[t] = i);\n      s.size > 0 && (a._map[t] = s);\n    }\n    s.clear();\n    return a.size > 0 ? a : Dict.empty;\n  }\n  clone() {\n    const e = new Dict(this.xref);\n    for (const t of this.getKeys()) e.set(t, this.getRaw(t));\n    return e;\n  }\n}\nclass Ref {\n  constructor(e, t) {\n    this.num = e;\n    this.gen = t;\n  }\n  toString() {\n    return 0 === this.gen ? `${this.num}R` : `${this.num}R${this.gen}`;\n  }\n  static fromString(e) {\n    const t = wt[e];\n    if (t) return t;\n    const i = /^(\\d+)R(\\d*)$/.exec(e);\n    return i && \"0\" !== i[1] ? wt[e] = new Ref(parseInt(i[1]), i[2] ? parseInt(i[2]) : 0) : null;\n  }\n  static get(e, t) {\n    const i = 0 === t ? `${e}R` : `${e}R${t}`;\n    return wt[i] ||= new Ref(e, t);\n  }\n}\nclass RefSet {\n  constructor(e = null) {\n    this._set = new Set(e?._set);\n  }\n  has(e) {\n    return this._set.has(e.toString());\n  }\n  put(e) {\n    this._set.add(e.toString());\n  }\n  remove(e) {\n    this._set.delete(e.toString());\n  }\n  [Symbol.iterator]() {\n    return this._set.values();\n  }\n  clear() {\n    this._set.clear();\n  }\n}\nclass RefSetCache {\n  constructor() {\n    this._map = new Map();\n  }\n  get size() {\n    return this._map.size;\n  }\n  get(e) {\n    return this._map.get(e.toString());\n  }\n  has(e) {\n    return this._map.has(e.toString());\n  }\n  put(e, t) {\n    this._map.set(e.toString(), t);\n  }\n  putAlias(e, t) {\n    this._map.set(e.toString(), this.get(t));\n  }\n  [Symbol.iterator]() {\n    return this._map.values();\n  }\n  clear() {\n    this._map.clear();\n  }\n  *items() {\n    for (const [e, t] of this._map) yield [Ref.fromString(e), t];\n  }\n}\nfunction isName(e, t) {\n  return e instanceof Name && (void 0 === t || e.name === t);\n}\nfunction isCmd(e, t) {\n  return e instanceof Cmd && (void 0 === t || e.cmd === t);\n}\nfunction isDict(e, t) {\n  return e instanceof Dict && (void 0 === t || isName(e.get(\"Type\"), t));\n}\nfunction isRefsEqual(e, t) {\n  return e.num === t.num && e.gen === t.gen;\n}\nclass BaseStream {\n  constructor() {\n    this.constructor === BaseStream && unreachable(\"Cannot initialize BaseStream.\");\n  }\n  get length() {\n    unreachable(\"Abstract getter `length` accessed\");\n  }\n  get isEmpty() {\n    unreachable(\"Abstract getter `isEmpty` accessed\");\n  }\n  get isDataLoaded() {\n    return shadow(this, \"isDataLoaded\", !0);\n  }\n  getByte() {\n    unreachable(\"Abstract method `getByte` called\");\n  }\n  getBytes(e) {\n    unreachable(\"Abstract method `getBytes` called\");\n  }\n  async getImageData(e, t) {\n    return this.getBytes(e, t);\n  }\n  async asyncGetBytes() {\n    unreachable(\"Abstract method `asyncGetBytes` called\");\n  }\n  get isAsync() {\n    return !1;\n  }\n  get canAsyncDecodeImageFromBuffer() {\n    return !1;\n  }\n  peekByte() {\n    const e = this.getByte();\n    -1 !== e && this.pos--;\n    return e;\n  }\n  peekBytes(e) {\n    const t = this.getBytes(e);\n    this.pos -= t.length;\n    return t;\n  }\n  getUint16() {\n    const e = this.getByte(),\n      t = this.getByte();\n    return -1 === e || -1 === t ? -1 : (e << 8) + t;\n  }\n  getInt32() {\n    return (this.getByte() << 24) + (this.getByte() << 16) + (this.getByte() << 8) + this.getByte();\n  }\n  getByteRange(e, t) {\n    unreachable(\"Abstract method `getByteRange` called\");\n  }\n  getString(e) {\n    return bytesToString(this.getBytes(e));\n  }\n  skip(e) {\n    this.pos += e || 1;\n  }\n  reset() {\n    unreachable(\"Abstract method `reset` called\");\n  }\n  moveStart() {\n    unreachable(\"Abstract method `moveStart` called\");\n  }\n  makeSubStream(e, t, i = null) {\n    unreachable(\"Abstract method `makeSubStream` called\");\n  }\n  getBaseStreams() {\n    return null;\n  }\n}\nconst bt = /^[1-9]\\.\\d$/;\nfunction getLookupTableFactory(e) {\n  let t;\n  return function () {\n    if (e) {\n      t = Object.create(null);\n      e(t);\n      e = null;\n    }\n    return t;\n  };\n}\nclass MissingDataException extends rt {\n  constructor(e, t) {\n    super(`Missing data [${e}, ${t})`, \"MissingDataException\");\n    this.begin = e;\n    this.end = t;\n  }\n}\nclass ParserEOFException extends rt {\n  constructor(e) {\n    super(e, \"ParserEOFException\");\n  }\n}\nclass XRefEntryException extends rt {\n  constructor(e) {\n    super(e, \"XRefEntryException\");\n  }\n}\nclass XRefParseException extends rt {\n  constructor(e) {\n    super(e, \"XRefParseException\");\n  }\n}\nfunction arrayBuffersToBytes(e) {\n  const t = e.length;\n  if (0 === t) return new Uint8Array(0);\n  if (1 === t) return new Uint8Array(e[0]);\n  let i = 0;\n  for (let a = 0; a < t; a++) i += e[a].byteLength;\n  const a = new Uint8Array(i);\n  let s = 0;\n  for (let i = 0; i < t; i++) {\n    const t = new Uint8Array(e[i]);\n    a.set(t, s);\n    s += t.byteLength;\n  }\n  return a;\n}\nfunction getInheritableProperty({\n  dict: e,\n  key: t,\n  getArray: i = !1,\n  stopWhenFound: a = !0\n}) {\n  let s;\n  const r = new RefSet();\n  for (; e instanceof Dict && (!e.objId || !r.has(e.objId));) {\n    e.objId && r.put(e.objId);\n    const n = i ? e.getArray(t) : e.get(t);\n    if (void 0 !== n) {\n      if (a) return n;\n      (s ||= []).push(n);\n    }\n    e = e.get(\"Parent\");\n  }\n  return s;\n}\nconst Ft = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\", \"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\", \"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"];\nfunction toRomanNumerals(e, t = !1) {\n  assert(Number.isInteger(e) && e > 0, \"The number should be a positive integer.\");\n  const i = [];\n  let a;\n  for (; e >= 1e3;) {\n    e -= 1e3;\n    i.push(\"M\");\n  }\n  a = e / 100 | 0;\n  e %= 100;\n  i.push(Ft[a]);\n  a = e / 10 | 0;\n  e %= 10;\n  i.push(Ft[10 + a]);\n  i.push(Ft[20 + e]);\n  const s = i.join(\"\");\n  return t ? s.toLowerCase() : s;\n}\nfunction log2(e) {\n  return e <= 0 ? 0 : Math.ceil(Math.log2(e));\n}\nfunction readInt8(e, t) {\n  return e[t] << 24 >> 24;\n}\nfunction readUint16(e, t) {\n  return e[t] << 8 | e[t + 1];\n}\nfunction readUint32(e, t) {\n  return (e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]) >>> 0;\n}\nfunction isWhiteSpace(e) {\n  return 32 === e || 9 === e || 13 === e || 10 === e;\n}\nfunction isNumberArray(e, t) {\n  return Array.isArray(e) && (null === t || e.length === t) && e.every(e => \"number\" == typeof e);\n}\nfunction lookupMatrix(e, t) {\n  return isNumberArray(e, 6) ? e : t;\n}\nfunction lookupRect(e, t) {\n  return isNumberArray(e, 4) ? e : t;\n}\nfunction lookupNormalRect(e, t) {\n  return isNumberArray(e, 4) ? Util.normalizeRect(e) : t;\n}\nfunction parseXFAPath(e) {\n  const t = /(.+)\\[(\\d+)\\]$/;\n  return e.split(\".\").map(e => {\n    const i = e.match(t);\n    return i ? {\n      name: i[1],\n      pos: parseInt(i[2], 10)\n    } : {\n      name: e,\n      pos: 0\n    };\n  });\n}\nfunction escapePDFName(e) {\n  const t = [];\n  let i = 0;\n  for (let a = 0, s = e.length; a < s; a++) {\n    const s = e.charCodeAt(a);\n    if (s < 33 || s > 126 || 35 === s || 40 === s || 41 === s || 60 === s || 62 === s || 91 === s || 93 === s || 123 === s || 125 === s || 47 === s || 37 === s) {\n      i < a && t.push(e.substring(i, a));\n      t.push(`#${s.toString(16)}`);\n      i = a + 1;\n    }\n  }\n  if (0 === t.length) return e;\n  i < e.length && t.push(e.substring(i, e.length));\n  return t.join(\"\");\n}\nfunction escapeString(e) {\n  return e.replaceAll(/([()\\\\\\n\\r])/g, e => \"\\n\" === e ? \"\\\\n\" : \"\\r\" === e ? \"\\\\r\" : `\\\\${e}`);\n}\nfunction _collectJS(e, t, i, a) {\n  if (!e) return;\n  let s = null;\n  if (e instanceof Ref) {\n    if (a.has(e)) return;\n    s = e;\n    a.put(s);\n    e = t.fetch(e);\n  }\n  if (Array.isArray(e)) for (const s of e) _collectJS(s, t, i, a);else if (e instanceof Dict) {\n    if (isName(e.get(\"S\"), \"JavaScript\")) {\n      const t = e.get(\"JS\");\n      let a;\n      t instanceof BaseStream ? a = t.getString() : \"string\" == typeof t && (a = t);\n      a &&= stringToPDFString(a).replaceAll(\"\\0\", \"\");\n      a && i.push(a);\n    }\n    _collectJS(e.getRaw(\"Next\"), t, i, a);\n  }\n  s && a.remove(s);\n}\nfunction collectActions(e, t, i) {\n  const a = Object.create(null),\n    s = getInheritableProperty({\n      dict: t,\n      key: \"AA\",\n      stopWhenFound: !1\n    });\n  if (s) for (let t = s.length - 1; t >= 0; t--) {\n    const r = s[t];\n    if (r instanceof Dict) for (const t of r.getKeys()) {\n      const s = i[t];\n      if (!s) continue;\n      const n = [];\n      _collectJS(r.getRaw(t), e, n, new RefSet());\n      n.length > 0 && (a[s] = n);\n    }\n  }\n  if (t.has(\"A\")) {\n    const i = [];\n    _collectJS(t.get(\"A\"), e, i, new RefSet());\n    i.length > 0 && (a.Action = i);\n  }\n  return objectSize(a) > 0 ? a : null;\n}\nconst St = {\n  60: \"&lt;\",\n  62: \"&gt;\",\n  38: \"&amp;\",\n  34: \"&quot;\",\n  39: \"&apos;\"\n};\nfunction* codePointIter(e) {\n  for (let t = 0, i = e.length; t < i; t++) {\n    const i = e.codePointAt(t);\n    i > 55295 && (i < 57344 || i > 65533) && t++;\n    yield i;\n  }\n}\nfunction encodeToXmlString(e) {\n  const t = [];\n  let i = 0;\n  for (let a = 0, s = e.length; a < s; a++) {\n    const s = e.codePointAt(a);\n    if (32 <= s && s <= 126) {\n      const r = St[s];\n      if (r) {\n        i < a && t.push(e.substring(i, a));\n        t.push(r);\n        i = a + 1;\n      }\n    } else {\n      i < a && t.push(e.substring(i, a));\n      t.push(`&#x${s.toString(16).toUpperCase()};`);\n      s > 55295 && (s < 57344 || s > 65533) && a++;\n      i = a + 1;\n    }\n  }\n  if (0 === t.length) return e;\n  i < e.length && t.push(e.substring(i, e.length));\n  return t.join(\"\");\n}\nfunction validateFontName(e, t = !1) {\n  const i = /^(\"|').*(\"|')$/.exec(e);\n  if (i && i[1] === i[2]) {\n    if (new RegExp(`[^\\\\\\\\]${i[1]}`).test(e.slice(1, -1))) {\n      t && warn(`FontFamily contains unescaped ${i[1]}: ${e}.`);\n      return !1;\n    }\n  } else for (const i of e.split(/[ \\t]+/)) if (/^(\\d|(-(\\d|-)))/.test(i) || !/^[\\w-\\\\]+$/.test(i)) {\n    t && warn(`FontFamily contains invalid <custom-ident>: ${e}.`);\n    return !1;\n  }\n  return !0;\n}\nfunction validateCSSFont(e) {\n  const t = new Set([\"100\", \"200\", \"300\", \"400\", \"500\", \"600\", \"700\", \"800\", \"900\", \"1000\", \"normal\", \"bold\", \"bolder\", \"lighter\"]),\n    {\n      fontFamily: i,\n      fontWeight: a,\n      italicAngle: s\n    } = e;\n  if (!validateFontName(i, !0)) return !1;\n  const r = a ? a.toString() : \"\";\n  e.fontWeight = t.has(r) ? r : \"400\";\n  const n = parseFloat(s);\n  e.italicAngle = isNaN(n) || n < -90 || n > 90 ? \"14\" : s.toString();\n  return !0;\n}\nfunction recoverJsURL(e) {\n  const t = new RegExp(\"^\\\\s*(\" + [\"app.launchURL\", \"window.open\", \"xfa.host.gotoURL\"].join(\"|\").replaceAll(\".\", \"\\\\.\") + \")\\\\((?:'|\\\")([^'\\\"]*)(?:'|\\\")(?:,\\\\s*(\\\\w+)\\\\)|\\\\))\", \"i\").exec(e);\n  if (t?.[2]) {\n    const e = t[2];\n    let i = !1;\n    \"true\" === t[3] && \"app.launchURL\" === t[1] && (i = !0);\n    return {\n      url: e,\n      newWindow: i\n    };\n  }\n  return null;\n}\nfunction numberToString(e) {\n  if (Number.isInteger(e)) return e.toString();\n  const t = Math.round(100 * e);\n  return t % 100 == 0 ? (t / 100).toString() : t % 10 == 0 ? e.toFixed(1) : e.toFixed(2);\n}\nfunction getNewAnnotationsMap(e) {\n  if (!e) return null;\n  const t = new Map();\n  for (const [i, a] of e) {\n    if (!i.startsWith(E)) continue;\n    let e = t.get(a.pageIndex);\n    if (!e) {\n      e = [];\n      t.set(a.pageIndex, e);\n    }\n    e.push(a);\n  }\n  return t.size > 0 ? t : null;\n}\nfunction isAscii(e) {\n  return /^[\\x00-\\x7F]*$/.test(e);\n}\nfunction stringToUTF16HexString(e) {\n  const t = [];\n  for (let i = 0, a = e.length; i < a; i++) {\n    const a = e.charCodeAt(i);\n    t.push((a >> 8 & 255).toString(16).padStart(2, \"0\"), (255 & a).toString(16).padStart(2, \"0\"));\n  }\n  return t.join(\"\");\n}\nfunction stringToUTF16String(e, t = !1) {\n  const i = [];\n  t && i.push(\"þÿ\");\n  for (let t = 0, a = e.length; t < a; t++) {\n    const a = e.charCodeAt(t);\n    i.push(String.fromCharCode(a >> 8 & 255), String.fromCharCode(255 & a));\n  }\n  return i.join(\"\");\n}\nfunction getRotationMatrix(e, t, i) {\n  switch (e) {\n    case 90:\n      return [0, 1, -1, 0, t, 0];\n    case 180:\n      return [-1, 0, 0, -1, t, i];\n    case 270:\n      return [0, -1, 1, 0, 0, i];\n    default:\n      throw new Error(\"Invalid rotation\");\n  }\n}\nfunction getSizeInBytes(e) {\n  return Math.ceil(Math.ceil(Math.log2(1 + e)) / 8);\n}\nclass Stream extends BaseStream {\n  constructor(e, t, i, a) {\n    super();\n    this.bytes = e instanceof Uint8Array ? e : new Uint8Array(e);\n    this.start = t || 0;\n    this.pos = this.start;\n    this.end = t + i || this.bytes.length;\n    this.dict = a;\n  }\n  get length() {\n    return this.end - this.start;\n  }\n  get isEmpty() {\n    return 0 === this.length;\n  }\n  getByte() {\n    return this.pos >= this.end ? -1 : this.bytes[this.pos++];\n  }\n  getBytes(e) {\n    const t = this.bytes,\n      i = this.pos,\n      a = this.end;\n    if (!e) return t.subarray(i, a);\n    let s = i + e;\n    s > a && (s = a);\n    this.pos = s;\n    return t.subarray(i, s);\n  }\n  getByteRange(e, t) {\n    e < 0 && (e = 0);\n    t > this.end && (t = this.end);\n    return this.bytes.subarray(e, t);\n  }\n  reset() {\n    this.pos = this.start;\n  }\n  moveStart() {\n    this.start = this.pos;\n  }\n  makeSubStream(e, t, i = null) {\n    return new Stream(this.bytes.buffer, e, t, i);\n  }\n}\nclass StringStream extends Stream {\n  constructor(e) {\n    super(stringToBytes(e));\n  }\n}\nclass NullStream extends Stream {\n  constructor() {\n    super(new Uint8Array(0));\n  }\n}\nclass ChunkedStream extends Stream {\n  constructor(e, t, i) {\n    super(new Uint8Array(e), 0, e, null);\n    this.chunkSize = t;\n    this._loadedChunks = new Set();\n    this.numChunks = Math.ceil(e / t);\n    this.manager = i;\n    this.progressiveDataLength = 0;\n    this.lastSuccessfulEnsureByteChunk = -1;\n  }\n  getMissingChunks() {\n    const e = [];\n    for (let t = 0, i = this.numChunks; t < i; ++t) this._loadedChunks.has(t) || e.push(t);\n    return e;\n  }\n  get numChunksLoaded() {\n    return this._loadedChunks.size;\n  }\n  get isDataLoaded() {\n    return this.numChunksLoaded === this.numChunks;\n  }\n  onReceiveData(e, t) {\n    const i = this.chunkSize;\n    if (e % i != 0) throw new Error(`Bad begin offset: ${e}`);\n    const a = e + t.byteLength;\n    if (a % i != 0 && a !== this.bytes.length) throw new Error(`Bad end offset: ${a}`);\n    this.bytes.set(new Uint8Array(t), e);\n    const s = Math.floor(e / i),\n      r = Math.floor((a - 1) / i) + 1;\n    for (let e = s; e < r; ++e) this._loadedChunks.add(e);\n  }\n  onReceiveProgressiveData(e) {\n    let t = this.progressiveDataLength;\n    const i = Math.floor(t / this.chunkSize);\n    this.bytes.set(new Uint8Array(e), t);\n    t += e.byteLength;\n    this.progressiveDataLength = t;\n    const a = t >= this.end ? this.numChunks : Math.floor(t / this.chunkSize);\n    for (let e = i; e < a; ++e) this._loadedChunks.add(e);\n  }\n  ensureByte(e) {\n    if (e < this.progressiveDataLength) return;\n    const t = Math.floor(e / this.chunkSize);\n    if (!(t > this.numChunks) && t !== this.lastSuccessfulEnsureByteChunk) {\n      if (!this._loadedChunks.has(t)) throw new MissingDataException(e, e + 1);\n      this.lastSuccessfulEnsureByteChunk = t;\n    }\n  }\n  ensureRange(e, t) {\n    if (e >= t) return;\n    if (t <= this.progressiveDataLength) return;\n    const i = Math.floor(e / this.chunkSize);\n    if (i > this.numChunks) return;\n    const a = Math.min(Math.floor((t - 1) / this.chunkSize) + 1, this.numChunks);\n    for (let s = i; s < a; ++s) if (!this._loadedChunks.has(s)) throw new MissingDataException(e, t);\n  }\n  nextEmptyChunk(e) {\n    const t = this.numChunks;\n    for (let i = 0; i < t; ++i) {\n      const a = (e + i) % t;\n      if (!this._loadedChunks.has(a)) return a;\n    }\n    return null;\n  }\n  hasChunk(e) {\n    return this._loadedChunks.has(e);\n  }\n  getByte() {\n    const e = this.pos;\n    if (e >= this.end) return -1;\n    e >= this.progressiveDataLength && this.ensureByte(e);\n    return this.bytes[this.pos++];\n  }\n  getBytes(e) {\n    const t = this.bytes,\n      i = this.pos,\n      a = this.end;\n    if (!e) {\n      a > this.progressiveDataLength && this.ensureRange(i, a);\n      return t.subarray(i, a);\n    }\n    let s = i + e;\n    s > a && (s = a);\n    s > this.progressiveDataLength && this.ensureRange(i, s);\n    this.pos = s;\n    return t.subarray(i, s);\n  }\n  getByteRange(e, t) {\n    e < 0 && (e = 0);\n    t > this.end && (t = this.end);\n    t > this.progressiveDataLength && this.ensureRange(e, t);\n    return this.bytes.subarray(e, t);\n  }\n  makeSubStream(e, t, i = null) {\n    t ? e + t > this.progressiveDataLength && this.ensureRange(e, e + t) : e >= this.progressiveDataLength && this.ensureByte(e);\n    function ChunkedStreamSubstream() {}\n    ChunkedStreamSubstream.prototype = Object.create(this);\n    ChunkedStreamSubstream.prototype.getMissingChunks = function () {\n      const e = this.chunkSize,\n        t = Math.floor(this.start / e),\n        i = Math.floor((this.end - 1) / e) + 1,\n        a = [];\n      for (let e = t; e < i; ++e) this._loadedChunks.has(e) || a.push(e);\n      return a;\n    };\n    Object.defineProperty(ChunkedStreamSubstream.prototype, \"isDataLoaded\", {\n      get() {\n        return this.numChunksLoaded === this.numChunks || 0 === this.getMissingChunks().length;\n      },\n      configurable: !0\n    });\n    const a = new ChunkedStreamSubstream();\n    a.pos = a.start = e;\n    a.end = e + t || this.end;\n    a.dict = i;\n    return a;\n  }\n  getBaseStreams() {\n    return [this];\n  }\n}\nclass ChunkedStreamManager {\n  constructor(e, t) {\n    this.length = t.length;\n    this.chunkSize = t.rangeChunkSize;\n    this.stream = new ChunkedStream(this.length, this.chunkSize, this);\n    this.pdfNetworkStream = e;\n    this.disableAutoFetch = t.disableAutoFetch;\n    this.msgHandler = t.msgHandler;\n    this.currRequestId = 0;\n    this._chunksNeededByRequest = new Map();\n    this._requestsByChunk = new Map();\n    this._promisesByRequest = new Map();\n    this.progressiveDataLength = 0;\n    this.aborted = !1;\n    this._loadedStreamCapability = Promise.withResolvers();\n  }\n  sendRequest(e, t) {\n    const i = this.pdfNetworkStream.getRangeReader(e, t);\n    i.isStreamingSupported || (i.onProgress = this.onProgress.bind(this));\n    let a = [],\n      s = 0;\n    return new Promise((e, t) => {\n      const readChunk = ({\n        value: r,\n        done: n\n      }) => {\n        try {\n          if (n) {\n            const t = arrayBuffersToBytes(a);\n            a = null;\n            e(t);\n            return;\n          }\n          s += r.byteLength;\n          i.isStreamingSupported && this.onProgress({\n            loaded: s\n          });\n          a.push(r);\n          i.read().then(readChunk, t);\n        } catch (e) {\n          t(e);\n        }\n      };\n      i.read().then(readChunk, t);\n    }).then(t => {\n      this.aborted || this.onReceiveData({\n        chunk: t,\n        begin: e\n      });\n    });\n  }\n  requestAllChunks(e = !1) {\n    if (!e) {\n      const e = this.stream.getMissingChunks();\n      this._requestChunks(e);\n    }\n    return this._loadedStreamCapability.promise;\n  }\n  _requestChunks(e) {\n    const t = this.currRequestId++,\n      i = new Set();\n    this._chunksNeededByRequest.set(t, i);\n    for (const t of e) this.stream.hasChunk(t) || i.add(t);\n    if (0 === i.size) return Promise.resolve();\n    const a = Promise.withResolvers();\n    this._promisesByRequest.set(t, a);\n    const s = [];\n    for (const e of i) {\n      let i = this._requestsByChunk.get(e);\n      if (!i) {\n        i = [];\n        this._requestsByChunk.set(e, i);\n        s.push(e);\n      }\n      i.push(t);\n    }\n    if (s.length > 0) {\n      const e = this.groupChunks(s);\n      for (const t of e) {\n        const e = t.beginChunk * this.chunkSize,\n          i = Math.min(t.endChunk * this.chunkSize, this.length);\n        this.sendRequest(e, i).catch(a.reject);\n      }\n    }\n    return a.promise.catch(e => {\n      if (!this.aborted) throw e;\n    });\n  }\n  getStream() {\n    return this.stream;\n  }\n  requestRange(e, t) {\n    t = Math.min(t, this.length);\n    const i = this.getBeginChunk(e),\n      a = this.getEndChunk(t),\n      s = [];\n    for (let e = i; e < a; ++e) s.push(e);\n    return this._requestChunks(s);\n  }\n  requestRanges(e = []) {\n    const t = [];\n    for (const i of e) {\n      const e = this.getBeginChunk(i.begin),\n        a = this.getEndChunk(i.end);\n      for (let i = e; i < a; ++i) t.includes(i) || t.push(i);\n    }\n    t.sort(function (e, t) {\n      return e - t;\n    });\n    return this._requestChunks(t);\n  }\n  groupChunks(e) {\n    const t = [];\n    let i = -1,\n      a = -1;\n    for (let s = 0, r = e.length; s < r; ++s) {\n      const r = e[s];\n      i < 0 && (i = r);\n      if (a >= 0 && a + 1 !== r) {\n        t.push({\n          beginChunk: i,\n          endChunk: a + 1\n        });\n        i = r;\n      }\n      s + 1 === e.length && t.push({\n        beginChunk: i,\n        endChunk: r + 1\n      });\n      a = r;\n    }\n    return t;\n  }\n  onProgress(e) {\n    this.msgHandler.send(\"DocProgress\", {\n      loaded: this.stream.numChunksLoaded * this.chunkSize + e.loaded,\n      total: this.length\n    });\n  }\n  onReceiveData(e) {\n    const t = e.chunk,\n      i = void 0 === e.begin,\n      a = i ? this.progressiveDataLength : e.begin,\n      s = a + t.byteLength,\n      r = Math.floor(a / this.chunkSize),\n      n = s < this.length ? Math.floor(s / this.chunkSize) : Math.ceil(s / this.chunkSize);\n    if (i) {\n      this.stream.onReceiveProgressiveData(t);\n      this.progressiveDataLength = s;\n    } else this.stream.onReceiveData(a, t);\n    this.stream.isDataLoaded && this._loadedStreamCapability.resolve(this.stream);\n    const g = [];\n    for (let e = r; e < n; ++e) {\n      const t = this._requestsByChunk.get(e);\n      if (t) {\n        this._requestsByChunk.delete(e);\n        for (const i of t) {\n          const t = this._chunksNeededByRequest.get(i);\n          t.has(e) && t.delete(e);\n          t.size > 0 || g.push(i);\n        }\n      }\n    }\n    if (!this.disableAutoFetch && 0 === this._requestsByChunk.size) {\n      let e;\n      if (1 === this.stream.numChunksLoaded) {\n        const t = this.stream.numChunks - 1;\n        this.stream.hasChunk(t) || (e = t);\n      } else e = this.stream.nextEmptyChunk(n);\n      Number.isInteger(e) && this._requestChunks([e]);\n    }\n    for (const e of g) {\n      const t = this._promisesByRequest.get(e);\n      this._promisesByRequest.delete(e);\n      t.resolve();\n    }\n    this.msgHandler.send(\"DocProgress\", {\n      loaded: this.stream.numChunksLoaded * this.chunkSize,\n      total: this.length\n    });\n  }\n  onError(e) {\n    this._loadedStreamCapability.reject(e);\n  }\n  getBeginChunk(e) {\n    return Math.floor(e / this.chunkSize);\n  }\n  getEndChunk(e) {\n    return Math.floor((e - 1) / this.chunkSize) + 1;\n  }\n  abort(e) {\n    this.aborted = !0;\n    this.pdfNetworkStream?.cancelAllRequests(e);\n    for (const t of this._promisesByRequest.values()) t.reject(e);\n  }\n}\nclass ColorSpace {\n  constructor(e, t) {\n    this.constructor === ColorSpace && unreachable(\"Cannot initialize ColorSpace.\");\n    this.name = e;\n    this.numComps = t;\n  }\n  getRgb(e, t) {\n    const i = new Uint8ClampedArray(3);\n    this.getRgbItem(e, t, i, 0);\n    return i;\n  }\n  getRgbItem(e, t, i, a) {\n    unreachable(\"Should not call ColorSpace.getRgbItem\");\n  }\n  getRgbBuffer(e, t, i, a, s, r, n) {\n    unreachable(\"Should not call ColorSpace.getRgbBuffer\");\n  }\n  getOutputLength(e, t) {\n    unreachable(\"Should not call ColorSpace.getOutputLength\");\n  }\n  isPassthrough(e) {\n    return !1;\n  }\n  isDefaultDecode(e, t) {\n    return ColorSpace.isDefaultDecode(e, this.numComps);\n  }\n  fillRgb(e, t, i, a, s, r, n, g, o) {\n    const c = t * i;\n    let C = null;\n    const h = 1 << n,\n      l = i !== s || t !== a;\n    if (this.isPassthrough(n)) C = g;else if (1 === this.numComps && c > h && \"DeviceGray\" !== this.name && \"DeviceRGB\" !== this.name) {\n      const t = n <= 8 ? new Uint8Array(h) : new Uint16Array(h);\n      for (let e = 0; e < h; e++) t[e] = e;\n      const i = new Uint8ClampedArray(3 * h);\n      this.getRgbBuffer(t, 0, h, i, 0, n, 0);\n      if (l) {\n        C = new Uint8Array(3 * c);\n        let e = 0;\n        for (let t = 0; t < c; ++t) {\n          const a = 3 * g[t];\n          C[e++] = i[a];\n          C[e++] = i[a + 1];\n          C[e++] = i[a + 2];\n        }\n      } else {\n        let t = 0;\n        for (let a = 0; a < c; ++a) {\n          const s = 3 * g[a];\n          e[t++] = i[s];\n          e[t++] = i[s + 1];\n          e[t++] = i[s + 2];\n          t += o;\n        }\n      }\n    } else if (l) {\n      C = new Uint8ClampedArray(3 * c);\n      this.getRgbBuffer(g, 0, c, C, 0, n, 0);\n    } else this.getRgbBuffer(g, 0, a * r, e, 0, n, o);\n    if (C) if (l) !function resizeRgbImage(e, t, i, a, s, r, n) {\n      n = 1 !== n ? 0 : n;\n      const g = i / s,\n        o = a / r;\n      let c,\n        C = 0;\n      const h = new Uint16Array(s),\n        l = 3 * i;\n      for (let e = 0; e < s; e++) h[e] = 3 * Math.floor(e * g);\n      for (let i = 0; i < r; i++) {\n        const a = Math.floor(i * o) * l;\n        for (let i = 0; i < s; i++) {\n          c = a + h[i];\n          t[C++] = e[c++];\n          t[C++] = e[c++];\n          t[C++] = e[c++];\n          C += n;\n        }\n      }\n    }(C, e, t, i, a, s, o);else {\n      let t = 0,\n        i = 0;\n      for (let s = 0, n = a * r; s < n; s++) {\n        e[t++] = C[i++];\n        e[t++] = C[i++];\n        e[t++] = C[i++];\n        t += o;\n      }\n    }\n  }\n  get usesZeroToOneRange() {\n    return shadow(this, \"usesZeroToOneRange\", !0);\n  }\n  static _cache(e, t, i, a) {\n    if (!i) throw new Error('ColorSpace._cache - expected \"localColorSpaceCache\" argument.');\n    if (!a) throw new Error('ColorSpace._cache - expected \"parsedColorSpace\" argument.');\n    let s, r;\n    if (e instanceof Ref) {\n      r = e;\n      e = t.fetch(e);\n    }\n    e instanceof Name && (s = e.name);\n    (s || r) && i.set(s, r, a);\n  }\n  static getCached(e, t, i) {\n    if (!i) throw new Error('ColorSpace.getCached - expected \"localColorSpaceCache\" argument.');\n    if (e instanceof Ref) {\n      const a = i.getByRef(e);\n      if (a) return a;\n      try {\n        e = t.fetch(e);\n      } catch (e) {\n        if (e instanceof MissingDataException) throw e;\n      }\n    }\n    if (e instanceof Name) {\n      const t = i.getByName(e.name);\n      if (t) return t;\n    }\n    return null;\n  }\n  static async parseAsync({\n    cs: e,\n    xref: t,\n    resources: i = null,\n    pdfFunctionFactory: a,\n    localColorSpaceCache: s\n  }) {\n    const r = this._parse(e, t, i, a);\n    this._cache(e, t, s, r);\n    return r;\n  }\n  static parse({\n    cs: e,\n    xref: t,\n    resources: i = null,\n    pdfFunctionFactory: a,\n    localColorSpaceCache: s\n  }) {\n    const r = this.getCached(e, t, s);\n    if (r) return r;\n    const n = this._parse(e, t, i, a);\n    this._cache(e, t, s, n);\n    return n;\n  }\n  static _parse(e, t, i = null, a) {\n    if ((e = t.fetchIfRef(e)) instanceof Name) switch (e.name) {\n      case \"G\":\n      case \"DeviceGray\":\n        return this.singletons.gray;\n      case \"RGB\":\n      case \"DeviceRGB\":\n        return this.singletons.rgb;\n      case \"DeviceRGBA\":\n        return this.singletons.rgba;\n      case \"CMYK\":\n      case \"DeviceCMYK\":\n        return this.singletons.cmyk;\n      case \"Pattern\":\n        return new PatternCS(null);\n      default:\n        if (i instanceof Dict) {\n          const s = i.get(\"ColorSpace\");\n          if (s instanceof Dict) {\n            const r = s.get(e.name);\n            if (r) {\n              if (r instanceof Name) return this._parse(r, t, i, a);\n              e = r;\n              break;\n            }\n          }\n        }\n        throw new FormatError(`Unrecognized ColorSpace: ${e.name}`);\n    }\n    if (Array.isArray(e)) {\n      const s = t.fetchIfRef(e[0]).name;\n      let r, n, g, o, c, C;\n      switch (s) {\n        case \"G\":\n        case \"DeviceGray\":\n          return this.singletons.gray;\n        case \"RGB\":\n        case \"DeviceRGB\":\n          return this.singletons.rgb;\n        case \"CMYK\":\n        case \"DeviceCMYK\":\n          return this.singletons.cmyk;\n        case \"CalGray\":\n          r = t.fetchIfRef(e[1]);\n          o = r.getArray(\"WhitePoint\");\n          c = r.getArray(\"BlackPoint\");\n          C = r.get(\"Gamma\");\n          return new CalGrayCS(o, c, C);\n        case \"CalRGB\":\n          r = t.fetchIfRef(e[1]);\n          o = r.getArray(\"WhitePoint\");\n          c = r.getArray(\"BlackPoint\");\n          C = r.getArray(\"Gamma\");\n          const h = r.getArray(\"Matrix\");\n          return new CalRGBCS(o, c, C, h);\n        case \"ICCBased\":\n          const l = t.fetchIfRef(e[1]).dict;\n          n = l.get(\"N\");\n          const Q = l.get(\"Alternate\");\n          if (Q) {\n            const e = this._parse(Q, t, i, a);\n            if (e.numComps === n) return e;\n            warn(\"ICCBased color space: Ignoring incorrect /Alternate entry.\");\n          }\n          if (1 === n) return this.singletons.gray;\n          if (3 === n) return this.singletons.rgb;\n          if (4 === n) return this.singletons.cmyk;\n          break;\n        case \"Pattern\":\n          g = e[1] || null;\n          g && (g = this._parse(g, t, i, a));\n          return new PatternCS(g);\n        case \"I\":\n        case \"Indexed\":\n          g = this._parse(e[1], t, i, a);\n          const E = t.fetchIfRef(e[2]) + 1,\n            u = t.fetchIfRef(e[3]);\n          return new IndexedCS(g, E, u);\n        case \"Separation\":\n        case \"DeviceN\":\n          const d = t.fetchIfRef(e[1]);\n          n = Array.isArray(d) ? d.length : 1;\n          g = this._parse(e[2], t, i, a);\n          const f = a.create(e[3]);\n          return new AlternateCS(n, g, f);\n        case \"Lab\":\n          r = t.fetchIfRef(e[1]);\n          o = r.getArray(\"WhitePoint\");\n          c = r.getArray(\"BlackPoint\");\n          const p = r.getArray(\"Range\");\n          return new LabCS(o, c, p);\n        default:\n          throw new FormatError(`Unimplemented ColorSpace object: ${s}`);\n      }\n    }\n    throw new FormatError(`Unrecognized ColorSpace object: ${e}`);\n  }\n  static isDefaultDecode(e, t) {\n    if (!Array.isArray(e)) return !0;\n    if (2 * t !== e.length) {\n      warn(\"The decode map is not the correct length\");\n      return !0;\n    }\n    for (let t = 0, i = e.length; t < i; t += 2) if (0 !== e[t] || 1 !== e[t + 1]) return !1;\n    return !0;\n  }\n  static get singletons() {\n    return shadow(this, \"singletons\", {\n      get gray() {\n        return shadow(this, \"gray\", new DeviceGrayCS());\n      },\n      get rgb() {\n        return shadow(this, \"rgb\", new DeviceRgbCS());\n      },\n      get rgba() {\n        return shadow(this, \"rgba\", new DeviceRgbaCS());\n      },\n      get cmyk() {\n        return shadow(this, \"cmyk\", new DeviceCmykCS());\n      }\n    });\n  }\n}\nclass AlternateCS extends ColorSpace {\n  constructor(e, t, i) {\n    super(\"Alternate\", e);\n    this.base = t;\n    this.tintFn = i;\n    this.tmpBuf = new Float32Array(t.numComps);\n  }\n  getRgbItem(e, t, i, a) {\n    const s = this.tmpBuf;\n    this.tintFn(e, t, s, 0);\n    this.base.getRgbItem(s, 0, i, a);\n  }\n  getRgbBuffer(e, t, i, a, s, r, n) {\n    const g = this.tintFn,\n      o = this.base,\n      c = 1 / ((1 << r) - 1),\n      C = o.numComps,\n      h = o.usesZeroToOneRange,\n      l = (o.isPassthrough(8) || !h) && 0 === n;\n    let Q = l ? s : 0;\n    const E = l ? a : new Uint8ClampedArray(C * i),\n      u = this.numComps,\n      d = new Float32Array(u),\n      f = new Float32Array(C);\n    let p, m;\n    for (p = 0; p < i; p++) {\n      for (m = 0; m < u; m++) d[m] = e[t++] * c;\n      g(d, 0, f, 0);\n      if (h) for (m = 0; m < C; m++) E[Q++] = 255 * f[m];else {\n        o.getRgbItem(f, 0, E, Q);\n        Q += C;\n      }\n    }\n    l || o.getRgbBuffer(E, 0, i, a, s, 8, n);\n  }\n  getOutputLength(e, t) {\n    return this.base.getOutputLength(e * this.base.numComps / this.numComps, t);\n  }\n}\nclass PatternCS extends ColorSpace {\n  constructor(e) {\n    super(\"Pattern\", null);\n    this.base = e;\n  }\n  isDefaultDecode(e, t) {\n    unreachable(\"Should not call PatternCS.isDefaultDecode\");\n  }\n}\nclass IndexedCS extends ColorSpace {\n  constructor(e, t, i) {\n    super(\"Indexed\", 1);\n    this.base = e;\n    this.highVal = t;\n    const a = e.numComps * t;\n    this.lookup = new Uint8Array(a);\n    if (i instanceof BaseStream) {\n      const e = i.getBytes(a);\n      this.lookup.set(e);\n    } else {\n      if (\"string\" != typeof i) throw new FormatError(`IndexedCS - unrecognized lookup table: ${i}`);\n      for (let e = 0; e < a; ++e) this.lookup[e] = 255 & i.charCodeAt(e);\n    }\n  }\n  getRgbItem(e, t, i, a) {\n    const s = this.base.numComps,\n      r = e[t] * s;\n    this.base.getRgbBuffer(this.lookup, r, 1, i, a, 8, 0);\n  }\n  getRgbBuffer(e, t, i, a, s, r, n) {\n    const g = this.base,\n      o = g.numComps,\n      c = g.getOutputLength(o, n),\n      C = this.lookup;\n    for (let r = 0; r < i; ++r) {\n      const i = e[t++] * o;\n      g.getRgbBuffer(C, i, 1, a, s, 8, n);\n      s += c;\n    }\n  }\n  getOutputLength(e, t) {\n    return this.base.getOutputLength(e * this.base.numComps, t);\n  }\n  isDefaultDecode(e, t) {\n    if (!Array.isArray(e)) return !0;\n    if (2 !== e.length) {\n      warn(\"Decode map length is not correct\");\n      return !0;\n    }\n    if (!Number.isInteger(t) || t < 1) {\n      warn(\"Bits per component is not correct\");\n      return !0;\n    }\n    return 0 === e[0] && e[1] === (1 << t) - 1;\n  }\n}\nclass DeviceGrayCS extends ColorSpace {\n  constructor() {\n    super(\"DeviceGray\", 1);\n  }\n  getRgbItem(e, t, i, a) {\n    const s = 255 * e[t];\n    i[a] = i[a + 1] = i[a + 2] = s;\n  }\n  getRgbBuffer(e, t, i, a, s, r, n) {\n    const g = 255 / ((1 << r) - 1);\n    let o = t,\n      c = s;\n    for (let t = 0; t < i; ++t) {\n      const t = g * e[o++];\n      a[c++] = t;\n      a[c++] = t;\n      a[c++] = t;\n      c += n;\n    }\n  }\n  getOutputLength(e, t) {\n    return e * (3 + t);\n  }\n}\nclass DeviceRgbCS extends ColorSpace {\n  constructor() {\n    super(\"DeviceRGB\", 3);\n  }\n  getRgbItem(e, t, i, a) {\n    i[a] = 255 * e[t];\n    i[a + 1] = 255 * e[t + 1];\n    i[a + 2] = 255 * e[t + 2];\n  }\n  getRgbBuffer(e, t, i, a, s, r, n) {\n    if (8 === r && 0 === n) {\n      a.set(e.subarray(t, t + 3 * i), s);\n      return;\n    }\n    const g = 255 / ((1 << r) - 1);\n    let o = t,\n      c = s;\n    for (let t = 0; t < i; ++t) {\n      a[c++] = g * e[o++];\n      a[c++] = g * e[o++];\n      a[c++] = g * e[o++];\n      c += n;\n    }\n  }\n  getOutputLength(e, t) {\n    return e * (3 + t) / 3 | 0;\n  }\n  isPassthrough(e) {\n    return 8 === e;\n  }\n}\nclass DeviceRgbaCS extends ColorSpace {\n  constructor() {\n    super(\"DeviceRGBA\", 4);\n  }\n  getOutputLength(e, t) {\n    return 4 * e;\n  }\n  isPassthrough(e) {\n    return 8 === e;\n  }\n}\nclass DeviceCmykCS extends ColorSpace {\n  constructor() {\n    super(\"DeviceCMYK\", 4);\n  }\n  #t(e, t, i, a, s) {\n    const r = e[t] * i,\n      n = e[t + 1] * i,\n      g = e[t + 2] * i,\n      o = e[t + 3] * i;\n    a[s] = 255 + r * (-4.387332384609988 * r + 54.48615194189176 * n + 18.82290502165302 * g + 212.25662451639585 * o - 285.2331026137004) + n * (1.7149763477362134 * n - 5.6096736904047315 * g + -17.873870861415444 * o - 5.497006427196366) + g * (-2.5217340131683033 * g - 21.248923337353073 * o + 17.5119270841813) + o * (-21.86122147463605 * o - 189.48180835922747);\n    a[s + 1] = 255 + r * (8.841041422036149 * r + 60.118027045597366 * n + 6.871425592049007 * g + 31.159100130055922 * o - 79.2970844816548) + n * (-15.310361306967817 * n + 17.575251261109482 * g + 131.35250912493976 * o - 190.9453302588951) + g * (4.444339102852739 * g + 9.8632861493405 * o - 24.86741582555878) + o * (-20.737325471181034 * o - 187.80453709719578);\n    a[s + 2] = 255 + r * (.8842522430003296 * r + 8.078677503112928 * n + 30.89978309703729 * g - .23883238689178934 * o - 14.183576799673286) + n * (10.49593273432072 * n + 63.02378494754052 * g + 50.606957656360734 * o - 112.23884253719248) + g * (.03296041114873217 * g + 115.60384449646641 * o - 193.58209356861505) + o * (-22.33816807309886 * o - 180.12613974708367);\n  }\n  getRgbItem(e, t, i, a) {\n    this.#t(e, t, 1, i, a);\n  }\n  getRgbBuffer(e, t, i, a, s, r, n) {\n    const g = 1 / ((1 << r) - 1);\n    for (let r = 0; r < i; r++) {\n      this.#t(e, t, g, a, s);\n      t += 4;\n      s += 3 + n;\n    }\n  }\n  getOutputLength(e, t) {\n    return e / 4 * (3 + t) | 0;\n  }\n}\nclass CalGrayCS extends ColorSpace {\n  constructor(e, t, i) {\n    super(\"CalGray\", 1);\n    if (!e) throw new FormatError(\"WhitePoint missing - required for color space CalGray\");\n    [this.XW, this.YW, this.ZW] = e;\n    [this.XB, this.YB, this.ZB] = t || [0, 0, 0];\n    this.G = i || 1;\n    if (this.XW < 0 || this.ZW < 0 || 1 !== this.YW) throw new FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);\n    if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {\n      info(`Invalid BlackPoint for ${this.name}, falling back to default.`);\n      this.XB = this.YB = this.ZB = 0;\n    }\n    0 === this.XB && 0 === this.YB && 0 === this.ZB || warn(`${this.name}, BlackPoint: XB: ${this.XB}, YB: ${this.YB}, ZB: ${this.ZB}, only default values are supported.`);\n    if (this.G < 1) {\n      info(`Invalid Gamma: ${this.G} for ${this.name}, falling back to default.`);\n      this.G = 1;\n    }\n  }\n  #t(e, t, i, a, s) {\n    const r = (e[t] * s) ** this.G,\n      n = this.YW * r,\n      g = Math.max(295.8 * n ** .3333333333333333 - 40.8, 0);\n    i[a] = g;\n    i[a + 1] = g;\n    i[a + 2] = g;\n  }\n  getRgbItem(e, t, i, a) {\n    this.#t(e, t, i, a, 1);\n  }\n  getRgbBuffer(e, t, i, a, s, r, n) {\n    const g = 1 / ((1 << r) - 1);\n    for (let r = 0; r < i; ++r) {\n      this.#t(e, t, a, s, g);\n      t += 1;\n      s += 3 + n;\n    }\n  }\n  getOutputLength(e, t) {\n    return e * (3 + t);\n  }\n}\nclass CalRGBCS extends ColorSpace {\n  static #i = new Float32Array([.8951, .2664, -.1614, -.7502, 1.7135, .0367, .0389, -.0685, 1.0296]);\n  static #a = new Float32Array([.9869929, -.1470543, .1599627, .4323053, .5183603, .0492912, -.0085287, .0400428, .9684867]);\n  static #s = new Float32Array([3.2404542, -1.5371385, -.4985314, -.969266, 1.8760108, .041556, .0556434, -.2040259, 1.0572252]);\n  static #r = new Float32Array([1, 1, 1]);\n  static #n = new Float32Array(3);\n  static #g = new Float32Array(3);\n  static #o = new Float32Array(3);\n  static #I = (24 / 116) ** 3 / 8;\n  constructor(e, t, i, a) {\n    super(\"CalRGB\", 3);\n    if (!e) throw new FormatError(\"WhitePoint missing - required for color space CalRGB\");\n    const [s, r, n] = this.whitePoint = e,\n      [g, o, c] = this.blackPoint = t || new Float32Array(3);\n    [this.GR, this.GG, this.GB] = i || new Float32Array([1, 1, 1]);\n    [this.MXA, this.MYA, this.MZA, this.MXB, this.MYB, this.MZB, this.MXC, this.MYC, this.MZC] = a || new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);\n    if (s < 0 || n < 0 || 1 !== r) throw new FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);\n    if (g < 0 || o < 0 || c < 0) {\n      info(`Invalid BlackPoint for ${this.name} [${g}, ${o}, ${c}], falling back to default.`);\n      this.blackPoint = new Float32Array(3);\n    }\n    if (this.GR < 0 || this.GG < 0 || this.GB < 0) {\n      info(`Invalid Gamma [${this.GR}, ${this.GG}, ${this.GB}] for ${this.name}, falling back to default.`);\n      this.GR = this.GG = this.GB = 1;\n    }\n  }\n  #c(e, t, i) {\n    i[0] = e[0] * t[0] + e[1] * t[1] + e[2] * t[2];\n    i[1] = e[3] * t[0] + e[4] * t[1] + e[5] * t[2];\n    i[2] = e[6] * t[0] + e[7] * t[1] + e[8] * t[2];\n  }\n  #C(e, t, i) {\n    i[0] = 1 * t[0] / e[0];\n    i[1] = 1 * t[1] / e[1];\n    i[2] = 1 * t[2] / e[2];\n  }\n  #h(e, t, i) {\n    i[0] = .95047 * t[0] / e[0];\n    i[1] = 1 * t[1] / e[1];\n    i[2] = 1.08883 * t[2] / e[2];\n  }\n  #B(e) {\n    return e <= .0031308 ? this.#l(0, 1, 12.92 * e) : e >= .99554525 ? 1 : this.#l(0, 1, 1.055 * e ** (1 / 2.4) - .055);\n  }\n  #l(e, t, i) {\n    return Math.max(e, Math.min(t, i));\n  }\n  #Q(e) {\n    return e < 0 ? -this.#Q(-e) : e > 8 ? ((e + 16) / 116) ** 3 : e * CalRGBCS.#I;\n  }\n  #E(e, t, i) {\n    if (0 === e[0] && 0 === e[1] && 0 === e[2]) {\n      i[0] = t[0];\n      i[1] = t[1];\n      i[2] = t[2];\n      return;\n    }\n    const a = this.#Q(0),\n      s = (1 - a) / (1 - this.#Q(e[0])),\n      r = 1 - s,\n      n = (1 - a) / (1 - this.#Q(e[1])),\n      g = 1 - n,\n      o = (1 - a) / (1 - this.#Q(e[2])),\n      c = 1 - o;\n    i[0] = t[0] * s + r;\n    i[1] = t[1] * n + g;\n    i[2] = t[2] * o + c;\n  }\n  #u(e, t, i) {\n    if (1 === e[0] && 1 === e[2]) {\n      i[0] = t[0];\n      i[1] = t[1];\n      i[2] = t[2];\n      return;\n    }\n    const a = i;\n    this.#c(CalRGBCS.#i, t, a);\n    const s = CalRGBCS.#n;\n    this.#C(e, a, s);\n    this.#c(CalRGBCS.#a, s, i);\n  }\n  #d(e, t, i) {\n    const a = i;\n    this.#c(CalRGBCS.#i, t, a);\n    const s = CalRGBCS.#n;\n    this.#h(e, a, s);\n    this.#c(CalRGBCS.#a, s, i);\n  }\n  #t(e, t, i, a, s) {\n    const r = this.#l(0, 1, e[t] * s),\n      n = this.#l(0, 1, e[t + 1] * s),\n      g = this.#l(0, 1, e[t + 2] * s),\n      o = 1 === r ? 1 : r ** this.GR,\n      c = 1 === n ? 1 : n ** this.GG,\n      C = 1 === g ? 1 : g ** this.GB,\n      h = this.MXA * o + this.MXB * c + this.MXC * C,\n      l = this.MYA * o + this.MYB * c + this.MYC * C,\n      Q = this.MZA * o + this.MZB * c + this.MZC * C,\n      E = CalRGBCS.#g;\n    E[0] = h;\n    E[1] = l;\n    E[2] = Q;\n    const u = CalRGBCS.#o;\n    this.#u(this.whitePoint, E, u);\n    const d = CalRGBCS.#g;\n    this.#E(this.blackPoint, u, d);\n    const f = CalRGBCS.#o;\n    this.#d(CalRGBCS.#r, d, f);\n    const p = CalRGBCS.#g;\n    this.#c(CalRGBCS.#s, f, p);\n    i[a] = 255 * this.#B(p[0]);\n    i[a + 1] = 255 * this.#B(p[1]);\n    i[a + 2] = 255 * this.#B(p[2]);\n  }\n  getRgbItem(e, t, i, a) {\n    this.#t(e, t, i, a, 1);\n  }\n  getRgbBuffer(e, t, i, a, s, r, n) {\n    const g = 1 / ((1 << r) - 1);\n    for (let r = 0; r < i; ++r) {\n      this.#t(e, t, a, s, g);\n      t += 3;\n      s += 3 + n;\n    }\n  }\n  getOutputLength(e, t) {\n    return e * (3 + t) / 3 | 0;\n  }\n}\nclass LabCS extends ColorSpace {\n  constructor(e, t, i) {\n    super(\"Lab\", 3);\n    if (!e) throw new FormatError(\"WhitePoint missing - required for color space Lab\");\n    [this.XW, this.YW, this.ZW] = e;\n    [this.amin, this.amax, this.bmin, this.bmax] = i || [-100, 100, -100, 100];\n    [this.XB, this.YB, this.ZB] = t || [0, 0, 0];\n    if (this.XW < 0 || this.ZW < 0 || 1 !== this.YW) throw new FormatError(\"Invalid WhitePoint components, no fallback available\");\n    if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {\n      info(\"Invalid BlackPoint, falling back to default\");\n      this.XB = this.YB = this.ZB = 0;\n    }\n    if (this.amin > this.amax || this.bmin > this.bmax) {\n      info(\"Invalid Range, falling back to defaults\");\n      this.amin = -100;\n      this.amax = 100;\n      this.bmin = -100;\n      this.bmax = 100;\n    }\n  }\n  #f(e) {\n    return e >= 6 / 29 ? e ** 3 : 108 / 841 * (e - 4 / 29);\n  }\n  #p(e, t, i, a) {\n    return i + e * (a - i) / t;\n  }\n  #t(e, t, i, a, s) {\n    let r = e[t],\n      n = e[t + 1],\n      g = e[t + 2];\n    if (!1 !== i) {\n      r = this.#p(r, i, 0, 100);\n      n = this.#p(n, i, this.amin, this.amax);\n      g = this.#p(g, i, this.bmin, this.bmax);\n    }\n    n > this.amax ? n = this.amax : n < this.amin && (n = this.amin);\n    g > this.bmax ? g = this.bmax : g < this.bmin && (g = this.bmin);\n    const o = (r + 16) / 116,\n      c = o + n / 500,\n      C = o - g / 200,\n      h = this.XW * this.#f(c),\n      l = this.YW * this.#f(o),\n      Q = this.ZW * this.#f(C);\n    let E, u, d;\n    if (this.ZW < 1) {\n      E = 3.1339 * h + -1.617 * l + -.4906 * Q;\n      u = -.9785 * h + 1.916 * l + .0333 * Q;\n      d = .072 * h + -.229 * l + 1.4057 * Q;\n    } else {\n      E = 3.2406 * h + -1.5372 * l + -.4986 * Q;\n      u = -.9689 * h + 1.8758 * l + .0415 * Q;\n      d = .0557 * h + -.204 * l + 1.057 * Q;\n    }\n    a[s] = 255 * Math.sqrt(E);\n    a[s + 1] = 255 * Math.sqrt(u);\n    a[s + 2] = 255 * Math.sqrt(d);\n  }\n  getRgbItem(e, t, i, a) {\n    this.#t(e, t, !1, i, a);\n  }\n  getRgbBuffer(e, t, i, a, s, r, n) {\n    const g = (1 << r) - 1;\n    for (let r = 0; r < i; r++) {\n      this.#t(e, t, g, a, s);\n      t += 3;\n      s += 3 + n;\n    }\n  }\n  getOutputLength(e, t) {\n    return e * (3 + t) / 3 | 0;\n  }\n  isDefaultDecode(e, t) {\n    return !0;\n  }\n  get usesZeroToOneRange() {\n    return shadow(this, \"usesZeroToOneRange\", !1);\n  }\n}\nfunction hexToInt(e, t) {\n  let i = 0;\n  for (let a = 0; a <= t; a++) i = i << 8 | e[a];\n  return i >>> 0;\n}\nfunction hexToStr(e, t) {\n  return 1 === t ? String.fromCharCode(e[0], e[1]) : 3 === t ? String.fromCharCode(e[0], e[1], e[2], e[3]) : String.fromCharCode(...e.subarray(0, t + 1));\n}\nfunction addHex(e, t, i) {\n  let a = 0;\n  for (let s = i; s >= 0; s--) {\n    a += e[s] + t[s];\n    e[s] = 255 & a;\n    a >>= 8;\n  }\n}\nfunction incHex(e, t) {\n  let i = 1;\n  for (let a = t; a >= 0 && i > 0; a--) {\n    i += e[a];\n    e[a] = 255 & i;\n    i >>= 8;\n  }\n}\nconst kt = 16;\nclass BinaryCMapStream {\n  constructor(e) {\n    this.buffer = e;\n    this.pos = 0;\n    this.end = e.length;\n    this.tmpBuf = new Uint8Array(19);\n  }\n  readByte() {\n    return this.pos >= this.end ? -1 : this.buffer[this.pos++];\n  }\n  readNumber() {\n    let e,\n      t = 0;\n    do {\n      const i = this.readByte();\n      if (i < 0) throw new FormatError(\"unexpected EOF in bcmap\");\n      e = !(128 & i);\n      t = t << 7 | 127 & i;\n    } while (!e);\n    return t;\n  }\n  readSigned() {\n    const e = this.readNumber();\n    return 1 & e ? ~(e >>> 1) : e >>> 1;\n  }\n  readHex(e, t) {\n    e.set(this.buffer.subarray(this.pos, this.pos + t + 1));\n    this.pos += t + 1;\n  }\n  readHexNumber(e, t) {\n    let i;\n    const a = this.tmpBuf;\n    let s = 0;\n    do {\n      const e = this.readByte();\n      if (e < 0) throw new FormatError(\"unexpected EOF in bcmap\");\n      i = !(128 & e);\n      a[s++] = 127 & e;\n    } while (!i);\n    let r = t,\n      n = 0,\n      g = 0;\n    for (; r >= 0;) {\n      for (; g < 8 && a.length > 0;) {\n        n |= a[--s] << g;\n        g += 7;\n      }\n      e[r] = 255 & n;\n      r--;\n      n >>= 8;\n      g -= 8;\n    }\n  }\n  readHexSigned(e, t) {\n    this.readHexNumber(e, t);\n    const i = 1 & e[t] ? 255 : 0;\n    let a = 0;\n    for (let s = 0; s <= t; s++) {\n      a = (1 & a) << 8 | e[s];\n      e[s] = a >> 1 ^ i;\n    }\n  }\n  readString() {\n    const e = this.readNumber(),\n      t = new Array(e);\n    for (let i = 0; i < e; i++) t[i] = this.readNumber();\n    return String.fromCharCode(...t);\n  }\n}\nclass BinaryCMapReader {\n  async process(e, t, i) {\n    const a = new BinaryCMapStream(e),\n      s = a.readByte();\n    t.vertical = !!(1 & s);\n    let r = null;\n    const n = new Uint8Array(kt),\n      g = new Uint8Array(kt),\n      o = new Uint8Array(kt),\n      c = new Uint8Array(kt),\n      C = new Uint8Array(kt);\n    let h, l;\n    for (; (l = a.readByte()) >= 0;) {\n      const e = l >> 5;\n      if (7 === e) {\n        switch (31 & l) {\n          case 0:\n            a.readString();\n            break;\n          case 1:\n            r = a.readString();\n        }\n        continue;\n      }\n      const i = !!(16 & l),\n        s = 15 & l;\n      if (s + 1 > kt) throw new Error(\"BinaryCMapReader.process: Invalid dataSize.\");\n      const Q = 1,\n        E = a.readNumber();\n      switch (e) {\n        case 0:\n          a.readHex(n, s);\n          a.readHexNumber(g, s);\n          addHex(g, n, s);\n          t.addCodespaceRange(s + 1, hexToInt(n, s), hexToInt(g, s));\n          for (let e = 1; e < E; e++) {\n            incHex(g, s);\n            a.readHexNumber(n, s);\n            addHex(n, g, s);\n            a.readHexNumber(g, s);\n            addHex(g, n, s);\n            t.addCodespaceRange(s + 1, hexToInt(n, s), hexToInt(g, s));\n          }\n          break;\n        case 1:\n          a.readHex(n, s);\n          a.readHexNumber(g, s);\n          addHex(g, n, s);\n          a.readNumber();\n          for (let e = 1; e < E; e++) {\n            incHex(g, s);\n            a.readHexNumber(n, s);\n            addHex(n, g, s);\n            a.readHexNumber(g, s);\n            addHex(g, n, s);\n            a.readNumber();\n          }\n          break;\n        case 2:\n          a.readHex(o, s);\n          h = a.readNumber();\n          t.mapOne(hexToInt(o, s), h);\n          for (let e = 1; e < E; e++) {\n            incHex(o, s);\n            if (!i) {\n              a.readHexNumber(C, s);\n              addHex(o, C, s);\n            }\n            h = a.readSigned() + (h + 1);\n            t.mapOne(hexToInt(o, s), h);\n          }\n          break;\n        case 3:\n          a.readHex(n, s);\n          a.readHexNumber(g, s);\n          addHex(g, n, s);\n          h = a.readNumber();\n          t.mapCidRange(hexToInt(n, s), hexToInt(g, s), h);\n          for (let e = 1; e < E; e++) {\n            incHex(g, s);\n            if (i) n.set(g);else {\n              a.readHexNumber(n, s);\n              addHex(n, g, s);\n            }\n            a.readHexNumber(g, s);\n            addHex(g, n, s);\n            h = a.readNumber();\n            t.mapCidRange(hexToInt(n, s), hexToInt(g, s), h);\n          }\n          break;\n        case 4:\n          a.readHex(o, Q);\n          a.readHex(c, s);\n          t.mapOne(hexToInt(o, Q), hexToStr(c, s));\n          for (let e = 1; e < E; e++) {\n            incHex(o, Q);\n            if (!i) {\n              a.readHexNumber(C, Q);\n              addHex(o, C, Q);\n            }\n            incHex(c, s);\n            a.readHexSigned(C, s);\n            addHex(c, C, s);\n            t.mapOne(hexToInt(o, Q), hexToStr(c, s));\n          }\n          break;\n        case 5:\n          a.readHex(n, Q);\n          a.readHexNumber(g, Q);\n          addHex(g, n, Q);\n          a.readHex(c, s);\n          t.mapBfRange(hexToInt(n, Q), hexToInt(g, Q), hexToStr(c, s));\n          for (let e = 1; e < E; e++) {\n            incHex(g, Q);\n            if (i) n.set(g);else {\n              a.readHexNumber(n, Q);\n              addHex(n, g, Q);\n            }\n            a.readHexNumber(g, Q);\n            addHex(g, n, Q);\n            a.readHex(c, s);\n            t.mapBfRange(hexToInt(n, Q), hexToInt(g, Q), hexToStr(c, s));\n          }\n          break;\n        default:\n          throw new Error(`BinaryCMapReader.process - unknown type: ${e}`);\n      }\n    }\n    return r ? i(r) : t;\n  }\n}\nconst Rt = new Uint8Array(0);\nclass DecodeStream extends BaseStream {\n  constructor(e) {\n    super();\n    this._rawMinBufferLength = e || 0;\n    this.pos = 0;\n    this.bufferLength = 0;\n    this.eof = !1;\n    this.buffer = Rt;\n    this.minBufferLength = 512;\n    if (e) for (; this.minBufferLength < e;) this.minBufferLength *= 2;\n  }\n  get isEmpty() {\n    for (; !this.eof && 0 === this.bufferLength;) this.readBlock();\n    return 0 === this.bufferLength;\n  }\n  ensureBuffer(e) {\n    const t = this.buffer;\n    if (e <= t.byteLength) return t;\n    let i = this.minBufferLength;\n    for (; i < e;) i *= 2;\n    const a = new Uint8Array(i);\n    a.set(t);\n    return this.buffer = a;\n  }\n  getByte() {\n    const e = this.pos;\n    for (; this.bufferLength <= e;) {\n      if (this.eof) return -1;\n      this.readBlock();\n    }\n    return this.buffer[this.pos++];\n  }\n  getBytes(e, t = null) {\n    const i = this.pos;\n    let a;\n    if (e) {\n      this.ensureBuffer(i + e);\n      a = i + e;\n      for (; !this.eof && this.bufferLength < a;) this.readBlock(t);\n      const s = this.bufferLength;\n      a > s && (a = s);\n    } else {\n      for (; !this.eof;) this.readBlock(t);\n      a = this.bufferLength;\n    }\n    this.pos = a;\n    return this.buffer.subarray(i, a);\n  }\n  async getImageData(e, t = null) {\n    if (!this.canAsyncDecodeImageFromBuffer) return this.getBytes(e, t);\n    const i = await this.stream.asyncGetBytes();\n    return this.decodeImage(i, t);\n  }\n  reset() {\n    this.pos = 0;\n  }\n  makeSubStream(e, t, i = null) {\n    if (void 0 === t) for (; !this.eof;) this.readBlock();else {\n      const i = e + t;\n      for (; this.bufferLength <= i && !this.eof;) this.readBlock();\n    }\n    return new Stream(this.buffer, e, t, i);\n  }\n  getBaseStreams() {\n    return this.str ? this.str.getBaseStreams() : null;\n  }\n}\nclass StreamsSequenceStream extends DecodeStream {\n  constructor(e, t = null) {\n    let i = 0;\n    for (const t of e) i += t instanceof DecodeStream ? t._rawMinBufferLength : t.length;\n    super(i);\n    this.streams = e;\n    this._onError = t;\n  }\n  readBlock() {\n    const e = this.streams;\n    if (0 === e.length) {\n      this.eof = !0;\n      return;\n    }\n    const t = e.shift();\n    let i;\n    try {\n      i = t.getBytes();\n    } catch (e) {\n      if (this._onError) {\n        this._onError(e, t.dict?.objId);\n        return;\n      }\n      throw e;\n    }\n    const a = this.bufferLength,\n      s = a + i.length;\n    this.ensureBuffer(s).set(i, a);\n    this.bufferLength = s;\n  }\n  getBaseStreams() {\n    const e = [];\n    for (const t of this.streams) {\n      const i = t.getBaseStreams();\n      i && e.push(...i);\n    }\n    return e.length > 0 ? e : null;\n  }\n}\nclass Ascii85Stream extends DecodeStream {\n  constructor(e, t) {\n    t && (t *= .8);\n    super(t);\n    this.str = e;\n    this.dict = e.dict;\n    this.input = new Uint8Array(5);\n  }\n  readBlock() {\n    const e = this.str;\n    let t = e.getByte();\n    for (; isWhiteSpace(t);) t = e.getByte();\n    if (-1 === t || 126 === t) {\n      this.eof = !0;\n      return;\n    }\n    const i = this.bufferLength;\n    let a, s;\n    if (122 === t) {\n      a = this.ensureBuffer(i + 4);\n      for (s = 0; s < 4; ++s) a[i + s] = 0;\n      this.bufferLength += 4;\n    } else {\n      const r = this.input;\n      r[0] = t;\n      for (s = 1; s < 5; ++s) {\n        t = e.getByte();\n        for (; isWhiteSpace(t);) t = e.getByte();\n        r[s] = t;\n        if (-1 === t || 126 === t) break;\n      }\n      a = this.ensureBuffer(i + s - 1);\n      this.bufferLength += s - 1;\n      if (s < 5) {\n        for (; s < 5; ++s) r[s] = 117;\n        this.eof = !0;\n      }\n      let n = 0;\n      for (s = 0; s < 5; ++s) n = 85 * n + (r[s] - 33);\n      for (s = 3; s >= 0; --s) {\n        a[i + s] = 255 & n;\n        n >>= 8;\n      }\n    }\n  }\n}\nclass AsciiHexStream extends DecodeStream {\n  constructor(e, t) {\n    t && (t *= .5);\n    super(t);\n    this.str = e;\n    this.dict = e.dict;\n    this.firstDigit = -1;\n  }\n  readBlock() {\n    const e = this.str.getBytes(8e3);\n    if (!e.length) {\n      this.eof = !0;\n      return;\n    }\n    const t = e.length + 1 >> 1,\n      i = this.ensureBuffer(this.bufferLength + t);\n    let a = this.bufferLength,\n      s = this.firstDigit;\n    for (const t of e) {\n      let e;\n      if (t >= 48 && t <= 57) e = 15 & t;else {\n        if (!(t >= 65 && t <= 70 || t >= 97 && t <= 102)) {\n          if (62 === t) {\n            this.eof = !0;\n            break;\n          }\n          continue;\n        }\n        e = 9 + (15 & t);\n      }\n      if (s < 0) s = e;else {\n        i[a++] = s << 4 | e;\n        s = -1;\n      }\n    }\n    if (s >= 0 && this.eof) {\n      i[a++] = s << 4;\n      s = -1;\n    }\n    this.firstDigit = s;\n    this.bufferLength = a;\n  }\n}\nconst Nt = -1,\n  Gt = [[-1, -1], [-1, -1], [7, 8], [7, 7], [6, 6], [6, 6], [6, 5], [6, 5], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2]],\n  xt = [[-1, -1], [12, -2], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [12, 1984], [12, 2048], [12, 2112], [12, 2176], [12, 2240], [12, 2304], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [12, 2368], [12, 2432], [12, 2496], [12, 2560]],\n  Ut = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [8, 29], [8, 29], [8, 30], [8, 30], [8, 45], [8, 45], [8, 46], [8, 46], [7, 22], [7, 22], [7, 22], [7, 22], [7, 23], [7, 23], [7, 23], [7, 23], [8, 47], [8, 47], [8, 48], [8, 48], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [7, 20], [7, 20], [7, 20], [7, 20], [8, 33], [8, 33], [8, 34], [8, 34], [8, 35], [8, 35], [8, 36], [8, 36], [8, 37], [8, 37], [8, 38], [8, 38], [7, 19], [7, 19], [7, 19], [7, 19], [8, 31], [8, 31], [8, 32], [8, 32], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [8, 53], [8, 53], [8, 54], [8, 54], [7, 26], [7, 26], [7, 26], [7, 26], [8, 39], [8, 39], [8, 40], [8, 40], [8, 41], [8, 41], [8, 42], [8, 42], [8, 43], [8, 43], [8, 44], [8, 44], [7, 21], [7, 21], [7, 21], [7, 21], [7, 28], [7, 28], [7, 28], [7, 28], [8, 61], [8, 61], [8, 62], [8, 62], [8, 63], [8, 63], [8, 0], [8, 0], [8, 320], [8, 320], [8, 384], [8, 384], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [7, 27], [7, 27], [7, 27], [7, 27], [8, 59], [8, 59], [8, 60], [8, 60], [9, 1472], [9, 1536], [9, 1600], [9, 1728], [7, 18], [7, 18], [7, 18], [7, 18], [7, 24], [7, 24], [7, 24], [7, 24], [8, 49], [8, 49], [8, 50], [8, 50], [8, 51], [8, 51], [8, 52], [8, 52], [7, 25], [7, 25], [7, 25], [7, 25], [8, 55], [8, 55], [8, 56], [8, 56], [8, 57], [8, 57], [8, 58], [8, 58], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [8, 448], [8, 448], [8, 512], [8, 512], [9, 704], [9, 768], [8, 640], [8, 640], [8, 576], [8, 576], [9, 832], [9, 896], [9, 960], [9, 1024], [9, 1088], [9, 1152], [9, 1216], [9, 1280], [9, 1344], [9, 1408], [7, 256], [7, 256], [7, 256], [7, 256], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7]],\n  Mt = [[-1, -1], [-1, -1], [12, -2], [12, -2], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [11, 1792], [11, 1792], [12, 1984], [12, 1984], [12, 2048], [12, 2048], [12, 2112], [12, 2112], [12, 2176], [12, 2176], [12, 2240], [12, 2240], [12, 2304], [12, 2304], [11, 1856], [11, 1856], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [11, 1920], [11, 1920], [12, 2368], [12, 2368], [12, 2432], [12, 2432], [12, 2496], [12, 2496], [12, 2560], [12, 2560], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [12, 52], [12, 52], [13, 640], [13, 704], [13, 768], [13, 832], [12, 55], [12, 55], [12, 56], [12, 56], [13, 1280], [13, 1344], [13, 1408], [13, 1472], [12, 59], [12, 59], [12, 60], [12, 60], [13, 1536], [13, 1600], [11, 24], [11, 24], [11, 24], [11, 24], [11, 25], [11, 25], [11, 25], [11, 25], [13, 1664], [13, 1728], [12, 320], [12, 320], [12, 384], [12, 384], [12, 448], [12, 448], [13, 512], [13, 576], [12, 53], [12, 53], [12, 54], [12, 54], [13, 896], [13, 960], [13, 1024], [13, 1088], [13, 1152], [13, 1216], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64]],\n  Lt = [[8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [11, 23], [11, 23], [12, 50], [12, 51], [12, 44], [12, 45], [12, 46], [12, 47], [12, 57], [12, 58], [12, 61], [12, 256], [10, 16], [10, 16], [10, 16], [10, 16], [10, 17], [10, 17], [10, 17], [10, 17], [12, 48], [12, 49], [12, 62], [12, 63], [12, 30], [12, 31], [12, 32], [12, 33], [12, 40], [12, 41], [11, 22], [11, 22], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [12, 128], [12, 192], [12, 26], [12, 27], [12, 28], [12, 29], [11, 19], [11, 19], [11, 20], [11, 20], [12, 34], [12, 35], [12, 36], [12, 37], [12, 38], [12, 39], [11, 21], [11, 21], [12, 42], [12, 43], [10, 0], [10, 0], [10, 0], [10, 0], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12]],\n  Ht = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [6, 9], [6, 8], [5, 7], [5, 7], [4, 6], [4, 6], [4, 6], [4, 6], [4, 5], [4, 5], [4, 5], [4, 5], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2]];\nclass CCITTFaxDecoder {\n  constructor(e, t = {}) {\n    if (!e || \"function\" != typeof e.next) throw new Error('CCITTFaxDecoder - invalid \"source\" parameter.');\n    this.source = e;\n    this.eof = !1;\n    this.encoding = t.K || 0;\n    this.eoline = t.EndOfLine || !1;\n    this.byteAlign = t.EncodedByteAlign || !1;\n    this.columns = t.Columns || 1728;\n    this.rows = t.Rows || 0;\n    this.eoblock = t.EndOfBlock ?? !0;\n    this.black = t.BlackIs1 || !1;\n    this.codingLine = new Uint32Array(this.columns + 1);\n    this.refLine = new Uint32Array(this.columns + 2);\n    this.codingLine[0] = this.columns;\n    this.codingPos = 0;\n    this.row = 0;\n    this.nextLine2D = this.encoding < 0;\n    this.inputBits = 0;\n    this.inputBuf = 0;\n    this.outputBits = 0;\n    this.rowsDone = !1;\n    let i;\n    for (; 0 === (i = this._lookBits(12));) this._eatBits(1);\n    1 === i && this._eatBits(12);\n    if (this.encoding > 0) {\n      this.nextLine2D = !this._lookBits(1);\n      this._eatBits(1);\n    }\n  }\n  readNextChar() {\n    if (this.eof) return -1;\n    const e = this.refLine,\n      t = this.codingLine,\n      i = this.columns;\n    let a, s, r, n, g;\n    if (0 === this.outputBits) {\n      this.rowsDone && (this.eof = !0);\n      if (this.eof) return -1;\n      this.err = !1;\n      let r, g, o;\n      if (this.nextLine2D) {\n        for (n = 0; t[n] < i; ++n) e[n] = t[n];\n        e[n++] = i;\n        e[n] = i;\n        t[0] = 0;\n        this.codingPos = 0;\n        a = 0;\n        s = 0;\n        for (; t[this.codingPos] < i;) {\n          r = this._getTwoDimCode();\n          switch (r) {\n            case 0:\n              this._addPixels(e[a + 1], s);\n              e[a + 1] < i && (a += 2);\n              break;\n            case 1:\n              r = g = 0;\n              if (s) {\n                do {\n                  r += o = this._getBlackCode();\n                } while (o >= 64);\n                do {\n                  g += o = this._getWhiteCode();\n                } while (o >= 64);\n              } else {\n                do {\n                  r += o = this._getWhiteCode();\n                } while (o >= 64);\n                do {\n                  g += o = this._getBlackCode();\n                } while (o >= 64);\n              }\n              this._addPixels(t[this.codingPos] + r, s);\n              t[this.codingPos] < i && this._addPixels(t[this.codingPos] + g, 1 ^ s);\n              for (; e[a] <= t[this.codingPos] && e[a] < i;) a += 2;\n              break;\n            case 7:\n              this._addPixels(e[a] + 3, s);\n              s ^= 1;\n              if (t[this.codingPos] < i) {\n                ++a;\n                for (; e[a] <= t[this.codingPos] && e[a] < i;) a += 2;\n              }\n              break;\n            case 5:\n              this._addPixels(e[a] + 2, s);\n              s ^= 1;\n              if (t[this.codingPos] < i) {\n                ++a;\n                for (; e[a] <= t[this.codingPos] && e[a] < i;) a += 2;\n              }\n              break;\n            case 3:\n              this._addPixels(e[a] + 1, s);\n              s ^= 1;\n              if (t[this.codingPos] < i) {\n                ++a;\n                for (; e[a] <= t[this.codingPos] && e[a] < i;) a += 2;\n              }\n              break;\n            case 2:\n              this._addPixels(e[a], s);\n              s ^= 1;\n              if (t[this.codingPos] < i) {\n                ++a;\n                for (; e[a] <= t[this.codingPos] && e[a] < i;) a += 2;\n              }\n              break;\n            case 8:\n              this._addPixelsNeg(e[a] - 3, s);\n              s ^= 1;\n              if (t[this.codingPos] < i) {\n                a > 0 ? --a : ++a;\n                for (; e[a] <= t[this.codingPos] && e[a] < i;) a += 2;\n              }\n              break;\n            case 6:\n              this._addPixelsNeg(e[a] - 2, s);\n              s ^= 1;\n              if (t[this.codingPos] < i) {\n                a > 0 ? --a : ++a;\n                for (; e[a] <= t[this.codingPos] && e[a] < i;) a += 2;\n              }\n              break;\n            case 4:\n              this._addPixelsNeg(e[a] - 1, s);\n              s ^= 1;\n              if (t[this.codingPos] < i) {\n                a > 0 ? --a : ++a;\n                for (; e[a] <= t[this.codingPos] && e[a] < i;) a += 2;\n              }\n              break;\n            case Nt:\n              this._addPixels(i, 0);\n              this.eof = !0;\n              break;\n            default:\n              info(\"bad 2d code\");\n              this._addPixels(i, 0);\n              this.err = !0;\n          }\n        }\n      } else {\n        t[0] = 0;\n        this.codingPos = 0;\n        s = 0;\n        for (; t[this.codingPos] < i;) {\n          r = 0;\n          if (s) do {\n            r += o = this._getBlackCode();\n          } while (o >= 64);else do {\n            r += o = this._getWhiteCode();\n          } while (o >= 64);\n          this._addPixels(t[this.codingPos] + r, s);\n          s ^= 1;\n        }\n      }\n      let c = !1;\n      this.byteAlign && (this.inputBits &= -8);\n      if (this.eoblock || this.row !== this.rows - 1) {\n        r = this._lookBits(12);\n        if (this.eoline) for (; r !== Nt && 1 !== r;) {\n          this._eatBits(1);\n          r = this._lookBits(12);\n        } else for (; 0 === r;) {\n          this._eatBits(1);\n          r = this._lookBits(12);\n        }\n        if (1 === r) {\n          this._eatBits(12);\n          c = !0;\n        } else r === Nt && (this.eof = !0);\n      } else this.rowsDone = !0;\n      if (!this.eof && this.encoding > 0 && !this.rowsDone) {\n        this.nextLine2D = !this._lookBits(1);\n        this._eatBits(1);\n      }\n      if (this.eoblock && c && this.byteAlign) {\n        r = this._lookBits(12);\n        if (1 === r) {\n          this._eatBits(12);\n          if (this.encoding > 0) {\n            this._lookBits(1);\n            this._eatBits(1);\n          }\n          if (this.encoding >= 0) for (n = 0; n < 4; ++n) {\n            r = this._lookBits(12);\n            1 !== r && info(\"bad rtc code: \" + r);\n            this._eatBits(12);\n            if (this.encoding > 0) {\n              this._lookBits(1);\n              this._eatBits(1);\n            }\n          }\n          this.eof = !0;\n        }\n      } else if (this.err && this.eoline) {\n        for (;;) {\n          r = this._lookBits(13);\n          if (r === Nt) {\n            this.eof = !0;\n            return -1;\n          }\n          if (r >> 1 == 1) break;\n          this._eatBits(1);\n        }\n        this._eatBits(12);\n        if (this.encoding > 0) {\n          this._eatBits(1);\n          this.nextLine2D = !(1 & r);\n        }\n      }\n      this.outputBits = t[0] > 0 ? t[this.codingPos = 0] : t[this.codingPos = 1];\n      this.row++;\n    }\n    if (this.outputBits >= 8) {\n      g = 1 & this.codingPos ? 0 : 255;\n      this.outputBits -= 8;\n      if (0 === this.outputBits && t[this.codingPos] < i) {\n        this.codingPos++;\n        this.outputBits = t[this.codingPos] - t[this.codingPos - 1];\n      }\n    } else {\n      r = 8;\n      g = 0;\n      do {\n        if (\"number\" != typeof this.outputBits) throw new FormatError('Invalid /CCITTFaxDecode data, \"outputBits\" must be a number.');\n        if (this.outputBits > r) {\n          g <<= r;\n          1 & this.codingPos || (g |= 255 >> 8 - r);\n          this.outputBits -= r;\n          r = 0;\n        } else {\n          g <<= this.outputBits;\n          1 & this.codingPos || (g |= 255 >> 8 - this.outputBits);\n          r -= this.outputBits;\n          this.outputBits = 0;\n          if (t[this.codingPos] < i) {\n            this.codingPos++;\n            this.outputBits = t[this.codingPos] - t[this.codingPos - 1];\n          } else if (r > 0) {\n            g <<= r;\n            r = 0;\n          }\n        }\n      } while (r);\n    }\n    this.black && (g ^= 255);\n    return g;\n  }\n  _addPixels(e, t) {\n    const i = this.codingLine;\n    let a = this.codingPos;\n    if (e > i[a]) {\n      if (e > this.columns) {\n        info(\"row is wrong length\");\n        this.err = !0;\n        e = this.columns;\n      }\n      1 & a ^ t && ++a;\n      i[a] = e;\n    }\n    this.codingPos = a;\n  }\n  _addPixelsNeg(e, t) {\n    const i = this.codingLine;\n    let a = this.codingPos;\n    if (e > i[a]) {\n      if (e > this.columns) {\n        info(\"row is wrong length\");\n        this.err = !0;\n        e = this.columns;\n      }\n      1 & a ^ t && ++a;\n      i[a] = e;\n    } else if (e < i[a]) {\n      if (e < 0) {\n        info(\"invalid code\");\n        this.err = !0;\n        e = 0;\n      }\n      for (; a > 0 && e < i[a - 1];) --a;\n      i[a] = e;\n    }\n    this.codingPos = a;\n  }\n  _findTableCode(e, t, i, a) {\n    const s = a || 0;\n    for (let a = e; a <= t; ++a) {\n      let e = this._lookBits(a);\n      if (e === Nt) return [!0, 1, !1];\n      a < t && (e <<= t - a);\n      if (!s || e >= s) {\n        const t = i[e - s];\n        if (t[0] === a) {\n          this._eatBits(a);\n          return [!0, t[1], !0];\n        }\n      }\n    }\n    return [!1, 0, !1];\n  }\n  _getTwoDimCode() {\n    let e,\n      t = 0;\n    if (this.eoblock) {\n      t = this._lookBits(7);\n      e = Gt[t];\n      if (e?.[0] > 0) {\n        this._eatBits(e[0]);\n        return e[1];\n      }\n    } else {\n      const e = this._findTableCode(1, 7, Gt);\n      if (e[0] && e[2]) return e[1];\n    }\n    info(\"Bad two dim code\");\n    return Nt;\n  }\n  _getWhiteCode() {\n    let e,\n      t = 0;\n    if (this.eoblock) {\n      t = this._lookBits(12);\n      if (t === Nt) return 1;\n      e = t >> 5 == 0 ? xt[t] : Ut[t >> 3];\n      if (e[0] > 0) {\n        this._eatBits(e[0]);\n        return e[1];\n      }\n    } else {\n      let e = this._findTableCode(1, 9, Ut);\n      if (e[0]) return e[1];\n      e = this._findTableCode(11, 12, xt);\n      if (e[0]) return e[1];\n    }\n    info(\"bad white code\");\n    this._eatBits(1);\n    return 1;\n  }\n  _getBlackCode() {\n    let e, t;\n    if (this.eoblock) {\n      e = this._lookBits(13);\n      if (e === Nt) return 1;\n      t = e >> 7 == 0 ? Mt[e] : e >> 9 == 0 && e >> 7 != 0 ? Lt[(e >> 1) - 64] : Ht[e >> 7];\n      if (t[0] > 0) {\n        this._eatBits(t[0]);\n        return t[1];\n      }\n    } else {\n      let e = this._findTableCode(2, 6, Ht);\n      if (e[0]) return e[1];\n      e = this._findTableCode(7, 12, Lt, 64);\n      if (e[0]) return e[1];\n      e = this._findTableCode(10, 13, Mt);\n      if (e[0]) return e[1];\n    }\n    info(\"bad black code\");\n    this._eatBits(1);\n    return 1;\n  }\n  _lookBits(e) {\n    let t;\n    for (; this.inputBits < e;) {\n      if (-1 === (t = this.source.next())) return 0 === this.inputBits ? Nt : this.inputBuf << e - this.inputBits & 65535 >> 16 - e;\n      this.inputBuf = this.inputBuf << 8 | t;\n      this.inputBits += 8;\n    }\n    return this.inputBuf >> this.inputBits - e & 65535 >> 16 - e;\n  }\n  _eatBits(e) {\n    (this.inputBits -= e) < 0 && (this.inputBits = 0);\n  }\n}\nclass CCITTFaxStream extends DecodeStream {\n  constructor(e, t, i) {\n    super(t);\n    this.str = e;\n    this.dict = e.dict;\n    i instanceof Dict || (i = Dict.empty);\n    const a = {\n      next: () => e.getByte()\n    };\n    this.ccittFaxDecoder = new CCITTFaxDecoder(a, {\n      K: i.get(\"K\"),\n      EndOfLine: i.get(\"EndOfLine\"),\n      EncodedByteAlign: i.get(\"EncodedByteAlign\"),\n      Columns: i.get(\"Columns\"),\n      Rows: i.get(\"Rows\"),\n      EndOfBlock: i.get(\"EndOfBlock\"),\n      BlackIs1: i.get(\"BlackIs1\")\n    });\n  }\n  readBlock() {\n    for (; !this.eof;) {\n      const e = this.ccittFaxDecoder.readNextChar();\n      if (-1 === e) {\n        this.eof = !0;\n        return;\n      }\n      this.ensureBuffer(this.bufferLength + 1);\n      this.buffer[this.bufferLength++] = e;\n    }\n  }\n}\nconst Jt = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),\n  Yt = new Int32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]),\n  vt = new Int32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353, 876545]),\n  Kt = [new Int32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9],\n  Tt = [new Int32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5];\nclass FlateStream extends DecodeStream {\n  constructor(e, t) {\n    super(t);\n    this.str = e;\n    this.dict = e.dict;\n    const i = e.getByte(),\n      a = e.getByte();\n    if (-1 === i || -1 === a) throw new FormatError(`Invalid header in flate stream: ${i}, ${a}`);\n    if (8 != (15 & i)) throw new FormatError(`Unknown compression method in flate stream: ${i}, ${a}`);\n    if (((i << 8) + a) % 31 != 0) throw new FormatError(`Bad FCHECK in flate stream: ${i}, ${a}`);\n    if (32 & a) throw new FormatError(`FDICT bit set in flate stream: ${i}, ${a}`);\n    this.codeSize = 0;\n    this.codeBuf = 0;\n  }\n  async getImageData(e, t) {\n    const i = await this.asyncGetBytes();\n    return i?.subarray(0, e) || this.getBytes(e);\n  }\n  async asyncGetBytes() {\n    this.str.reset();\n    const e = this.str.getBytes();\n    try {\n      const {\n          readable: t,\n          writable: i\n        } = new DecompressionStream(\"deflate\"),\n        a = i.getWriter();\n      a.write(e);\n      a.close();\n      const s = [];\n      let r = 0;\n      for await (const e of t) {\n        s.push(e);\n        r += e.byteLength;\n      }\n      const n = new Uint8Array(r);\n      let g = 0;\n      for (const e of s) {\n        n.set(e, g);\n        g += e.byteLength;\n      }\n      return n;\n    } catch {\n      this.str = new Stream(e, 2, e.length, this.str.dict);\n      this.reset();\n      return null;\n    }\n  }\n  get isAsync() {\n    return !0;\n  }\n  getBits(e) {\n    const t = this.str;\n    let i,\n      a = this.codeSize,\n      s = this.codeBuf;\n    for (; a < e;) {\n      if (-1 === (i = t.getByte())) throw new FormatError(\"Bad encoding in flate stream\");\n      s |= i << a;\n      a += 8;\n    }\n    i = s & (1 << e) - 1;\n    this.codeBuf = s >> e;\n    this.codeSize = a -= e;\n    return i;\n  }\n  getCode(e) {\n    const t = this.str,\n      i = e[0],\n      a = e[1];\n    let s,\n      r = this.codeSize,\n      n = this.codeBuf;\n    for (; r < a && -1 !== (s = t.getByte());) {\n      n |= s << r;\n      r += 8;\n    }\n    const g = i[n & (1 << a) - 1],\n      o = g >> 16,\n      c = 65535 & g;\n    if (o < 1 || r < o) throw new FormatError(\"Bad encoding in flate stream\");\n    this.codeBuf = n >> o;\n    this.codeSize = r - o;\n    return c;\n  }\n  generateHuffmanTable(e) {\n    const t = e.length;\n    let i,\n      a = 0;\n    for (i = 0; i < t; ++i) e[i] > a && (a = e[i]);\n    const s = 1 << a,\n      r = new Int32Array(s);\n    for (let n = 1, g = 0, o = 2; n <= a; ++n, g <<= 1, o <<= 1) for (let a = 0; a < t; ++a) if (e[a] === n) {\n      let e = 0,\n        t = g;\n      for (i = 0; i < n; ++i) {\n        e = e << 1 | 1 & t;\n        t >>= 1;\n      }\n      for (i = e; i < s; i += o) r[i] = n << 16 | a;\n      ++g;\n    }\n    return [r, a];\n  }\n  #m(e) {\n    info(e);\n    this.eof = !0;\n  }\n  readBlock() {\n    let e, t, i;\n    const a = this.str;\n    try {\n      t = this.getBits(3);\n    } catch (e) {\n      this.#m(e.message);\n      return;\n    }\n    1 & t && (this.eof = !0);\n    t >>= 1;\n    if (0 === t) {\n      let t;\n      if (-1 === (t = a.getByte())) {\n        this.#m(\"Bad block header in flate stream\");\n        return;\n      }\n      let i = t;\n      if (-1 === (t = a.getByte())) {\n        this.#m(\"Bad block header in flate stream\");\n        return;\n      }\n      i |= t << 8;\n      if (-1 === (t = a.getByte())) {\n        this.#m(\"Bad block header in flate stream\");\n        return;\n      }\n      let s = t;\n      if (-1 === (t = a.getByte())) {\n        this.#m(\"Bad block header in flate stream\");\n        return;\n      }\n      s |= t << 8;\n      if (s !== (65535 & ~i) && (0 !== i || 0 !== s)) throw new FormatError(\"Bad uncompressed block length in flate stream\");\n      this.codeBuf = 0;\n      this.codeSize = 0;\n      const r = this.bufferLength,\n        n = r + i;\n      e = this.ensureBuffer(n);\n      this.bufferLength = n;\n      if (0 === i) -1 === a.peekByte() && (this.eof = !0);else {\n        const t = a.getBytes(i);\n        e.set(t, r);\n        t.length < i && (this.eof = !0);\n      }\n      return;\n    }\n    let s, r;\n    if (1 === t) {\n      s = Kt;\n      r = Tt;\n    } else {\n      if (2 !== t) throw new FormatError(\"Unknown block type in flate stream\");\n      {\n        const e = this.getBits(5) + 257,\n          t = this.getBits(5) + 1,\n          a = this.getBits(4) + 4,\n          n = new Uint8Array(Jt.length);\n        let g;\n        for (g = 0; g < a; ++g) n[Jt[g]] = this.getBits(3);\n        const o = this.generateHuffmanTable(n);\n        i = 0;\n        g = 0;\n        const c = e + t,\n          C = new Uint8Array(c);\n        let h, l, Q;\n        for (; g < c;) {\n          const e = this.getCode(o);\n          if (16 === e) {\n            h = 2;\n            l = 3;\n            Q = i;\n          } else if (17 === e) {\n            h = 3;\n            l = 3;\n            Q = i = 0;\n          } else {\n            if (18 !== e) {\n              C[g++] = i = e;\n              continue;\n            }\n            h = 7;\n            l = 11;\n            Q = i = 0;\n          }\n          let t = this.getBits(h) + l;\n          for (; t-- > 0;) C[g++] = Q;\n        }\n        s = this.generateHuffmanTable(C.subarray(0, e));\n        r = this.generateHuffmanTable(C.subarray(e, c));\n      }\n    }\n    e = this.buffer;\n    let n = e ? e.length : 0,\n      g = this.bufferLength;\n    for (;;) {\n      let t = this.getCode(s);\n      if (t < 256) {\n        if (g + 1 >= n) {\n          e = this.ensureBuffer(g + 1);\n          n = e.length;\n        }\n        e[g++] = t;\n        continue;\n      }\n      if (256 === t) {\n        this.bufferLength = g;\n        return;\n      }\n      t -= 257;\n      t = Yt[t];\n      let a = t >> 16;\n      a > 0 && (a = this.getBits(a));\n      i = (65535 & t) + a;\n      t = this.getCode(r);\n      t = vt[t];\n      a = t >> 16;\n      a > 0 && (a = this.getBits(a));\n      const o = (65535 & t) + a;\n      if (g + i >= n) {\n        e = this.ensureBuffer(g + i);\n        n = e.length;\n      }\n      for (let t = 0; t < i; ++t, ++g) e[g] = e[g - o];\n    }\n  }\n}\nconst qt = [{\n  qe: 22017,\n  nmps: 1,\n  nlps: 1,\n  switchFlag: 1\n}, {\n  qe: 13313,\n  nmps: 2,\n  nlps: 6,\n  switchFlag: 0\n}, {\n  qe: 6145,\n  nmps: 3,\n  nlps: 9,\n  switchFlag: 0\n}, {\n  qe: 2753,\n  nmps: 4,\n  nlps: 12,\n  switchFlag: 0\n}, {\n  qe: 1313,\n  nmps: 5,\n  nlps: 29,\n  switchFlag: 0\n}, {\n  qe: 545,\n  nmps: 38,\n  nlps: 33,\n  switchFlag: 0\n}, {\n  qe: 22017,\n  nmps: 7,\n  nlps: 6,\n  switchFlag: 1\n}, {\n  qe: 21505,\n  nmps: 8,\n  nlps: 14,\n  switchFlag: 0\n}, {\n  qe: 18433,\n  nmps: 9,\n  nlps: 14,\n  switchFlag: 0\n}, {\n  qe: 14337,\n  nmps: 10,\n  nlps: 14,\n  switchFlag: 0\n}, {\n  qe: 12289,\n  nmps: 11,\n  nlps: 17,\n  switchFlag: 0\n}, {\n  qe: 9217,\n  nmps: 12,\n  nlps: 18,\n  switchFlag: 0\n}, {\n  qe: 7169,\n  nmps: 13,\n  nlps: 20,\n  switchFlag: 0\n}, {\n  qe: 5633,\n  nmps: 29,\n  nlps: 21,\n  switchFlag: 0\n}, {\n  qe: 22017,\n  nmps: 15,\n  nlps: 14,\n  switchFlag: 1\n}, {\n  qe: 21505,\n  nmps: 16,\n  nlps: 14,\n  switchFlag: 0\n}, {\n  qe: 20737,\n  nmps: 17,\n  nlps: 15,\n  switchFlag: 0\n}, {\n  qe: 18433,\n  nmps: 18,\n  nlps: 16,\n  switchFlag: 0\n}, {\n  qe: 14337,\n  nmps: 19,\n  nlps: 17,\n  switchFlag: 0\n}, {\n  qe: 13313,\n  nmps: 20,\n  nlps: 18,\n  switchFlag: 0\n}, {\n  qe: 12289,\n  nmps: 21,\n  nlps: 19,\n  switchFlag: 0\n}, {\n  qe: 10241,\n  nmps: 22,\n  nlps: 19,\n  switchFlag: 0\n}, {\n  qe: 9217,\n  nmps: 23,\n  nlps: 20,\n  switchFlag: 0\n}, {\n  qe: 8705,\n  nmps: 24,\n  nlps: 21,\n  switchFlag: 0\n}, {\n  qe: 7169,\n  nmps: 25,\n  nlps: 22,\n  switchFlag: 0\n}, {\n  qe: 6145,\n  nmps: 26,\n  nlps: 23,\n  switchFlag: 0\n}, {\n  qe: 5633,\n  nmps: 27,\n  nlps: 24,\n  switchFlag: 0\n}, {\n  qe: 5121,\n  nmps: 28,\n  nlps: 25,\n  switchFlag: 0\n}, {\n  qe: 4609,\n  nmps: 29,\n  nlps: 26,\n  switchFlag: 0\n}, {\n  qe: 4353,\n  nmps: 30,\n  nlps: 27,\n  switchFlag: 0\n}, {\n  qe: 2753,\n  nmps: 31,\n  nlps: 28,\n  switchFlag: 0\n}, {\n  qe: 2497,\n  nmps: 32,\n  nlps: 29,\n  switchFlag: 0\n}, {\n  qe: 2209,\n  nmps: 33,\n  nlps: 30,\n  switchFlag: 0\n}, {\n  qe: 1313,\n  nmps: 34,\n  nlps: 31,\n  switchFlag: 0\n}, {\n  qe: 1089,\n  nmps: 35,\n  nlps: 32,\n  switchFlag: 0\n}, {\n  qe: 673,\n  nmps: 36,\n  nlps: 33,\n  switchFlag: 0\n}, {\n  qe: 545,\n  nmps: 37,\n  nlps: 34,\n  switchFlag: 0\n}, {\n  qe: 321,\n  nmps: 38,\n  nlps: 35,\n  switchFlag: 0\n}, {\n  qe: 273,\n  nmps: 39,\n  nlps: 36,\n  switchFlag: 0\n}, {\n  qe: 133,\n  nmps: 40,\n  nlps: 37,\n  switchFlag: 0\n}, {\n  qe: 73,\n  nmps: 41,\n  nlps: 38,\n  switchFlag: 0\n}, {\n  qe: 37,\n  nmps: 42,\n  nlps: 39,\n  switchFlag: 0\n}, {\n  qe: 21,\n  nmps: 43,\n  nlps: 40,\n  switchFlag: 0\n}, {\n  qe: 9,\n  nmps: 44,\n  nlps: 41,\n  switchFlag: 0\n}, {\n  qe: 5,\n  nmps: 45,\n  nlps: 42,\n  switchFlag: 0\n}, {\n  qe: 1,\n  nmps: 45,\n  nlps: 43,\n  switchFlag: 0\n}, {\n  qe: 22017,\n  nmps: 46,\n  nlps: 46,\n  switchFlag: 0\n}];\nclass ArithmeticDecoder {\n  constructor(e, t, i) {\n    this.data = e;\n    this.bp = t;\n    this.dataEnd = i;\n    this.chigh = e[t];\n    this.clow = 0;\n    this.byteIn();\n    this.chigh = this.chigh << 7 & 65535 | this.clow >> 9 & 127;\n    this.clow = this.clow << 7 & 65535;\n    this.ct -= 7;\n    this.a = 32768;\n  }\n  byteIn() {\n    const e = this.data;\n    let t = this.bp;\n    if (255 === e[t]) {\n      if (e[t + 1] > 143) {\n        this.clow += 65280;\n        this.ct = 8;\n      } else {\n        t++;\n        this.clow += e[t] << 9;\n        this.ct = 7;\n        this.bp = t;\n      }\n    } else {\n      t++;\n      this.clow += t < this.dataEnd ? e[t] << 8 : 65280;\n      this.ct = 8;\n      this.bp = t;\n    }\n    if (this.clow > 65535) {\n      this.chigh += this.clow >> 16;\n      this.clow &= 65535;\n    }\n  }\n  readBit(e, t) {\n    let i = e[t] >> 1,\n      a = 1 & e[t];\n    const s = qt[i],\n      r = s.qe;\n    let n,\n      g = this.a - r;\n    if (this.chigh < r) {\n      if (g < r) {\n        g = r;\n        n = a;\n        i = s.nmps;\n      } else {\n        g = r;\n        n = 1 ^ a;\n        1 === s.switchFlag && (a = n);\n        i = s.nlps;\n      }\n    } else {\n      this.chigh -= r;\n      if (0 != (32768 & g)) {\n        this.a = g;\n        return a;\n      }\n      if (g < r) {\n        n = 1 ^ a;\n        1 === s.switchFlag && (a = n);\n        i = s.nlps;\n      } else {\n        n = a;\n        i = s.nmps;\n      }\n    }\n    do {\n      0 === this.ct && this.byteIn();\n      g <<= 1;\n      this.chigh = this.chigh << 1 & 65535 | this.clow >> 15 & 1;\n      this.clow = this.clow << 1 & 65535;\n      this.ct--;\n    } while (0 == (32768 & g));\n    this.a = g;\n    e[t] = i << 1 | a;\n    return n;\n  }\n}\nclass Jbig2Error extends rt {\n  constructor(e) {\n    super(e, \"Jbig2Error\");\n  }\n}\nclass ContextCache {\n  getContexts(e) {\n    return e in this ? this[e] : this[e] = new Int8Array(65536);\n  }\n}\nclass DecodingContext {\n  constructor(e, t, i) {\n    this.data = e;\n    this.start = t;\n    this.end = i;\n  }\n  get decoder() {\n    return shadow(this, \"decoder\", new ArithmeticDecoder(this.data, this.start, this.end));\n  }\n  get contextCache() {\n    return shadow(this, \"contextCache\", new ContextCache());\n  }\n}\nconst Ot = 2 ** 31 - 1,\n  Pt = -(2 ** 31);\nfunction decodeInteger(e, t, i) {\n  const a = e.getContexts(t);\n  let s = 1;\n  function readBits(e) {\n    let t = 0;\n    for (let r = 0; r < e; r++) {\n      const e = i.readBit(a, s);\n      s = s < 256 ? s << 1 | e : 511 & (s << 1 | e) | 256;\n      t = t << 1 | e;\n    }\n    return t >>> 0;\n  }\n  const r = readBits(1),\n    n = readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(32) + 4436 : readBits(12) + 340 : readBits(8) + 84 : readBits(6) + 20 : readBits(4) + 4 : readBits(2);\n  let g;\n  0 === r ? g = n : n > 0 && (g = -n);\n  return g >= Pt && g <= Ot ? g : null;\n}\nfunction decodeIAID(e, t, i) {\n  const a = e.getContexts(\"IAID\");\n  let s = 1;\n  for (let e = 0; e < i; e++) {\n    s = s << 1 | t.readBit(a, s);\n  }\n  return i < 31 ? s & (1 << i) - 1 : 2147483647 & s;\n}\nconst Wt = [\"SymbolDictionary\", null, null, null, \"IntermediateTextRegion\", null, \"ImmediateTextRegion\", \"ImmediateLosslessTextRegion\", null, null, null, null, null, null, null, null, \"PatternDictionary\", null, null, null, \"IntermediateHalftoneRegion\", null, \"ImmediateHalftoneRegion\", \"ImmediateLosslessHalftoneRegion\", null, null, null, null, null, null, null, null, null, null, null, null, \"IntermediateGenericRegion\", null, \"ImmediateGenericRegion\", \"ImmediateLosslessGenericRegion\", \"IntermediateGenericRefinementRegion\", null, \"ImmediateGenericRefinementRegion\", \"ImmediateLosslessGenericRefinementRegion\", null, null, null, null, \"PageInformation\", \"EndOfPage\", \"EndOfStripe\", \"EndOfFile\", \"Profiles\", \"Tables\", null, null, null, null, null, null, null, null, \"Extension\"],\n  jt = [[{\n    x: -1,\n    y: -2\n  }, {\n    x: 0,\n    y: -2\n  }, {\n    x: 1,\n    y: -2\n  }, {\n    x: -2,\n    y: -1\n  }, {\n    x: -1,\n    y: -1\n  }, {\n    x: 0,\n    y: -1\n  }, {\n    x: 1,\n    y: -1\n  }, {\n    x: 2,\n    y: -1\n  }, {\n    x: -4,\n    y: 0\n  }, {\n    x: -3,\n    y: 0\n  }, {\n    x: -2,\n    y: 0\n  }, {\n    x: -1,\n    y: 0\n  }], [{\n    x: -1,\n    y: -2\n  }, {\n    x: 0,\n    y: -2\n  }, {\n    x: 1,\n    y: -2\n  }, {\n    x: 2,\n    y: -2\n  }, {\n    x: -2,\n    y: -1\n  }, {\n    x: -1,\n    y: -1\n  }, {\n    x: 0,\n    y: -1\n  }, {\n    x: 1,\n    y: -1\n  }, {\n    x: 2,\n    y: -1\n  }, {\n    x: -3,\n    y: 0\n  }, {\n    x: -2,\n    y: 0\n  }, {\n    x: -1,\n    y: 0\n  }], [{\n    x: -1,\n    y: -2\n  }, {\n    x: 0,\n    y: -2\n  }, {\n    x: 1,\n    y: -2\n  }, {\n    x: -2,\n    y: -1\n  }, {\n    x: -1,\n    y: -1\n  }, {\n    x: 0,\n    y: -1\n  }, {\n    x: 1,\n    y: -1\n  }, {\n    x: -2,\n    y: 0\n  }, {\n    x: -1,\n    y: 0\n  }], [{\n    x: -3,\n    y: -1\n  }, {\n    x: -2,\n    y: -1\n  }, {\n    x: -1,\n    y: -1\n  }, {\n    x: 0,\n    y: -1\n  }, {\n    x: 1,\n    y: -1\n  }, {\n    x: -4,\n    y: 0\n  }, {\n    x: -3,\n    y: 0\n  }, {\n    x: -2,\n    y: 0\n  }, {\n    x: -1,\n    y: 0\n  }]],\n  Xt = [{\n    coding: [{\n      x: 0,\n      y: -1\n    }, {\n      x: 1,\n      y: -1\n    }, {\n      x: -1,\n      y: 0\n    }],\n    reference: [{\n      x: 0,\n      y: -1\n    }, {\n      x: 1,\n      y: -1\n    }, {\n      x: -1,\n      y: 0\n    }, {\n      x: 0,\n      y: 0\n    }, {\n      x: 1,\n      y: 0\n    }, {\n      x: -1,\n      y: 1\n    }, {\n      x: 0,\n      y: 1\n    }, {\n      x: 1,\n      y: 1\n    }]\n  }, {\n    coding: [{\n      x: -1,\n      y: -1\n    }, {\n      x: 0,\n      y: -1\n    }, {\n      x: 1,\n      y: -1\n    }, {\n      x: -1,\n      y: 0\n    }],\n    reference: [{\n      x: 0,\n      y: -1\n    }, {\n      x: -1,\n      y: 0\n    }, {\n      x: 0,\n      y: 0\n    }, {\n      x: 1,\n      y: 0\n    }, {\n      x: 0,\n      y: 1\n    }, {\n      x: 1,\n      y: 1\n    }]\n  }],\n  Zt = [39717, 1941, 229, 405],\n  Vt = [32, 8];\nfunction decodeBitmap(e, t, i, a, s, r, n, g) {\n  if (e) {\n    return decodeMMRBitmap(new Reader(g.data, g.start, g.end), t, i, !1);\n  }\n  if (0 === a && !r && !s && 4 === n.length && 3 === n[0].x && -1 === n[0].y && -3 === n[1].x && -1 === n[1].y && 2 === n[2].x && -2 === n[2].y && -2 === n[3].x && -2 === n[3].y) return function decodeBitmapTemplate0(e, t, i) {\n    const a = i.decoder,\n      s = i.contextCache.getContexts(\"GB\"),\n      r = [];\n    let n, g, o, c, C, h, l;\n    for (g = 0; g < t; g++) {\n      C = r[g] = new Uint8Array(e);\n      h = g < 1 ? C : r[g - 1];\n      l = g < 2 ? C : r[g - 2];\n      n = l[0] << 13 | l[1] << 12 | l[2] << 11 | h[0] << 7 | h[1] << 6 | h[2] << 5 | h[3] << 4;\n      for (o = 0; o < e; o++) {\n        C[o] = c = a.readBit(s, n);\n        n = (31735 & n) << 1 | (o + 3 < e ? l[o + 3] << 11 : 0) | (o + 4 < e ? h[o + 4] << 4 : 0) | c;\n      }\n    }\n    return r;\n  }(t, i, g);\n  const o = !!r,\n    c = jt[a].concat(n);\n  c.sort(function (e, t) {\n    return e.y - t.y || e.x - t.x;\n  });\n  const C = c.length,\n    h = new Int8Array(C),\n    l = new Int8Array(C),\n    Q = [];\n  let E,\n    u,\n    d = 0,\n    f = 0,\n    p = 0,\n    m = 0;\n  for (u = 0; u < C; u++) {\n    h[u] = c[u].x;\n    l[u] = c[u].y;\n    f = Math.min(f, c[u].x);\n    p = Math.max(p, c[u].x);\n    m = Math.min(m, c[u].y);\n    u < C - 1 && c[u].y === c[u + 1].y && c[u].x === c[u + 1].x - 1 ? d |= 1 << C - 1 - u : Q.push(u);\n  }\n  const y = Q.length,\n    w = new Int8Array(y),\n    D = new Int8Array(y),\n    b = new Uint16Array(y);\n  for (E = 0; E < y; E++) {\n    u = Q[E];\n    w[E] = c[u].x;\n    D[E] = c[u].y;\n    b[E] = 1 << C - 1 - u;\n  }\n  const F = -f,\n    S = -m,\n    k = t - p,\n    R = Zt[a];\n  let N = new Uint8Array(t);\n  const G = [],\n    x = g.decoder,\n    U = g.contextCache.getContexts(\"GB\");\n  let M,\n    L,\n    H,\n    J,\n    Y,\n    v = 0,\n    K = 0;\n  for (let e = 0; e < i; e++) {\n    if (s) {\n      v ^= x.readBit(U, R);\n      if (v) {\n        G.push(N);\n        continue;\n      }\n    }\n    N = new Uint8Array(N);\n    G.push(N);\n    for (M = 0; M < t; M++) {\n      if (o && r[e][M]) {\n        N[M] = 0;\n        continue;\n      }\n      if (M >= F && M < k && e >= S) {\n        K = K << 1 & d;\n        for (u = 0; u < y; u++) {\n          L = e + D[u];\n          H = M + w[u];\n          J = G[L][H];\n          if (J) {\n            J = b[u];\n            K |= J;\n          }\n        }\n      } else {\n        K = 0;\n        Y = C - 1;\n        for (u = 0; u < C; u++, Y--) {\n          H = M + h[u];\n          if (H >= 0 && H < t) {\n            L = e + l[u];\n            if (L >= 0) {\n              J = G[L][H];\n              J && (K |= J << Y);\n            }\n          }\n        }\n      }\n      const i = x.readBit(U, K);\n      N[M] = i;\n    }\n  }\n  return G;\n}\nfunction decodeRefinement(e, t, i, a, s, r, n, g, o) {\n  let c = Xt[i].coding;\n  0 === i && (c = c.concat([g[0]]));\n  const C = c.length,\n    h = new Int32Array(C),\n    l = new Int32Array(C);\n  let Q;\n  for (Q = 0; Q < C; Q++) {\n    h[Q] = c[Q].x;\n    l[Q] = c[Q].y;\n  }\n  let E = Xt[i].reference;\n  0 === i && (E = E.concat([g[1]]));\n  const u = E.length,\n    d = new Int32Array(u),\n    f = new Int32Array(u);\n  for (Q = 0; Q < u; Q++) {\n    d[Q] = E[Q].x;\n    f[Q] = E[Q].y;\n  }\n  const p = a[0].length,\n    m = a.length,\n    y = Vt[i],\n    w = [],\n    D = o.decoder,\n    b = o.contextCache.getContexts(\"GR\");\n  let F = 0;\n  for (let i = 0; i < t; i++) {\n    if (n) {\n      F ^= D.readBit(b, y);\n      if (F) throw new Jbig2Error(\"prediction is not supported\");\n    }\n    const t = new Uint8Array(e);\n    w.push(t);\n    for (let n = 0; n < e; n++) {\n      let g,\n        o,\n        c = 0;\n      for (Q = 0; Q < C; Q++) {\n        g = i + l[Q];\n        o = n + h[Q];\n        g < 0 || o < 0 || o >= e ? c <<= 1 : c = c << 1 | w[g][o];\n      }\n      for (Q = 0; Q < u; Q++) {\n        g = i + f[Q] - r;\n        o = n + d[Q] - s;\n        g < 0 || g >= m || o < 0 || o >= p ? c <<= 1 : c = c << 1 | a[g][o];\n      }\n      const E = D.readBit(b, c);\n      t[n] = E;\n    }\n  }\n  return w;\n}\nfunction decodeTextRegion(e, t, i, a, s, r, n, g, o, c, C, h, l, Q, E, u, d, f, p) {\n  if (e && t) throw new Jbig2Error(\"refinement with Huffman is not supported\");\n  const m = [];\n  let y, w;\n  for (y = 0; y < a; y++) {\n    w = new Uint8Array(i);\n    if (s) for (let e = 0; e < i; e++) w[e] = s;\n    m.push(w);\n  }\n  const D = d.decoder,\n    b = d.contextCache;\n  let F = e ? -Q.tableDeltaT.decode(p) : -decodeInteger(b, \"IADT\", D),\n    S = 0;\n  y = 0;\n  for (; y < r;) {\n    F += e ? Q.tableDeltaT.decode(p) : decodeInteger(b, \"IADT\", D);\n    S += e ? Q.tableFirstS.decode(p) : decodeInteger(b, \"IAFS\", D);\n    let a = S;\n    for (;;) {\n      let s = 0;\n      n > 1 && (s = e ? p.readBits(f) : decodeInteger(b, \"IAIT\", D));\n      const r = n * F + s,\n        S = e ? Q.symbolIDTable.decode(p) : decodeIAID(b, D, o),\n        k = t && (e ? p.readBit() : decodeInteger(b, \"IARI\", D));\n      let R = g[S],\n        N = R[0].length,\n        G = R.length;\n      if (k) {\n        const e = decodeInteger(b, \"IARDW\", D),\n          t = decodeInteger(b, \"IARDH\", D);\n        N += e;\n        G += t;\n        R = decodeRefinement(N, G, E, R, (e >> 1) + decodeInteger(b, \"IARDX\", D), (t >> 1) + decodeInteger(b, \"IARDY\", D), !1, u, d);\n      }\n      let x = 0;\n      c ? 1 & h ? x = G - 1 : a += G - 1 : h > 1 ? a += N - 1 : x = N - 1;\n      const U = r - (1 & h ? 0 : G - 1),\n        M = a - (2 & h ? N - 1 : 0);\n      let L, H, J;\n      if (c) for (L = 0; L < G; L++) {\n        w = m[M + L];\n        if (!w) continue;\n        J = R[L];\n        const e = Math.min(i - U, N);\n        switch (l) {\n          case 0:\n            for (H = 0; H < e; H++) w[U + H] |= J[H];\n            break;\n          case 2:\n            for (H = 0; H < e; H++) w[U + H] ^= J[H];\n            break;\n          default:\n            throw new Jbig2Error(`operator ${l} is not supported`);\n        }\n      } else for (H = 0; H < G; H++) {\n        w = m[U + H];\n        if (w) {\n          J = R[H];\n          switch (l) {\n            case 0:\n              for (L = 0; L < N; L++) w[M + L] |= J[L];\n              break;\n            case 2:\n              for (L = 0; L < N; L++) w[M + L] ^= J[L];\n              break;\n            default:\n              throw new Jbig2Error(`operator ${l} is not supported`);\n          }\n        }\n      }\n      y++;\n      const Y = e ? Q.tableDeltaS.decode(p) : decodeInteger(b, \"IADS\", D);\n      if (null === Y) break;\n      a += x + Y + C;\n    }\n  }\n  return m;\n}\nfunction readSegmentHeader(e, t) {\n  const i = {};\n  i.number = readUint32(e, t);\n  const a = e[t + 4],\n    s = 63 & a;\n  if (!Wt[s]) throw new Jbig2Error(\"invalid segment type: \" + s);\n  i.type = s;\n  i.typeName = Wt[s];\n  i.deferredNonRetain = !!(128 & a);\n  const r = !!(64 & a),\n    n = e[t + 5];\n  let g = n >> 5 & 7;\n  const o = [31 & n];\n  let c = t + 6;\n  if (7 === n) {\n    g = 536870911 & readUint32(e, c - 1);\n    c += 3;\n    let t = g + 7 >> 3;\n    o[0] = e[c++];\n    for (; --t > 0;) o.push(e[c++]);\n  } else if (5 === n || 6 === n) throw new Jbig2Error(\"invalid referred-to flags\");\n  i.retainBits = o;\n  let C = 4;\n  i.number <= 256 ? C = 1 : i.number <= 65536 && (C = 2);\n  const h = [];\n  let l, Q;\n  for (l = 0; l < g; l++) {\n    let t;\n    t = 1 === C ? e[c] : 2 === C ? readUint16(e, c) : readUint32(e, c);\n    h.push(t);\n    c += C;\n  }\n  i.referredTo = h;\n  if (r) {\n    i.pageAssociation = readUint32(e, c);\n    c += 4;\n  } else i.pageAssociation = e[c++];\n  i.length = readUint32(e, c);\n  c += 4;\n  if (4294967295 === i.length) {\n    if (38 !== s) throw new Jbig2Error(\"invalid unknown segment length\");\n    {\n      const t = readRegionSegmentInformation(e, c),\n        a = !!(1 & e[c + zt]),\n        s = 6,\n        r = new Uint8Array(s);\n      if (!a) {\n        r[0] = 255;\n        r[1] = 172;\n      }\n      r[2] = t.height >>> 24 & 255;\n      r[3] = t.height >> 16 & 255;\n      r[4] = t.height >> 8 & 255;\n      r[5] = 255 & t.height;\n      for (l = c, Q = e.length; l < Q; l++) {\n        let t = 0;\n        for (; t < s && r[t] === e[l + t];) t++;\n        if (t === s) {\n          i.length = l + s;\n          break;\n        }\n      }\n      if (4294967295 === i.length) throw new Jbig2Error(\"segment end was not found\");\n    }\n  }\n  i.headerEnd = c;\n  return i;\n}\nfunction readSegments(e, t, i, a) {\n  const s = [];\n  let r = i;\n  for (; r < a;) {\n    const i = readSegmentHeader(t, r);\n    r = i.headerEnd;\n    const a = {\n      header: i,\n      data: t\n    };\n    if (!e.randomAccess) {\n      a.start = r;\n      r += i.length;\n      a.end = r;\n    }\n    s.push(a);\n    if (51 === i.type) break;\n  }\n  if (e.randomAccess) for (let e = 0, t = s.length; e < t; e++) {\n    s[e].start = r;\n    r += s[e].header.length;\n    s[e].end = r;\n  }\n  return s;\n}\nfunction readRegionSegmentInformation(e, t) {\n  return {\n    width: readUint32(e, t),\n    height: readUint32(e, t + 4),\n    x: readUint32(e, t + 8),\n    y: readUint32(e, t + 12),\n    combinationOperator: 7 & e[t + 16]\n  };\n}\nconst zt = 17;\nfunction processSegment(e, t) {\n  const i = e.header,\n    a = e.data,\n    s = e.end;\n  let r,\n    n,\n    g,\n    o,\n    c = e.start;\n  switch (i.type) {\n    case 0:\n      const e = {},\n        t = readUint16(a, c);\n      e.huffman = !!(1 & t);\n      e.refinement = !!(2 & t);\n      e.huffmanDHSelector = t >> 2 & 3;\n      e.huffmanDWSelector = t >> 4 & 3;\n      e.bitmapSizeSelector = t >> 6 & 1;\n      e.aggregationInstancesSelector = t >> 7 & 1;\n      e.bitmapCodingContextUsed = !!(256 & t);\n      e.bitmapCodingContextRetained = !!(512 & t);\n      e.template = t >> 10 & 3;\n      e.refinementTemplate = t >> 12 & 1;\n      c += 2;\n      if (!e.huffman) {\n        o = 0 === e.template ? 4 : 1;\n        n = [];\n        for (g = 0; g < o; g++) {\n          n.push({\n            x: readInt8(a, c),\n            y: readInt8(a, c + 1)\n          });\n          c += 2;\n        }\n        e.at = n;\n      }\n      if (e.refinement && !e.refinementTemplate) {\n        n = [];\n        for (g = 0; g < 2; g++) {\n          n.push({\n            x: readInt8(a, c),\n            y: readInt8(a, c + 1)\n          });\n          c += 2;\n        }\n        e.refinementAt = n;\n      }\n      e.numberOfExportedSymbols = readUint32(a, c);\n      c += 4;\n      e.numberOfNewSymbols = readUint32(a, c);\n      c += 4;\n      r = [e, i.number, i.referredTo, a, c, s];\n      break;\n    case 6:\n    case 7:\n      const C = {};\n      C.info = readRegionSegmentInformation(a, c);\n      c += zt;\n      const h = readUint16(a, c);\n      c += 2;\n      C.huffman = !!(1 & h);\n      C.refinement = !!(2 & h);\n      C.logStripSize = h >> 2 & 3;\n      C.stripSize = 1 << C.logStripSize;\n      C.referenceCorner = h >> 4 & 3;\n      C.transposed = !!(64 & h);\n      C.combinationOperator = h >> 7 & 3;\n      C.defaultPixelValue = h >> 9 & 1;\n      C.dsOffset = h << 17 >> 27;\n      C.refinementTemplate = h >> 15 & 1;\n      if (C.huffman) {\n        const e = readUint16(a, c);\n        c += 2;\n        C.huffmanFS = 3 & e;\n        C.huffmanDS = e >> 2 & 3;\n        C.huffmanDT = e >> 4 & 3;\n        C.huffmanRefinementDW = e >> 6 & 3;\n        C.huffmanRefinementDH = e >> 8 & 3;\n        C.huffmanRefinementDX = e >> 10 & 3;\n        C.huffmanRefinementDY = e >> 12 & 3;\n        C.huffmanRefinementSizeSelector = !!(16384 & e);\n      }\n      if (C.refinement && !C.refinementTemplate) {\n        n = [];\n        for (g = 0; g < 2; g++) {\n          n.push({\n            x: readInt8(a, c),\n            y: readInt8(a, c + 1)\n          });\n          c += 2;\n        }\n        C.refinementAt = n;\n      }\n      C.numberOfSymbolInstances = readUint32(a, c);\n      c += 4;\n      r = [C, i.referredTo, a, c, s];\n      break;\n    case 16:\n      const l = {},\n        Q = a[c++];\n      l.mmr = !!(1 & Q);\n      l.template = Q >> 1 & 3;\n      l.patternWidth = a[c++];\n      l.patternHeight = a[c++];\n      l.maxPatternIndex = readUint32(a, c);\n      c += 4;\n      r = [l, i.number, a, c, s];\n      break;\n    case 22:\n    case 23:\n      const E = {};\n      E.info = readRegionSegmentInformation(a, c);\n      c += zt;\n      const u = a[c++];\n      E.mmr = !!(1 & u);\n      E.template = u >> 1 & 3;\n      E.enableSkip = !!(8 & u);\n      E.combinationOperator = u >> 4 & 7;\n      E.defaultPixelValue = u >> 7 & 1;\n      E.gridWidth = readUint32(a, c);\n      c += 4;\n      E.gridHeight = readUint32(a, c);\n      c += 4;\n      E.gridOffsetX = 4294967295 & readUint32(a, c);\n      c += 4;\n      E.gridOffsetY = 4294967295 & readUint32(a, c);\n      c += 4;\n      E.gridVectorX = readUint16(a, c);\n      c += 2;\n      E.gridVectorY = readUint16(a, c);\n      c += 2;\n      r = [E, i.referredTo, a, c, s];\n      break;\n    case 38:\n    case 39:\n      const d = {};\n      d.info = readRegionSegmentInformation(a, c);\n      c += zt;\n      const f = a[c++];\n      d.mmr = !!(1 & f);\n      d.template = f >> 1 & 3;\n      d.prediction = !!(8 & f);\n      if (!d.mmr) {\n        o = 0 === d.template ? 4 : 1;\n        n = [];\n        for (g = 0; g < o; g++) {\n          n.push({\n            x: readInt8(a, c),\n            y: readInt8(a, c + 1)\n          });\n          c += 2;\n        }\n        d.at = n;\n      }\n      r = [d, a, c, s];\n      break;\n    case 48:\n      const p = {\n        width: readUint32(a, c),\n        height: readUint32(a, c + 4),\n        resolutionX: readUint32(a, c + 8),\n        resolutionY: readUint32(a, c + 12)\n      };\n      4294967295 === p.height && delete p.height;\n      const m = a[c + 16];\n      readUint16(a, c + 17);\n      p.lossless = !!(1 & m);\n      p.refinement = !!(2 & m);\n      p.defaultPixelValue = m >> 2 & 1;\n      p.combinationOperator = m >> 3 & 3;\n      p.requiresBuffer = !!(32 & m);\n      p.combinationOperatorOverride = !!(64 & m);\n      r = [p];\n      break;\n    case 49:\n    case 50:\n    case 51:\n    case 62:\n      break;\n    case 53:\n      r = [i.number, a, c, s];\n      break;\n    default:\n      throw new Jbig2Error(`segment type ${i.typeName}(${i.type}) is not implemented`);\n  }\n  const C = \"on\" + i.typeName;\n  C in t && t[C].apply(t, r);\n}\nfunction processSegments(e, t) {\n  for (let i = 0, a = e.length; i < a; i++) processSegment(e[i], t);\n}\nclass SimpleSegmentVisitor {\n  onPageInformation(e) {\n    this.currentPageInfo = e;\n    const t = e.width + 7 >> 3,\n      i = new Uint8ClampedArray(t * e.height);\n    e.defaultPixelValue && i.fill(255);\n    this.buffer = i;\n  }\n  drawBitmap(e, t) {\n    const i = this.currentPageInfo,\n      a = e.width,\n      s = e.height,\n      r = i.width + 7 >> 3,\n      n = i.combinationOperatorOverride ? e.combinationOperator : i.combinationOperator,\n      g = this.buffer,\n      o = 128 >> (7 & e.x);\n    let c,\n      C,\n      h,\n      l,\n      Q = e.y * r + (e.x >> 3);\n    switch (n) {\n      case 0:\n        for (c = 0; c < s; c++) {\n          h = o;\n          l = Q;\n          for (C = 0; C < a; C++) {\n            t[c][C] && (g[l] |= h);\n            h >>= 1;\n            if (!h) {\n              h = 128;\n              l++;\n            }\n          }\n          Q += r;\n        }\n        break;\n      case 2:\n        for (c = 0; c < s; c++) {\n          h = o;\n          l = Q;\n          for (C = 0; C < a; C++) {\n            t[c][C] && (g[l] ^= h);\n            h >>= 1;\n            if (!h) {\n              h = 128;\n              l++;\n            }\n          }\n          Q += r;\n        }\n        break;\n      default:\n        throw new Jbig2Error(`operator ${n} is not supported`);\n    }\n  }\n  onImmediateGenericRegion(e, t, i, a) {\n    const s = e.info,\n      r = new DecodingContext(t, i, a),\n      n = decodeBitmap(e.mmr, s.width, s.height, e.template, e.prediction, null, e.at, r);\n    this.drawBitmap(s, n);\n  }\n  onImmediateLosslessGenericRegion() {\n    this.onImmediateGenericRegion(...arguments);\n  }\n  onSymbolDictionary(e, t, i, a, s, r) {\n    let n, g;\n    if (e.huffman) {\n      n = function getSymbolDictionaryHuffmanTables(e, t, i) {\n        let a,\n          s,\n          r,\n          n,\n          g = 0;\n        switch (e.huffmanDHSelector) {\n          case 0:\n          case 1:\n            a = getStandardTable(e.huffmanDHSelector + 4);\n            break;\n          case 3:\n            a = getCustomHuffmanTable(g, t, i);\n            g++;\n            break;\n          default:\n            throw new Jbig2Error(\"invalid Huffman DH selector\");\n        }\n        switch (e.huffmanDWSelector) {\n          case 0:\n          case 1:\n            s = getStandardTable(e.huffmanDWSelector + 2);\n            break;\n          case 3:\n            s = getCustomHuffmanTable(g, t, i);\n            g++;\n            break;\n          default:\n            throw new Jbig2Error(\"invalid Huffman DW selector\");\n        }\n        if (e.bitmapSizeSelector) {\n          r = getCustomHuffmanTable(g, t, i);\n          g++;\n        } else r = getStandardTable(1);\n        n = e.aggregationInstancesSelector ? getCustomHuffmanTable(g, t, i) : getStandardTable(1);\n        return {\n          tableDeltaHeight: a,\n          tableDeltaWidth: s,\n          tableBitmapSize: r,\n          tableAggregateInstances: n\n        };\n      }(e, i, this.customTables);\n      g = new Reader(a, s, r);\n    }\n    let o = this.symbols;\n    o || (this.symbols = o = {});\n    const c = [];\n    for (const e of i) {\n      const t = o[e];\n      t && c.push(...t);\n    }\n    const C = new DecodingContext(a, s, r);\n    o[t] = function decodeSymbolDictionary(e, t, i, a, s, r, n, g, o, c, C, h) {\n      if (e && t) throw new Jbig2Error(\"symbol refinement with Huffman is not supported\");\n      const l = [];\n      let Q = 0,\n        E = log2(i.length + a);\n      const u = C.decoder,\n        d = C.contextCache;\n      let f, p;\n      if (e) {\n        f = getStandardTable(1);\n        p = [];\n        E = Math.max(E, 1);\n      }\n      for (; l.length < a;) {\n        Q += e ? r.tableDeltaHeight.decode(h) : decodeInteger(d, \"IADH\", u);\n        let a = 0,\n          s = 0;\n        const f = e ? p.length : 0;\n        for (;;) {\n          const f = e ? r.tableDeltaWidth.decode(h) : decodeInteger(d, \"IADW\", u);\n          if (null === f) break;\n          a += f;\n          s += a;\n          let m;\n          if (t) {\n            const s = decodeInteger(d, \"IAAI\", u);\n            if (s > 1) m = decodeTextRegion(e, t, a, Q, 0, s, 1, i.concat(l), E, 0, 0, 1, 0, r, o, c, C, 0, h);else {\n              const e = decodeIAID(d, u, E),\n                t = decodeInteger(d, \"IARDX\", u),\n                s = decodeInteger(d, \"IARDY\", u);\n              m = decodeRefinement(a, Q, o, e < i.length ? i[e] : l[e - i.length], t, s, !1, c, C);\n            }\n            l.push(m);\n          } else if (e) p.push(a);else {\n            m = decodeBitmap(!1, a, Q, n, !1, null, g, C);\n            l.push(m);\n          }\n        }\n        if (e && !t) {\n          const e = r.tableBitmapSize.decode(h);\n          h.byteAlign();\n          let t;\n          if (0 === e) t = readUncompressedBitmap(h, s, Q);else {\n            const i = h.end,\n              a = h.position + e;\n            h.end = a;\n            t = decodeMMRBitmap(h, s, Q, !1);\n            h.end = i;\n            h.position = a;\n          }\n          const i = p.length;\n          if (f === i - 1) l.push(t);else {\n            let e,\n              a,\n              s,\n              r,\n              n,\n              g = 0;\n            for (e = f; e < i; e++) {\n              r = p[e];\n              s = g + r;\n              n = [];\n              for (a = 0; a < Q; a++) n.push(t[a].subarray(g, s));\n              l.push(n);\n              g = s;\n            }\n          }\n        }\n      }\n      const m = [],\n        y = [];\n      let w,\n        D,\n        b = !1;\n      const F = i.length + a;\n      for (; y.length < F;) {\n        let t = e ? f.decode(h) : decodeInteger(d, \"IAEX\", u);\n        for (; t--;) y.push(b);\n        b = !b;\n      }\n      for (w = 0, D = i.length; w < D; w++) y[w] && m.push(i[w]);\n      for (let e = 0; e < a; w++, e++) y[w] && m.push(l[e]);\n      return m;\n    }(e.huffman, e.refinement, c, e.numberOfNewSymbols, e.numberOfExportedSymbols, n, e.template, e.at, e.refinementTemplate, e.refinementAt, C, g);\n  }\n  onImmediateTextRegion(e, t, i, a, s) {\n    const r = e.info;\n    let n, g;\n    const o = this.symbols,\n      c = [];\n    for (const e of t) {\n      const t = o[e];\n      t && c.push(...t);\n    }\n    const C = log2(c.length);\n    if (e.huffman) {\n      g = new Reader(i, a, s);\n      n = function getTextRegionHuffmanTables(e, t, i, a, s) {\n        const r = [];\n        for (let e = 0; e <= 34; e++) {\n          const t = s.readBits(4);\n          r.push(new HuffmanLine([e, t, 0, 0]));\n        }\n        const n = new HuffmanTable(r, !1);\n        r.length = 0;\n        for (let e = 0; e < a;) {\n          const t = n.decode(s);\n          if (t >= 32) {\n            let i, a, n;\n            switch (t) {\n              case 32:\n                if (0 === e) throw new Jbig2Error(\"no previous value in symbol ID table\");\n                a = s.readBits(2) + 3;\n                i = r[e - 1].prefixLength;\n                break;\n              case 33:\n                a = s.readBits(3) + 3;\n                i = 0;\n                break;\n              case 34:\n                a = s.readBits(7) + 11;\n                i = 0;\n                break;\n              default:\n                throw new Jbig2Error(\"invalid code length in symbol ID table\");\n            }\n            for (n = 0; n < a; n++) {\n              r.push(new HuffmanLine([e, i, 0, 0]));\n              e++;\n            }\n          } else {\n            r.push(new HuffmanLine([e, t, 0, 0]));\n            e++;\n          }\n        }\n        s.byteAlign();\n        const g = new HuffmanTable(r, !1);\n        let o,\n          c,\n          C,\n          h = 0;\n        switch (e.huffmanFS) {\n          case 0:\n          case 1:\n            o = getStandardTable(e.huffmanFS + 6);\n            break;\n          case 3:\n            o = getCustomHuffmanTable(h, t, i);\n            h++;\n            break;\n          default:\n            throw new Jbig2Error(\"invalid Huffman FS selector\");\n        }\n        switch (e.huffmanDS) {\n          case 0:\n          case 1:\n          case 2:\n            c = getStandardTable(e.huffmanDS + 8);\n            break;\n          case 3:\n            c = getCustomHuffmanTable(h, t, i);\n            h++;\n            break;\n          default:\n            throw new Jbig2Error(\"invalid Huffman DS selector\");\n        }\n        switch (e.huffmanDT) {\n          case 0:\n          case 1:\n          case 2:\n            C = getStandardTable(e.huffmanDT + 11);\n            break;\n          case 3:\n            C = getCustomHuffmanTable(h, t, i);\n            h++;\n            break;\n          default:\n            throw new Jbig2Error(\"invalid Huffman DT selector\");\n        }\n        if (e.refinement) throw new Jbig2Error(\"refinement with Huffman is not supported\");\n        return {\n          symbolIDTable: g,\n          tableFirstS: o,\n          tableDeltaS: c,\n          tableDeltaT: C\n        };\n      }(e, t, this.customTables, c.length, g);\n    }\n    const h = new DecodingContext(i, a, s),\n      l = decodeTextRegion(e.huffman, e.refinement, r.width, r.height, e.defaultPixelValue, e.numberOfSymbolInstances, e.stripSize, c, C, e.transposed, e.dsOffset, e.referenceCorner, e.combinationOperator, n, e.refinementTemplate, e.refinementAt, h, e.logStripSize, g);\n    this.drawBitmap(r, l);\n  }\n  onImmediateLosslessTextRegion() {\n    this.onImmediateTextRegion(...arguments);\n  }\n  onPatternDictionary(e, t, i, a, s) {\n    let r = this.patterns;\n    r || (this.patterns = r = {});\n    const n = new DecodingContext(i, a, s);\n    r[t] = function decodePatternDictionary(e, t, i, a, s, r) {\n      const n = [];\n      if (!e) {\n        n.push({\n          x: -t,\n          y: 0\n        });\n        0 === s && n.push({\n          x: -3,\n          y: -1\n        }, {\n          x: 2,\n          y: -2\n        }, {\n          x: -2,\n          y: -2\n        });\n      }\n      const g = decodeBitmap(e, (a + 1) * t, i, s, !1, null, n, r),\n        o = [];\n      for (let e = 0; e <= a; e++) {\n        const a = [],\n          s = t * e,\n          r = s + t;\n        for (let e = 0; e < i; e++) a.push(g[e].subarray(s, r));\n        o.push(a);\n      }\n      return o;\n    }(e.mmr, e.patternWidth, e.patternHeight, e.maxPatternIndex, e.template, n);\n  }\n  onImmediateHalftoneRegion(e, t, i, a, s) {\n    const r = this.patterns[t[0]],\n      n = e.info,\n      g = new DecodingContext(i, a, s),\n      o = function decodeHalftoneRegion(e, t, i, a, s, r, n, g, o, c, C, h, l, Q, E) {\n        if (n) throw new Jbig2Error(\"skip is not supported\");\n        if (0 !== g) throw new Jbig2Error(`operator \"${g}\" is not supported in halftone region`);\n        const u = [];\n        let d, f, p;\n        for (d = 0; d < s; d++) {\n          p = new Uint8Array(a);\n          if (r) for (f = 0; f < a; f++) p[f] = r;\n          u.push(p);\n        }\n        const m = t.length,\n          y = t[0],\n          w = y[0].length,\n          D = y.length,\n          b = log2(m),\n          F = [];\n        if (!e) {\n          F.push({\n            x: i <= 1 ? 3 : 2,\n            y: -1\n          });\n          0 === i && F.push({\n            x: -3,\n            y: -1\n          }, {\n            x: 2,\n            y: -2\n          }, {\n            x: -2,\n            y: -2\n          });\n        }\n        const S = [];\n        let k, R, N, G, x, U, M, L, H, J, Y;\n        e && (k = new Reader(E.data, E.start, E.end));\n        for (d = b - 1; d >= 0; d--) {\n          R = e ? decodeMMRBitmap(k, o, c, !0) : decodeBitmap(!1, o, c, i, !1, null, F, E);\n          S[d] = R;\n        }\n        for (N = 0; N < c; N++) for (G = 0; G < o; G++) {\n          x = 0;\n          U = 0;\n          for (f = b - 1; f >= 0; f--) {\n            x ^= S[f][N][G];\n            U |= x << f;\n          }\n          M = t[U];\n          L = C + N * Q + G * l >> 8;\n          H = h + N * l - G * Q >> 8;\n          if (L >= 0 && L + w <= a && H >= 0 && H + D <= s) for (d = 0; d < D; d++) {\n            Y = u[H + d];\n            J = M[d];\n            for (f = 0; f < w; f++) Y[L + f] |= J[f];\n          } else {\n            let e, t;\n            for (d = 0; d < D; d++) {\n              t = H + d;\n              if (!(t < 0 || t >= s)) {\n                Y = u[t];\n                J = M[d];\n                for (f = 0; f < w; f++) {\n                  e = L + f;\n                  e >= 0 && e < a && (Y[e] |= J[f]);\n                }\n              }\n            }\n          }\n        }\n        return u;\n      }(e.mmr, r, e.template, n.width, n.height, e.defaultPixelValue, e.enableSkip, e.combinationOperator, e.gridWidth, e.gridHeight, e.gridOffsetX, e.gridOffsetY, e.gridVectorX, e.gridVectorY, g);\n    this.drawBitmap(n, o);\n  }\n  onImmediateLosslessHalftoneRegion() {\n    this.onImmediateHalftoneRegion(...arguments);\n  }\n  onTables(e, t, i, a) {\n    let s = this.customTables;\n    s || (this.customTables = s = {});\n    s[e] = function decodeTablesSegment(e, t, i) {\n      const a = e[t],\n        s = 4294967295 & readUint32(e, t + 1),\n        r = 4294967295 & readUint32(e, t + 5),\n        n = new Reader(e, t + 9, i),\n        g = 1 + (a >> 1 & 7),\n        o = 1 + (a >> 4 & 7),\n        c = [];\n      let C,\n        h,\n        l = s;\n      do {\n        C = n.readBits(g);\n        h = n.readBits(o);\n        c.push(new HuffmanLine([l, C, h, 0]));\n        l += 1 << h;\n      } while (l < r);\n      C = n.readBits(g);\n      c.push(new HuffmanLine([s - 1, C, 32, 0, \"lower\"]));\n      C = n.readBits(g);\n      c.push(new HuffmanLine([r, C, 32, 0]));\n      if (1 & a) {\n        C = n.readBits(g);\n        c.push(new HuffmanLine([C, 0]));\n      }\n      return new HuffmanTable(c, !1);\n    }(t, i, a);\n  }\n}\nclass HuffmanLine {\n  constructor(e) {\n    if (2 === e.length) {\n      this.isOOB = !0;\n      this.rangeLow = 0;\n      this.prefixLength = e[0];\n      this.rangeLength = 0;\n      this.prefixCode = e[1];\n      this.isLowerRange = !1;\n    } else {\n      this.isOOB = !1;\n      this.rangeLow = e[0];\n      this.prefixLength = e[1];\n      this.rangeLength = e[2];\n      this.prefixCode = e[3];\n      this.isLowerRange = \"lower\" === e[4];\n    }\n  }\n}\nclass HuffmanTreeNode {\n  constructor(e) {\n    this.children = [];\n    if (e) {\n      this.isLeaf = !0;\n      this.rangeLength = e.rangeLength;\n      this.rangeLow = e.rangeLow;\n      this.isLowerRange = e.isLowerRange;\n      this.isOOB = e.isOOB;\n    } else this.isLeaf = !1;\n  }\n  buildTree(e, t) {\n    const i = e.prefixCode >> t & 1;\n    if (t <= 0) this.children[i] = new HuffmanTreeNode(e);else {\n      let a = this.children[i];\n      a || (this.children[i] = a = new HuffmanTreeNode(null));\n      a.buildTree(e, t - 1);\n    }\n  }\n  decodeNode(e) {\n    if (this.isLeaf) {\n      if (this.isOOB) return null;\n      const t = e.readBits(this.rangeLength);\n      return this.rangeLow + (this.isLowerRange ? -t : t);\n    }\n    const t = this.children[e.readBit()];\n    if (!t) throw new Jbig2Error(\"invalid Huffman data\");\n    return t.decodeNode(e);\n  }\n}\nclass HuffmanTable {\n  constructor(e, t) {\n    t || this.assignPrefixCodes(e);\n    this.rootNode = new HuffmanTreeNode(null);\n    for (let t = 0, i = e.length; t < i; t++) {\n      const i = e[t];\n      i.prefixLength > 0 && this.rootNode.buildTree(i, i.prefixLength - 1);\n    }\n  }\n  decode(e) {\n    return this.rootNode.decodeNode(e);\n  }\n  assignPrefixCodes(e) {\n    const t = e.length;\n    let i = 0;\n    for (let a = 0; a < t; a++) i = Math.max(i, e[a].prefixLength);\n    const a = new Uint32Array(i + 1);\n    for (let i = 0; i < t; i++) a[e[i].prefixLength]++;\n    let s,\n      r,\n      n,\n      g = 1,\n      o = 0;\n    a[0] = 0;\n    for (; g <= i;) {\n      o = o + a[g - 1] << 1;\n      s = o;\n      r = 0;\n      for (; r < t;) {\n        n = e[r];\n        if (n.prefixLength === g) {\n          n.prefixCode = s;\n          s++;\n        }\n        r++;\n      }\n      g++;\n    }\n  }\n}\nconst _t = {};\nfunction getStandardTable(e) {\n  let t,\n    i = _t[e];\n  if (i) return i;\n  switch (e) {\n    case 1:\n      t = [[0, 1, 4, 0], [16, 2, 8, 2], [272, 3, 16, 6], [65808, 3, 32, 7]];\n      break;\n    case 2:\n      t = [[0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [75, 6, 32, 62], [6, 63]];\n      break;\n    case 3:\n      t = [[-256, 8, 8, 254], [0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [-257, 8, 32, 255, \"lower\"], [75, 7, 32, 126], [6, 62]];\n      break;\n    case 4:\n      t = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [76, 5, 32, 31]];\n      break;\n    case 5:\n      t = [[-255, 7, 8, 126], [1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [-256, 7, 32, 127, \"lower\"], [76, 6, 32, 62]];\n      break;\n    case 6:\n      t = [[-2048, 5, 10, 28], [-1024, 4, 9, 8], [-512, 4, 8, 9], [-256, 4, 7, 10], [-128, 5, 6, 29], [-64, 5, 5, 30], [-32, 4, 5, 11], [0, 2, 7, 0], [128, 3, 7, 2], [256, 3, 8, 3], [512, 4, 9, 12], [1024, 4, 10, 13], [-2049, 6, 32, 62, \"lower\"], [2048, 6, 32, 63]];\n      break;\n    case 7:\n      t = [[-1024, 4, 9, 8], [-512, 3, 8, 0], [-256, 4, 7, 9], [-128, 5, 6, 26], [-64, 5, 5, 27], [-32, 4, 5, 10], [0, 4, 5, 11], [32, 5, 5, 28], [64, 5, 6, 29], [128, 4, 7, 12], [256, 3, 8, 1], [512, 3, 9, 2], [1024, 3, 10, 3], [-1025, 5, 32, 30, \"lower\"], [2048, 5, 32, 31]];\n      break;\n    case 8:\n      t = [[-15, 8, 3, 252], [-7, 9, 1, 508], [-5, 8, 1, 253], [-3, 9, 0, 509], [-2, 7, 0, 124], [-1, 4, 0, 10], [0, 2, 1, 0], [2, 5, 0, 26], [3, 6, 0, 58], [4, 3, 4, 4], [20, 6, 1, 59], [22, 4, 4, 11], [38, 4, 5, 12], [70, 5, 6, 27], [134, 5, 7, 28], [262, 6, 7, 60], [390, 7, 8, 125], [646, 6, 10, 61], [-16, 9, 32, 510, \"lower\"], [1670, 9, 32, 511], [2, 1]];\n      break;\n    case 9:\n      t = [[-31, 8, 4, 252], [-15, 9, 2, 508], [-11, 8, 2, 253], [-7, 9, 1, 509], [-5, 7, 1, 124], [-3, 4, 1, 10], [-1, 3, 1, 2], [1, 3, 1, 3], [3, 5, 1, 26], [5, 6, 1, 58], [7, 3, 5, 4], [39, 6, 2, 59], [43, 4, 5, 11], [75, 4, 6, 12], [139, 5, 7, 27], [267, 5, 8, 28], [523, 6, 8, 60], [779, 7, 9, 125], [1291, 6, 11, 61], [-32, 9, 32, 510, \"lower\"], [3339, 9, 32, 511], [2, 0]];\n      break;\n    case 10:\n      t = [[-21, 7, 4, 122], [-5, 8, 0, 252], [-4, 7, 0, 123], [-3, 5, 0, 24], [-2, 2, 2, 0], [2, 5, 0, 25], [3, 6, 0, 54], [4, 7, 0, 124], [5, 8, 0, 253], [6, 2, 6, 1], [70, 5, 5, 26], [102, 6, 5, 55], [134, 6, 6, 56], [198, 6, 7, 57], [326, 6, 8, 58], [582, 6, 9, 59], [1094, 6, 10, 60], [2118, 7, 11, 125], [-22, 8, 32, 254, \"lower\"], [4166, 8, 32, 255], [2, 2]];\n      break;\n    case 11:\n      t = [[1, 1, 0, 0], [2, 2, 1, 2], [4, 4, 0, 12], [5, 4, 1, 13], [7, 5, 1, 28], [9, 5, 2, 29], [13, 6, 2, 60], [17, 7, 2, 122], [21, 7, 3, 123], [29, 7, 4, 124], [45, 7, 5, 125], [77, 7, 6, 126], [141, 7, 32, 127]];\n      break;\n    case 12:\n      t = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 1, 6], [5, 5, 0, 28], [6, 5, 1, 29], [8, 6, 1, 60], [10, 7, 0, 122], [11, 7, 1, 123], [13, 7, 2, 124], [17, 7, 3, 125], [25, 7, 4, 126], [41, 8, 5, 254], [73, 8, 32, 255]];\n      break;\n    case 13:\n      t = [[1, 1, 0, 0], [2, 3, 0, 4], [3, 4, 0, 12], [4, 5, 0, 28], [5, 4, 1, 13], [7, 3, 3, 5], [15, 6, 1, 58], [17, 6, 2, 59], [21, 6, 3, 60], [29, 6, 4, 61], [45, 6, 5, 62], [77, 7, 6, 126], [141, 7, 32, 127]];\n      break;\n    case 14:\n      t = [[-2, 3, 0, 4], [-1, 3, 0, 5], [0, 1, 0, 0], [1, 3, 0, 6], [2, 3, 0, 7]];\n      break;\n    case 15:\n      t = [[-24, 7, 4, 124], [-8, 6, 2, 60], [-4, 5, 1, 28], [-2, 4, 0, 12], [-1, 3, 0, 4], [0, 1, 0, 0], [1, 3, 0, 5], [2, 4, 0, 13], [3, 5, 1, 29], [5, 6, 2, 61], [9, 7, 4, 125], [-25, 7, 32, 126, \"lower\"], [25, 7, 32, 127]];\n      break;\n    default:\n      throw new Jbig2Error(`standard table B.${e} does not exist`);\n  }\n  for (let e = 0, i = t.length; e < i; e++) t[e] = new HuffmanLine(t[e]);\n  i = new HuffmanTable(t, !0);\n  _t[e] = i;\n  return i;\n}\nclass Reader {\n  constructor(e, t, i) {\n    this.data = e;\n    this.start = t;\n    this.end = i;\n    this.position = t;\n    this.shift = -1;\n    this.currentByte = 0;\n  }\n  readBit() {\n    if (this.shift < 0) {\n      if (this.position >= this.end) throw new Jbig2Error(\"end of data while reading bit\");\n      this.currentByte = this.data[this.position++];\n      this.shift = 7;\n    }\n    const e = this.currentByte >> this.shift & 1;\n    this.shift--;\n    return e;\n  }\n  readBits(e) {\n    let t,\n      i = 0;\n    for (t = e - 1; t >= 0; t--) i |= this.readBit() << t;\n    return i;\n  }\n  byteAlign() {\n    this.shift = -1;\n  }\n  next() {\n    return this.position >= this.end ? -1 : this.data[this.position++];\n  }\n}\nfunction getCustomHuffmanTable(e, t, i) {\n  let a = 0;\n  for (let s = 0, r = t.length; s < r; s++) {\n    const r = i[t[s]];\n    if (r) {\n      if (e === a) return r;\n      a++;\n    }\n  }\n  throw new Jbig2Error(\"can't find custom Huffman table\");\n}\nfunction readUncompressedBitmap(e, t, i) {\n  const a = [];\n  for (let s = 0; s < i; s++) {\n    const i = new Uint8Array(t);\n    a.push(i);\n    for (let a = 0; a < t; a++) i[a] = e.readBit();\n    e.byteAlign();\n  }\n  return a;\n}\nfunction decodeMMRBitmap(e, t, i, a) {\n  const s = new CCITTFaxDecoder(e, {\n      K: -1,\n      Columns: t,\n      Rows: i,\n      BlackIs1: !0,\n      EndOfBlock: a\n    }),\n    r = [];\n  let n,\n    g = !1;\n  for (let e = 0; e < i; e++) {\n    const e = new Uint8Array(t);\n    r.push(e);\n    let i = -1;\n    for (let a = 0; a < t; a++) {\n      if (i < 0) {\n        n = s.readNextChar();\n        if (-1 === n) {\n          n = 0;\n          g = !0;\n        }\n        i = 7;\n      }\n      e[a] = n >> i & 1;\n      i--;\n    }\n  }\n  if (a && !g) {\n    const e = 5;\n    for (let t = 0; t < e && -1 !== s.readNextChar(); t++);\n  }\n  return r;\n}\nclass Jbig2Image {\n  parseChunks(e) {\n    return function parseJbig2Chunks(e) {\n      const t = new SimpleSegmentVisitor();\n      for (let i = 0, a = e.length; i < a; i++) {\n        const a = e[i];\n        processSegments(readSegments({}, a.data, a.start, a.end), t);\n      }\n      return t.buffer;\n    }(e);\n  }\n  parse(e) {\n    throw new Error(\"Not implemented: Jbig2Image.parse\");\n  }\n}\nclass Jbig2Stream extends DecodeStream {\n  constructor(e, t, i) {\n    super(t);\n    this.stream = e;\n    this.dict = e.dict;\n    this.maybeLength = t;\n    this.params = i;\n  }\n  get bytes() {\n    return shadow(this, \"bytes\", this.stream.getBytes(this.maybeLength));\n  }\n  ensureBuffer(e) {}\n  readBlock() {\n    this.decodeImage();\n  }\n  decodeImage(e) {\n    if (this.eof) return this.buffer;\n    e ||= this.bytes;\n    const t = new Jbig2Image(),\n      i = [];\n    if (this.params instanceof Dict) {\n      const e = this.params.get(\"JBIG2Globals\");\n      if (e instanceof BaseStream) {\n        const t = e.getBytes();\n        i.push({\n          data: t,\n          start: 0,\n          end: t.length\n        });\n      }\n    }\n    i.push({\n      data: e,\n      start: 0,\n      end: e.length\n    });\n    const a = t.parseChunks(i),\n      s = a.length;\n    for (let e = 0; e < s; e++) a[e] ^= 255;\n    this.buffer = a;\n    this.bufferLength = s;\n    this.eof = !0;\n    return this.buffer;\n  }\n  get canAsyncDecodeImageFromBuffer() {\n    return this.stream.isAsync;\n  }\n}\nfunction convertToRGBA(e) {\n  switch (e.kind) {\n    case D:\n      return convertBlackAndWhiteToRGBA(e);\n    case b:\n      return function convertRGBToRGBA({\n        src: e,\n        srcPos: t = 0,\n        dest: i,\n        destPos: a = 0,\n        width: s,\n        height: r\n      }) {\n        let n = 0;\n        const g = e.length >> 2,\n          o = new Uint32Array(e.buffer, t, g);\n        if (FeatureTest.isLittleEndian) {\n          for (; n < g - 2; n += 3, a += 4) {\n            const e = o[n],\n              t = o[n + 1],\n              s = o[n + 2];\n            i[a] = 4278190080 | e;\n            i[a + 1] = e >>> 24 | t << 8 | 4278190080;\n            i[a + 2] = t >>> 16 | s << 16 | 4278190080;\n            i[a + 3] = s >>> 8 | 4278190080;\n          }\n          for (let t = 4 * n, s = e.length; t < s; t += 3) i[a++] = e[t] | e[t + 1] << 8 | e[t + 2] << 16 | 4278190080;\n        } else {\n          for (; n < g - 2; n += 3, a += 4) {\n            const e = o[n],\n              t = o[n + 1],\n              s = o[n + 2];\n            i[a] = 255 | e;\n            i[a + 1] = e << 24 | t >>> 8 | 255;\n            i[a + 2] = t << 16 | s >>> 16 | 255;\n            i[a + 3] = s << 8 | 255;\n          }\n          for (let t = 4 * n, s = e.length; t < s; t += 3) i[a++] = e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | 255;\n        }\n        return {\n          srcPos: t,\n          destPos: a\n        };\n      }(e);\n  }\n  return null;\n}\nfunction convertBlackAndWhiteToRGBA({\n  src: e,\n  srcPos: t = 0,\n  dest: i,\n  width: a,\n  height: s,\n  nonBlackColor: r = 4294967295,\n  inverseDecode: n = !1\n}) {\n  const g = FeatureTest.isLittleEndian ? 4278190080 : 255,\n    [o, c] = n ? [r, g] : [g, r],\n    C = a >> 3,\n    h = 7 & a,\n    l = e.length;\n  i = new Uint32Array(i.buffer);\n  let Q = 0;\n  for (let a = 0; a < s; a++) {\n    for (const a = t + C; t < a; t++) {\n      const a = t < l ? e[t] : 255;\n      i[Q++] = 128 & a ? c : o;\n      i[Q++] = 64 & a ? c : o;\n      i[Q++] = 32 & a ? c : o;\n      i[Q++] = 16 & a ? c : o;\n      i[Q++] = 8 & a ? c : o;\n      i[Q++] = 4 & a ? c : o;\n      i[Q++] = 2 & a ? c : o;\n      i[Q++] = 1 & a ? c : o;\n    }\n    if (0 === h) continue;\n    const a = t < l ? e[t++] : 255;\n    for (let e = 0; e < h; e++) i[Q++] = a & 1 << 7 - e ? c : o;\n  }\n  return {\n    srcPos: t,\n    destPos: Q\n  };\n}\nclass JpegError extends rt {\n  constructor(e) {\n    super(e, \"JpegError\");\n  }\n}\nclass DNLMarkerError extends rt {\n  constructor(e, t) {\n    super(e, \"DNLMarkerError\");\n    this.scanLines = t;\n  }\n}\nclass EOIMarkerError extends rt {\n  constructor(e) {\n    super(e, \"EOIMarkerError\");\n  }\n}\nconst $t = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]),\n  Ai = 4017,\n  ei = 799,\n  ti = 3406,\n  ii = 2276,\n  ai = 1567,\n  si = 3784,\n  ri = 5793,\n  ni = 2896;\nfunction buildHuffmanTable(e, t) {\n  let i,\n    a,\n    s = 0,\n    r = 16;\n  for (; r > 0 && !e[r - 1];) r--;\n  const n = [{\n    children: [],\n    index: 0\n  }];\n  let g,\n    o = n[0];\n  for (i = 0; i < r; i++) {\n    for (a = 0; a < e[i]; a++) {\n      o = n.pop();\n      o.children[o.index] = t[s];\n      for (; o.index > 0;) o = n.pop();\n      o.index++;\n      n.push(o);\n      for (; n.length <= i;) {\n        n.push(g = {\n          children: [],\n          index: 0\n        });\n        o.children[o.index] = g.children;\n        o = g;\n      }\n      s++;\n    }\n    if (i + 1 < r) {\n      n.push(g = {\n        children: [],\n        index: 0\n      });\n      o.children[o.index] = g.children;\n      o = g;\n    }\n  }\n  return n[0].children;\n}\nfunction getBlockBufferOffset(e, t, i) {\n  return 64 * ((e.blocksPerLine + 1) * t + i);\n}\nfunction decodeScan(e, t, i, a, s, r, n, g, o, c = !1) {\n  const C = i.mcusPerLine,\n    h = i.progressive,\n    l = t;\n  let Q = 0,\n    E = 0;\n  function readBit() {\n    if (E > 0) {\n      E--;\n      return Q >> E & 1;\n    }\n    Q = e[t++];\n    if (255 === Q) {\n      const a = e[t++];\n      if (a) {\n        if (220 === a && c) {\n          const a = readUint16(e, t += 2);\n          t += 2;\n          if (a > 0 && a !== i.scanLines) throw new DNLMarkerError(\"Found DNL marker (0xFFDC) while parsing scan data\", a);\n        } else if (217 === a) {\n          if (c) {\n            const e = p * (8 === i.precision ? 8 : 0);\n            if (e > 0 && Math.round(i.scanLines / e) >= 5) throw new DNLMarkerError(\"Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter\", e);\n          }\n          throw new EOIMarkerError(\"Found EOI marker (0xFFD9) while parsing scan data\");\n        }\n        throw new JpegError(`unexpected marker ${(Q << 8 | a).toString(16)}`);\n      }\n    }\n    E = 7;\n    return Q >>> 7;\n  }\n  function decodeHuffman(e) {\n    let t = e;\n    for (;;) {\n      t = t[readBit()];\n      switch (typeof t) {\n        case \"number\":\n          return t;\n        case \"object\":\n          continue;\n      }\n      throw new JpegError(\"invalid huffman sequence\");\n    }\n  }\n  function receive(e) {\n    let t = 0;\n    for (; e > 0;) {\n      t = t << 1 | readBit();\n      e--;\n    }\n    return t;\n  }\n  function receiveAndExtend(e) {\n    if (1 === e) return 1 === readBit() ? 1 : -1;\n    const t = receive(e);\n    return t >= 1 << e - 1 ? t : t + (-1 << e) + 1;\n  }\n  let u = 0;\n  let d,\n    f = 0;\n  let p = 0;\n  function decodeMcu(e, t, i, a, s) {\n    const r = i % C;\n    p = (i / C | 0) * e.v + a;\n    const n = r * e.h + s;\n    t(e, getBlockBufferOffset(e, p, n));\n  }\n  function decodeBlock(e, t, i) {\n    p = i / e.blocksPerLine | 0;\n    const a = i % e.blocksPerLine;\n    t(e, getBlockBufferOffset(e, p, a));\n  }\n  const m = a.length;\n  let y, w, D, b, F, S;\n  S = h ? 0 === r ? 0 === g ? function decodeDCFirst(e, t) {\n    const i = decodeHuffman(e.huffmanTableDC),\n      a = 0 === i ? 0 : receiveAndExtend(i) << o;\n    e.blockData[t] = e.pred += a;\n  } : function decodeDCSuccessive(e, t) {\n    e.blockData[t] |= readBit() << o;\n  } : 0 === g ? function decodeACFirst(e, t) {\n    if (u > 0) {\n      u--;\n      return;\n    }\n    let i = r;\n    const a = n;\n    for (; i <= a;) {\n      const a = decodeHuffman(e.huffmanTableAC),\n        s = 15 & a,\n        r = a >> 4;\n      if (0 === s) {\n        if (r < 15) {\n          u = receive(r) + (1 << r) - 1;\n          break;\n        }\n        i += 16;\n        continue;\n      }\n      i += r;\n      const n = $t[i];\n      e.blockData[t + n] = receiveAndExtend(s) * (1 << o);\n      i++;\n    }\n  } : function decodeACSuccessive(e, t) {\n    let i = r;\n    const a = n;\n    let s,\n      g,\n      c = 0;\n    for (; i <= a;) {\n      const a = t + $t[i],\n        r = e.blockData[a] < 0 ? -1 : 1;\n      switch (f) {\n        case 0:\n          g = decodeHuffman(e.huffmanTableAC);\n          s = 15 & g;\n          c = g >> 4;\n          if (0 === s) {\n            if (c < 15) {\n              u = receive(c) + (1 << c);\n              f = 4;\n            } else {\n              c = 16;\n              f = 1;\n            }\n          } else {\n            if (1 !== s) throw new JpegError(\"invalid ACn encoding\");\n            d = receiveAndExtend(s);\n            f = c ? 2 : 3;\n          }\n          continue;\n        case 1:\n        case 2:\n          if (e.blockData[a]) e.blockData[a] += r * (readBit() << o);else {\n            c--;\n            0 === c && (f = 2 === f ? 3 : 0);\n          }\n          break;\n        case 3:\n          if (e.blockData[a]) e.blockData[a] += r * (readBit() << o);else {\n            e.blockData[a] = d << o;\n            f = 0;\n          }\n          break;\n        case 4:\n          e.blockData[a] && (e.blockData[a] += r * (readBit() << o));\n      }\n      i++;\n    }\n    if (4 === f) {\n      u--;\n      0 === u && (f = 0);\n    }\n  } : function decodeBaseline(e, t) {\n    const i = decodeHuffman(e.huffmanTableDC),\n      a = 0 === i ? 0 : receiveAndExtend(i);\n    e.blockData[t] = e.pred += a;\n    let s = 1;\n    for (; s < 64;) {\n      const i = decodeHuffman(e.huffmanTableAC),\n        a = 15 & i,\n        r = i >> 4;\n      if (0 === a) {\n        if (r < 15) break;\n        s += 16;\n        continue;\n      }\n      s += r;\n      const n = $t[s];\n      e.blockData[t + n] = receiveAndExtend(a);\n      s++;\n    }\n  };\n  let k,\n    R = 0;\n  const N = 1 === m ? a[0].blocksPerLine * a[0].blocksPerColumn : C * i.mcusPerColumn;\n  let G, x;\n  for (; R <= N;) {\n    const i = s ? Math.min(N - R, s) : N;\n    if (i > 0) {\n      for (w = 0; w < m; w++) a[w].pred = 0;\n      u = 0;\n      if (1 === m) {\n        y = a[0];\n        for (F = 0; F < i; F++) {\n          decodeBlock(y, S, R);\n          R++;\n        }\n      } else for (F = 0; F < i; F++) {\n        for (w = 0; w < m; w++) {\n          y = a[w];\n          G = y.h;\n          x = y.v;\n          for (D = 0; D < x; D++) for (b = 0; b < G; b++) decodeMcu(y, S, R, D, b);\n        }\n        R++;\n      }\n    }\n    E = 0;\n    k = findNextFileMarker(e, t);\n    if (!k) break;\n    if (k.invalid) {\n      warn(`decodeScan - ${i > 0 ? \"unexpected\" : \"excessive\"} MCU data, current marker is: ${k.invalid}`);\n      t = k.offset;\n    }\n    if (!(k.marker >= 65488 && k.marker <= 65495)) break;\n    t += 2;\n  }\n  return t - l;\n}\nfunction quantizeAndInverse(e, t, i) {\n  const a = e.quantizationTable,\n    s = e.blockData;\n  let r, n, g, o, c, C, h, l, Q, E, u, d, f, p, m, y, w;\n  if (!a) throw new JpegError(\"missing required Quantization Table.\");\n  for (let e = 0; e < 64; e += 8) {\n    Q = s[t + e];\n    E = s[t + e + 1];\n    u = s[t + e + 2];\n    d = s[t + e + 3];\n    f = s[t + e + 4];\n    p = s[t + e + 5];\n    m = s[t + e + 6];\n    y = s[t + e + 7];\n    Q *= a[e];\n    if (0 != (E | u | d | f | p | m | y)) {\n      E *= a[e + 1];\n      u *= a[e + 2];\n      d *= a[e + 3];\n      f *= a[e + 4];\n      p *= a[e + 5];\n      m *= a[e + 6];\n      y *= a[e + 7];\n      r = ri * Q + 128 >> 8;\n      n = ri * f + 128 >> 8;\n      g = u;\n      o = m;\n      c = ni * (E - y) + 128 >> 8;\n      l = ni * (E + y) + 128 >> 8;\n      C = d << 4;\n      h = p << 4;\n      r = r + n + 1 >> 1;\n      n = r - n;\n      w = g * si + o * ai + 128 >> 8;\n      g = g * ai - o * si + 128 >> 8;\n      o = w;\n      c = c + h + 1 >> 1;\n      h = c - h;\n      l = l + C + 1 >> 1;\n      C = l - C;\n      r = r + o + 1 >> 1;\n      o = r - o;\n      n = n + g + 1 >> 1;\n      g = n - g;\n      w = c * ii + l * ti + 2048 >> 12;\n      c = c * ti - l * ii + 2048 >> 12;\n      l = w;\n      w = C * ei + h * Ai + 2048 >> 12;\n      C = C * Ai - h * ei + 2048 >> 12;\n      h = w;\n      i[e] = r + l;\n      i[e + 7] = r - l;\n      i[e + 1] = n + h;\n      i[e + 6] = n - h;\n      i[e + 2] = g + C;\n      i[e + 5] = g - C;\n      i[e + 3] = o + c;\n      i[e + 4] = o - c;\n    } else {\n      w = ri * Q + 512 >> 10;\n      i[e] = w;\n      i[e + 1] = w;\n      i[e + 2] = w;\n      i[e + 3] = w;\n      i[e + 4] = w;\n      i[e + 5] = w;\n      i[e + 6] = w;\n      i[e + 7] = w;\n    }\n  }\n  for (let e = 0; e < 8; ++e) {\n    Q = i[e];\n    E = i[e + 8];\n    u = i[e + 16];\n    d = i[e + 24];\n    f = i[e + 32];\n    p = i[e + 40];\n    m = i[e + 48];\n    y = i[e + 56];\n    if (0 != (E | u | d | f | p | m | y)) {\n      r = ri * Q + 2048 >> 12;\n      n = ri * f + 2048 >> 12;\n      g = u;\n      o = m;\n      c = ni * (E - y) + 2048 >> 12;\n      l = ni * (E + y) + 2048 >> 12;\n      C = d;\n      h = p;\n      r = 4112 + (r + n + 1 >> 1);\n      n = r - n;\n      w = g * si + o * ai + 2048 >> 12;\n      g = g * ai - o * si + 2048 >> 12;\n      o = w;\n      c = c + h + 1 >> 1;\n      h = c - h;\n      l = l + C + 1 >> 1;\n      C = l - C;\n      r = r + o + 1 >> 1;\n      o = r - o;\n      n = n + g + 1 >> 1;\n      g = n - g;\n      w = c * ii + l * ti + 2048 >> 12;\n      c = c * ti - l * ii + 2048 >> 12;\n      l = w;\n      w = C * ei + h * Ai + 2048 >> 12;\n      C = C * Ai - h * ei + 2048 >> 12;\n      h = w;\n      Q = r + l;\n      y = r - l;\n      E = n + h;\n      m = n - h;\n      u = g + C;\n      p = g - C;\n      d = o + c;\n      f = o - c;\n      Q < 16 ? Q = 0 : Q >= 4080 ? Q = 255 : Q >>= 4;\n      E < 16 ? E = 0 : E >= 4080 ? E = 255 : E >>= 4;\n      u < 16 ? u = 0 : u >= 4080 ? u = 255 : u >>= 4;\n      d < 16 ? d = 0 : d >= 4080 ? d = 255 : d >>= 4;\n      f < 16 ? f = 0 : f >= 4080 ? f = 255 : f >>= 4;\n      p < 16 ? p = 0 : p >= 4080 ? p = 255 : p >>= 4;\n      m < 16 ? m = 0 : m >= 4080 ? m = 255 : m >>= 4;\n      y < 16 ? y = 0 : y >= 4080 ? y = 255 : y >>= 4;\n      s[t + e] = Q;\n      s[t + e + 8] = E;\n      s[t + e + 16] = u;\n      s[t + e + 24] = d;\n      s[t + e + 32] = f;\n      s[t + e + 40] = p;\n      s[t + e + 48] = m;\n      s[t + e + 56] = y;\n    } else {\n      w = ri * Q + 8192 >> 14;\n      w = w < -2040 ? 0 : w >= 2024 ? 255 : w + 2056 >> 4;\n      s[t + e] = w;\n      s[t + e + 8] = w;\n      s[t + e + 16] = w;\n      s[t + e + 24] = w;\n      s[t + e + 32] = w;\n      s[t + e + 40] = w;\n      s[t + e + 48] = w;\n      s[t + e + 56] = w;\n    }\n  }\n}\nfunction buildComponentData(e, t) {\n  const i = t.blocksPerLine,\n    a = t.blocksPerColumn,\n    s = new Int16Array(64);\n  for (let e = 0; e < a; e++) for (let a = 0; a < i; a++) {\n    quantizeAndInverse(t, getBlockBufferOffset(t, e, a), s);\n  }\n  return t.blockData;\n}\nfunction findNextFileMarker(e, t, i = t) {\n  const a = e.length - 1;\n  let s = i < t ? i : t;\n  if (t >= a) return null;\n  const r = readUint16(e, t);\n  if (r >= 65472 && r <= 65534) return {\n    invalid: null,\n    marker: r,\n    offset: t\n  };\n  let n = readUint16(e, s);\n  for (; !(n >= 65472 && n <= 65534);) {\n    if (++s >= a) return null;\n    n = readUint16(e, s);\n  }\n  return {\n    invalid: r.toString(16),\n    marker: n,\n    offset: s\n  };\n}\nclass JpegImage {\n  constructor({\n    decodeTransform: e = null,\n    colorTransform: t = -1\n  } = {}) {\n    this._decodeTransform = e;\n    this._colorTransform = t;\n  }\n  parse(e, {\n    dnlScanLines: t = null\n  } = {}) {\n    function readDataBlock() {\n      const t = readUint16(e, s);\n      s += 2;\n      let i = s + t - 2;\n      const a = findNextFileMarker(e, i, s);\n      if (a?.invalid) {\n        warn(\"readDataBlock - incorrect length, current marker is: \" + a.invalid);\n        i = a.offset;\n      }\n      const r = e.subarray(s, i);\n      s += r.length;\n      return r;\n    }\n    function prepareComponents(e) {\n      const t = Math.ceil(e.samplesPerLine / 8 / e.maxH),\n        i = Math.ceil(e.scanLines / 8 / e.maxV);\n      for (const a of e.components) {\n        const s = Math.ceil(Math.ceil(e.samplesPerLine / 8) * a.h / e.maxH),\n          r = Math.ceil(Math.ceil(e.scanLines / 8) * a.v / e.maxV),\n          n = t * a.h,\n          g = 64 * (i * a.v) * (n + 1);\n        a.blockData = new Int16Array(g);\n        a.blocksPerLine = s;\n        a.blocksPerColumn = r;\n      }\n      e.mcusPerLine = t;\n      e.mcusPerColumn = i;\n    }\n    let i,\n      a,\n      s = 0,\n      r = null,\n      n = null,\n      g = 0;\n    const o = [],\n      c = [],\n      C = [];\n    let h = readUint16(e, s);\n    s += 2;\n    if (65496 !== h) throw new JpegError(\"SOI not found\");\n    h = readUint16(e, s);\n    s += 2;\n    A: for (; 65497 !== h;) {\n      let l, Q, E;\n      switch (h) {\n        case 65504:\n        case 65505:\n        case 65506:\n        case 65507:\n        case 65508:\n        case 65509:\n        case 65510:\n        case 65511:\n        case 65512:\n        case 65513:\n        case 65514:\n        case 65515:\n        case 65516:\n        case 65517:\n        case 65518:\n        case 65519:\n        case 65534:\n          const u = readDataBlock();\n          65504 === h && 74 === u[0] && 70 === u[1] && 73 === u[2] && 70 === u[3] && 0 === u[4] && (r = {\n            version: {\n              major: u[5],\n              minor: u[6]\n            },\n            densityUnits: u[7],\n            xDensity: u[8] << 8 | u[9],\n            yDensity: u[10] << 8 | u[11],\n            thumbWidth: u[12],\n            thumbHeight: u[13],\n            thumbData: u.subarray(14, 14 + 3 * u[12] * u[13])\n          });\n          65518 === h && 65 === u[0] && 100 === u[1] && 111 === u[2] && 98 === u[3] && 101 === u[4] && (n = {\n            version: u[5] << 8 | u[6],\n            flags0: u[7] << 8 | u[8],\n            flags1: u[9] << 8 | u[10],\n            transformCode: u[11]\n          });\n          break;\n        case 65499:\n          const d = readUint16(e, s);\n          s += 2;\n          const f = d + s - 2;\n          let p;\n          for (; s < f;) {\n            const t = e[s++],\n              i = new Uint16Array(64);\n            if (t >> 4 == 0) for (Q = 0; Q < 64; Q++) {\n              p = $t[Q];\n              i[p] = e[s++];\n            } else {\n              if (t >> 4 != 1) throw new JpegError(\"DQT - invalid table spec\");\n              for (Q = 0; Q < 64; Q++) {\n                p = $t[Q];\n                i[p] = readUint16(e, s);\n                s += 2;\n              }\n            }\n            o[15 & t] = i;\n          }\n          break;\n        case 65472:\n        case 65473:\n        case 65474:\n          if (i) throw new JpegError(\"Only single frame JPEGs supported\");\n          s += 2;\n          i = {};\n          i.extended = 65473 === h;\n          i.progressive = 65474 === h;\n          i.precision = e[s++];\n          const m = readUint16(e, s);\n          s += 2;\n          i.scanLines = t || m;\n          i.samplesPerLine = readUint16(e, s);\n          s += 2;\n          i.components = [];\n          i.componentIds = {};\n          const y = e[s++];\n          let w = 0,\n            D = 0;\n          for (l = 0; l < y; l++) {\n            const t = e[s],\n              a = e[s + 1] >> 4,\n              r = 15 & e[s + 1];\n            w < a && (w = a);\n            D < r && (D = r);\n            const n = e[s + 2];\n            E = i.components.push({\n              h: a,\n              v: r,\n              quantizationId: n,\n              quantizationTable: null\n            });\n            i.componentIds[t] = E - 1;\n            s += 3;\n          }\n          i.maxH = w;\n          i.maxV = D;\n          prepareComponents(i);\n          break;\n        case 65476:\n          const b = readUint16(e, s);\n          s += 2;\n          for (l = 2; l < b;) {\n            const t = e[s++],\n              i = new Uint8Array(16);\n            let a = 0;\n            for (Q = 0; Q < 16; Q++, s++) a += i[Q] = e[s];\n            const r = new Uint8Array(a);\n            for (Q = 0; Q < a; Q++, s++) r[Q] = e[s];\n            l += 17 + a;\n            (t >> 4 == 0 ? C : c)[15 & t] = buildHuffmanTable(i, r);\n          }\n          break;\n        case 65501:\n          s += 2;\n          a = readUint16(e, s);\n          s += 2;\n          break;\n        case 65498:\n          const F = 1 == ++g && !t;\n          s += 2;\n          const S = e[s++],\n            k = [];\n          for (l = 0; l < S; l++) {\n            const t = e[s++],\n              a = i.componentIds[t],\n              r = i.components[a];\n            r.index = t;\n            const n = e[s++];\n            r.huffmanTableDC = C[n >> 4];\n            r.huffmanTableAC = c[15 & n];\n            k.push(r);\n          }\n          const R = e[s++],\n            N = e[s++],\n            G = e[s++];\n          try {\n            const t = decodeScan(e, s, i, k, a, R, N, G >> 4, 15 & G, F);\n            s += t;\n          } catch (t) {\n            if (t instanceof DNLMarkerError) {\n              warn(`${t.message} -- attempting to re-parse the JPEG image.`);\n              return this.parse(e, {\n                dnlScanLines: t.scanLines\n              });\n            }\n            if (t instanceof EOIMarkerError) {\n              warn(`${t.message} -- ignoring the rest of the image data.`);\n              break A;\n            }\n            throw t;\n          }\n          break;\n        case 65500:\n          s += 4;\n          break;\n        case 65535:\n          255 !== e[s] && s--;\n          break;\n        default:\n          const x = findNextFileMarker(e, s - 2, s - 3);\n          if (x?.invalid) {\n            warn(\"JpegImage.parse - unexpected data, current marker is: \" + x.invalid);\n            s = x.offset;\n            break;\n          }\n          if (!x || s >= e.length - 1) {\n            warn(\"JpegImage.parse - reached the end of the image data without finding an EOI marker (0xFFD9).\");\n            break A;\n          }\n          throw new JpegError(\"JpegImage.parse - unknown marker: \" + h.toString(16));\n      }\n      h = readUint16(e, s);\n      s += 2;\n    }\n    if (!i) throw new JpegError(\"JpegImage.parse - no frame data found.\");\n    this.width = i.samplesPerLine;\n    this.height = i.scanLines;\n    this.jfif = r;\n    this.adobe = n;\n    this.components = [];\n    for (const e of i.components) {\n      const t = o[e.quantizationId];\n      t && (e.quantizationTable = t);\n      this.components.push({\n        index: e.index,\n        output: buildComponentData(0, e),\n        scaleX: e.h / i.maxH,\n        scaleY: e.v / i.maxV,\n        blocksPerLine: e.blocksPerLine,\n        blocksPerColumn: e.blocksPerColumn\n      });\n    }\n    this.numComponents = this.components.length;\n  }\n  _getLinearizedBlockData(e, t, i = !1) {\n    const a = this.width / e,\n      s = this.height / t;\n    let r,\n      n,\n      g,\n      o,\n      c,\n      C,\n      h,\n      l,\n      Q,\n      E,\n      u,\n      d = 0;\n    const f = this.components.length,\n      p = e * t * f,\n      m = new Uint8ClampedArray(p),\n      y = new Uint32Array(e),\n      w = 4294967288;\n    let D;\n    for (h = 0; h < f; h++) {\n      r = this.components[h];\n      n = r.scaleX * a;\n      g = r.scaleY * s;\n      d = h;\n      u = r.output;\n      o = r.blocksPerLine + 1 << 3;\n      if (n !== D) {\n        for (c = 0; c < e; c++) {\n          l = 0 | c * n;\n          y[c] = (l & w) << 3 | 7 & l;\n        }\n        D = n;\n      }\n      for (C = 0; C < t; C++) {\n        l = 0 | C * g;\n        E = o * (l & w) | (7 & l) << 3;\n        for (c = 0; c < e; c++) {\n          m[d] = u[E + y[c]];\n          d += f;\n        }\n      }\n    }\n    let b = this._decodeTransform;\n    i || 4 !== f || b || (b = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255]));\n    if (b) for (h = 0; h < p;) for (l = 0, Q = 0; l < f; l++, h++, Q += 2) m[h] = (m[h] * b[Q] >> 8) + b[Q + 1];\n    return m;\n  }\n  get _isColorConversionNeeded() {\n    return this.adobe ? !!this.adobe.transformCode : 3 === this.numComponents ? 0 !== this._colorTransform && (82 !== this.components[0].index || 71 !== this.components[1].index || 66 !== this.components[2].index) : 1 === this._colorTransform;\n  }\n  _convertYccToRgb(e) {\n    let t, i, a;\n    for (let s = 0, r = e.length; s < r; s += 3) {\n      t = e[s];\n      i = e[s + 1];\n      a = e[s + 2];\n      e[s] = t - 179.456 + 1.402 * a;\n      e[s + 1] = t + 135.459 - .344 * i - .714 * a;\n      e[s + 2] = t - 226.816 + 1.772 * i;\n    }\n    return e;\n  }\n  _convertYccToRgba(e, t) {\n    for (let i = 0, a = 0, s = e.length; i < s; i += 3, a += 4) {\n      const s = e[i],\n        r = e[i + 1],\n        n = e[i + 2];\n      t[a] = s - 179.456 + 1.402 * n;\n      t[a + 1] = s + 135.459 - .344 * r - .714 * n;\n      t[a + 2] = s - 226.816 + 1.772 * r;\n      t[a + 3] = 255;\n    }\n    return t;\n  }\n  _convertYcckToRgb(e) {\n    let t,\n      i,\n      a,\n      s,\n      r = 0;\n    for (let n = 0, g = e.length; n < g; n += 4) {\n      t = e[n];\n      i = e[n + 1];\n      a = e[n + 2];\n      s = e[n + 3];\n      e[r++] = i * (-660635669420364e-19 * i + .000437130475926232 * a - 54080610064599e-18 * t + .00048449797120281 * s - .154362151871126) - 122.67195406894 + a * (-.000957964378445773 * a + .000817076911346625 * t - .00477271405408747 * s + 1.53380253221734) + t * (.000961250184130688 * t - .00266257332283933 * s + .48357088451265) + s * (-.000336197177618394 * s + .484791561490776);\n      e[r++] = 107.268039397724 + i * (219927104525741e-19 * i - .000640992018297945 * a + .000659397001245577 * t + .000426105652938837 * s - .176491792462875) + a * (-.000778269941513683 * a + .00130872261408275 * t + .000770482631801132 * s - .151051492775562) + t * (.00126935368114843 * t - .00265090189010898 * s + .25802910206845) + s * (-.000318913117588328 * s - .213742400323665);\n      e[r++] = i * (-.000570115196973677 * i - 263409051004589e-19 * a + .0020741088115012 * t - .00288260236853442 * s + .814272968359295) - 20.810012546947 + a * (-153496057440975e-19 * a - .000132689043961446 * t + .000560833691242812 * s - .195152027534049) + t * (.00174418132927582 * t - .00255243321439347 * s + .116935020465145) + s * (-.000343531996510555 * s + .24165260232407);\n    }\n    return e.subarray(0, r);\n  }\n  _convertYcckToRgba(e) {\n    for (let t = 0, i = e.length; t < i; t += 4) {\n      const i = e[t],\n        a = e[t + 1],\n        s = e[t + 2],\n        r = e[t + 3];\n      e[t] = a * (-660635669420364e-19 * a + .000437130475926232 * s - 54080610064599e-18 * i + .00048449797120281 * r - .154362151871126) - 122.67195406894 + s * (-.000957964378445773 * s + .000817076911346625 * i - .00477271405408747 * r + 1.53380253221734) + i * (.000961250184130688 * i - .00266257332283933 * r + .48357088451265) + r * (-.000336197177618394 * r + .484791561490776);\n      e[t + 1] = 107.268039397724 + a * (219927104525741e-19 * a - .000640992018297945 * s + .000659397001245577 * i + .000426105652938837 * r - .176491792462875) + s * (-.000778269941513683 * s + .00130872261408275 * i + .000770482631801132 * r - .151051492775562) + i * (.00126935368114843 * i - .00265090189010898 * r + .25802910206845) + r * (-.000318913117588328 * r - .213742400323665);\n      e[t + 2] = a * (-.000570115196973677 * a - 263409051004589e-19 * s + .0020741088115012 * i - .00288260236853442 * r + .814272968359295) - 20.810012546947 + s * (-153496057440975e-19 * s - .000132689043961446 * i + .000560833691242812 * r - .195152027534049) + i * (.00174418132927582 * i - .00255243321439347 * r + .116935020465145) + r * (-.000343531996510555 * r + .24165260232407);\n      e[t + 3] = 255;\n    }\n    return e;\n  }\n  _convertYcckToCmyk(e) {\n    let t, i, a;\n    for (let s = 0, r = e.length; s < r; s += 4) {\n      t = e[s];\n      i = e[s + 1];\n      a = e[s + 2];\n      e[s] = 434.456 - t - 1.402 * a;\n      e[s + 1] = 119.541 - t + .344 * i + .714 * a;\n      e[s + 2] = 481.816 - t - 1.772 * i;\n    }\n    return e;\n  }\n  _convertCmykToRgb(e) {\n    let t,\n      i,\n      a,\n      s,\n      r = 0;\n    for (let n = 0, g = e.length; n < g; n += 4) {\n      t = e[n];\n      i = e[n + 1];\n      a = e[n + 2];\n      s = e[n + 3];\n      e[r++] = 255 + t * (-6747147073602441e-20 * t + .0008379262121013727 * i + .0002894718188643294 * a + .003264231057537806 * s - 1.1185611867203937) + i * (26374107616089405e-21 * i - 8626949158638572e-20 * a - .0002748769067499491 * s - .02155688794978967) + a * (-3878099212869363e-20 * a - .0003267808279485286 * s + .0686742238595345) - s * (.0003361971776183937 * s + .7430659151342254);\n      e[r++] = 255 + t * (.00013596372813588848 * t + .000924537132573585 * i + .00010567359618683593 * a + .0004791864687436512 * s - .3109689587515875) + i * (-.00023545346108370344 * i + .0002702845253534714 * a + .0020200308977307156 * s - .7488052167015494) + a * (6834815998235662e-20 * a + .00015168452363460973 * s - .09751927774728933) - s * (.0003189131175883281 * s + .7364883807733168);\n      e[r++] = 255 + t * (13598650411385307e-21 * t + .00012423956175490851 * i + .0004751985097583589 * a - 36729317476630422e-22 * s - .05562186980264034) + i * (.00016141380598724676 * i + .0009692239130725186 * a + .0007782692450036253 * s - .44015232367526463) + a * (5.068882914068769e-7 * a + .0017778369011375071 * s - .7591454649749609) - s * (.0003435319965105553 * s + .7063770186160144);\n    }\n    return e.subarray(0, r);\n  }\n  _convertCmykToRgba(e) {\n    for (let t = 0, i = e.length; t < i; t += 4) {\n      const i = e[t],\n        a = e[t + 1],\n        s = e[t + 2],\n        r = e[t + 3];\n      e[t] = 255 + i * (-6747147073602441e-20 * i + .0008379262121013727 * a + .0002894718188643294 * s + .003264231057537806 * r - 1.1185611867203937) + a * (26374107616089405e-21 * a - 8626949158638572e-20 * s - .0002748769067499491 * r - .02155688794978967) + s * (-3878099212869363e-20 * s - .0003267808279485286 * r + .0686742238595345) - r * (.0003361971776183937 * r + .7430659151342254);\n      e[t + 1] = 255 + i * (.00013596372813588848 * i + .000924537132573585 * a + .00010567359618683593 * s + .0004791864687436512 * r - .3109689587515875) + a * (-.00023545346108370344 * a + .0002702845253534714 * s + .0020200308977307156 * r - .7488052167015494) + s * (6834815998235662e-20 * s + .00015168452363460973 * r - .09751927774728933) - r * (.0003189131175883281 * r + .7364883807733168);\n      e[t + 2] = 255 + i * (13598650411385307e-21 * i + .00012423956175490851 * a + .0004751985097583589 * s - 36729317476630422e-22 * r - .05562186980264034) + a * (.00016141380598724676 * a + .0009692239130725186 * s + .0007782692450036253 * r - .44015232367526463) + s * (5.068882914068769e-7 * s + .0017778369011375071 * r - .7591454649749609) - r * (.0003435319965105553 * r + .7063770186160144);\n      e[t + 3] = 255;\n    }\n    return e;\n  }\n  getData({\n    width: e,\n    height: t,\n    forceRGBA: i = !1,\n    forceRGB: a = !1,\n    isSourcePDF: s = !1\n  }) {\n    if (this.numComponents > 4) throw new JpegError(\"Unsupported color mode\");\n    const r = this._getLinearizedBlockData(e, t, s);\n    if (1 === this.numComponents && (i || a)) {\n      const e = r.length * (i ? 4 : 3),\n        t = new Uint8ClampedArray(e);\n      let a = 0;\n      if (i) !function grayToRGBA(e, t) {\n        if (FeatureTest.isLittleEndian) for (let i = 0, a = e.length; i < a; i++) t[i] = 65793 * e[i] | 4278190080;else for (let i = 0, a = e.length; i < a; i++) t[i] = 16843008 * e[i] | 255;\n      }(r, new Uint32Array(t.buffer));else for (const e of r) {\n        t[a++] = e;\n        t[a++] = e;\n        t[a++] = e;\n      }\n      return t;\n    }\n    if (3 === this.numComponents && this._isColorConversionNeeded) {\n      if (i) {\n        const e = new Uint8ClampedArray(r.length / 3 * 4);\n        return this._convertYccToRgba(r, e);\n      }\n      return this._convertYccToRgb(r);\n    }\n    if (4 === this.numComponents) {\n      if (this._isColorConversionNeeded) return i ? this._convertYcckToRgba(r) : a ? this._convertYcckToRgb(r) : this._convertYcckToCmyk(r);\n      if (i) return this._convertCmykToRgba(r);\n      if (a) return this._convertCmykToRgb(r);\n    }\n    return r;\n  }\n}\nclass JpegStream extends DecodeStream {\n  constructor(e, t, i) {\n    super(t);\n    this.stream = e;\n    this.dict = e.dict;\n    this.maybeLength = t;\n    this.params = i;\n  }\n  get bytes() {\n    return shadow(this, \"bytes\", this.stream.getBytes(this.maybeLength));\n  }\n  ensureBuffer(e) {}\n  readBlock() {\n    this.decodeImage();\n  }\n  decodeImage(e) {\n    if (this.eof) return this.buffer;\n    e ||= this.bytes;\n    for (let t = 0, i = e.length - 1; t < i; t++) if (255 === e[t] && 216 === e[t + 1]) {\n      t > 0 && (e = e.subarray(t));\n      break;\n    }\n    const t = {\n        decodeTransform: void 0,\n        colorTransform: void 0\n      },\n      i = this.dict.getArray(\"D\", \"Decode\");\n    if ((this.forceRGBA || this.forceRGB) && Array.isArray(i)) {\n      const e = this.dict.get(\"BPC\", \"BitsPerComponent\") || 8,\n        a = i.length,\n        s = new Int32Array(a);\n      let r = !1;\n      const n = (1 << e) - 1;\n      for (let e = 0; e < a; e += 2) {\n        s[e] = 256 * (i[e + 1] - i[e]) | 0;\n        s[e + 1] = i[e] * n | 0;\n        256 === s[e] && 0 === s[e + 1] || (r = !0);\n      }\n      r && (t.decodeTransform = s);\n    }\n    if (this.params instanceof Dict) {\n      const e = this.params.get(\"ColorTransform\");\n      Number.isInteger(e) && (t.colorTransform = e);\n    }\n    const a = new JpegImage(t);\n    a.parse(e);\n    const s = a.getData({\n      width: this.drawWidth,\n      height: this.drawHeight,\n      forceRGBA: this.forceRGBA,\n      forceRGB: this.forceRGB,\n      isSourcePDF: !0\n    });\n    this.buffer = s;\n    this.bufferLength = s.length;\n    this.eof = !0;\n    return this.buffer;\n  }\n  get canAsyncDecodeImageFromBuffer() {\n    return this.stream.isAsync;\n  }\n}\nvar gi,\n  oi = (gi = \"undefined\" != typeof document ? document.currentScript?.src : void 0, function (e = {}) {\n    var t,\n      i,\n      a = e;\n    new Promise((e, a) => {\n      t = e;\n      i = a;\n    });\n    a.decode = function (e, {\n      numComponents: t = 4,\n      isIndexedColormap: i = !1,\n      smaskInData: s = !1\n    }) {\n      const r = e.length,\n        n = a._malloc(r);\n      a.HEAPU8.set(e, n);\n      const g = a._jp2_decode(n, r, t > 0 ? t : 0, !!i, !!s);\n      a._free(n);\n      if (g) {\n        const {\n          errorMessages: e\n        } = a;\n        if (e) {\n          delete a.errorMessages;\n          return e;\n        }\n        return \"Unknown error\";\n      }\n      const {\n        imageData: o\n      } = a;\n      a.imageData = null;\n      return o;\n    };\n    var s,\n      r = Object.assign({}, a),\n      n = \"./this.program\",\n      g = \"\";\n    \"undefined\" != typeof document && document.currentScript && (g = document.currentScript.src);\n    gi && (g = gi);\n    g = g.startsWith(\"blob:\") ? \"\" : g.substr(0, g.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1);\n    var o,\n      c,\n      C,\n      h,\n      l,\n      Q = a.print || console.log.bind(console),\n      E = a.printErr || console.error.bind(console);\n    Object.assign(a, r);\n    r = null;\n    a.arguments && a.arguments;\n    a.thisProgram && (n = a.thisProgram);\n    a.quit && a.quit;\n    a.wasmBinary && (o = a.wasmBinary);\n    function tryParseAsDataURI(e) {\n      if (isDataURI(e)) return function intArrayFromBase64(e) {\n        for (var t = atob(e), i = new Uint8Array(t.length), a = 0; a < t.length; ++a) i[a] = t.charCodeAt(a);\n        return i;\n      }(e.slice(D.length));\n    }\n    function updateMemoryViews() {\n      var e = c.buffer;\n      a.HEAP8 = C = new Int8Array(e);\n      a.HEAP16 = new Int16Array(e);\n      a.HEAPU8 = h = new Uint8Array(e);\n      a.HEAPU16 = new Uint16Array(e);\n      a.HEAP32 = new Int32Array(e);\n      a.HEAPU32 = l = new Uint32Array(e);\n      a.HEAPF32 = new Float32Array(e);\n      a.HEAPF64 = new Float64Array(e);\n    }\n    var u,\n      d = [],\n      f = [],\n      p = [],\n      m = 0,\n      y = null,\n      w = null,\n      D = \"data:application/octet-stream;base64,\",\n      isDataURI = e => e.startsWith(D);\n    function instantiateSync(e, t) {\n      var i,\n        a = function getBinarySync(e) {\n          if (e == u && o) return new Uint8Array(o);\n          var t = tryParseAsDataURI(e);\n          if (t) return t;\n          if (s) return s(e);\n          throw 'sync fetching of the wasm failed: you can preload it to Module[\"wasmBinary\"] manually, or emcc.py will do that for you when generating HTML (but not JS)';\n        }(e);\n      i = new WebAssembly.Module(a);\n      return [new WebAssembly.Instance(i, t), i];\n    }\n    var callRuntimeCallbacks = e => {\n      for (; e.length > 0;) e.shift()(a);\n    };\n    a.noExitRuntime;\n    var b,\n      growMemory = e => {\n        var t = (e - c.buffer.byteLength + 65535) / 65536;\n        try {\n          c.grow(t);\n          updateMemoryViews();\n          return 1;\n        } catch (e) {}\n      },\n      F = {},\n      getEnvStrings = () => {\n        if (!getEnvStrings.strings) {\n          var e = {\n            USER: \"web_user\",\n            LOGNAME: \"web_user\",\n            PATH: \"/\",\n            PWD: \"/\",\n            HOME: \"/home/web_user\",\n            LANG: (\"object\" == typeof navigator && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\",\n            _: n || \"./this.program\"\n          };\n          for (var t in F) void 0 === F[t] ? delete e[t] : e[t] = F[t];\n          var i = [];\n          for (var t in e) i.push(`${t}=${e[t]}`);\n          getEnvStrings.strings = i;\n        }\n        return getEnvStrings.strings;\n      },\n      S = [null, [], []],\n      k = \"undefined\" != typeof TextDecoder ? new TextDecoder(\"utf8\") : void 0,\n      UTF8ArrayToString = (e, t, i) => {\n        for (var a = t + i, s = t; e[s] && !(s >= a);) ++s;\n        if (s - t > 16 && e.buffer && k) return k.decode(e.subarray(t, s));\n        for (var r = \"\"; t < s;) {\n          var n = e[t++];\n          if (128 & n) {\n            var g = 63 & e[t++];\n            if (192 != (224 & n)) {\n              var o = 63 & e[t++];\n              if ((n = 224 == (240 & n) ? (15 & n) << 12 | g << 6 | o : (7 & n) << 18 | g << 12 | o << 6 | 63 & e[t++]) < 65536) r += String.fromCharCode(n);else {\n                var c = n - 65536;\n                r += String.fromCharCode(55296 | c >> 10, 56320 | 1023 & c);\n              }\n            } else r += String.fromCharCode((31 & n) << 6 | g);\n          } else r += String.fromCharCode(n);\n        }\n        return r;\n      },\n      printChar = (e, t) => {\n        var i = S[e];\n        if (0 === t || 10 === t) {\n          (1 === e ? Q : E)(UTF8ArrayToString(i, 0));\n          i.length = 0;\n        } else i.push(t);\n      },\n      UTF8ToString = (e, t) => e ? UTF8ArrayToString(h, e, t) : \"\",\n      R = {\n        c: (e, t, i) => h.copyWithin(e, t, t + i),\n        g: function _copy_pixels_1(e, t) {\n          e >>= 2;\n          const i = a.imageData = new Uint8ClampedArray(t),\n            s = a.HEAP32.subarray(e, e + t);\n          i.set(s);\n        },\n        f: function _copy_pixels_3(e, t, i, s) {\n          e >>= 2;\n          t >>= 2;\n          i >>= 2;\n          const r = a.imageData = new Uint8ClampedArray(3 * s),\n            n = a.HEAP32.subarray(e, e + s),\n            g = a.HEAP32.subarray(t, t + s),\n            o = a.HEAP32.subarray(i, i + s);\n          for (let e = 0; e < s; e++) {\n            r[3 * e] = n[e];\n            r[3 * e + 1] = g[e];\n            r[3 * e + 2] = o[e];\n          }\n        },\n        e: function _copy_pixels_4(e, t, i, s, r) {\n          e >>= 2;\n          t >>= 2;\n          i >>= 2;\n          s >>= 2;\n          const n = a.imageData = new Uint8ClampedArray(4 * r),\n            g = a.HEAP32.subarray(e, e + r),\n            o = a.HEAP32.subarray(t, t + r),\n            c = a.HEAP32.subarray(i, i + r),\n            C = a.HEAP32.subarray(s, s + r);\n          for (let e = 0; e < r; e++) {\n            n[4 * e] = g[e];\n            n[4 * e + 1] = o[e];\n            n[4 * e + 2] = c[e];\n            n[4 * e + 3] = C[e];\n          }\n        },\n        k: e => {\n          var t = h.length,\n            i = 2147483648;\n          if ((e >>>= 0) > i) return !1;\n          for (var a, s, r = 1; r <= 4; r *= 2) {\n            var n = t * (1 + .2 / r);\n            n = Math.min(n, e + 100663296);\n            var g = Math.min(i, (a = Math.max(e, n)) + ((s = 65536) - a % s) % s);\n            if (growMemory(g)) return !0;\n          }\n          return !1;\n        },\n        l: (e, t) => {\n          var i = 0;\n          getEnvStrings().forEach((a, s) => {\n            var r = t + i;\n            l[e + 4 * s >> 2] = r;\n            ((e, t) => {\n              for (var i = 0; i < e.length; ++i) C[t++] = e.charCodeAt(i);\n              C[t] = 0;\n            })(a, r);\n            i += a.length + 1;\n          });\n          return 0;\n        },\n        m: (e, t) => {\n          var i = getEnvStrings();\n          l[e >> 2] = i.length;\n          var a = 0;\n          i.forEach(e => a += e.length + 1);\n          l[t >> 2] = a;\n          return 0;\n        },\n        n: e => 52,\n        j: function _fd_seek(e, t, i, a, s) {\n          return 70;\n        },\n        b: (e, t, i, a) => {\n          for (var s = 0, r = 0; r < i; r++) {\n            var n = l[t >> 2],\n              g = l[t + 4 >> 2];\n            t += 8;\n            for (var o = 0; o < g; o++) printChar(e, h[n + o]);\n            s += g;\n          }\n          l[a >> 2] = s;\n          return 0;\n        },\n        o: function _gray_to_rgba(e, t) {\n          e >>= 2;\n          const i = a.imageData = new Uint8ClampedArray(4 * t),\n            s = a.HEAP32.subarray(e, e + t);\n          for (let e = 0; e < t; e++) {\n            i[4 * e] = i[4 * e + 1] = i[4 * e + 2] = s[e];\n            i[4 * e + 3] = 255;\n          }\n        },\n        i: function _graya_to_rgba(e, t, i) {\n          e >>= 2;\n          t >>= 2;\n          const s = a.imageData = new Uint8ClampedArray(4 * i),\n            r = a.HEAP32.subarray(e, e + i),\n            n = a.HEAP32.subarray(t, t + i);\n          for (let e = 0; e < i; e++) {\n            s[4 * e] = s[4 * e + 1] = s[4 * e + 2] = r[e];\n            s[4 * e + 3] = n[e];\n          }\n        },\n        d: function _jsPrintWarning(e) {\n          const t = UTF8ToString(e);\n          (a.warn || console.warn)(`OpenJPEG: ${t}`);\n        },\n        h: function _rgb_to_rgba(e, t, i, s) {\n          e >>= 2;\n          t >>= 2;\n          i >>= 2;\n          const r = a.imageData = new Uint8ClampedArray(4 * s),\n            n = a.HEAP32.subarray(e, e + s),\n            g = a.HEAP32.subarray(t, t + s),\n            o = a.HEAP32.subarray(i, i + s);\n          for (let e = 0; e < s; e++) {\n            r[4 * e] = n[e];\n            r[4 * e + 1] = g[e];\n            r[4 * e + 2] = o[e];\n            r[4 * e + 3] = 255;\n          }\n        },\n        a: function _storeErrorMessage(e) {\n          const t = UTF8ToString(e);\n          a.errorMessages ? a.errorMessages += \"\\n\" + t : a.errorMessages = t;\n        }\n      },\n      N = function createWasm() {\n        var e = function getWasmImports() {\n          return {\n            a: R\n          };\n        }();\n        function receiveInstance(e, t) {\n          N = e.exports;\n          c = N.p;\n          updateMemoryViews();\n          !function addOnInit(e) {\n            f.unshift(e);\n          }(N.q);\n          !function removeRunDependency(e) {\n            m--;\n            a.monitorRunDependencies?.(m);\n            if (0 == m) {\n              if (null !== y) {\n                clearInterval(y);\n                y = null;\n              }\n              if (w) {\n                var t = w;\n                w = null;\n                t();\n              }\n            }\n          }();\n          return N;\n        }\n        !function addRunDependency(e) {\n          m++;\n          a.monitorRunDependencies?.(m);\n        }();\n        if (a.instantiateWasm) try {\n          return a.instantiateWasm(e, receiveInstance);\n        } catch (e) {\n          E(`Module.instantiateWasm callback failed with error: ${e}`);\n          i(e);\n        }\n        u || (u = \"data:application/octet-stream;base64,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A0kNAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgACADQQRrIgRLBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAswAQF/AkAgAEUNACABRQ0AQQggACABbCIBECUiAARAIABBACABEBUaCyAAIQILIAILEQAgAEUEQEEADwtBCCAAECUL8gICAn8BfgJAIAJFDQAgACABOgAAIAAgAmoiA0EBayABOgAAIAJBA0kNACAAIAE6AAIgACABOgABIANBA2sgAToAACADQQJrIAE6AAAgAkEHSQ0AIAAgAToAAyADQQRrIAE6AAAgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBBGsgATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQQhrIAE2AgAgAkEMayABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkEQayABNgIAIAJBFGsgATYCACACQRhrIAE2AgAgAkEcayABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa1CgYCAgBB+IQUgAyAEaiEBA0AgASAFNwMYIAEgBTcDECABIAU3AwggASAFNwMAIAFBIGohASACQSBrIgJBH0sNAAsLIAALJwEBfyMAQRBrIgMkACADIAI2AgwgACABIAJBAEEAEGsgA0EQaiQAC+gFAQl/IAFFBEBBAA8LAn8gAEUE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ACAEIE5BCmpBAiAFEBpBAkcEQCAFQQFBAiAAKAK4ARtBlhJBABAPIAAoArgBRSFnDAELIE5BCmogTkEMakECEBEgTigCDCIBQZD/A0YNACABQdn/A0YEQCAAQYACNgIIIABBADYCzAEMAQsgBCkDCCKGAVAEfkIABSCGASAEKQM4fQtQBEAgAEHAADYCCCAFQQJBrD9BABAPDAELQQAhZyAFQQFB7D5BABAPCyBOQRBqJAAgZwsLACAABEAgABAQCwu0AQEBfyAAKAIMRQRAIAIgACgCJCABEQMADwsCQEEIEBQiA0UNACADIAI2AgQgAyABNgIAQQgQFCIBRQRAIAMQEA8LIAEgAzYCACAAIAAoAgRB5ABsIgI2AigDQCAAKAIYIAJKDQALIAEgACgCFDYCBCAAIAE2AhQgACAAKAIYQQFqNgIYIAAoAhwiAUUNACABKAIAQQA2AgggACABKAIENgIcIAAgACgCIEEBazYCICABEBALC/oCAQR/AkAgAEUNACAAKAKsKCIBBEAgACgCqCgiAgRAQQAhAQNAIAAoAqwoIAFBA3RqKAIAIgMEQCADEBAgACgCqCghAgsgAUEBaiIBIAJJDQALIAAoAqwoIQELIABBADYCqCggARAQIABBADYCrCgLIAAoArQoIgEEQCABEBAgAEEANgK0KAsgACgC0CsiAQRAIAEQECAAQQA2AtArCyAAKALsKyIBBEAgARAQIABBADYC7CsLIAAoAugrIgEEQCABEBAgAEEANgLoKwsgACgC/CsiAQRAIAEQECAAQQA2AoQsIABCADcC/CsLIAAoAvArIgEEQCAAKAL0KyIDBH9BACECA0AgASgCDCIEBEAgBBAQIAFBADYCDCAAKAL0KyEDCyABQRRqIQEgAkEBaiICIANJDQALIAAoAvArBSABCxAQIABBADYC8CsLIAAoAuQrIgEEQCABEBAgAEEANgLkKwsgACgC3CsiAUUNACABEBAgAEIANwLcKwsLyAcCEX8BfiAAKAIQIghBIE8EQCAAKQMIpw8LAkAgACgCFCIDQQROBEAgACgCACICQQNrKAIAIQEgACADQQRrIgM2AhQgACACQQRrNgIADAELIANBAEwEQAwBCyADQQFxIQ0gACgCACECAkAgA0EBRgRAQRghBAwBCyADQf7///8HcSEJQRghBANAIAAgAkEB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IABBADYCiAEgACgCZBAQIABBADYCZCAALQC8AUECcUUEQCAAKAKoARAQCyAAQdAAakEAQfAAEBUaIAAoAsABEDIgAEEANgLAASAAKALEARAyIABBADYCwAEgACgCyAEiAQRAIAEoAhwiAgRAIAIQECABQQA2AhwLIAEoAigiAgRAIAEoAiQEQANAIAIgBUEobCIDaigCJCIEBEAgBBAQIAEoAigiAiADakEANgIkCyACIANqKAIQIgQEQCAEEBAgASgCKCICIANqQQA2AhALIAIgA2ooAhgiBARAIAQQECABKAIoIgIgA2pBADYCGAsgBUEBaiIFIAEoAiRJDQALCyACEBAgAUEANgIoCyABEBALIABBADYCyAEgACgCSBAhIABBADYCSCAAKAJMECEgAEEANgJMIAAoAtQBIgMEQAJAIAMoAghFDQAgAygCDARAIANBADYCKANAIAMoAhhBAEoNAAsLIANBATYCECADKAIAEBAgAygCHCICRQ0AA0AgAigCBCEBIAIQECADIAE2AhwgASICDQALCyADKAIkIgIEQCACKAIEIgVBAEoEQEEAIQEDQCACKAIAIAFBDGxqIgQoAggiBgRAIAQoAgQgBhECACACKAIEIQULIAFBAWoiASAFSA0ACwsgAigCABAQIAIQEAsgAxAQCyAAQQA2AtQBIAAQEAsL5gMCCH8EfiAAKAIUKAIAKAIUIAFBzABsaiIJKAIMIgggACgCGCgCGCABQTRsaiIKNQIEIhBCAX0iEiAANQI8fCAQgKciCyAIIAtJGyEMIAkoAggiCCAKNQIAIhFCAX0iEyAANQI4fCARgKciCiAIIApJGyEKIAkoAgQiCCASIAA1AjR8IBCApyILIAggC0sbIQsgCSgCACIIIBMgADUCMHwgEYCnIg0gCCANSxshDUEAIQggACgCICgC0CsgAUG4CGxqKAIUIQ4CQCAJKAIUQQAgAmtBfyACG2oiAkUEQCAKIQAgDSEIIAshAQwBCyADQQFxIAJBAWsiD3QiCSANSQRAIA0gCWutQn8gAq0iEIZCf4V8IBCIpyEIC0EAIQBBACEBIANBAXYgD3QiAyALSQRAIAsgA2utQn8gAq0iEIZCf4V8IBCIpyEBCyAJIApJBEAgCiAJa61CfyACrSIQhkJ/hXwgEIinIQALIAMgDE8EQEEAIQwMAQsgDCAD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IABBADYCPCAAQucHNwI0IABBADYCLCAAQucHNwIkIABBADYCHCAAQucHNwIUIABBADYCDCAAQucHNwIEIABBQGshACACQQRqIgIgA0cNAAsLIAFBA3EiAUUNAEEAIQIDQCAAQQA2AgwgAELnBzcCBCAAQRBqIQAgAkEBaiICIAFHDQALCwv7BQEQfyMAQYACayIIJAACf0EBQRQQEyIGRQRAIAJBAUH0MEEAEA9BAAwBCyAGIAE2AgQgBiAANgIAIAggATYCACAIIAA2AoABA0AgCCAFIg1BAWoiBUECdCIHaiABQQFqQQJtIgM2AgAgCEGAAWogB2ogAEEBakECbSIHNgIAIAQgACABbCIJaiEEIAMhASAHIQAgCUEBSw0ACyAGIAQ2AgggBEUEQCAGEBBBAAwBCyAGIARBEBATIgM2AgwgA0UEQCACQQFB2hpBABAPIAYQEEEADAELIAYgBigCCCILQQR0NgIQIAMhACANBEAgAyAGKAIEIAYoAgBsQQR0aiIEIQEDQAJAIAggDkECdCICaigCACIJQQBMDQAgCUEBayEMQQAhBwJAIAhBgAFqIAJqKAIAIgJBAEwEQEEAIQUgCUEBRwRAIAlB/v///wdxIQoDQCAFIAxGIQ8gBUECaiEFIAEgBCAPGyIEIQEgB0ECaiIHIApHDQALCyAJQQFxDQEgBCEBDAILA0AgBCEFIAIhBANAAkAgACABNgIAIARBAUYEQCAAQRBqIQAgAUEQaiEBDAELIAAgATYCECABQRBqIQEgAEEgaiEAIARBAkohECAEQQJrIQQgEA0BCwsgASAFIAJBBHRqIAcgByAMRnJBAXEiChshBCABIAUgChshASAHQQFqIgcgCUcNAAsMAQsgASAEIAJBBHRqIAUgBSAMRnJBAXEiBRshESABIAQgBRshASARIQQLIA5BAWoiDiANRw0ACwsgAEEANgIAAkAgC0UNACALQQRPBEAgC0F8cSEAQQAhAQNAIANBADYCPCADQucHNwI0IANBADYCLCADQucHNwIkIANBADYCHCADQucHNwIUIANBADYCDCADQucHNwIEIANBQGshAyABQQRqIgEgAEcNAAsLIAtBA3EiAEUNAEEAIQEDQCADQQA2AgwgA0LnBzcCBCADQRBqIQMgAUEBaiIBIABHDQALCyAGCyESIAhBgAJqJAAgEgtTAQF/An8gAC0ADEH/AUYEQCAAQoD+g4DwADcCDEEAIAAoAggiASAAKAIETw0BGiAAIAFBAWo2AgggACABLQAAQYD+A3I2AgwLIABBADYCEEEBCwt+AgF/AX4gAL0iA0I0iKdB/w9xIgJB/w9HBHwgAkUEQCABIABEAAAAAAAAAABhBH9BAAUgAEQAAAAAAADwQ6IgARBlIQAgASgCAEFAags2AgAgAA8LIAEgAkH+B2s2AgAgA0L/////////h4B/g0KAgICAgICA8D+EvwUgAAsLSQEBfwJAQQFBLBATIgEEQCABQQA2AhACQCAAQQBMBEAgAUEBQQgQEyIANgIkIABFDQEMAwsgAUEANgIMCyABEBALQQAhAQsgAQuRAgAgAEUEQEEADwsCfwJAIAFB/wBNDQACQEGU0AEoAgAoAgBFBEAgAUGAf3FBgL8DRg0CDAELIAFB/w9NBEAgACABQT9xQYABcjoAASAAIAFBBnZBwAFyOgAAQQIMAwsgAUGAQHFBgMADRyABQYCwA09xRQRAIAAgAUE/cUGAAXI6AAIgACABQQx2QeABcjoAACAAIAFBBnZBP3FBgAFyOgABQQMMAwsgAUGAgARrQf//P00EQCAAIAFBP3FBgAFyOgADIAAgAUESdkHwAXI6AAAgACABQQZ2QT9xQYABcjoAAiAAIAFBDHZBP3FBgAFyOgABQQQMAwsLQZTHAUEZNgIAQX8MAQsgACABOgAAQQELC7wCAAJAAkACQAJAAkACQAJAAkACQAJAAkAgAUEJaw4SAAgJCggJAQIDBAoJCgoICQUGBwsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsgACACIAMRAwALDwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMAC3MBBn8gACgCACIDLAAAQTBrIgFBCUsE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AyAAQRh2NgIUIAMgBDYCECADIABBCHZB/wFxNgIcIAMgAEEQdkH/AXE2AhggAkEBQc31ACADQRBqEA8MBwsgBSAITQRAIAYhBAwECyAFIQggBiAFEBciBA0DIAYQECACQQFB/w9BABAPQQAMBwsgBEECcUUEQCACQQFBwg9BABAPIAYQEEEADAcLIAAgBEH/////B3I2AmQgASAHIAVrrSINIAIgASgCKBEIACANUQ0DIAAtAGRBCHFFDQEgAkECQZIcQQAQDwsgBhAQQQEMBQsgAkEBQZIcQQAQDyAGEBBBAAwECyABIAQgBSACEBogBUcEQCACQQFBxBxBABAPIAQQEEEADAQLIAAgBCIGIAUgAiAKKAIEEQEADQALIAQQEEEADAILIAJBAUGiJUEAEA9BAAwBCyAGEBBBAAshDCADQfAAaiQAIAwL5gEBBn8gACgCCEE1IAIQJARAAkAgACgCCCIGKAIAIQMgBigCCCEFAkACQAJ/AkAgAwRAQQEhBCADQQFxIQcgA0EBRw0BQQAMAgsgBkEANgIADAILIANBfnEhAwNAAn9BACAERQ0AGkEAIAAgASACIAUoAgARAABFDQAaIAAgASACIAUoAgQRAABBAEcLIQQgBUEIaiEFIAhBAmoiCCADRw0ACyAERQshAyAHBEAgAw0CIAAgASACIAUoAgARAABBAEchBAsgBkEANgIAIARFDQILIAAoAgAaQQEPCyAGQQA2AgALC0EACwoAIAAoAgAaQQALFAAgACgCACIABEAgACABNgK4AQsLIQAgACgCACABEFMgAEEAOgB8IAAgASgCuEBBAXE2AoABCzIAIAJFBEBBAA8LIAAoAgAgASACIAMQSEUEQCADQQFBqS9BABAPQQAPCyAAIAIgAxBxC2kCAn8BfCMAQRBrIgMkACACBEADQCAAIANBCGoQRCABAn8gAysDCCIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAs2AgAgAUEEaiEBIABBCGohACAEQQFqIgQgAkcNAAsLIANBEGokAAuEAQICfwF9IwBBEGsiAyQAIAIEQANAIAMgAC0AADoADyADIAAtAAE6AA4gAyAALQACOgANIAMgAC0AAzoADCABAn8gAyoCDCIFi0MAAABPXQRAIAWoDAELQYCAgIB4CzYCACABQQRqIQEgAEEEaiEAIARBAWoiBCACRw0ACwsgA0EQaiQAC0sBAn8jAEEQayIDJAAgAgRAA0AgACADQQxqQQQQESABIAMoAgw2AgAgAUEEaiEBIABBBGohACAEQQFqIgQgAkcNAAsLIANBEGokAAtLAQJ/IwBBEGsiAyQAIAIEQANAIAAgA0EMakECEBEgASADKAIMNgIAIAFBBGohASAAQQJqIQAgBEEBaiIEIAJHDQALCyADQRBqJAALSgECfyMAQRBrIgMkACACBEADQCAAIANBCGoQRCABIAMrAwi2OAIAIAFBBGohASAAQQhqIQAgBEEBaiIEIAJHDQALCyADQRBqJAALaAECfyMAQRBrIgMkACACBEADQCADIAAtAAA6AA8gAyAALQABOgAOIAMgAC0AAjoADSADIAAtAAM6AAwgASADKgIMOAIAIAFBBGohASAAQQRqIQAgBEEBaiIEIAJHDQALCyADQRBqJAALTAECfyMAQRBrIgMkACACBEADQCAAIANBDGpBBBARIAEgAygCDLM4AgAgAUEEaiEBIABBBGohACAEQQFqIgQgAkcNAAsLIANBEGokAAtMAQJ/IwBBEGsiAyQAIAIEQANAIAAgA0EMakECEBEgASADKAIMszgCACABQQRqIQEgAEECaiEAIARBAWoiBCACRw0ACwsgA0EQaiQAC6oIAg1/AXsjAEEQayIIJAACfyAAKAIIQRBGBEAgACgCnAEgACgCzAFBjCxsagwBCyAAKAIMCyEJAkAgAkUEQCADQQFB8B9BABAPDAELIAAoAkghBkEBIQQgASAIQQhqQQEQESAIKAIIIgVBAk8EQCADQQJBxsgAQQAQDwwBCyACIAVBAWpHBEBBACEEIANBAkHwH0EAEA8MAQsCQCAGKAIQIgNFDQAgCSgC0CshBCADQQhPBEAgA0F4cSEGQQAhAgNAIARBADYCvEMgBEEANgKEOyAEQQA2AswyIARBADYClCogBEEANgLcISAEQQA2AqQZIARBADYC7BAgBEEANgK0CCAEQcDDAGohBCACQQhqIgIgBkcNAAsLIANBB3EiA0UNAEEAIQIDQCAEQQA2ArQIIARBuAhqIQQgAkEBaiICIANHDQALCyAJKALoKyICBH8gAhAQIAlBADYC6CsgCCgCCAUgBQtFBEBBASEEDAELA0AgAUEBaiIBIAhBDGpBARARAkAgCSgCgCxFDQAgCSgC/CsiAygCACAIKAIMRw0AIAMoAgQiBSAAKAJIIgYoAhBHDQAgAygCCCICBEBBACEEIAIoAhAgBSAFbCIFIAIoAgBBAnRB0L0BaigCAGxHDQMgCSAFQQJ0EBQiBzYC6CsgB0UNAyACKAIMIAcgBSACKAIAQQJ0QYDAAWooAgARBQALIAMoAgwiAkUNAEEAIQQgAigCECAGKAIQIgMgAigCAEECdEHQvQFqKAIAbEcNAiADQQJ0EBQiBUUNAiACKAIMIAUgAyACKAIAQQJ0QZDAAWooAgARBQACQCAGKAIQIgdFDQAgCSgC0CshBEEAIQsCQAJAIAdBBEkNACAEQbQIaiIMIAUgB0ECdGpJBEAgBSAEIAdBuAhsakkNAQsgBEHcIWohDSAEQaQZaiEOIARB7BBqIQ8gBSAHQXxxIgZBAnRqIQIgBCAGQbgIbGohBEEAIQMDQCAMIANBuAhsIgpqIAUgA0ECdGr9AAIAIhH9WgIAACAKIA9qIBH9WgIAASAKIA5qIBH9WgIAAiAKIA1qIBH9WgIAAyADQQRqIgMgBkcNAAsgBiAHRg0CDAELIAUhAkEAIQYLIAcgBiIDa0EHcSIKBEADQCAEIAIoAgA2ArQIIANBAWohAyAEQbgIaiEEIAJBBGohAiALQQFqIgsgCkcNAAsLIAYgB2tBeEsNAANAIAQgAigCADYCtAggBCACKAIENgLsECAEIAIoAgg2AqQZIAQgAigCDDYC3CEgBCACKAIQNgKUKiAEIAIoAhQ2AswyIAQgAigCGDYChDsgBCACKAIcNgK8QyAEQcDDAGohBCACQSBqIQIgA0EIaiIDIAdHDQALCyAFEBALQQEhBCAQQQFqIhAgCCgCCEkNAAsLIAhBEGokACAECwQAQn8LvwkBC38jAEEQayIFJAACfyAAKAIIQRBGBEAgACgCnAEgACgCzAFBjCxsagwBCyAAKAIMCyEHAn8gAkEBTQRAIANBAUHYI0EAEA9BAAwBCyABIAVBDGpBAhARIAUoAgwEQCADQQJB8CxBABAPQQEMAQsgAkEGTQRAIANBAUHYI0EAEA9BAAwBCyABQQJqIAVBCGpBARARIAcoAvwrIgkhAAJAAkACQCAHKAKALCIGRQ0AIAUoAgghCANAIAAoAgAgCEYNASAAQRRqIQAgBEEBaiIEIAZHDQALDAELIAQgBkcNAQsgBygChCwgBkYEfyAHIAZBCmoiADYChCwgCSAAQRRsEBciAEUEQCAHKAL8KxAQIAdBADYChCwgB0IANwL8KyADQQFB8iNBABAPQQAMAwsgByAANgL8KyAAIAcoAoAsIgRBFGxqQQAgBygChCwgBGtBFGwQFRogBygC/CshCSAHKAKALAUgBgtBFGwgCWohAEEBIQsLIAAgBSgCCDYCACABQQNqIAVBDGpBAhARIAUoAgwEQCADQQJB8CxBABAPQQEMAQsgAUEFaiAFQQRqQQIQESAFKAIEIgRBAk8EQCADQQJBqBdBABAPQQEMAQsgAkEHayEGIAQEQCABQQdqIQJBACEJA0AgBkECTQRAIANBAUHYI0EAEA9BAAwDCyACIAVBDGpBARARIAUoAgxBAUcEQCADQQJBsipBABAPQQEMAwsgAkEBaiAFQQIQESAAIAUoAgAiBEH//wFxIgE2AgQgBkEDayIIIARBD3ZBAWoiBiABbEECaiIKSQRAIANBAUHYI0EAEA9BAAwDCyACQQNqIQJBACEEIAEEQANAIAIgBUEMaiAGEBEgBCAFKAIMRwRAIANBAkHaL0EAEA9BAQwFCyACIAZqIQIgBEEBaiIEIAAoAgRJDQALCyACIAVBAhARIAUgBSgCACIEQf//AXEiATYCACAAKAIEIAFHBEAgA0ECQdgYQQAQD0EBDAMLIAggCmsiCiAEQQ92QQFqIgYgAWxBA2oiDEkEQCADQQFB2CNBABAPQQAMAwsgAkECaiECQQAhBCABBEADQCACIAVBDGogBhARIAQgBSgCDEcEQCADQQJB2i9BABAPQQEMBQsgAiAGaiECIARBAWoiBCAAKAIESQ0ACwsgAiAFQQxqQQMQESAFKAIMIQYgAEIANwIIIAAgBkGAgARxRSAALQAQQf4BcXI6ABAgBSAGQf8BcSIINgIIAkAgCEUNACAHKAL0KyINBEAgBygC8CshBEEAIQEDQCAIIAQoAghGBEAgACAENgIIDAMLIARBFGohBCABQQFqIgEgDUcNAAsLIANBAUHYI0EAEA9BAAwDCyAFIAZBCHZB/wFxIgY2AggCQCAGRQ0AIAcoAvQrIggEQCAHKALwKyEEQQAhAQNAIAYgBCgCCEYEQCAAIAQ2AgwMAwsgBEEUaiEEIAFBAWoiASAIRw0ACwsgA0EBQdgjQQAQD0EADAMLIAogDGshBiACQQNqIQIgCUEBaiIJIAUoAgRJDQALCyAGBEAgA0EBQdgjQQAQD0EADAELQQEgC0UNABogByAHKAKALEEBajYCgCxBAQshDiAFQRBqJAAgDgv1AQEFfyMAQRBrIgQkAAJAIAIgACgCSCgCECIGQQJqRwRAIANBAUHwIkEAEA8MAQsgASAEQQxqQQIQESAGIAQoAgxHBEAgA0EBQfAiQQAQDwwBCyAGRQRAQQEhBQwBCyABQQJqIQIgACgCSCgCGCEAQQAhAQNAIAIgBEEIakEBEBEgACAEKAIIIgVB/wBxIgdBAWoiCDYCGCAAIAVBB3ZBAXE2AiAgB0EfTwRAIAQgCDYCBCAEIAE2AgAgA0EBQbfzACAEEA9BACEFDAILIABBNGohAEEBIQUgAkEBaiECIAFBAWoiASAGRw0ACwsgBEEQaiQAIAULmAUBCn8jAEEQayIHJAACfyAAKAIIQRBGBEAgACgCnAEgACgCzAFBjCxsagwBCyAAKAIMCyEFAn8gAkEBTQRAIANBAUHxHkEAEA9BAAwBCyABIAdBDGpBAhARAkAgBygCDARAIANBAkGGG0EAEA8MAQsgAkEGTQRAIANBAUHxHkEAEA9BAAwCCyABQQJqIAdBDGpBAhARIAUoAvArIQQgBy0ADCEKAkACQAJAIAUoAvQrIgZFBEAgBCEADAELIAQhAANAIAAoAgggCkYNASAAQRRqIQAgCEEBaiIIIAZHDQALDAELIAYgCEcNAQsgBSgC+CsgBkYEQCAFIAZBCmoiADYC+CsgBCAAQRRsEBchACAFKALwKyEEIABFBEAgBBAQIAVBADYC+CsgBUIANwLwKyADQQFBix9BABAPQQAMBAsCQCAAIARGDQAgBSgCgCwiC0UNACAFKAL8KyEMQQAhCANAIAwgCEEUbGoiBigCCCIJBEAgBiAAIAkgBGtqNgIICyAGKAIMIgkEQCAGIAAgCSAEa2o2AgwLIAhBAWoiCCALRw0ACwsgBSAANgLwKyAAIAUoAvQrIgRBFGxqQQAgBSgC+CsgBGtBFGwQFRogBSgC9CshBiAFKALwKyEECyAFIAZBAWo2AvQrIAQgBkEUbGohAAsgACgCDCIEBEAgBBAQIABCADcCDAsgACAKNgIIIAAgBygCDCIEQQp2QQNxNgIAIAAgBEEIdkEDcTYCBCABQQRqIAdBDGpBAhARIAcoAgwEQCADQQJBvRZBABAPDAELIAAgAkEGayICEBQiBDYCDCAERQRAIANBAUHxHkEAEA9BAAwCCyAEIAFBBmogAhASGiAAIAI2AhALQQELIQ0gB0EQaiQAIA0LJwBBASEBIAIgACgCSCgCEEECdEcEfyADQQFB1yFBABAPQQAFQQELC6sDAQV/IwBBEGsiBiQAAn8gAkEBTQRAIANBAUH9HUEAEA9BAAwBCyAALQC8AUEBcQRAIANBAUGJ3gBBABAPQQAMAQsgACgCnAEgACgCzAFBjCxsaiIAIAAtAIgsQQJyOgCILCABIAZBDGpBARARAkAgACgCrCgiBEUEQCAAIAYoAgxBAWoiBUEIEBMiBDYCrCggBEUEQCADQQFBlx5BABAPQQAMAwsgACAFNgKoKAwBCyAGKAIMIgUgACgCqChJDQAgBCAFQQFqIgRBA3QQFyIFRQRAIANBAUGXHkEAEA9BAAwCCyAAIAU2AqwoIAUgACgCqCgiB0EDdGpBACAEIAdrQQN0EBUaIAAgBDYCqCggACgCrCghBAsgBCAGKAIMIgVBA3RqKAIABEAgBiAFNgIAIANBAUG9NSAGEA9BAAwBCyACQQFrIgIQFCEEIAAoAqwoIgAgBigCDCIFQQN0aiAENgIAIARFBEAgA0EBQZceQQAQD0EADAELIAAgBUEDdGogAjYCBCAAIAYoAgxBA3RqKAIAIAFBAWogAhASGkEBCyEIIAZBEGokACAIC/UCAQV/IwBBEGsiBiQAAn8gAkEBTQRAIANBAUGkIEEAEA9BAAwBCyAAIAAtALwBQQFyOgC8ASABIAZBDGpBARARAkAgACgCdCIERQRAIAAgBigCDEEBaiIFQQgQEyIENgJ0IARFBEAgA0EBQb4gQQAQD0EADAMLIAAgBTYCcAwBCyAGKAIMIgUgACgCcEkNACAEIAVBAWoiBEEDdBAXIgVFBEAgA0EBQb4gQQAQD0EADAILIAAgBTYCdCAFIAAoAnAiB0EDdGpBACAEIAdrQQN0EBUaIAAgBDYCcCAAKAJ0IQQLIAQgBigCDCIFQQN0aigCAARAIAYgBTYCACADQQFB0zUgBhAPQQAMAQsgAkEBayICEBQhBCAAKAJ0IgAgBigCDCIFQQN0aiAENgIAIARFBEAgA0EBQb4gQQAQD0EADAELIAAgBUEDdGogAjYCBCAAIAYoAgxBA3RqKAIAIAFBAWogAhASGkEBCyEIIAZBEGokACAIC6ABAQR/IwBBEGsiBCQAAn8gAkUEQCADQQFB1x5BABAPQQAMAQsgASAEQQxqQQEQEUEBIAJBAWsiBUUNABpBACEAQQAhAgNAIAFBAWoiASAEQQhqQQEQESAEKAIIIgZBGHRBH3UgBkH/AHEgAnJBB3RxIQIgAEEBaiIAIAVHDQALQQEgAkUNABogA0EBQdceQQAQD0EACyEHIARBEGokACAHCxsAQQEhACACBH9BAQUgA0EBQf4gQQAQD0EACwuAAQEBfyMAQRBrIgAkAEEBIQQCQCACQQFNBEBBACEEIANBAUHkIEEAEA8MAQsgASAAQQxqQQEQESABQQFqIABBCGpBARARIAJBAmsgACgCCCIBQQV2QQJxIAFBBHZBA3FqQQJqcEUNAEEAIQQgA0EBQeQgQQAQDwsgAEEQaiQAIAQLBABBAAsLorwBIQBBgAgLkXVjYW5ub3QgYWxsb2NhdGUgb3BqX3RjZF9zZWdfZGF0YV9jaHVua190KiBhcnJheQAtKyAgIDBYMHgALTBYKzBYIDBYLTB4KzB4IDB4AFVua25vd24gZm9ybWF0AEZhaWxlZCB0byBzZXR1cCB0aGUgZGVjb2RlcgBGYWlsZWQgdG8gcmVhZCB0aGUgaGVhZGVyAG5hbgAqbF90aWxlX2xlbiA+IFVJTlRfTUFYIC0gT1BKX0NPTU1PTl9DQkxLX0RBVEFfRVhUUkEgLSBwX2oyay0+bV9zcGVjaWZpY19wYXJhbS5tX2RlY29kZXIubV9zb3RfbGVuZ3RoAGluZgBGYWlsZWQgdG8gZGVjb2RlIHRoZSBpbWFnZQBJbnZhbGlkIGFjY2VzcyB0byBwaS0+aW5jbHVkZQAvdG1wL29wZW5qcGVnL3NyYy9iaW4vY29tbW9uL2NvbG9yLmMAQUxMX0NQVVMAT1BKX05VTV9USFJFQURTAE5BTgBJTkYAcF9qMmstPm1fc3BlY2lmaWNfcGFyYW0ubV9kZWNvZGVyLm1fc290X2xlbmd0aCA+IFVJTlRfTUFYIC0gT1BKX0NPTU1PTl9DQkxLX0RBVEFfRVhUUkEACQkJIHByZWNjaW50c2l6ZSAodyxoKT0ACQkJIHN0ZXBzaXplcyAobSxlKT0ALgAobnVsbCkAKCVkLCVkKSAAJXN9CgAJCSB9CgBbREVWXSBEdW1wIGFuIGltYWdlX2NvbXBfaGVhZGVyIHN0cnVjdCB7CgBbREVWXSBEdW1wIGFuIGltYWdlX2hlYWRlciBzdHJ1Y3QgewoASW1hZ2UgaW5mbyB7CgAJIGRlZmF1bHQgdGlsZSB7CgAlcwkgY29tcG9uZW50ICVkIHsKAAkJIGNvbXAgJWQgewoACSBUaWxlIGluZGV4OiB7CgAJIE1hcmtlciBsaXN0OiB7CgBDb2Rlc3RyZWFtIGluZGV4IGZyb20gbWFpbiBoZWFkZXI6IHsKAENvZGVzdHJlYW0gaW5mbyBmcm9tIG1haW4gaGVhZGVyOiB7CgBTdHJlYW0gZXJyb3Igd2hpbGUgcmVhZGluZyBKUDIgSGVhZGVyIGJveAoARm91bmQgYSBtaXNwbGFjZWQgJyVjJWMlYyVjJyBib3ggb3V0c2lkZSBqcDJoIGJveAoATWFsZm9ybWVkIEpQMiBmaWxlIGZvcm1hdDogZmlyc3QgYm94IG11c3QgYmUgSlBFRyAyMDAwIHNpZ25hdHVyZSBib3gKAE1hbGZvcm1lZCBKUDIgZmlsZSBmb3JtYXQ6IHNlY29uZCBib3ggbXVzdCBiZSBmaWxlIHR5cGUgYm94CgBOb3QgZW5vdWdoIG1lbW9yeSB0byBoYW5kbGUganBlZzIwMDAgYm94CgBOb3QgZW5vdWdoIG1lbW9yeSB3aXRoIEZUWVAgQm94CgBBIG1hcmtlciBJRCB3YXMgZXhwZWN0ZWQgKDB4ZmYtLSkgaW5zdGVhZCBvZiAlLjh4CgAJCSBtY3Q9JXgKAAkJCSBjYmxrc3R5PSUjeAoACQkJIGNzdHk9JSN4CgAJCSBwcmc9JSN4CgBJbnRlZ2VyIG92ZXJmbG93CgAJIHRkeD0ldSwgdGR5PSV1CgAJIHR3PSV1LCB0aD0ldQoACSB0eDA9JXUsIHR5MD0ldQoASW52YWxpZCBjb21wb25lbnQgaW5kZXg6ICV1CgBTdHJlYW0gdG9vIHNob3J0CgBNYXJrZXIgaGFuZGxlciBmdW5jdGlvbiBmYWlsZWQgdG8gcmVhZCB0aGUgbWFya2VyIHNlZ21lbnQKAE5vdCBlbm91Z2ggbWVtb3J5IGZvciBjdXJyZW50IHByZWNpbmN0IGNvZGVibG9jayBlbGVtZW50CgBFcnJvciByZWFkaW5nIFNQQ29kIFNQQ29jIGVsZW1lbnQKAEVycm9yIHJlYWRpbmcgU1FjZCBvciBTUWNjIGVsZW1lbnQKAEEgQlBDQyBoZWFkZXIgYm94IGlzIGF2YWlsYWJsZSBhbHRob3VnaCBCUEMgZ2l2ZW4gYnkgdGhlIElIRFIgYm94ICglZCkgaW5kaWNhdGUgY29tcG9uZW50cyBiaXQgZGVwdGggaXMgY29uc3RhbnQKAEVycm9yIHdpdGggU0laIG1hcmtlcjogaWxsZWdhbCB0aWxlIG9mZnNldAoASW52YWxpZCBwcmVjaW5jdAoATm90IGVub3VnaCBtZW1vcnkgdG8gaGFuZGxlIGJhbmQgcHJlY2ludHMKAEZhaWxlZCB0byBkZWNvZGUgYWxsIHVzZWQgY29tcG9uZW50cwoAU2l6ZSBvZiBjb2RlIGJsb2NrIGRhdGEgZXhjZWVkcyBzeXN0ZW0gbGltaXRzCgBTaXplIG9mIHRpbGUgZGF0YSBleGNlZWRzIHN5c3RlbSBsaW1pdHMKAENhbm5vdCB0YWtlIGluIGNoYXJnZSBtdWx0aXBsZSBNQ1QgbWFya2VycwoAQ29ycnVwdGVkIFBQTSBtYXJrZXJzCgBOb3QgZW5vdWdoIG1lbW9yeSBmb3IgdGlsZSByZXNvbHV0aW9ucwoAQ2Fubm90IHRha2UgaW4gY2hhcmdlIG11bHRpcGxlIGNvbGxlY3Rpb25zCgBJbnZhbGlkIFBDTFIgYm94LiBSZXBvcnRzIDAgcGFsZXR0ZSBjb2x1bW5zCgBXZSBkbyBub3Qgc3VwcG9ydCBST0kgaW4gZGVjb2RpbmcgSFQgY29kZWJsb2NrcwoAQ2Fubm90IGhhbmRsZSBib3ggb2YgdW5kZWZpbmVkIHNpemVzCgBDYW5ub3QgdGFrZSBpbiBjaGFyZ2UgY29sbGVjdGlvbnMgd2l0aG91dCBzYW1lIG51bWJlciBvZiBpbmRpeGVzCgBJbnZhbGlkIHRpbGVjLT53aW5feHh4IHZhbHVlcwoAQ2Fubm90IGhhbmRsZSBib3ggb2YgbGVzcyB0aGFuIDggYnl0ZXMKAENhbm5vdCBoYW5kbGUgWEwgYm94IG9mIGxlc3MgdGhhbiAxNiBieXRlcwoAQ29tcG9uZW50IGluZGV4ICV1IHVzZWQgc2V2ZXJhbCB0aW1lcwoASW52YWxpZCBQQ0xSIGJveC4gUmVwb3J0cyAlZCBlbnRyaWVzCgBOb3QgZW5vdWdoIG1lbW9yeSB0byBjcmVhdGUgVGFnLXRyZWUgbm9kZXMKAENhbm5vdCB0YWtlIGluIGNoYXJnZSBtY3QgZGF0YSB3aXRoaW4gbXVsdGlwbGUgTUNUIHJlY29yZHMKAENhbm5vdCBkZWNvZGUgdGlsZSwgbWVtb3J5IGVycm9yCgBvcGpfajJrX2FwcGx5X25iX3RpbGVfcGFydHNfY29ycmVjdGlvbiBlcnJvcgoAUHJvYmxlbSB3aXRoIHNraXBwaW5nIEpQRUcyMDAwIGJveCwgc3RyZWFtIGVycm9yCgBQcm9ibGVtIHdpdGggcmVhZGluZyBKUEVHMjAwMCBib3gsIHN0cmVhbSBlcnJvcgoAVW5rbm93biBtYXJrZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIGFkZCB0bCBtYXJrZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIGFkZCBtaCBtYXJrZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIHRha2UgaW4gY2hhcmdlIFNJWiBtYXJrZXIKAEVycm9yIHJlYWRpbmcgUFBUIG1hcmtlcgoATm90IGVub3VnaCBtZW1vcnkgdG8gcmVhZCBQUFQgbWFya2VyCgBFcnJvciByZWFkaW5nIFNPVCBtYXJrZXIKAEVycm9yIHJlYWRpbmcgUExUIG1hcmtlcgoARXJyb3IgcmVhZGluZyBNQ1QgbWFya2VyCgBOb3QgZW5vdWdoIG1lbW9yeSB0byByZWFkIE1DVCBtYXJrZXIKAE5vdCBlbm91Z2ggc3BhY2UgZm9yIGV4cGVjdGVkIFNPUCBtYXJrZXIKAEV4cGVjdGVkIFNPUCBtYXJrZXIKAEVycm9yIHJlYWRpbmcgTUNPIG1hcmtlcgoARXJyb3IgcmVhZGluZyBSR04gbWFya2VyCgBFcnJvciByZWFkaW5nIFBQTSBtYXJrZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIHJlYWQgUFBNIG1hcmtlcgoARXJyb3IgcmVhZGluZyBUTE0gbWFya2VyCgBFcnJvciByZWFkaW5nIFBMTSBtYXJrZXIKAE5vdCBlbm91Z2ggc3BhY2UgZm9yIGV4cGVjdGVkIEVQSCBtYXJrZXIKAEV4cGVjdGVkIEVQSCBtYXJrZXIKAEVycm9yIHJlYWRpbmcgQ1JHIG1hcmtlcgoAVW5rbm93biBwcm9ncmVzc2lvbiBvcmRlciBpbiBDT0QgbWFya2VyCgBVbmtub3duIFNjb2QgdmFsdWUgaW4gQ09EIG1hcmtlcgoARXJyb3IgcmVhZGluZyBDT0QgbWFya2VyCgBFcnJvciByZWFkaW5nIFFDRCBtYXJrZXIKAENycm9yIHJlYWRpbmcgQ0JEIG1hcmtlcgoARXJyb3IgcmVhZGluZyBQT0MgbWFya2VyCgBFcnJvciByZWFkaW5nIENPQyBtYXJrZXIKAEVycm9yIHJlYWRpbmcgUUNDIG1hcmtlcgoARXJyb3IgcmVhZGluZyBNQ0MgbWFya2VyCgBOb3QgZW5vdWdoIG1lbW9yeSB0byByZWFkIE1DQyBtYXJrZXIKAHJlcXVpcmVkIFNJWiBtYXJrZXIgbm90IGZvdW5kIGluIG1haW4gaGVhZGVyCgByZXF1aXJlZCBDT0QgbWFya2VyIG5vdCBmb3VuZCBpbiBtYWluIGhlYWRlcgoAcmVxdWlyZWQgUUNEIG1hcmtlciBub3QgZm91bmQgaW4gbWFpbiBoZWFkZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIGhhbmRsZSBqcGVnMjAwMCBmaWxlIGhlYWRlcgoATm90IGVub3VnaCBtZW1vcnkgdG8gcmVhZCBoZWFkZXIKAEVycm9yIHdpdGggSlAgU2lnbmF0dXJlIDogYmFkIG1hZ2ljIG51bWJlcgoASW4gU09UIG1hcmtlciwgVFBTb3QgKCVkKSBpcyBub3QgdmFsaWQgcmVnYXJkcyB0byB0aGUgY3VycmVudCBudW1iZXIgb2YgdGlsZS1wYXJ0ICglZCksIGdpdmluZyB1cAoASW4gU09UIG1hcmtlciwgVFBTb3QgKCVkKSBpcyBub3QgdmFsaWQgcmVnYXJkcyB0byB0aGUgcHJldmlvdXMgbnVtYmVyIG9mIHRpbGUtcGFydCAoJWQpLCBnaXZpbmcgdXAKAEluIFNPVCBtYXJrZXIsIFRQU290ICglZCkgaXMgbm90IHZhbGlkIHJlZ2FyZHMgdG8gdGhlIGN1cnJlbnQgbnVtYmVyIG9mIHRpbGUtcGFydCAoaGVhZGVyKSAoJWQpLCBnaXZpbmcgdXAKAHRpbGVzIHJlcXVpcmUgYXQgbGVhc3Qgb25lIHJlc29sdXRpb24KAE1hcmtlciBpcyBub3QgY29tcGxpYW50IHdpdGggaXRzIHBvc2l0aW9uCgBQcm9ibGVtIHdpdGggc2VlayBmdW5jdGlvbgoARXJyb3IgcmVhZGluZyBTUENvZCBTUENvYyBlbGVtZW50LCBJbnZhbGlkIGNibGt3L2NibGtoIGNvbWJpbmF0aW9uCgBJbnZhbGlkIG11bHRpcGxlIGNvbXBvbmVudCB0cmFuc2Zvcm1hdGlvbgoAQ2Fubm90IHRha2UgaW4gY2hhcmdlIGNvbGxlY3Rpb25zIG90aGVyIHRoYW4gYXJyYXkgZGVjb3JyZWxhdGlvbgoAVG9vIGxhcmdlIHZhbHVlIGZvciBOcHBtCgBOb3QgZW5vdWdoIGJ5dGVzIHRvIHJlYWQgTnBwbQoAYmFkIHBsYWNlZCBqcGVnIGNvZGVzdHJlYW0KAAkgTWFpbiBoZWFkZXIgc3RhcnQgcG9zaXRpb249JWxsaQoJIE1haW4gaGVhZGVyIGVuZCBwb3NpdGlvbj0lbGxpCgBNYXJrZXIgc2l6ZSBpbmNvbnNpc3RlbnQgd2l0aCBzdHJlYW0gbGVuZ3RoCgBUaWxlIHBhcnQgbGVuZ3RoIHNpemUgaW5jb25zaXN0ZW50IHdpdGggc3RyZWFtIGxlbmd0aAoAQ2Fubm90IHRha2UgaW4gY2hhcmdlIG11bHRpcGxlIGRhdGEgc3Bhbm5pbmcKAFdyb25nIGZsYWcKAEVycm9yIHdpdGggRlRZUCBzaWduYXR1cmUgQm94IHNpemUKAEVycm9yIHdpdGggSlAgc2lnbmF0dXJlIEJveCBzaXplCgBJbnZhbGlkIHByZWNpbmN0IHNpemUKAEluY29uc2lzdGVudCBtYXJrZXIgc2l6ZQoASW52YWxpZCBtYXJrZXIgc2l6ZQoARXJyb3Igd2l0aCBTSVogbWFya2VyIHNpemUKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIGFkZCBhIG5ldyB2YWxpZGF0aW9uIHByb2NlZHVyZQoATm90IGVub3VnaCBtZW1vcnkgdG8gZGVjb2RlIHRpbGUKAEZhaWxlZCB0byBkZWNvZGUgdGhlIGNvZGVzdHJlYW0gaW4gdGhlIEpQMiBmaWxlCgBDYW5ub3QgdGFrZSBpbiBjaGFyZ2UgY29sbGVjdGlvbnMgd2l0aCBpbmRpeCBzaHVmZmxlCgBDYW5ub3QgYWxsb2NhdGUgVGllciAxIGhhbmRsZQoATm8gZGVjb2RlZCBhcmVhIHBhcmFtZXRlcnMsIHNldCB0aGUgZGVjb2RlZCBhcmVhIHRvIHRoZSB3aG9sZSBpbWFnZQoATm90IGVub3VnaCBtZW1vcnkgdG8gY3JlYXRlIFRhZy10cmVlCgBOb3QgZW5vdWdoIG1lbW9yeSB0byByZWluaXRpYWxpemUgdGhlIHRhZyB0cmVlCgBFcnJvciByZWFkaW5nIFNQQ29kIFNQQ29jIGVsZW1lbnQsIEludmFsaWQgdHJhbnNmb3JtYXRpb24gZm91bmQKAEVycm9yIHJlYWRpbmcgU1BDb2QgU1BDb2MgZWxlbWVudC4gVW5zdXBwb3J0ZWQgTWl4ZWQgSFQgY29kZS1ibG9jayBzdHlsZSBmb3VuZAoAVGlsZSBZIGNvb3JkaW5hdGVzIGFyZSBub3Qgc3VwcG9ydGVkCgBUaWxlIFggY29vcmRpbmF0ZXMgYXJlIG5vdCBzdXBwb3J0ZWQKAEltYWdlIGNvb3JkaW5hdGVzIGFib3ZlIElOVF9NQVggYXJlIG5vdCBzdXBwb3J0ZWQKAEpQRUcyMDAwIEhlYWRlciBib3ggbm90IHJlYWQgeWV0LCAnJWMlYyVjJWMnIGJveCB3aWxsIGJlIGlnbm9yZWQKAG9wal9qMmtfbWVyZ2VfcHB0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIHJlYWQgU09UIG1hcmtlci4gVGlsZSBpbmRleCBhbGxvY2F0aW9uIGZhaWxlZAoASWdub3JpbmcgaWhkciBib3guIEZpcnN0IGloZHIgYm94IGFscmVhZHkgcmVhZAoAWnBwdCAldSBhbHJlYWR5IHJlYWQKAFpwcG0gJXUgYWxyZWFkeSByZWFkCgBQVEVSTSBjaGVjayBmYWlsdXJlOiAlZCBzeW50aGV0aXplZCAweEZGIG1hcmtlcnMgcmVhZAoACQkJIGNibGt3PTJeJWQKAAkJCSBjYmxraD0yXiVkCgAJCQkgcW50c3R5PSVkCgAlcyBkeD0lZCwgZHk9JWQKAAkJCSByb2lzaGlmdD0lZAoACQkJIG51bWdiaXRzPSVkCgAJCSBudW1sYXllcnM9JWQKACVzIG51bWNvbXBzPSVkCgBvcGpfanAyX2FwcGx5X2NkZWY6IGFjbj0lZCwgbnVtY29tcHM9JWQKAG9wal9qcDJfYXBwbHlfY2RlZjogY249JWQsIG51bWNvbXBzPSVkCgAJCQkgbnVtcmVzb2x1dGlvbnM9JWQKAAkJIHR5cGU9JSN4LCBwb3M9JWxsaSwgbGVuPSVkCgAlcyBzZ25kPSVkCgAJCQkgcW1mYmlkPSVkCgAlcyBwcmVjPSVkCgAJCSBuYiBvZiB0aWxlLXBhcnQgaW4gdGlsZSBbJWRdPSVkCgAlcyB4MT0lZCwgeTE9JWQKACVzIHgwPSVkLCB5MD0lZAoARmFpbGVkIHRvIGRlY29kZSB0aWxlICVkLyVkCgBTZXR0aW5nIGRlY29kaW5nIGFyZWEgdG8gJWQsJWQsJWQsJWQKAEZhaWxlZCB0byBkZWNvZGUgY29tcG9uZW50ICVkCgBJbnZhbGlkIHZhbHVlIGZvciBudW1yZXNvbHV0aW9ucyA6ICVkLCBtYXggdmFsdWUgaXMgc2V0IGluIG9wZW5qcGVnLmggYXQgJWQKAEludmFsaWQgY29tcG9uZW50IG51bWJlcjogJWQsIHJlZ2FyZGluZyB0aGUgbnVtYmVyIG9mIGNvbXBvbmVudHMgJWQKAFRvbyBtYW55IFBPQ3MgJWQKAEludmFsaWQgdGlsZSBudW1iZXIgJWQKAEludmFsaWQgdGlsZSBwYXJ0IGluZGV4IGZvciB0aWxlIG51bWJlciAlZC4gR290ICVkLCBleHBlY3RlZCAlZAoARXJyb3Igd2l0aCBTSVogbWFya2VyOiBudW1iZXIgb2YgY29tcG9uZW50IGlzIGlsbGVnYWwgLT4gJWQKAE5vdCBlbm91Z2ggbWVtb3J5IGZvciBjaWVsYWIKAENhbm5vdCBhbGxvY2F0ZSBjYmxrLT5kZWNvZGVkX2RhdGEKAEZhaWxlZCB0byBtZXJnZSBQUFQgZGF0YQoARmFpbGVkIHRvIG1lcmdlIFBQTSBkYXRhCgBJbnZhbGlkIG51bWJlciBvZiBsYXllcnMgaW4gQ09EIG1hcmtlciA6ICVkIG5vdCBpbiByYW5nZSBbMS02NTUzNV0KACVzOiVkOmNvbG9yX2NteWtfdG9fcmdiCglDQU4gTk9UIENPTlZFUlQKACVzOiVkOmNvbG9yX2VzeWNjX3RvX3JnYgoJQ0FOIE5PVCBDT05WRVJUCgAlczolZDpjb2xvcl9zeWNjX3RvX3JnYgoJQ0FOIE5PVCBDT05WRVJUCgBTdHJlYW0gdG9vIHNob3J0LCBleHBlY3RlZCBTT1QKAFVuYWJsZSB0byBzZXQgdDEgaGFuZGxlIGFzIFRMUwoAU3RyZWFtIGRvZXMgbm90IGVuZCB3aXRoIEVPQwoAQ2Fubm90IGhhbmRsZSBib3ggc2l6ZXMgaGlnaGVyIHRoYW4gMl4zMgoAb3BqX3BpX25leHRfbHJjcCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3BpX25leHRfcmxjcCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3BpX25leHRfY3BybCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3BpX25leHRfcGNybCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3BpX25leHRfcnBjbCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3QxX2RlY29kZV9jYmxrKCk6IHVuc3VwcG9ydGVkIGJwbm9fcGx1c19vbmUgPSAlZCA+PSAzMQoARmFpbGVkIHRvIGRlY29kZSB0aWxlIDEvMQoASW5zdWZmaWNpZW50IGRhdGEgZm9yIENNQVAgYm94LgoATmVlZCB0byByZWFkIGEgUENMUiBib3ggYmVmb3JlIHRoZSBDTUFQIGJveC4KAEluc3VmZmljaWVudCBkYXRhIGZvciBDREVGIGJveC4KAE51bWJlciBvZiBjaGFubmVsIGRlc2NyaXB0aW9uIGlzIGVxdWFsIHRvIHplcm8gaW4gQ0RFRiBib3guCgBTdHJlYW0gZXJyb3Igd2hpbGUgcmVhZGluZyBKUDIgSGVhZGVyIGJveDogbm8gJ2loZHInIGJveC4KAE5vbiBjb25mb3JtYW50IGNvZGVzdHJlYW0gVFBzb3Q9PVROc290LgoAU3RyZWFtIGVycm9yIHdoaWxlIHJlYWRpbmcgSlAyIEhlYWRlciBib3g6IGJveCBsZW5ndGggaXMgaW5jb25zaXN0ZW50LgoAQm94IGxlbmd0aCBpcyBpbmNvbnNpc3RlbnQuCgBSZXNvbHV0aW9uIGZhY3RvciBpcyBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gcmVzb2x1dGlvbiBpbiB0aGUgY29tcG9uZW50LgoAQ29tcG9uZW50IG1hcHBpbmcgc2VlbXMgd3JvbmcuIFRyeWluZyB0byBjb3JyZWN0LgoASW5jb21wbGV0ZSBjaGFubmVsIGRlZmluaXRpb25zLgoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gSW52YWxpZCBjb2RlYmxvY2sgbGVuZ3RoIHZhbHVlcy4KAFdlIGRvIG5vdCBzdXBwb3J0IG1vcmUgdGhhbiAzIGNvZGluZyBwYXNzZXMgaW4gYW4gSFQgY29kZWJsb2NrOyBUaGlzIGNvZGVibG9ja3MgaGFzICVkIHBhc3Nlcy4KAE1hbGZvcm1lZCBIVCBjb2RlYmxvY2suIERlY29kaW5nIHRoaXMgY29kZWJsb2NrIGlzIHN0b3BwZWQuIFRoZXJlIGFyZSAlZCB6ZXJvIGJpdHBsYW5lcyBpbiAlZCBiaXRwbGFuZXMuCgBDYW5ub3QgdGFrZSBpbiBjaGFyZ2UgbXVsdGlwbGUgdHJhbnNmb3JtYXRpb24gc3RhZ2VzLgoAVW5rbm93biBtYXJrZXIgaGFzIGJlZW4gZGV0ZWN0ZWQgYW5kIGdlbmVyYXRlZCBlcnJvci4KAENvZGVjIHByb3ZpZGVkIHRvIHRoZSBvcGpfc2V0dXBfZGVjb2RlciBmdW5jdGlvbiBpcyBub3QgYSBkZWNvbXByZXNzb3IgaGFuZGxlci4KAENvZGVjIHByb3ZpZGVkIHRvIHRoZSBvcGpfcmVhZF9oZWFkZXIgZnVuY3Rpb24gaXMgbm90IGEgZGVjb21wcmVzc29yIGhhbmRsZXIuCgBUaWxlcyBkb24ndCBhbGwgaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb24uIFNraXAgdGhlIE1DVCBzdGVwLgoATnVtYmVyIG9mIGNvbXBvbmVudHMgKCVkKSBpcyBpbmNvbnNpc3RlbnQgd2l0aCBhIE1DVC4gU2tpcCB0aGUgTUNUIHN0ZXAuCgBKUDIgYm94IHdoaWNoIGFyZSBhZnRlciB0aGUgY29kZXN0cmVhbSB3aWxsIG5vdCBiZSByZWFkIGJ5IHRoaXMgZnVuY3Rpb24uCgBNYWxmb3JtZWQgSFQgY29kZWJsb2NrLiBXaGVuIHRoZSBudW1iZXIgb2YgemVybyBwbGFuZXMgYml0cGxhbmVzIGlzIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgYml0cGxhbmVzLCBvbmx5IHRoZSBjbGVhbnVwIHBhc3MgbWFrZXMgc2Vuc2UsIGJ1dCB3ZSBoYXZlICVkIHBhc3NlcyBpbiB0aGlzIGNvZGVibG9jay4gVGhlcmVmb3JlLCBvbmx5IHRoZSBjbGVhbnVwIHBhc3Mgd2lsbCBiZSBkZWNvZGVkLiBUaGlzIG1lc3NhZ2Ugd2lsbCBub3QgYmUgZGlzcGxheWVkIGFnYWluLgoASW1hZ2UgaGFzIGxlc3MgY29tcG9uZW50cyB0aGFuIGNvZGVzdHJlYW0uCgBOZWVkIHRvIGRlY29kZSB0aGUgbWFpbiBoZWFkZXIgYmVmb3JlIGJlZ2luIHRvIGRlY29kZSB0aGUgcmVtYWluaW5nIGNvZGVzdHJlYW0uCgBQc290IHZhbHVlIG9mIHRoZSBjdXJyZW50IHRpbGUtcGFydCBpcyBlcXVhbCB0byB6ZXJvLCB3ZSBhc3N1bWluZyBpdCBpcyB0aGUgbGFzdCB0aWxlLXBhcnQgb2YgdGhlIGNvZGVzdHJlYW0uCgBBIG1hbGZvcm1lZCBjb2RlYmxvY2sgdGhhdCBoYXMgbW9yZSB0aGFuIG9uZSBjb2RpbmcgcGFzcywgYnV0IHplcm8gbGVuZ3RoIGZvciAybmQgYW5kIHBvdGVudGlhbGx5IHRoZSAzcmQgcGFzcyBpbiBhbiBIVCBjb2RlYmxvY2suCgAJCQkgdGlsZS1wYXJ0WyVkXTogc3Rhcl9wb3M9JWxsaSwgZW5kX2hlYWRlcj0lbGxpLCBlbmRfcG9zPSVsbGkuCgBUaWxlICV1IGhhcyBUUHNvdCA9PSAwIGFuZCBUTnNvdCA9PSAwLCBidXQgbm8gb3RoZXIgdGlsZS1wYXJ0cyB3ZXJlIGZvdW5kLiBFT0MgaXMgYWxzbyBtaXNzaW5nLgoAQ29tcG9uZW50ICVkIGRvZXNuJ3QgaGF2ZSBhIG1hcHBpbmcuCgBBIGNvbmZvcm1pbmcgSlAyIHJlYWRlciBzaGFsbCBpZ25vcmUgYWxsIENvbG91ciBTcGVjaWZpY2F0aW9uIGJveGVzIGFmdGVyIHRoZSBmaXJzdCwgc28gd2UgaWdub3JlIHRoaXMgb25lLgoAVGhlIHNpZ25hdHVyZSBib3ggbXVzdCBiZSB0aGUgZmlyc3QgYm94IGluIHRoZSBmaWxlLgoAVGhlICBib3ggbXVzdCBiZSB0aGUgZmlyc3QgYm94IGluIHRoZSBmaWxlLgoAVGhlIGZ0eXAgYm94IG11c3QgYmUgdGhlIHNlY29uZCBib3ggaW4gdGhlIGZpbGUuCgBGYWlsZWQgdG8gZGVjb2RlLgoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gSW5jb3JyZWN0IE1FTCBzZWdtZW50IHNlcXVlbmNlLgoAQ29tcG9uZW50ICVkIGlzIG1hcHBlZCB0d2ljZS4KAE9ubHkgb25lIENNQVAgYm94IGlzIGFsbG93ZWQuCgBXZSBuZWVkIGFuIGltYWdlIHByZXZpb3VzbHkgY3JlYXRlZC4KAElIRFIgYm94X21pc3NpbmcuIFJlcXVpcmVkLgoASlAySCBib3ggbWlzc2luZy4gUmVxdWlyZWQuCgBOb3Qgc3VyZSBob3cgdGhhdCBoYXBwZW5lZC4KAE1haW4gaGVhZGVyIGhhcyBiZWVuIGNvcnJlY3RseSBkZWNvZGVkLgoAVGlsZSAlZC8lZCBoYXMgYmVlbiBkZWNvZGVkLgoASGVhZGVyIG9mIHRpbGUgJWQgLyAlZCBoYXMgYmVlbiByZWFkLgoARW1wdHkgU09UIG1hcmtlciBkZXRlY3RlZDogUHNvdD0lZC4KAERpcmVjdCB1c2UgYXQgIyVkIGhvd2V2ZXIgcGNvbD0lZC4KAEltcGxlbWVudGF0aW9uIGxpbWl0YXRpb246IGZvciBwYWxldHRlIG1hcHBpbmcsIHBjb2xbJWRdIHNob3VsZCBiZSBlcXVhbCB0byAlZCwgYnV0IGlzIGVxdWFsIHRvICVkLgoASW52YWxpZCBjb21wb25lbnQvcGFsZXR0ZSBpbmRleCBmb3IgZGlyZWN0IG1hcHBpbmcgJWQuCgBJbnZhbGlkIHZhbHVlIGZvciBjbWFwWyVkXS5tdHlwID0gJWQuCgBQc290IHZhbHVlIGlzIG5vdCBjb3JyZWN0IHJlZ2FyZHMgdG8gdGhlIEpQRUcyMDAwIG5vcm06ICVkLgoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gVkxDIGNvZGUgcHJvZHVjZXMgc2lnbmlmaWNhbnQgc2FtcGxlcyBvdXRzaWRlIHRoZSBjb2RlYmxvY2sgYXJlYS4KAFVuZXhwZWN0ZWQgT09NLgoAMzIgYml0cyBhcmUgbm90IGVub3VnaCB0byBkZWNvZGUgdGhpcyBjb2RlYmxvY2ssIHNpbmNlIHRoZSBudW1iZXIgb2YgYml0cGxhbmUsICVkLCBpcyBsYXJnZXIgdGhhbiAzMC4KAEJvdHRvbSBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feTE9JWQpIHNob3VsZCBiZSA+IDAuCgBSaWdodCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDE9JWQpIHNob3VsZCBiZSA+IDAuCgBVcCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feTA9JWQpIHNob3VsZCBiZSA+PSAwLgoATGVmdCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDA9JWQpIHNob3VsZCBiZSA+PSAwLgoARXJyb3IgcmVhZGluZyBQUFQgbWFya2VyOiBwYWNrZXQgaGVhZGVyIGhhdmUgYmVlbiBwcmV2aW91c2x5IGZvdW5kIGluIHRoZSBtYWluIGhlYWRlciAoUFBNIG1hcmtlcikuCgBTdGFydCB0byByZWFkIGoyayBtYWluIGhlYWRlciAoJWxsZCkuCgBCb3R0b20gcG9zaXRpb24gb2YgdGhlIGRlY29kZWQgYXJlYSAocmVnaW9uX3kxPSVkKSBpcyBvdXRzaWRlIHRoZSBpbWFnZSBhcmVhIChZc2l6PSVkKS4KAFVwIHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl95MD0lZCkgaXMgb3V0c2lkZSB0aGUgaW1hZ2UgYXJlYSAoWXNpej0lZCkuCgBSaWdodCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDE9JWQpIGlzIG91dHNpZGUgdGhlIGltYWdlIGFyZWEgKFhzaXo9JWQpLgoATGVmdCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDA9JWQpIGlzIG91dHNpZGUgdGhlIGltYWdlIGFyZWEgKFhzaXo9JWQpLgoAQm90dG9tIHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl95MT0lZCkgaXMgb3V0c2lkZSB0aGUgaW1hZ2UgYXJlYSAoWU9zaXo9JWQpLgoAVXAgcG9zaXRpb24gb2YgdGhlIGRlY29kZWQgYXJlYSAocmVnaW9uX3kwPSVkKSBpcyBvdXRzaWRlIHRoZSBpbWFnZSBhcmVhIChZT3Npej0lZCkuCgBSaWdodCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDE9JWQpIGlzIG91dHNpZGUgdGhlIGltYWdlIGFyZWEgKFhPc2l6PSVkKS4KAExlZnQgcG9zaXRpb24gb2YgdGhlIGRlY29kZWQgYXJlYSAocmVnaW9uX3gwPSVkKSBpcyBvdXRzaWRlIHRoZSBpbWFnZSBhcmVhIChYT3Npej0lZCkuCgBTaXplIHggb2YgdGhlIGRlY29kZWQgY29tcG9uZW50IGltYWdlIGlzIGluY29ycmVjdCAoY29tcFslZF0udz0lZCkuCgBTaXplIHkgb2YgdGhlIGRlY29kZWQgY29tcG9uZW50IGltYWdlIGlzIGluY29ycmVjdCAoY29tcFslZF0uaD0lZCkuCgBUaWxlIHJlYWQsIGRlY29kZWQgYW5kIHVwZGF0ZWQgaXMgbm90IHRoZSBkZXNpcmVkIG9uZSAoJWQgdnMgJWQpLgoASW52YWxpZCBjb21wb25lbnQgaW5kZXggJWQgKD49ICVkKS4KAG9wal9yZWFkX2hlYWRlcigpIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIG9wal9zZXRfZGVjb2RlZF9jb21wb25lbnRzKCkuCgBNZW1vcnkgYWxsb2NhdGlvbiBmYWlsdXJlIGluIG9wal9qcDJfYXBwbHlfcGNscigpLgoAaW1hZ2UtPmNvbXBzWyVkXS5kYXRhID09IE5VTEwgaW4gb3BqX2pwMl9hcHBseV9wY2xyKCkuCgBpbnZhbGlkIGJveCBzaXplICVkICgleCkKAEZhaWwgdG8gcmVhZCB0aGUgY3VycmVudCBtYXJrZXIgc2VnbWVudCAoJSN4KQoARXJyb3Igd2l0aCBTSVogbWFya2VyOiBJSERSIHcoJXUpIGgoJXUpIHZzLiBTSVogdygldSkgaCgldSkKAEVycm9yIHJlYWRpbmcgQ09DIG1hcmtlciAoYmFkIG51bWJlciBvZiBjb21wb25lbnRzKQoASW52YWxpZCBudW1iZXIgb2YgdGlsZXMgOiAldSB4ICV1IChtYXhpbXVtIGZpeGVkIGJ5IGpwZWcyMDAwIG5vcm0gaXMgNjU1MzUgdGlsZXMpCgBJbnZhbGlkIG51bWJlciBvZiBjb21wb25lbnRzIChpaGRyKQoATm90IGVub3VnaCBtZW1vcnkgdG8gaGFuZGxlIGltYWdlIGhlYWRlciAoaWhkcikKAFdyb25nIHZhbHVlcyBmb3I6IHcoJWQpIGgoJWQpIG51bWNvbXBzKCVkKSAoaWhkcikKAEludmFsaWQgdmFsdWVzIGZvciBjb21wID0gJWQgOiBkeD0ldSBkeT0ldSAoc2hvdWxkIGJlIGJldHdlZW4gMSBhbmQgMjU1IGFjY29yZGluZyB0byB0aGUgSlBFRzIwMDAgbm9ybSkKAEJhZCBpbWFnZSBoZWFkZXIgYm94IChiYWQgc2l6ZSkKAEJhZCBDT0xSIGhlYWRlciBib3ggKGJhZCBzaXplKQoAQmFkIEJQQ0MgaGVhZGVyIGJveCAoYmFkIHNpemUpCgBFcnJvciB3aXRoIFNJWiBtYXJrZXI6IG5lZ2F0aXZlIG9yIHplcm8gaW1hZ2Ugc2l6ZSAoJWxsZCB4ICVsbGQpCgBza2lwOiBzZWdtZW50IHRvbyBsb25nICglZCkgd2l0aCBtYXggKCVkKSBmb3IgY29kZWJsb2NrICVkIChwPSVkLCBiPSVkLCByPSVkLCBjPSVkKQoAcmVhZDogc2VnbWVudCB0b28gbG9uZyAoJWQpIHdpdGggbWF4ICglZCkgZm9yIGNvZGVibG9jayAlZCAocD0lZCwgYj0lZCwgcj0lZCwgYz0lZCkKAERlc3BpdGUgSlAyIEJQQyE9MjU1LCBwcmVjaXNpb24gYW5kL29yIHNnbmQgdmFsdWVzIGZvciBjb21wWyVkXSBpcyBkaWZmZXJlbnQgdGhhbiBjb21wWzBdOgogICAgICAgIFswXSBwcmVjKCVkKSBzZ25kKCVkKSBbJWRdIHByZWMoJWQpIHNnbmQoJWQpCgBiYWQgY29tcG9uZW50IG51bWJlciBpbiBSR04gKCVkIHdoZW4gdGhlcmUgYXJlIG9ubHkgJWQpCgBFcnJvciB3aXRoIFNJWiBtYXJrZXI6IG51bWJlciBvZiBjb21wb25lbnQgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgcmVtYWluaW5nIG51bWJlciBvZiBwYXJhbWV0ZXJzICggJWQgdnMgJWQpCgBFcnJvciB3aXRoIFNJWiBtYXJrZXI6IGludmFsaWQgdGlsZSBzaXplICh0ZHg6ICVkLCB0ZHk6ICVkKQoAQmFkIENPTFIgaGVhZGVyIGJveCAoYmFkIHNpemU6ICVkKQoAQmFkIENPTFIgaGVhZGVyIGJveCAoQ0lFTGFiLCBiYWQgc2l6ZTogJWQpCgBQVEVSTSBjaGVjayBmYWlsdXJlOiAlZCByZW1haW5pbmcgYnl0ZXMgaW4gY29kZSBibG9jayAoJWQgdXNlZCAvICVkKQoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gT25lIG9mIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQ6IDIgPD0gU2N1cCA8PSBtaW4oTGN1cCwgNDA3OSkKAEludmFsaWQgdmFsdWVzIGZvciBjb21wID0gJWQgOiBwcmVjPSV1IChzaG91bGQgYmUgYmV0d2VlbiAxIGFuZCAzOCBhY2NvcmRpbmcgdG8gdGhlIEpQRUcyMDAwIG5vcm0uIE9wZW5KcGVnIG9ubHkgc3VwcG9ydHMgdXAgdG8gMzEpCgBJbnZhbGlkIGJpdCBudW1iZXIgJWQgaW4gb3BqX3QyX3JlYWRfcGFja2V0X2hlYWRlcigpCgBTdHJlYW0gZXJyb3IhCgBFcnJvciBvbiB3cml0aW5nIHN0cmVhbSEKAFN0cmVhbSByZWFjaGVkIGl0cyBlbmQgIQoARXhwZWN0ZWQgYSBTT0MgbWFya2VyIAoASW52YWxpZCBib3ggc2l6ZSAlZCBmb3IgYm94ICclYyVjJWMlYycuIE5lZWQgJWQgYnl0ZXMsICVkIGJ5dGVzIHJlbWFpbmluZyAKAE1hbGZvcm1lZCBIVCBjb2RlYmxvY2suIERlY29kaW5nIHRoaXMgY29kZWJsb2NrIGlzIHN0b3BwZWQuIFVfcSBpcyBsYXJnZXIgdGhhbiB6ZXJvIGJpdHBsYW5lcyArIDEgCgBNYWxmb3JtZWQgSFQgY29kZWJsb2NrLiBEZWNvZGluZyB0aGlzIGNvZGVibG9jayBpcyBzdG9wcGVkLiBVX3EgaXNsYXJnZXIgdGhhbiBiaXRwbGFuZXMgKyAxIAoAQ09MUiBCT1ggbWV0aCB2YWx1ZSBpcyBub3QgYSByZWd1bGFyIHZhbHVlICglZCksIHNvIHdlIHdpbGwgaWdub3JlIHRoZSBlbnRpcmUgQ29sb3VyIFNwZWNpZmljYXRpb24gYm94LiAKAFdoaWxlIHJlYWRpbmcgQ0NQX1FOVFNUWSBlbGVtZW50IGluc2lkZSBRQ0Qgb3IgUUNDIG1hcmtlciBzZWdtZW50LCBudW1iZXIgb2Ygc3ViYmFuZHMgKCVkKSBpcyBncmVhdGVyIHRvIE9QSl9KMktfTUFYQkFORFMgKCVkKS4gU28gd2UgbGltaXQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBzdG9yZWQgdG8gT1BKX0oyS19NQVhCQU5EUyAoJWQpIGFuZCBza2lwIHRoZSByZXN0LiAKAEpQMiBJSERSIGJveDogY29tcHJlc3Npb24gdHlwZSBpbmRpY2F0ZSB0aGF0IHRoZSBmaWxlIGlzIG5vdCBhIGNvbmZvcm1pbmcgSlAyIGZpbGUgKCVkKSAKAFRpbGUgaW5kZXggcHJvdmlkZWQgYnkgdGhlIHVzZXIgaXMgaW5jb3JyZWN0ICVkIChtYXggPSAlZCkgCgBFcnJvciBkZWNvZGluZyBjb21wb25lbnQgJWQuClRoZSBudW1iZXIgb2YgcmVzb2x1dGlvbnMgdG8gcmVtb3ZlICglZCkgaXMgZ3JlYXRlciBvciBlcXVhbCB0aGFuIHRoZSBudW1iZXIgb2YgcmVzb2x1dGlvbnMgb2YgdGhpcyBjb21wb25lbnQgKCVkKQpNb2RpZnkgdGhlIGNwX3JlZHVjZSBwYXJhbWV0ZXIuCgoASW1hZ2UgZGF0YSBoYXMgYmVlbiB1cGRhdGVkIHdpdGggdGlsZSAlZC4KCgBBoP0AC4AgIwClAEMAZgCDAO6oFADf2CMAvhBDAP/1gwB+IFUAX1EjADUAQwBORIMAzsQUAM/MIwD+4kMA/5mDAJYAxQA/MSMApQBDAF5EgwDOyBQA3xEjAP70QwD//IMAngBVAHcAIwA1AEMA//GDAK6IFAC3ACMA/vhDAO/kgwCOiMUAHxEjAKUAQwBmAIMA7qgUAN9UIwC+EEMA7yKDAH4gVQB/IiMANQBDAE5EgwDOxBQAvxEjAP7iQwD3AIMAlgDFAD8iIwClAEMAXkSDAM7IFADXACMA/vRDAP+6gwCeAFUAbwAjADUAQwD/5oMArogUAK+iIwD++EMA5wCDAI6IxQAvIgIAxQCEAH4gAgDOxCQA9wACAP6iRABWAAIAngAUANcAAgC+EIQAZgACAK6IJADfEQIA7qhEADYAAgCOiBQAHxECAMUAhABuAAIAzogkAP+IAgD+uEQATkQCAJYAFAC3AAIA/uSEAF5EAgCmACQA5wACAN5URAAuIgIAPgAUAHcAAgDFAIQAfiACAM7EJAD/8QIA/qJEAFYAAgCeABQAvxECAL4QhABmAAIArogkAO8iAgDuqEQANgACAI6IFAB/IgIAxQCEAG4AAgDOiCQA7+QCAP64RABORAIAlgAUAK+iAgD+5IQAXkQCAKYAJADf2AIA3lREAC4iAgA+ABQAX1ECAFUAhABmAAIA3ogkAP8yAgD+EUQATkQCAK4AFAC3AAIAfjGEAF5RAgDGACQA1wACAO4gRAAeEQIAngAUAHcAAgBVAIQAXlQCAM5EJADnAAIA/vFEADYAAgCmABQAX1UCAP50hAA+EQIAviAkAH90AgDexEQA//gCAJYAFAAvIgIAVQCEAGYAAgDeiCQA9wACAP4RRABORAIArgAUAI+IAgB+MYQAXlECAMYAJADPyAIA7iBEAB4RAgCeABQAbwACAFUAhABeVAIAzkQkAN/RAgD+8UQANgACAKYAFAB/IgIA/nSEAD4RAgC+ICQAvyICAN7ERADvIgIAlgAUAD8yAwDe1P30//wUAD4RVQCPiAMAvjKFAOcAJQBeUf6qf3IDAM5E/fjvRBQAfmRFAK+iAwCmAF1V35n98TYA/vVvYgMA3tH99P/mFAB+cVUAv7EDAK6IhQDf1SUATkT+8n9mAwDGAP347+IUAF5URQCfEQMAlgBdVc/I/fEeEe7IZwADAN7U/fT/8xQAPhFVAL8RAwC+MoUA39glAF5R/qovIgMAzkT9+PcAFAB+ZEUAn5gDAKYAXVXXAP3xNgD+9W9EAwDe0f30/7kUAH5xVQC3AAMAroiFAN/cJQBORP7ydwADAMYA/fjv5BQAXlRFAH9zAwCWAF1Vv7j98R4R7sg/MgIApQCEAH5AAgDeECQA3xECAP5yRABWAAIArqgUAL+yAgCWAIQAZgACAMYAJADnAAIA7shEAC4iAgCOiBQAdwACAKUAhABuAAIAzogkAPcAAgD+kUQANgACAK6iFACvqgIA/riEAF4AAgC+ACQAz8QCAO5ERAD/9AIAPiIUAB8RAgClAIQAfkACAN4QJAD/mQIA/nJEAFYAAgCuqBQAtwACAJYAhABmAAIAxgAkANcAAgDuyEQALiICAI6IFABPRAIApQCEAG4AAgDOiCQA7+ICAP6RRAA2AAIArqIUAH9EAgD+uIQAXgACAL4AJACfAAIA7kREAP92AgA+IhQAPzEDAMYAhQD/2f3yfmT+8b+ZAwCuoiUA72b99FYA7uJ/cwMAvphFAPcA/fhmAP52n4gDAI6IFQDf1aUALiLemE9EAwC+soUA//z98m4ilgC3AAMArqolAN/R/fQ2AN7Ub2QDAK6oRQDv6v34XkTu6H9xAwA+MhUAz8SlAP/6zog/MQMAxgCFAP93/fJ+ZP7xv7MDAK6iJQDnAP30VgDu4ncAAwC+mEUA7+T9+GYA/nZ/ZgMAjogVANcApQAuIt6YPzMDAL6yhQD/df3ybiKWAJ+RAwCuqiUA35n99DYA3tRfUQMArqhFAO/s/fheRO7of3IDAD4yFQC/saUA//POiB8RAwDeVP3yHhEUAH5k/vjPzAMAvpFFAO8iJQAuIv7zj4gDAMYAhQD3ABQAXhH+/K+oAwCmADUA38j98T4x/mZvZAMAzsj98v/1FABmAP70v7oDAK4iRQDnACUAPjL+6n9zAwC+soUA31UUAFYAfnGfEQMAlgA1AM/E/fE+M+7oT0QDAN5U/fIeERQAfmT++L+ZAwC+kUUA7+IlAC4i/vN/ZgMAxgCFAO/kFABeEf78n5gDAKYANQDXAP3xPjH+Zm8iAwDOyP3y/7kUAGYA/vS3AAMAriJFAN/RJQA+Mv7qdwADAL6yhQDv7BQAVgB+cX9yAwCWADUAv7j98T4z7uhfVPzx3tH9+tcA/PgWAP3/f3T89H5x/fO/s/zy7+ru6E9E/PGuIgUAv7j8+PcA/vx3APz0XhH99X91/PLf2O7iPzP88b6y/frPiPz4//v9/39z/PRuAP3ztwD88u9m/vk/MfzxngAFAL+6/Pj//f72ZwD89CYA/fWPiPzy39ze1C8i/PHe0f36z8T8+BYA/f9/cvz0fnH987+Z/PLv7O7oRwD88a4iBQCnAPz4//f+/FcA/PReEf31lwD88t/V7uI3APzxvrL9+scA/Pj//v3/f2b89G4A/fOvqPzy5wD++T8y/PGeAAUAv7H8+O/k/vZfVPz0JgD99YcA/PLfmd7UHxETAGUAQwDeAIMAjYgjAE5EEwClAEMAroiDADUAIwDXABMAxQBDAJ4AgwBVACMALiITAJUAQwB+AIMA/hAjAHcAEwBlAEMAzoiDAI2IIwAeERMApQBDAF4AgwA1ACMA5wATAMUAQwC+AIMAVQAjAP8REwCVAEMAPgCDAO5AIwCvohMAZQBDAN4AgwCNiCMATkQTAKUAQwCuiIMANQAjAO9EEwDFAEMAngCDAFUAIwAuIhMAlQBDAH4AgwD+ECMAtwATAGUAQwDOiIMAjYgjAB4REwClAEMAXgCDADUAIwDPxBMAxQBDAL4AgwBVACMA9wATAJUAQwA+AIMA7kAjAG8AAQCEAAEAVgABABQAAQDXAAEAJAABAJYAAQBFAAEAdwABAIQAAQDGAAEAFAABAI+IAQAkAAEA9wABADUAAQAvIgEAhAABAP5AAQAUAAEAtwABACQAAQC/AAEARQABAGcAAQCEAAEApgABABQAAQBPRAEAJAABAOcAAQA1AAEAPxEBAIQAAQBWAAEAFAABAM8AAQAkAAEAlgABAEUAAQBvAAEAhAABAMYAAQAUAAEAnwABACQAAQDvAAEANQABAD8yAQCEAAEA/kABABQAAQCvAAEAJAABAP9EAQBFAAEAXwABAIQAAQCmAAEAFAABAH8AAQAkAAEA3wABADUAAQAfEQEAJAABAFYAAQCFAAEAvwABABQAAQD3AAEAxgABAHcAAQAkAAEA//gBAEUAAQB/AAEAFAABAN8AAQCmAAEAPzEBACQAAQAuIgEAhQABALcAAQAUAAEA70QBAK6iAQBnAAEAJAABAP9RAQBFAAEAlwABABQAAQDPAAEANgABAD8iAQAkAAEAVgABAIUAAQC/sgEAFAABAO9AAQDGAAEAbwABACQAAQD/cgEARQABAJ8AAQAUAAEA1wABAKYAAQBPRAEAJAABAC4iAQCFAAEAr6gBABQAAQDnAAEArqIBAF8AAQAkAAEA/0QBAEUAAQCPiAEAFAABAK+qAQA2AAEAHxECAP74JABWAAIAtgCFAP9mAgDOABQAHhECAJYANQCvqAIA9gAkAD4xAgCmAEUAv7MCAL6yFAD/9QIAZgB+UV9UAgD+8iQALiICAK4ihQDvRAIAxgAUAP/0AgB2ADUAf0QCAN5AJAA+MgIAngBFANcAAgC+iBQA//oCAF4R/vFPRAIA/vgkAFYAAgC2AIUA78gCAM4AFAAeEQIAlgA1AI+IAgD2ACQAPjECAKYARQDfRAIAvrIUAP+oAgBmAH5RbwACAP7yJAAuIgIAriKFAOcAAgDGABQA7+ICAHYANQB/cgIA3kAkAD4yAgCeAEUAv7ECAL6IFAD/cwIAXhH+8T8zAQCEAAEA7iABAMUAAQDPxAEARAABAP8yAQAVAAEAj4gBAIQAAQBmAAEAJQABAK8AAQBEAAEA7yIBAKYAAQBfAAEAhAABAE5EAQDFAAEAz8wBAEQAAQD3AAEAFQABAG8AAQCEAAEAVgABACUAAQCfAAEARAABAN8AAQD+MAEALyIBAIQAAQDuIAEAxQABAM/IAQBEAAEA/xEBABUAAQB3AAEAhAABAGYAAQAlAAEAfwABAEQAAQDnAAEApgABADcAAQCEAAEATkQBAMUAAQC3AAEARAABAL8AAQAVAAEAPwABAIQAAQBWAAEAJQABAJcAAQBEAAEA1wABAP4wAQAfEQIA7qhEAI6IAgDWAMUA//MCAP78JQA+AAIAtgBVAN/YAgD++EQAZgACAH4ghQD/mQIA5gD1ADYAAgCmABUAnwACAP7yRAB2AAIAzkTFAP92AgD+8SUATkQCAK4AVQDPyAIA/vREAF5EAgC+EIUA7+QCAN5U9QAeEQIAlgAVAC8iAgDuqEQAjogCANYAxQD/+gIA/vwlAD4AAgC2AFUAvxECAP74RABmAAIAfiCFAO8iAgDmAPUANgACAKYAFQB/IgIA/vJEAHYAAgDORMUA/9UCAP7xJQBORAIArgBVAG8AAgD+9EQAXkQCAL4QhQDfEQIA3lT1AB4RAgCWABUAX1EDAPYAFAAeEUQAjoilAN/UAwCuolUA/3YkAD4itgCvqgMA5gAUAP/1RABmAIUAz8wDAJ4AxQDvRCQANgD++H8xAwDu6BQA//FEAHYApQDPxAMAfiJVAN/RJABORP70X1EDANYAFADv4kQAXkSFAL8iAwCWAMUA38gkAC4i/vJvIgMA9gAUAB4RRACOiKUAv7EDAK6iVQD/MyQAPiK2AK+oAwDmABQA/7lEAGYAhQC/qAMAngDFAO/kJAA2AP74b2QDAO7oFAD//EQAdgClAM/IAwB+IlUA7+okAE5E/vR/dAMA1gAUAP/6RABeRIUAv7IDAJYAxQDfRCQALiL+8j8x8wD++v3xNgAEAL4ydQDfEfMA3lT98u/k1QB+cf78f3PzAP7z/fgeEQQAlgBVAL+x8wDOALUA39j99GYA/rlfVPMA/nb98SYABACmAHUAnwDzAK4A/fL/99UARgD+9X908wDmAP34FgAEAIYAVQCPiPMAxgC1AO/i/fReEe6oPxHzAP76/fE2AAQAvjJ1AN/R8wDeVP3y//vVAH5x/vx/RPMA/vP9+B4RBACWAFUAf3LzAM4AtQDvIv30ZgD+uU9E8wD+dv3xJgAEAKYAdQC/EfMArgD98v//1QBGAP71PzLzAOYA/fgWAAQAhgBVAG8A8wDGALUAv7j99F4R7qgvIgBBrJ0BC6QeAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAwAAAAMAAAAEAAAABQAAALchQiFnIUIhERERETMzMzN3d3d3AAAAAAAAAAABVgAAAAAAABBPAAAgTwAAAVYAAAEAAAAgTwAAEE8AAAE0AAAAAAAAME8AALBPAAABNAAAAQAAAEBPAADATwAAARgAAAAAAABQTwAAEFAAAAEYAAABAAAAYE8AACBQAADBCgAAAAAAAHBPAABwUAAAwQoAAAEAAACATwAAgFAAACEFAAAAAAAAkE8AAJBSAAAhBQAAAQAAAKBPAACgUgAAIQIAAAAAAACwUwAAEFMAACECAAABAAAAwFMAACBTAAABVgAAAAAAANBPAADATwAAAVYAAAEAAADgTwAAsE8AAAFUAAAAAAAA8E8AALBQAAABVAAAAQAAAABQAADAUAAAAUgAAAAAAAAQUAAAsFAAAAFIAAABAAAAIFAAAMBQAAABOAAAAAAAADBQAACwUAAAATgAAAEAAABAUAAAwFAAAAEwAAAAAAAAUFAAABBRAAABMAAAAQAAAGBQAAAgUQAAASQAAAAAAABwUAAAMFEAAAEkAAABAAAAgFAAAEBRAAABHAAAAAAAAJBQAABwUQAAARwAAAEAAACgUAAAgFEAAAEWAAAAAAAAkFIAAJBRAAABFgAAAQAAAKBSAACgUQAAAVYAAAAAAADQUAAAwFAAAAFWAAABAAAA4FAAALBQAAABVAAAAAAAAPBQAACwUAAAAVQAAAEAAAAAUQAAwFAAAAFRAAAAAAAAEFEAANBQAAABUQAAAQAAACBRAADgUAAAAUgAAAAAAAAwUQAA8FAAAAFIAAABAAAAQFEAAABRAAABOAAAAAAAAFBRAAAQUQAAATgAAAEAAABgUQAAIFEAAAE0AAAAAAAAcFEAADBRAAABNAAAAQAAAIBRAABAUQAAATAAAAAAAACQUQAAUFEAAAEwAAABAAAAoFEAAGBRAAABKAAAAAAAALBRAABQUQAAASgAAAEAAADAUQAAYFEAAAEkAAAAAAAA0FEAAHBRAAABJAAAAQAAAOBRAACAUQAAASIAAAAAAADwUQAAkFEAAAEiAAABAAAAAFIAAKBRAAABHAAAAAAAABBSAACwUQAAARwAAAEAAAAgUgAAwFEAAAEYAAAAAAAAMFIAANBRAAABGAAAAQAAAEBSAADgUQAAARYAAAAAAABQUgAA8FEAAAEWAAABAAAAYFIAAABSAAABFAAAAAAAAHBSAAAQUgAAARQAAAEAAACAUgAAIFIAAAESAAAAAAAAkFIAADBSAAABEgAAAQAAAKBSAABAUgAAAREAAAAAAACwUgAAUFIAAAERAAABAAAAwFIAAGBSAADBCgAAAAAAANBSAABwUgAAwQoAAAEAAADgUgAAgFIAAMEJAAAAAAAA8FIAAJBSAADBCQAAAQAAAABTAACgUgAAoQgAAAAAAAAQUwAAsFIAAKEIAAABAAAAIFMAAMBSAAAhBQAAAAAAADBTAADQUgAAIQUAAAEAAABAUwAA4FIAAEEEAAAAAAAAUFMAAPBSAABBBAAAAQAAAGBTAAAAUwAAoQIAAAAAAABwUwAAEFMAAKECAAABAAAAgFMAACBTAAAhAgAAAAAAAJBTAAAwUwAAIQIAAAEAAACgUwAAQFMAAEEBAAAAAAAAsFMAAFBTAABBAQAAAQAAAMBTAABgUwAAEQEAAAAAAADQUwAAcFMAABEBAAABAAAA4FMAAIBTAACFAAAAAAAAAPBTAACQUwAAhQAAAAEAAAAAVAAAoFMAAEkAAAAAAAAAEFQAALBTAABJAAAAAQAAACBUAADAUwAAJQAAAAAAAAAwVAAA0FMAACUAAAABAAAAQFQAAOBTAAAVAAAAAAAAAFBUAADwUwAAFQAAAAEAAABgVAAAAFQAAAkAAAAAAAAAcFQAABBUAAAJAAAAAQAAAIBUAAAgVAAABQAAAAAAAACQVAAAMFQAAAUAAAABAAAAoFQAAEBUAAABAAAAAAAAAJBUAABQVAAAAQAAAAEAAACgVAAAYFQAAAFWAAAAAAAAsFQAALBUAAABVgAAAQAAAMBUAADAVAAAAAEDAwECAwMFBgcHBgYHBwABAwMBAgMDBQYHBwYGBwcFBgcHBgYHBwgICAgICAgIBQYHBwYGBwcICAgICAgICAECAwMCAgMDBgYHBwYGBwcBAgMDAgIDAwYGBwcGBgcHBgYHBwYGBwcICAgICAgICAYGBwcGBgcHCAgICAgICAgDAwQEAwMEBAcHBwcHBwcHAwMEBAMDBAQHBwcHBwcHBwcHBwcHBwcHCAgICAgICAgHBwcHBwcHBwgICAgICAgIAwMEBAMDBAQHBwcHBwcHBwMDBAQDAwQEBwcHBwcHBwcHBwcHBwcHBwgICAgICAgIBwcHBwcHBwcICAgICAgICAECAwMCAgMDBgYHBwYGBwcBAgMDAgIDAwYGBwcGBgcHBgYHBwYGBwcICAgICAgICAYGBwcGBgcHCAgICAgICAgCAgMDAgIDAwYGBwcGBgcHAgIDAwICAwMGBgcHBgYHBwYGBwcGBgcHCAgICAgICAgGBgcHBgYHBwgICAgICAgIAwMEBAMDBAQHBwcHBwcHBwMDBAQDAwQEBwcHBwcHBwcHBwcHBwcHBwgICAgICAgIBwcHBwcHBwcICAgICAgICAMDBAQDAwQEBwcHBwcHBwcDAwQEAwMEBAcHBwcHBwcHBwcHBwcHBwcICAgICAgICAcHBwcHBwcHCAgICAgICAgAAQUGAQIGBgMDBwcDAwcHAAEFBgECBgYDAwcHAwMHBwMDBwcDAwcHBAQHBwQEBwcDAwcHAwMHBwQEBwcEBAcHAQIGBgICBgYDAwcHAwMHBwECBgYCAgYGAwMHBwMDBwcDAwcHAwMHBwQEBwcEBAcHAwMHBwMDBwcEBAcHBAQHBwUGCAgGBggIBwcICAcHCAgFBggIBgYICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgGBggIBgYICAcHCAgHBwgIBgYICAYGCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIAQIGBgICBgYDAwcHAwMHBwECBgYCAgYGAwMHBwMDBwcDAwcHAwMHBwQEBwcEBAcHAwMHBwMDBwcEBAcHBAQHBwICBgYCAgYGAwMHBwMDBwcCAgYGAgIGBgMDBwcDAwcHAwMHBwMDBwcEBAcHBAQHBwMDBwcDAwcHBAQHBwQEBwcGBggIBgYICAcHCAgHBwgIBgYICAYGCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBgYICAYGCAgHBwgIBwcICAYGCAgGBggIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAABAwMBAgMDBQYHBwYGBwcAAQMDAQIDAwUGBwcGBgcHBQYHBwYGBwcICAgICAgICAUGBwcGBgcHCAgICAgICAgBAgMDAgIDAwYGBwcGBgcHAQIDAwICAwMGBgcHBgYHBwYGBwcGBgcHCAgICAgICAgGBgcHBgYHBwgICAgICAgIAwMEBAMDBAQHBwcHBwcHBwMDBAQDAwQEBwcHBwcHBwcHBwcHBwcHBwgICAgICAgIBwcHBwcHBwcICAgICAgICAMDBAQDAwQEBwcHBwcHBwcDAwQEAwMEBAcHBwcHBwcHBwcHBwcHBwcICAgICAgICAcHBwcHBwcHCAgICAgICAgBAgMDAgIDAwYGBwcGBgcHAQIDAwICAwMGBgcHBgYHBwYGBwcGBgcHCAgICAgICAgGBgcHBgYHBwgICAgICAgIAgIDAwICAwMGBgcHBgYHBwICAwMCAgMDBgYHBwYGBwcGBgcHBgYHBwgICAgICAgIBgYHBwYGBwcICAgICAgICAMDBAQDAwQEBwcHBwcHBwcDAwQEAwMEBAcHBwcHBwcHBwcHBwcHBwcICAgICAgICAcHBwcHBwcHCAgICAgICAgDAwQEAwMEBAcHBwcHBwcHAwMEBAMDBAQHBwcHBwcHBwcHBwcHBwcHCAgICAgICAgHBwcHBwcHBwgICAgICAgIAAMBBAMGBAcBBAIFBAcFBwADAQQDBgQHAQQCBQQHBQcBBAIFBAcFBwIFAgUFBwUHAQQCBQQHBQcCBQIFBQcFBwMGBAcGCAcIBAcFBwcIBwgDBgQHBggHCAQHBQcHCAcIBAcFBwcIBwgFBwUHBwgHCAQHBQcHCAcIBQcFBwcIBwgBBAIFBAcFBwIFAgUFBwUHAQQCBQQHBQcCBQIFBQcFBwIFAgUFBwUHAgUCBQUHBQcCBQIFBQcFBwIFAgUFBwUHBAcFBwcIBwgFBwUHBwgHCAQHBQcHCAcIBQcFBwcIBwgFBwUHBwgHCAUHBQcHCAcIBQcFBwcIBwgFBwUHBwgHCAMGBAcGCAcIBAcFBwcIBwgDBgQHBggHCAQHBQcHCAcIBAcFBwcIBwgFBwUHBwgHCAQHBQcHCAcIBQcFBwcIBwgGCAcICAgICAcIBwgICAgIBggHCAgICAgHCAcICAgICAcIBwgICAgIBwgHCAgICAgHCAcICAgICAcIBwgICAgIBAcFBwcIBwgFBwUHBwgHCAQHBQcHCAcIBQcFBwcIBwgFBwUHBwgHCAUHBQcHCAcIBQcFBwcIBwgFBwUHBwgHCAcIBwgICAgIBwgHCAgICAgHCAcICAgICAcIBwgICAgIBwgHCAgICAgHCAcICAgICAcIBwgICAgIBwgHCAgICAgJCQoKCQkKCgwMDQsMDA0LCQkKCgkJCgoMDAsNDAwLDQwMDQ0MDAsLDAkNCgkMCgsMDAsLDAwNDQwJCwoJDAoNCQkKCgkJCgoMDA0LDAwNCwkJCgoJCQoKDAwLDQwMCw0MDA0NDAwLCwwJDQoJDAoLDAwLCwwMDQ0MCQsKCQwKDQoKCgoKCgoKDQsNCw0LDQsKCgkJCgoJCQ0LDAwNCwwMDQ0NDQsLCwsNCg0KCgsKCw0NDAwLCwwMDQoMCQoLCQwKCgkJCgoJCQsNDAwLDQwMCgoKCgoKCgoLDQsNCw0LDQsLDAwNDQwMCwoMCQoNCQwLCwsLDQ0NDQsKCwoKDQoNAEHZuwELNwEAAQABAAEAAAEBAAABAQABAAEAAQABAAAAAAEBAQEAAAAAAAEAAQAAAAABAQEBAAAAAQABAQEAQZm8AQs3AQABAAEAAQAAAQEAAAEBAAEAAQABAAEAAAAAAQEBAQAAAAAAAQABAAAAAAEBAQEAAAABAAEBAQBB2bwBCwcBAAEAAQABAEHpvAELlQIBAAEAAQABAAAAAAEBAQEAAAAAAAEAAQAAAAABAQEBAAAAAAABAAEBAQAAAQEAAAABAAEAAQABAQEBAQEBAQEAAQABAAEAAQAAAAABAQEBAAEAAAEBAAEAAAAAAQEBAQABAAEBAQEBAgAAAAQAAAAEAAAACAAAAJD/AAAMAAAAGAAAAFL/AAAUAAAAGQAAAFP/AAAUAAAAGgAAAF7/AAAUAAAAGwAAAFz/AAAUAAAAHAAAAF3/AAAUAAAAHQAAAF//AAAUAAAAHgAAAFH/AAACAAAAHwAAAFX/AAAEAAAAIAAAAFf/AAAEAAAAIQAAAFj/AAAQAAAAIgAAAGD/AAAEAAAAIwAAAGH/AAAQAAAAJAAAAJH/AEGIvwELZWP/AAAEAAAAJQAAAGT/AAAUAAAAJgAAAHT/AAAUAAAAJwAAAHj/AAAEAAAAKAAAAFD/AAAEAAAAKQAAAFn/AAAEAAAAKgAAAHX/AAAUAAAAKwAAAHf/AAAUAAAALAAAAAAAAAAUAEGAwAELNS0AAAAuAAAALwAAADAAAAAxAAAAMgAAADMAAAA0AAAAICBQajYAAABweXRmNwAAAGgycGo4AEHAwAELMnJkaGk5AAAAcmxvYzoAAABjY3BiOwAAAHJsY3A8AAAAcGFtYz0AAABmZWRjPgAAAPhiAEGAwQELQRkACwAZGRkAAAAABQAAAAAAAAkAAAAACwAAAAAAAAAAGQAKChkZGQMKBwABAAkLGAAACQYLAAALAAYZAAAAGRkZAEHRwQELIQ4AAAAAAAAAABkACw0ZGRkADQAAAgAJDgAAAAkADgAADgBBi8IBCwEMAEGXwgELFRMAAAAAEwAAAAAJDAAAAAAADAAADABBxcIBCwEQAEHRwgELFQ8AAAAEDwAAAAAJEAAAAAAAEAAAEABB/8IBCwESAEGLwwELHhEAAAAAEQAAAAAJEgAAAAAAEgAAEgAAGgAAABoaGgBBwsMBCw4aAAAAGhoaAAAAAAAACQBB88MBCwEUAEH/wwELFRcAAAAAFwAAAAAJFAAAAAAAFAAAFABBrcQBCwEWAEG5xAELJxUAAAAAFQAAAAAJFgAAAAAAFgAAFgAAMDEyMzQ1Njc4OUFCQ0RFRgBB4MQBCwmQbAEAAAAAAAUAQfTEAQsBaQBBjMUBCwpqAAAAawAAAHhoAEGkxQELAQIAQbTFAQsI//////////8AQfjFAQsBBQBBhMYBCwFsAEGcxgELDmoAAABtAAAAiGgAAAAEAEG0xgELAQEAQcTGAQsF/////wo=\");\n        return receiveInstance(instantiateSync(u, e)[0]);\n      }();\n    N.q, a._malloc = N.r, a._free = N.s, a._jp2_decode = N.u;\n    w = function runCaller() {\n      b || run();\n      b || (w = runCaller);\n    };\n    function run() {\n      if (!(m > 0)) {\n        !function preRun() {\n          if (a.preRun) {\n            \"function\" == typeof a.preRun && (a.preRun = [a.preRun]);\n            for (; a.preRun.length;) e = a.preRun.shift(), d.unshift(e);\n          }\n          var e;\n          callRuntimeCallbacks(d);\n        }();\n        if (!(m > 0)) if (a.setStatus) {\n          a.setStatus(\"Running...\");\n          setTimeout(function () {\n            setTimeout(function () {\n              a.setStatus(\"\");\n            }, 1);\n            doRun();\n          }, 1);\n        } else doRun();\n      }\n      function doRun() {\n        if (!b) {\n          b = !0;\n          a.calledRun = !0;\n          !function initRuntime() {\n            callRuntimeCallbacks(f);\n          }();\n          t(a);\n          a.onRuntimeInitialized && a.onRuntimeInitialized();\n          !function postRun() {\n            if (a.postRun) {\n              \"function\" == typeof a.postRun && (a.postRun = [a.postRun]);\n              for (; a.postRun.length;) e = a.postRun.shift(), p.unshift(e);\n            }\n            var e;\n            callRuntimeCallbacks(p);\n          }();\n        }\n      }\n    }\n    if (a.preInit) {\n      \"function\" == typeof a.preInit && (a.preInit = [a.preInit]);\n      for (; a.preInit.length > 0;) a.preInit.pop()();\n    }\n    run();\n    return a;\n  });\nconst Ii = oi;\nclass JpxError extends rt {\n  constructor(e) {\n    super(e, \"JpxError\");\n  }\n}\nclass JpxImage {\n  static #y = null;\n  static decode(e, t) {\n    t ||= {};\n    this.#y ||= Ii({\n      warn\n    });\n    const i = this.#y.decode(e, t);\n    if (\"string\" == typeof i) throw new JpxError(i);\n    return i;\n  }\n  static cleanup() {\n    this.#y = null;\n  }\n  static parseImageProperties(e) {\n    let t = e.getByte();\n    for (; t >= 0;) {\n      const i = t;\n      t = e.getByte();\n      if (65361 === (i << 8 | t)) {\n        e.skip(4);\n        const t = e.getInt32() >>> 0,\n          i = e.getInt32() >>> 0,\n          a = e.getInt32() >>> 0,\n          s = e.getInt32() >>> 0;\n        e.skip(16);\n        return {\n          width: t - a,\n          height: i - s,\n          bitsPerComponent: 8,\n          componentsCount: e.getUint16()\n        };\n      }\n    }\n    throw new JpxError(\"No size marker found in JPX stream\");\n  }\n}\nclass JpxStream extends DecodeStream {\n  constructor(e, t, i) {\n    super(t);\n    this.stream = e;\n    this.dict = e.dict;\n    this.maybeLength = t;\n    this.params = i;\n  }\n  get bytes() {\n    return shadow(this, \"bytes\", this.stream.getBytes(this.maybeLength));\n  }\n  ensureBuffer(e) {}\n  readBlock(e) {\n    this.decodeImage(null, e);\n  }\n  decodeImage(e, t) {\n    if (this.eof) return this.buffer;\n    e ||= this.bytes;\n    this.buffer = JpxImage.decode(e, t);\n    this.bufferLength = this.buffer.length;\n    this.eof = !0;\n    return this.buffer;\n  }\n  get canAsyncDecodeImageFromBuffer() {\n    return this.stream.isAsync;\n  }\n}\nclass LZWStream extends DecodeStream {\n  constructor(e, t, i) {\n    super(t);\n    this.str = e;\n    this.dict = e.dict;\n    this.cachedData = 0;\n    this.bitsCached = 0;\n    const a = 4096,\n      s = {\n        earlyChange: i,\n        codeLength: 9,\n        nextCode: 258,\n        dictionaryValues: new Uint8Array(a),\n        dictionaryLengths: new Uint16Array(a),\n        dictionaryPrevCodes: new Uint16Array(a),\n        currentSequence: new Uint8Array(a),\n        currentSequenceLength: 0\n      };\n    for (let e = 0; e < 256; ++e) {\n      s.dictionaryValues[e] = e;\n      s.dictionaryLengths[e] = 1;\n    }\n    this.lzwState = s;\n  }\n  readBits(e) {\n    let t = this.bitsCached,\n      i = this.cachedData;\n    for (; t < e;) {\n      const e = this.str.getByte();\n      if (-1 === e) {\n        this.eof = !0;\n        return null;\n      }\n      i = i << 8 | e;\n      t += 8;\n    }\n    this.bitsCached = t -= e;\n    this.cachedData = i;\n    this.lastCode = null;\n    return i >>> t & (1 << e) - 1;\n  }\n  readBlock() {\n    let e,\n      t,\n      i,\n      a = 1024;\n    const s = this.lzwState;\n    if (!s) return;\n    const r = s.earlyChange;\n    let n = s.nextCode;\n    const g = s.dictionaryValues,\n      o = s.dictionaryLengths,\n      c = s.dictionaryPrevCodes;\n    let C = s.codeLength,\n      h = s.prevCode;\n    const l = s.currentSequence;\n    let Q = s.currentSequenceLength,\n      E = 0,\n      u = this.bufferLength,\n      d = this.ensureBuffer(this.bufferLength + a);\n    for (e = 0; e < 512; e++) {\n      const e = this.readBits(C),\n        s = Q > 0;\n      if (e < 256) {\n        l[0] = e;\n        Q = 1;\n      } else {\n        if (!(e >= 258)) {\n          if (256 === e) {\n            C = 9;\n            n = 258;\n            Q = 0;\n            continue;\n          }\n          this.eof = !0;\n          delete this.lzwState;\n          break;\n        }\n        if (e < n) {\n          Q = o[e];\n          for (t = Q - 1, i = e; t >= 0; t--) {\n            l[t] = g[i];\n            i = c[i];\n          }\n        } else l[Q++] = l[0];\n      }\n      if (s) {\n        c[n] = h;\n        o[n] = o[h] + 1;\n        g[n] = l[0];\n        n++;\n        C = n + r & n + r - 1 ? C : 0 | Math.min(Math.log(n + r) / .6931471805599453 + 1, 12);\n      }\n      h = e;\n      E += Q;\n      if (a < E) {\n        do {\n          a += 512;\n        } while (a < E);\n        d = this.ensureBuffer(this.bufferLength + a);\n      }\n      for (t = 0; t < Q; t++) d[u++] = l[t];\n    }\n    s.nextCode = n;\n    s.codeLength = C;\n    s.prevCode = h;\n    s.currentSequenceLength = Q;\n    this.bufferLength = u;\n  }\n}\nclass PredictorStream extends DecodeStream {\n  constructor(e, t, i) {\n    super(t);\n    if (!(i instanceof Dict)) return e;\n    const a = this.predictor = i.get(\"Predictor\") || 1;\n    if (a <= 1) return e;\n    if (2 !== a && (a < 10 || a > 15)) throw new FormatError(`Unsupported predictor: ${a}`);\n    this.readBlock = 2 === a ? this.readBlockTiff : this.readBlockPng;\n    this.str = e;\n    this.dict = e.dict;\n    const s = this.colors = i.get(\"Colors\") || 1,\n      r = this.bits = i.get(\"BPC\", \"BitsPerComponent\") || 8,\n      n = this.columns = i.get(\"Columns\") || 1;\n    this.pixBytes = s * r + 7 >> 3;\n    this.rowBytes = n * s * r + 7 >> 3;\n    return this;\n  }\n  readBlockTiff() {\n    const e = this.rowBytes,\n      t = this.bufferLength,\n      i = this.ensureBuffer(t + e),\n      a = this.bits,\n      s = this.colors,\n      r = this.str.getBytes(e);\n    this.eof = !r.length;\n    if (this.eof) return;\n    let n,\n      g = 0,\n      o = 0,\n      c = 0,\n      C = 0,\n      h = t;\n    if (1 === a && 1 === s) for (n = 0; n < e; ++n) {\n      let e = r[n] ^ g;\n      e ^= e >> 1;\n      e ^= e >> 2;\n      e ^= e >> 4;\n      g = (1 & e) << 7;\n      i[h++] = e;\n    } else if (8 === a) {\n      for (n = 0; n < s; ++n) i[h++] = r[n];\n      for (; n < e; ++n) {\n        i[h] = i[h - s] + r[n];\n        h++;\n      }\n    } else if (16 === a) {\n      const t = 2 * s;\n      for (n = 0; n < t; ++n) i[h++] = r[n];\n      for (; n < e; n += 2) {\n        const e = ((255 & r[n]) << 8) + (255 & r[n + 1]) + ((255 & i[h - t]) << 8) + (255 & i[h - t + 1]);\n        i[h++] = e >> 8 & 255;\n        i[h++] = 255 & e;\n      }\n    } else {\n      const e = new Uint8Array(s + 1),\n        h = (1 << a) - 1;\n      let l = 0,\n        Q = t;\n      const E = this.columns;\n      for (n = 0; n < E; ++n) for (let t = 0; t < s; ++t) {\n        if (c < a) {\n          g = g << 8 | 255 & r[l++];\n          c += 8;\n        }\n        e[t] = e[t] + (g >> c - a) & h;\n        c -= a;\n        o = o << a | e[t];\n        C += a;\n        if (C >= 8) {\n          i[Q++] = o >> C - 8 & 255;\n          C -= 8;\n        }\n      }\n      C > 0 && (i[Q++] = (o << 8 - C) + (g & (1 << 8 - C) - 1));\n    }\n    this.bufferLength += e;\n  }\n  readBlockPng() {\n    const e = this.rowBytes,\n      t = this.pixBytes,\n      i = this.str.getByte(),\n      a = this.str.getBytes(e);\n    this.eof = !a.length;\n    if (this.eof) return;\n    const s = this.bufferLength,\n      r = this.ensureBuffer(s + e);\n    let n = r.subarray(s - e, s);\n    0 === n.length && (n = new Uint8Array(e));\n    let g,\n      o,\n      c,\n      C = s;\n    switch (i) {\n      case 0:\n        for (g = 0; g < e; ++g) r[C++] = a[g];\n        break;\n      case 1:\n        for (g = 0; g < t; ++g) r[C++] = a[g];\n        for (; g < e; ++g) {\n          r[C] = r[C - t] + a[g] & 255;\n          C++;\n        }\n        break;\n      case 2:\n        for (g = 0; g < e; ++g) r[C++] = n[g] + a[g] & 255;\n        break;\n      case 3:\n        for (g = 0; g < t; ++g) r[C++] = (n[g] >> 1) + a[g];\n        for (; g < e; ++g) {\n          r[C] = (n[g] + r[C - t] >> 1) + a[g] & 255;\n          C++;\n        }\n        break;\n      case 4:\n        for (g = 0; g < t; ++g) {\n          o = n[g];\n          c = a[g];\n          r[C++] = o + c;\n        }\n        for (; g < e; ++g) {\n          o = n[g];\n          const e = n[g - t],\n            i = r[C - t],\n            s = i + o - e;\n          let h = s - i;\n          h < 0 && (h = -h);\n          let l = s - o;\n          l < 0 && (l = -l);\n          let Q = s - e;\n          Q < 0 && (Q = -Q);\n          c = a[g];\n          r[C++] = h <= l && h <= Q ? i + c : l <= Q ? o + c : e + c;\n        }\n        break;\n      default:\n        throw new FormatError(`Unsupported predictor: ${i}`);\n    }\n    this.bufferLength += e;\n  }\n}\nclass RunLengthStream extends DecodeStream {\n  constructor(e, t) {\n    super(t);\n    this.str = e;\n    this.dict = e.dict;\n  }\n  readBlock() {\n    const e = this.str.getBytes(2);\n    if (!e || e.length < 2 || 128 === e[0]) {\n      this.eof = !0;\n      return;\n    }\n    let t,\n      i = this.bufferLength,\n      a = e[0];\n    if (a < 128) {\n      t = this.ensureBuffer(i + a + 1);\n      t[i++] = e[1];\n      if (a > 0) {\n        const e = this.str.getBytes(a);\n        t.set(e, i);\n        i += a;\n      }\n    } else {\n      a = 257 - a;\n      const s = e[1];\n      t = this.ensureBuffer(i + a + 1);\n      for (let e = 0; e < a; e++) t[i++] = s;\n    }\n    this.bufferLength = i;\n  }\n}\nclass Parser {\n  constructor({\n    lexer: e,\n    xref: t,\n    allowStreams: i = !1,\n    recoveryMode: a = !1\n  }) {\n    this.lexer = e;\n    this.xref = t;\n    this.allowStreams = i;\n    this.recoveryMode = a;\n    this.imageCache = Object.create(null);\n    this._imageId = 0;\n    this.refill();\n  }\n  refill() {\n    this.buf1 = this.lexer.getObj();\n    this.buf2 = this.lexer.getObj();\n  }\n  shift() {\n    if (this.buf2 instanceof Cmd && \"ID\" === this.buf2.cmd) {\n      this.buf1 = this.buf2;\n      this.buf2 = null;\n    } else {\n      this.buf1 = this.buf2;\n      this.buf2 = this.lexer.getObj();\n    }\n  }\n  tryShift() {\n    try {\n      this.shift();\n      return !0;\n    } catch (e) {\n      if (e instanceof MissingDataException) throw e;\n      return !1;\n    }\n  }\n  getObj(e = null) {\n    const t = this.buf1;\n    this.shift();\n    if (t instanceof Cmd) switch (t.cmd) {\n      case \"BI\":\n        return this.makeInlineImage(e);\n      case \"[\":\n        const i = [];\n        for (; !isCmd(this.buf1, \"]\") && this.buf1 !== pt;) i.push(this.getObj(e));\n        if (this.buf1 === pt) {\n          if (this.recoveryMode) return i;\n          throw new ParserEOFException(\"End of file inside array.\");\n        }\n        this.shift();\n        return i;\n      case \"<<\":\n        const a = new Dict(this.xref);\n        for (; !isCmd(this.buf1, \">>\") && this.buf1 !== pt;) {\n          if (!(this.buf1 instanceof Name)) {\n            info(\"Malformed dictionary: key must be a name object\");\n            this.shift();\n            continue;\n          }\n          const t = this.buf1.name;\n          this.shift();\n          if (this.buf1 === pt) break;\n          a.set(t, this.getObj(e));\n        }\n        if (this.buf1 === pt) {\n          if (this.recoveryMode) return a;\n          throw new ParserEOFException(\"End of file inside dictionary.\");\n        }\n        if (isCmd(this.buf2, \"stream\")) return this.allowStreams ? this.makeStream(a, e) : a;\n        this.shift();\n        return a;\n      default:\n        return t;\n    }\n    if (Number.isInteger(t)) {\n      if (Number.isInteger(this.buf1) && isCmd(this.buf2, \"R\")) {\n        const e = Ref.get(t, this.buf1);\n        this.shift();\n        this.shift();\n        return e;\n      }\n      return t;\n    }\n    return \"string\" == typeof t && e ? e.decryptString(t) : t;\n  }\n  findDefaultInlineStreamEnd(e) {\n    const {\n        knownCommands: t\n      } = this.lexer,\n      i = e.pos;\n    let a,\n      s,\n      r = 0;\n    for (; -1 !== (a = e.getByte());) if (0 === r) r = 69 === a ? 1 : 0;else if (1 === r) r = 73 === a ? 2 : 0;else if (32 === a || 10 === a || 13 === a) {\n      s = e.pos;\n      const i = e.peekBytes(15),\n        n = i.length;\n      if (0 === n) break;\n      for (let e = 0; e < n; e++) {\n        a = i[e];\n        if ((0 !== a || 0 === i[e + 1]) && 10 !== a && 13 !== a && (a < 32 || a > 127)) {\n          r = 0;\n          break;\n        }\n      }\n      if (2 !== r) continue;\n      if (!t) {\n        warn(\"findDefaultInlineStreamEnd - `lexer.knownCommands` is undefined.\");\n        continue;\n      }\n      const g = new Lexer(new Stream(i.slice()), t);\n      g._hexStringWarn = () => {};\n      let o = 0;\n      for (;;) {\n        const e = g.getObj();\n        if (e === pt) {\n          r = 0;\n          break;\n        }\n        if (e instanceof Cmd) {\n          const i = t[e.cmd];\n          if (!i) {\n            r = 0;\n            break;\n          }\n          if (i.variableArgs ? o <= i.numArgs : o === i.numArgs) break;\n          o = 0;\n        } else o++;\n      }\n      if (2 === r) break;\n    } else r = 0;\n    if (-1 === a) {\n      warn(\"findDefaultInlineStreamEnd: Reached the end of the stream without finding a valid EI marker\");\n      if (s) {\n        warn('... trying to recover by using the last \"EI\" occurrence.');\n        e.skip(-(e.pos - s));\n      }\n    }\n    let n = 4;\n    e.skip(-n);\n    a = e.peekByte();\n    e.skip(n);\n    isWhiteSpace(a) || n--;\n    return e.pos - n - i;\n  }\n  findDCTDecodeInlineStreamEnd(e) {\n    const t = e.pos;\n    let i,\n      a,\n      s = !1;\n    for (; -1 !== (i = e.getByte());) if (255 === i) {\n      switch (e.getByte()) {\n        case 0:\n          break;\n        case 255:\n          e.skip(-1);\n          break;\n        case 217:\n          s = !0;\n          break;\n        case 192:\n        case 193:\n        case 194:\n        case 195:\n        case 197:\n        case 198:\n        case 199:\n        case 201:\n        case 202:\n        case 203:\n        case 205:\n        case 206:\n        case 207:\n        case 196:\n        case 204:\n        case 218:\n        case 219:\n        case 220:\n        case 221:\n        case 222:\n        case 223:\n        case 224:\n        case 225:\n        case 226:\n        case 227:\n        case 228:\n        case 229:\n        case 230:\n        case 231:\n        case 232:\n        case 233:\n        case 234:\n        case 235:\n        case 236:\n        case 237:\n        case 238:\n        case 239:\n        case 254:\n          a = e.getUint16();\n          a > 2 ? e.skip(a - 2) : e.skip(-2);\n      }\n      if (s) break;\n    }\n    const r = e.pos - t;\n    if (-1 === i) {\n      warn(\"Inline DCTDecode image stream: EOI marker not found, searching for /EI/ instead.\");\n      e.skip(-r);\n      return this.findDefaultInlineStreamEnd(e);\n    }\n    this.inlineStreamSkipEI(e);\n    return r;\n  }\n  findASCII85DecodeInlineStreamEnd(e) {\n    const t = e.pos;\n    let i;\n    for (; -1 !== (i = e.getByte());) if (126 === i) {\n      const t = e.pos;\n      i = e.peekByte();\n      for (; isWhiteSpace(i);) {\n        e.skip();\n        i = e.peekByte();\n      }\n      if (62 === i) {\n        e.skip();\n        break;\n      }\n      if (e.pos > t) {\n        const t = e.peekBytes(2);\n        if (69 === t[0] && 73 === t[1]) break;\n      }\n    }\n    const a = e.pos - t;\n    if (-1 === i) {\n      warn(\"Inline ASCII85Decode image stream: EOD marker not found, searching for /EI/ instead.\");\n      e.skip(-a);\n      return this.findDefaultInlineStreamEnd(e);\n    }\n    this.inlineStreamSkipEI(e);\n    return a;\n  }\n  findASCIIHexDecodeInlineStreamEnd(e) {\n    const t = e.pos;\n    let i;\n    for (; -1 !== (i = e.getByte()) && 62 !== i;);\n    const a = e.pos - t;\n    if (-1 === i) {\n      warn(\"Inline ASCIIHexDecode image stream: EOD marker not found, searching for /EI/ instead.\");\n      e.skip(-a);\n      return this.findDefaultInlineStreamEnd(e);\n    }\n    this.inlineStreamSkipEI(e);\n    return a;\n  }\n  inlineStreamSkipEI(e) {\n    let t,\n      i = 0;\n    for (; -1 !== (t = e.getByte());) if (0 === i) i = 69 === t ? 1 : 0;else if (1 === i) i = 73 === t ? 2 : 0;else if (2 === i) break;\n  }\n  makeInlineImage(e) {\n    const t = this.lexer,\n      i = t.stream,\n      a = Object.create(null);\n    let s;\n    for (; !isCmd(this.buf1, \"ID\") && this.buf1 !== pt;) {\n      if (!(this.buf1 instanceof Name)) throw new FormatError(\"Dictionary key must be a name object\");\n      const t = this.buf1.name;\n      this.shift();\n      if (this.buf1 === pt) break;\n      a[t] = this.getObj(e);\n    }\n    -1 !== t.beginInlineImagePos && (s = i.pos - t.beginInlineImagePos);\n    const r = this.xref.fetchIfRef(a.F || a.Filter);\n    let n;\n    if (r instanceof Name) n = r.name;else if (Array.isArray(r)) {\n      const e = this.xref.fetchIfRef(r[0]);\n      e instanceof Name && (n = e.name);\n    }\n    const g = i.pos;\n    let o, c;\n    switch (n) {\n      case \"DCT\":\n      case \"DCTDecode\":\n        o = this.findDCTDecodeInlineStreamEnd(i);\n        break;\n      case \"A85\":\n      case \"ASCII85Decode\":\n        o = this.findASCII85DecodeInlineStreamEnd(i);\n        break;\n      case \"AHx\":\n      case \"ASCIIHexDecode\":\n        o = this.findASCIIHexDecodeInlineStreamEnd(i);\n        break;\n      default:\n        o = this.findDefaultInlineStreamEnd(i);\n    }\n    if (o < 1e3 && s > 0) {\n      const e = i.pos;\n      i.pos = t.beginInlineImagePos;\n      c = function getInlineImageCacheKey(e) {\n        const t = [],\n          i = e.length;\n        let a = 0;\n        for (; a < i - 1;) t.push(e[a++] << 8 | e[a++]);\n        a < i && t.push(e[a]);\n        return i + \"_\" + String.fromCharCode.apply(null, t);\n      }(i.getBytes(s + o));\n      i.pos = e;\n      const a = this.imageCache[c];\n      if (void 0 !== a) {\n        this.buf2 = Cmd.get(\"EI\");\n        this.shift();\n        a.reset();\n        return a;\n      }\n    }\n    const C = new Dict(this.xref);\n    for (const e in a) C.set(e, a[e]);\n    let h = i.makeSubStream(g, o, C);\n    e && (h = e.createStream(h, o));\n    h = this.filter(h, C, o);\n    h.dict = C;\n    if (void 0 !== c) {\n      h.cacheKey = \"inline_img_\" + ++this._imageId;\n      this.imageCache[c] = h;\n    }\n    this.buf2 = Cmd.get(\"EI\");\n    this.shift();\n    return h;\n  }\n  #w(e) {\n    const {\n      stream: t\n    } = this.lexer;\n    t.pos = e;\n    const i = new Uint8Array([101, 110, 100]),\n      a = i.length,\n      s = [new Uint8Array([115, 116, 114, 101, 97, 109]), new Uint8Array([115, 116, 101, 97, 109]), new Uint8Array([115, 116, 114, 101, 97])],\n      r = 9 - a;\n    for (; t.pos < t.end;) {\n      const n = t.peekBytes(2048),\n        g = n.length - 9;\n      if (g <= 0) break;\n      let o = 0;\n      for (; o < g;) {\n        let g = 0;\n        for (; g < a && n[o + g] === i[g];) g++;\n        if (g >= a) {\n          let a = !1;\n          for (const e of s) {\n            const t = e.length;\n            let s = 0;\n            for (; s < t && n[o + g + s] === e[s];) s++;\n            if (s >= r) {\n              a = !0;\n              break;\n            }\n            if (s >= t) {\n              if (isWhiteSpace(n[o + g + s])) {\n                info(`Found \"${bytesToString([...i, ...e])}\" when searching for endstream command.`);\n                a = !0;\n              }\n              break;\n            }\n          }\n          if (a) {\n            t.pos += o;\n            return t.pos - e;\n          }\n        }\n        o++;\n      }\n      t.pos += g;\n    }\n    return -1;\n  }\n  makeStream(e, t) {\n    const i = this.lexer;\n    let a = i.stream;\n    i.skipToNextLine();\n    const s = a.pos - 1;\n    let r = e.get(\"Length\");\n    if (!Number.isInteger(r)) {\n      info(`Bad length \"${r && r.toString()}\" in stream.`);\n      r = 0;\n    }\n    a.pos = s + r;\n    i.nextChar();\n    if (this.tryShift() && isCmd(this.buf2, \"endstream\")) this.shift();else {\n      r = this.#w(s);\n      if (r < 0) throw new FormatError(\"Missing endstream command.\");\n      i.nextChar();\n      this.shift();\n      this.shift();\n    }\n    this.shift();\n    a = a.makeSubStream(s, r, e);\n    t && (a = t.createStream(a, r));\n    a = this.filter(a, e, r);\n    a.dict = e;\n    return a;\n  }\n  filter(e, t, i) {\n    let a = t.get(\"F\", \"Filter\"),\n      s = t.get(\"DP\", \"DecodeParms\");\n    if (a instanceof Name) {\n      Array.isArray(s) && warn(\"/DecodeParms should not be an Array, when /Filter is a Name.\");\n      return this.makeFilter(e, a.name, i, s);\n    }\n    let r = i;\n    if (Array.isArray(a)) {\n      const t = a,\n        i = s;\n      for (let n = 0, g = t.length; n < g; ++n) {\n        a = this.xref.fetchIfRef(t[n]);\n        if (!(a instanceof Name)) throw new FormatError(`Bad filter name \"${a}\"`);\n        s = null;\n        Array.isArray(i) && n in i && (s = this.xref.fetchIfRef(i[n]));\n        e = this.makeFilter(e, a.name, r, s);\n        r = null;\n      }\n    }\n    return e;\n  }\n  makeFilter(e, t, i, a) {\n    if (0 === i) {\n      warn(`Empty \"${t}\" stream.`);\n      return new NullStream();\n    }\n    try {\n      switch (t) {\n        case \"Fl\":\n        case \"FlateDecode\":\n          return a ? new PredictorStream(new FlateStream(e, i), i, a) : new FlateStream(e, i);\n        case \"LZW\":\n        case \"LZWDecode\":\n          let t = 1;\n          if (a) {\n            a.has(\"EarlyChange\") && (t = a.get(\"EarlyChange\"));\n            return new PredictorStream(new LZWStream(e, i, t), i, a);\n          }\n          return new LZWStream(e, i, t);\n        case \"DCT\":\n        case \"DCTDecode\":\n          return new JpegStream(e, i, a);\n        case \"JPX\":\n        case \"JPXDecode\":\n          return new JpxStream(e, i, a);\n        case \"A85\":\n        case \"ASCII85Decode\":\n          return new Ascii85Stream(e, i);\n        case \"AHx\":\n        case \"ASCIIHexDecode\":\n          return new AsciiHexStream(e, i);\n        case \"CCF\":\n        case \"CCITTFaxDecode\":\n          return new CCITTFaxStream(e, i, a);\n        case \"RL\":\n        case \"RunLengthDecode\":\n          return new RunLengthStream(e, i);\n        case \"JBIG2Decode\":\n          return new Jbig2Stream(e, i, a);\n      }\n      warn(`Filter \"${t}\" is not supported.`);\n      return e;\n    } catch (e) {\n      if (e instanceof MissingDataException) throw e;\n      warn(`Invalid stream: \"${e}\"`);\n      return new NullStream();\n    }\n  }\n}\nconst ci = [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\nfunction toHexDigit(e) {\n  return e >= 48 && e <= 57 ? 15 & e : e >= 65 && e <= 70 || e >= 97 && e <= 102 ? 9 + (15 & e) : -1;\n}\nclass Lexer {\n  constructor(e, t = null) {\n    this.stream = e;\n    this.nextChar();\n    this.strBuf = [];\n    this.knownCommands = t;\n    this._hexStringNumWarn = 0;\n    this.beginInlineImagePos = -1;\n  }\n  nextChar() {\n    return this.currentChar = this.stream.getByte();\n  }\n  peekChar() {\n    return this.stream.peekByte();\n  }\n  getNumber() {\n    let e = this.currentChar,\n      t = !1,\n      i = 0,\n      a = 1;\n    if (45 === e) {\n      a = -1;\n      e = this.nextChar();\n      45 === e && (e = this.nextChar());\n    } else 43 === e && (e = this.nextChar());\n    if (10 === e || 13 === e) do {\n      e = this.nextChar();\n    } while (10 === e || 13 === e);\n    if (46 === e) {\n      i = 10;\n      e = this.nextChar();\n    }\n    if (e < 48 || e > 57) {\n      const t = `Invalid number: ${String.fromCharCode(e)} (charCode ${e})`;\n      if (isWhiteSpace(e) || -1 === e) {\n        info(`Lexer.getNumber - \"${t}\".`);\n        return 0;\n      }\n      throw new FormatError(t);\n    }\n    let s = e - 48,\n      r = 0,\n      n = 1;\n    for (; (e = this.nextChar()) >= 0;) if (e >= 48 && e <= 57) {\n      const a = e - 48;\n      if (t) r = 10 * r + a;else {\n        0 !== i && (i *= 10);\n        s = 10 * s + a;\n      }\n    } else if (46 === e) {\n      if (0 !== i) break;\n      i = 1;\n    } else if (45 === e) warn(\"Badly formatted number: minus sign in the middle\");else {\n      if (69 !== e && 101 !== e) break;\n      e = this.peekChar();\n      if (43 === e || 45 === e) {\n        n = 45 === e ? -1 : 1;\n        this.nextChar();\n      } else if (e < 48 || e > 57) break;\n      t = !0;\n    }\n    0 !== i && (s /= i);\n    t && (s *= 10 ** (n * r));\n    return a * s;\n  }\n  getString() {\n    let e = 1,\n      t = !1;\n    const i = this.strBuf;\n    i.length = 0;\n    let a = this.nextChar();\n    for (;;) {\n      let s = !1;\n      switch (0 | a) {\n        case -1:\n          warn(\"Unterminated string\");\n          t = !0;\n          break;\n        case 40:\n          ++e;\n          i.push(\"(\");\n          break;\n        case 41:\n          if (0 == --e) {\n            this.nextChar();\n            t = !0;\n          } else i.push(\")\");\n          break;\n        case 92:\n          a = this.nextChar();\n          switch (a) {\n            case -1:\n              warn(\"Unterminated string\");\n              t = !0;\n              break;\n            case 110:\n              i.push(\"\\n\");\n              break;\n            case 114:\n              i.push(\"\\r\");\n              break;\n            case 116:\n              i.push(\"\\t\");\n              break;\n            case 98:\n              i.push(\"\\b\");\n              break;\n            case 102:\n              i.push(\"\\f\");\n              break;\n            case 92:\n            case 40:\n            case 41:\n              i.push(String.fromCharCode(a));\n              break;\n            case 48:\n            case 49:\n            case 50:\n            case 51:\n            case 52:\n            case 53:\n            case 54:\n            case 55:\n              let e = 15 & a;\n              a = this.nextChar();\n              s = !0;\n              if (a >= 48 && a <= 55) {\n                e = (e << 3) + (15 & a);\n                a = this.nextChar();\n                if (a >= 48 && a <= 55) {\n                  s = !1;\n                  e = (e << 3) + (15 & a);\n                }\n              }\n              i.push(String.fromCharCode(e));\n              break;\n            case 13:\n              10 === this.peekChar() && this.nextChar();\n              break;\n            case 10:\n              break;\n            default:\n              i.push(String.fromCharCode(a));\n          }\n          break;\n        default:\n          i.push(String.fromCharCode(a));\n      }\n      if (t) break;\n      s || (a = this.nextChar());\n    }\n    return i.join(\"\");\n  }\n  getName() {\n    let e, t;\n    const i = this.strBuf;\n    i.length = 0;\n    for (; (e = this.nextChar()) >= 0 && !ci[e];) if (35 === e) {\n      e = this.nextChar();\n      if (ci[e]) {\n        warn(\"Lexer_getName: NUMBER SIGN (#) should be followed by a hexadecimal number.\");\n        i.push(\"#\");\n        break;\n      }\n      const a = toHexDigit(e);\n      if (-1 !== a) {\n        t = e;\n        e = this.nextChar();\n        const s = toHexDigit(e);\n        if (-1 === s) {\n          warn(`Lexer_getName: Illegal digit (${String.fromCharCode(e)}) in hexadecimal number.`);\n          i.push(\"#\", String.fromCharCode(t));\n          if (ci[e]) break;\n          i.push(String.fromCharCode(e));\n          continue;\n        }\n        i.push(String.fromCharCode(a << 4 | s));\n      } else i.push(\"#\", String.fromCharCode(e));\n    } else i.push(String.fromCharCode(e));\n    i.length > 127 && warn(`Name token is longer than allowed by the spec: ${i.length}`);\n    return Name.get(i.join(\"\"));\n  }\n  _hexStringWarn(e) {\n    5 != this._hexStringNumWarn++ ? this._hexStringNumWarn > 5 || warn(`getHexString - ignoring invalid character: ${e}`) : warn(\"getHexString - ignoring additional invalid characters.\");\n  }\n  getHexString() {\n    const e = this.strBuf;\n    e.length = 0;\n    let t,\n      i,\n      a = this.currentChar,\n      s = !0;\n    this._hexStringNumWarn = 0;\n    for (;;) {\n      if (a < 0) {\n        warn(\"Unterminated hex string\");\n        break;\n      }\n      if (62 === a) {\n        this.nextChar();\n        break;\n      }\n      if (1 !== ci[a]) {\n        if (s) {\n          t = toHexDigit(a);\n          if (-1 === t) {\n            this._hexStringWarn(a);\n            a = this.nextChar();\n            continue;\n          }\n        } else {\n          i = toHexDigit(a);\n          if (-1 === i) {\n            this._hexStringWarn(a);\n            a = this.nextChar();\n            continue;\n          }\n          e.push(String.fromCharCode(t << 4 | i));\n        }\n        s = !s;\n        a = this.nextChar();\n      } else a = this.nextChar();\n    }\n    return e.join(\"\");\n  }\n  getObj() {\n    let e = !1,\n      t = this.currentChar;\n    for (;;) {\n      if (t < 0) return pt;\n      if (e) 10 !== t && 13 !== t || (e = !1);else if (37 === t) e = !0;else if (1 !== ci[t]) break;\n      t = this.nextChar();\n    }\n    switch (0 | t) {\n      case 48:\n      case 49:\n      case 50:\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n      case 43:\n      case 45:\n      case 46:\n        return this.getNumber();\n      case 40:\n        return this.getString();\n      case 47:\n        return this.getName();\n      case 91:\n        this.nextChar();\n        return Cmd.get(\"[\");\n      case 93:\n        this.nextChar();\n        return Cmd.get(\"]\");\n      case 60:\n        t = this.nextChar();\n        if (60 === t) {\n          this.nextChar();\n          return Cmd.get(\"<<\");\n        }\n        return this.getHexString();\n      case 62:\n        t = this.nextChar();\n        if (62 === t) {\n          this.nextChar();\n          return Cmd.get(\">>\");\n        }\n        return Cmd.get(\">\");\n      case 123:\n        this.nextChar();\n        return Cmd.get(\"{\");\n      case 125:\n        this.nextChar();\n        return Cmd.get(\"}\");\n      case 41:\n        this.nextChar();\n        throw new FormatError(`Illegal character: ${t}`);\n    }\n    let i = String.fromCharCode(t);\n    if (t < 32 || t > 127) {\n      const e = this.peekChar();\n      if (e >= 32 && e <= 127) {\n        this.nextChar();\n        return Cmd.get(i);\n      }\n    }\n    const a = this.knownCommands;\n    let s = void 0 !== a?.[i];\n    for (; (t = this.nextChar()) >= 0 && !ci[t];) {\n      const e = i + String.fromCharCode(t);\n      if (s && void 0 === a[e]) break;\n      if (128 === i.length) throw new FormatError(`Command token too long: ${i.length}`);\n      i = e;\n      s = void 0 !== a?.[i];\n    }\n    if (\"true\" === i) return !0;\n    if (\"false\" === i) return !1;\n    if (\"null\" === i) return null;\n    \"BI\" === i && (this.beginInlineImagePos = this.stream.pos);\n    return Cmd.get(i);\n  }\n  skipToNextLine() {\n    let e = this.currentChar;\n    for (; e >= 0;) {\n      if (13 === e) {\n        e = this.nextChar();\n        10 === e && this.nextChar();\n        break;\n      }\n      if (10 === e) {\n        this.nextChar();\n        break;\n      }\n      e = this.nextChar();\n    }\n  }\n}\nclass Linearization {\n  static create(e) {\n    function getInt(e, t, i = !1) {\n      const a = e.get(t);\n      if (Number.isInteger(a) && (i ? a >= 0 : a > 0)) return a;\n      throw new Error(`The \"${t}\" parameter in the linearization dictionary is invalid.`);\n    }\n    const t = new Parser({\n        lexer: new Lexer(e),\n        xref: null\n      }),\n      i = t.getObj(),\n      a = t.getObj(),\n      s = t.getObj(),\n      r = t.getObj();\n    let n, g;\n    if (!(Number.isInteger(i) && Number.isInteger(a) && isCmd(s, \"obj\") && r instanceof Dict && \"number\" == typeof (n = r.get(\"Linearized\")) && n > 0)) return null;\n    if ((g = getInt(r, \"L\")) !== e.length) throw new Error('The \"L\" parameter in the linearization dictionary does not equal the stream length.');\n    return {\n      length: g,\n      hints: function getHints(e) {\n        const t = e.get(\"H\");\n        let i;\n        if (Array.isArray(t) && (2 === (i = t.length) || 4 === i)) {\n          for (let e = 0; e < i; e++) {\n            const i = t[e];\n            if (!(Number.isInteger(i) && i > 0)) throw new Error(`Hint (${e}) in the linearization dictionary is invalid.`);\n          }\n          return t;\n        }\n        throw new Error(\"Hint array in the linearization dictionary is invalid.\");\n      }(r),\n      objectNumberFirst: getInt(r, \"O\"),\n      endFirst: getInt(r, \"E\"),\n      numPages: getInt(r, \"N\"),\n      mainXRefEntriesOffset: getInt(r, \"T\"),\n      pageFirst: r.has(\"P\") ? getInt(r, \"P\", !0) : 0\n    };\n  }\n}\nconst Ci = [\"Adobe-GB1-UCS2\", \"Adobe-CNS1-UCS2\", \"Adobe-Japan1-UCS2\", \"Adobe-Korea1-UCS2\", \"78-EUC-H\", \"78-EUC-V\", \"78-H\", \"78-RKSJ-H\", \"78-RKSJ-V\", \"78-V\", \"78ms-RKSJ-H\", \"78ms-RKSJ-V\", \"83pv-RKSJ-H\", \"90ms-RKSJ-H\", \"90ms-RKSJ-V\", \"90msp-RKSJ-H\", \"90msp-RKSJ-V\", \"90pv-RKSJ-H\", \"90pv-RKSJ-V\", \"Add-H\", \"Add-RKSJ-H\", \"Add-RKSJ-V\", \"Add-V\", \"Adobe-CNS1-0\", \"Adobe-CNS1-1\", \"Adobe-CNS1-2\", \"Adobe-CNS1-3\", \"Adobe-CNS1-4\", \"Adobe-CNS1-5\", \"Adobe-CNS1-6\", \"Adobe-GB1-0\", \"Adobe-GB1-1\", \"Adobe-GB1-2\", \"Adobe-GB1-3\", \"Adobe-GB1-4\", \"Adobe-GB1-5\", \"Adobe-Japan1-0\", \"Adobe-Japan1-1\", \"Adobe-Japan1-2\", \"Adobe-Japan1-3\", \"Adobe-Japan1-4\", \"Adobe-Japan1-5\", \"Adobe-Japan1-6\", \"Adobe-Korea1-0\", \"Adobe-Korea1-1\", \"Adobe-Korea1-2\", \"B5-H\", \"B5-V\", \"B5pc-H\", \"B5pc-V\", \"CNS-EUC-H\", \"CNS-EUC-V\", \"CNS1-H\", \"CNS1-V\", \"CNS2-H\", \"CNS2-V\", \"ETHK-B5-H\", \"ETHK-B5-V\", \"ETen-B5-H\", \"ETen-B5-V\", \"ETenms-B5-H\", \"ETenms-B5-V\", \"EUC-H\", \"EUC-V\", \"Ext-H\", \"Ext-RKSJ-H\", \"Ext-RKSJ-V\", \"Ext-V\", \"GB-EUC-H\", \"GB-EUC-V\", \"GB-H\", \"GB-V\", \"GBK-EUC-H\", \"GBK-EUC-V\", \"GBK2K-H\", \"GBK2K-V\", \"GBKp-EUC-H\", \"GBKp-EUC-V\", \"GBT-EUC-H\", \"GBT-EUC-V\", \"GBT-H\", \"GBT-V\", \"GBTpc-EUC-H\", \"GBTpc-EUC-V\", \"GBpc-EUC-H\", \"GBpc-EUC-V\", \"H\", \"HKdla-B5-H\", \"HKdla-B5-V\", \"HKdlb-B5-H\", \"HKdlb-B5-V\", \"HKgccs-B5-H\", \"HKgccs-B5-V\", \"HKm314-B5-H\", \"HKm314-B5-V\", \"HKm471-B5-H\", \"HKm471-B5-V\", \"HKscs-B5-H\", \"HKscs-B5-V\", \"Hankaku\", \"Hiragana\", \"KSC-EUC-H\", \"KSC-EUC-V\", \"KSC-H\", \"KSC-Johab-H\", \"KSC-Johab-V\", \"KSC-V\", \"KSCms-UHC-H\", \"KSCms-UHC-HW-H\", \"KSCms-UHC-HW-V\", \"KSCms-UHC-V\", \"KSCpc-EUC-H\", \"KSCpc-EUC-V\", \"Katakana\", \"NWP-H\", \"NWP-V\", \"RKSJ-H\", \"RKSJ-V\", \"Roman\", \"UniCNS-UCS2-H\", \"UniCNS-UCS2-V\", \"UniCNS-UTF16-H\", \"UniCNS-UTF16-V\", \"UniCNS-UTF32-H\", \"UniCNS-UTF32-V\", \"UniCNS-UTF8-H\", \"UniCNS-UTF8-V\", \"UniGB-UCS2-H\", \"UniGB-UCS2-V\", \"UniGB-UTF16-H\", \"UniGB-UTF16-V\", \"UniGB-UTF32-H\", \"UniGB-UTF32-V\", \"UniGB-UTF8-H\", \"UniGB-UTF8-V\", \"UniJIS-UCS2-H\", \"UniJIS-UCS2-HW-H\", \"UniJIS-UCS2-HW-V\", \"UniJIS-UCS2-V\", \"UniJIS-UTF16-H\", \"UniJIS-UTF16-V\", \"UniJIS-UTF32-H\", \"UniJIS-UTF32-V\", \"UniJIS-UTF8-H\", \"UniJIS-UTF8-V\", \"UniJIS2004-UTF16-H\", \"UniJIS2004-UTF16-V\", \"UniJIS2004-UTF32-H\", \"UniJIS2004-UTF32-V\", \"UniJIS2004-UTF8-H\", \"UniJIS2004-UTF8-V\", \"UniJISPro-UCS2-HW-V\", \"UniJISPro-UCS2-V\", \"UniJISPro-UTF8-V\", \"UniJISX0213-UTF32-H\", \"UniJISX0213-UTF32-V\", \"UniJISX02132004-UTF32-H\", \"UniJISX02132004-UTF32-V\", \"UniKS-UCS2-H\", \"UniKS-UCS2-V\", \"UniKS-UTF16-H\", \"UniKS-UTF16-V\", \"UniKS-UTF32-H\", \"UniKS-UTF32-V\", \"UniKS-UTF8-H\", \"UniKS-UTF8-V\", \"V\", \"WP-Symbol\"],\n  hi = 2 ** 24 - 1;\nclass CMap {\n  constructor(e = !1) {\n    this.codespaceRanges = [[], [], [], []];\n    this.numCodespaceRanges = 0;\n    this._map = [];\n    this.name = \"\";\n    this.vertical = !1;\n    this.useCMap = null;\n    this.builtInCMap = e;\n  }\n  addCodespaceRange(e, t, i) {\n    this.codespaceRanges[e - 1].push(t, i);\n    this.numCodespaceRanges++;\n  }\n  mapCidRange(e, t, i) {\n    if (t - e > hi) throw new Error(\"mapCidRange - ignoring data above MAX_MAP_RANGE.\");\n    for (; e <= t;) this._map[e++] = i++;\n  }\n  mapBfRange(e, t, i) {\n    if (t - e > hi) throw new Error(\"mapBfRange - ignoring data above MAX_MAP_RANGE.\");\n    const a = i.length - 1;\n    for (; e <= t;) {\n      this._map[e++] = i;\n      const t = i.charCodeAt(a) + 1;\n      t > 255 ? i = i.substring(0, a - 1) + String.fromCharCode(i.charCodeAt(a - 1) + 1) + \"\\0\" : i = i.substring(0, a) + String.fromCharCode(t);\n    }\n  }\n  mapBfRangeToArray(e, t, i) {\n    if (t - e > hi) throw new Error(\"mapBfRangeToArray - ignoring data above MAX_MAP_RANGE.\");\n    const a = i.length;\n    let s = 0;\n    for (; e <= t && s < a;) {\n      this._map[e] = i[s++];\n      ++e;\n    }\n  }\n  mapOne(e, t) {\n    this._map[e] = t;\n  }\n  lookup(e) {\n    return this._map[e];\n  }\n  contains(e) {\n    return void 0 !== this._map[e];\n  }\n  forEach(e) {\n    const t = this._map,\n      i = t.length;\n    if (i <= 65536) for (let a = 0; a < i; a++) void 0 !== t[a] && e(a, t[a]);else for (const i in t) e(i, t[i]);\n  }\n  charCodeOf(e) {\n    const t = this._map;\n    if (t.length <= 65536) return t.indexOf(e);\n    for (const i in t) if (t[i] === e) return 0 | i;\n    return -1;\n  }\n  getMap() {\n    return this._map;\n  }\n  readCharCode(e, t, i) {\n    let a = 0;\n    const s = this.codespaceRanges;\n    for (let r = 0, n = s.length; r < n; r++) {\n      a = (a << 8 | e.charCodeAt(t + r)) >>> 0;\n      const n = s[r];\n      for (let e = 0, t = n.length; e < t;) {\n        const t = n[e++],\n          s = n[e++];\n        if (a >= t && a <= s) {\n          i.charcode = a;\n          i.length = r + 1;\n          return;\n        }\n      }\n    }\n    i.charcode = 0;\n    i.length = 1;\n  }\n  getCharCodeLength(e) {\n    const t = this.codespaceRanges;\n    for (let i = 0, a = t.length; i < a; i++) {\n      const a = t[i];\n      for (let t = 0, s = a.length; t < s;) {\n        const s = a[t++],\n          r = a[t++];\n        if (e >= s && e <= r) return i + 1;\n      }\n    }\n    return 1;\n  }\n  get length() {\n    return this._map.length;\n  }\n  get isIdentityCMap() {\n    if (\"Identity-H\" !== this.name && \"Identity-V\" !== this.name) return !1;\n    if (65536 !== this._map.length) return !1;\n    for (let e = 0; e < 65536; e++) if (this._map[e] !== e) return !1;\n    return !0;\n  }\n}\nclass IdentityCMap extends CMap {\n  constructor(e, t) {\n    super();\n    this.vertical = e;\n    this.addCodespaceRange(t, 0, 65535);\n  }\n  mapCidRange(e, t, i) {\n    unreachable(\"should not call mapCidRange\");\n  }\n  mapBfRange(e, t, i) {\n    unreachable(\"should not call mapBfRange\");\n  }\n  mapBfRangeToArray(e, t, i) {\n    unreachable(\"should not call mapBfRangeToArray\");\n  }\n  mapOne(e, t) {\n    unreachable(\"should not call mapCidOne\");\n  }\n  lookup(e) {\n    return Number.isInteger(e) && e <= 65535 ? e : void 0;\n  }\n  contains(e) {\n    return Number.isInteger(e) && e <= 65535;\n  }\n  forEach(e) {\n    for (let t = 0; t <= 65535; t++) e(t, t);\n  }\n  charCodeOf(e) {\n    return Number.isInteger(e) && e <= 65535 ? e : -1;\n  }\n  getMap() {\n    const e = new Array(65536);\n    for (let t = 0; t <= 65535; t++) e[t] = t;\n    return e;\n  }\n  get length() {\n    return 65536;\n  }\n  get isIdentityCMap() {\n    unreachable(\"should not access .isIdentityCMap\");\n  }\n}\nfunction strToInt(e) {\n  let t = 0;\n  for (let i = 0; i < e.length; i++) t = t << 8 | e.charCodeAt(i);\n  return t >>> 0;\n}\nfunction expectString(e) {\n  if (\"string\" != typeof e) throw new FormatError(\"Malformed CMap: expected string.\");\n}\nfunction expectInt(e) {\n  if (!Number.isInteger(e)) throw new FormatError(\"Malformed CMap: expected int.\");\n}\nfunction parseBfChar(e, t) {\n  for (;;) {\n    let i = t.getObj();\n    if (i === pt) break;\n    if (isCmd(i, \"endbfchar\")) return;\n    expectString(i);\n    const a = strToInt(i);\n    i = t.getObj();\n    expectString(i);\n    const s = i;\n    e.mapOne(a, s);\n  }\n}\nfunction parseBfRange(e, t) {\n  for (;;) {\n    let i = t.getObj();\n    if (i === pt) break;\n    if (isCmd(i, \"endbfrange\")) return;\n    expectString(i);\n    const a = strToInt(i);\n    i = t.getObj();\n    expectString(i);\n    const s = strToInt(i);\n    i = t.getObj();\n    if (Number.isInteger(i) || \"string\" == typeof i) {\n      const t = Number.isInteger(i) ? String.fromCharCode(i) : i;\n      e.mapBfRange(a, s, t);\n    } else {\n      if (!isCmd(i, \"[\")) break;\n      {\n        i = t.getObj();\n        const r = [];\n        for (; !isCmd(i, \"]\") && i !== pt;) {\n          r.push(i);\n          i = t.getObj();\n        }\n        e.mapBfRangeToArray(a, s, r);\n      }\n    }\n  }\n  throw new FormatError(\"Invalid bf range.\");\n}\nfunction parseCidChar(e, t) {\n  for (;;) {\n    let i = t.getObj();\n    if (i === pt) break;\n    if (isCmd(i, \"endcidchar\")) return;\n    expectString(i);\n    const a = strToInt(i);\n    i = t.getObj();\n    expectInt(i);\n    const s = i;\n    e.mapOne(a, s);\n  }\n}\nfunction parseCidRange(e, t) {\n  for (;;) {\n    let i = t.getObj();\n    if (i === pt) break;\n    if (isCmd(i, \"endcidrange\")) return;\n    expectString(i);\n    const a = strToInt(i);\n    i = t.getObj();\n    expectString(i);\n    const s = strToInt(i);\n    i = t.getObj();\n    expectInt(i);\n    const r = i;\n    e.mapCidRange(a, s, r);\n  }\n}\nfunction parseCodespaceRange(e, t) {\n  for (;;) {\n    let i = t.getObj();\n    if (i === pt) break;\n    if (isCmd(i, \"endcodespacerange\")) return;\n    if (\"string\" != typeof i) break;\n    const a = strToInt(i);\n    i = t.getObj();\n    if (\"string\" != typeof i) break;\n    const s = strToInt(i);\n    e.addCodespaceRange(i.length, a, s);\n  }\n  throw new FormatError(\"Invalid codespace range.\");\n}\nfunction parseWMode(e, t) {\n  const i = t.getObj();\n  Number.isInteger(i) && (e.vertical = !!i);\n}\nfunction parseCMapName(e, t) {\n  const i = t.getObj();\n  i instanceof Name && (e.name = i.name);\n}\nasync function parseCMap(e, t, i, a) {\n  let s, r;\n  A: for (;;) try {\n    const i = t.getObj();\n    if (i === pt) break;\n    if (i instanceof Name) {\n      \"WMode\" === i.name ? parseWMode(e, t) : \"CMapName\" === i.name && parseCMapName(e, t);\n      s = i;\n    } else if (i instanceof Cmd) switch (i.cmd) {\n      case \"endcmap\":\n        break A;\n      case \"usecmap\":\n        s instanceof Name && (r = s.name);\n        break;\n      case \"begincodespacerange\":\n        parseCodespaceRange(e, t);\n        break;\n      case \"beginbfchar\":\n        parseBfChar(e, t);\n        break;\n      case \"begincidchar\":\n        parseCidChar(e, t);\n        break;\n      case \"beginbfrange\":\n        parseBfRange(e, t);\n        break;\n      case \"begincidrange\":\n        parseCidRange(e, t);\n    }\n  } catch (e) {\n    if (e instanceof MissingDataException) throw e;\n    warn(\"Invalid cMap data: \" + e);\n    continue;\n  }\n  !a && r && (a = r);\n  return a ? extendCMap(e, i, a) : e;\n}\nasync function extendCMap(e, t, i) {\n  e.useCMap = await createBuiltInCMap(i, t);\n  if (0 === e.numCodespaceRanges) {\n    const t = e.useCMap.codespaceRanges;\n    for (let i = 0; i < t.length; i++) e.codespaceRanges[i] = t[i].slice();\n    e.numCodespaceRanges = e.useCMap.numCodespaceRanges;\n  }\n  e.useCMap.forEach(function (t, i) {\n    e.contains(t) || e.mapOne(t, e.useCMap.lookup(t));\n  });\n  return e;\n}\nasync function createBuiltInCMap(e, t) {\n  if (\"Identity-H\" === e) return new IdentityCMap(!1, 2);\n  if (\"Identity-V\" === e) return new IdentityCMap(!0, 2);\n  if (!Ci.includes(e)) throw new Error(\"Unknown CMap name: \" + e);\n  if (!t) throw new Error(\"Built-in CMap parameters are not provided.\");\n  const {\n      cMapData: i,\n      compressionType: a\n    } = await t(e),\n    s = new CMap(!0);\n  if (a === mA.BINARY) return new BinaryCMapReader().process(i, s, e => extendCMap(s, t, e));\n  if (a === mA.NONE) {\n    const e = new Lexer(new Stream(i));\n    return parseCMap(s, e, t, null);\n  }\n  throw new Error(`Invalid CMap \"compressionType\" value: ${a}`);\n}\nclass CMapFactory {\n  static async create({\n    encoding: e,\n    fetchBuiltInCMap: t,\n    useCMap: i\n  }) {\n    if (e instanceof Name) return createBuiltInCMap(e.name, t);\n    if (e instanceof BaseStream) {\n      const a = await parseCMap(new CMap(), new Lexer(e), t, i);\n      return a.isIdentityCMap ? createBuiltInCMap(a.name, t) : a;\n    }\n    throw new Error(\"Encoding required.\");\n  }\n}\nconst Bi = [\".notdef\", \"space\", \"exclam\", \"quotedbl\", \"numbersign\", \"dollar\", \"percent\", \"ampersand\", \"quoteright\", \"parenleft\", \"parenright\", \"asterisk\", \"plus\", \"comma\", \"hyphen\", \"period\", \"slash\", \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"colon\", \"semicolon\", \"less\", \"equal\", \"greater\", \"question\", \"at\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"bracketleft\", \"backslash\", \"bracketright\", \"asciicircum\", \"underscore\", \"quoteleft\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"braceleft\", \"bar\", \"braceright\", \"asciitilde\", \"exclamdown\", \"cent\", \"sterling\", \"fraction\", \"yen\", \"florin\", \"section\", \"currency\", \"quotesingle\", \"quotedblleft\", \"guillemotleft\", \"guilsinglleft\", \"guilsinglright\", \"fi\", \"fl\", \"endash\", \"dagger\", \"daggerdbl\", \"periodcentered\", \"paragraph\", \"bullet\", \"quotesinglbase\", \"quotedblbase\", \"quotedblright\", \"guillemotright\", \"ellipsis\", \"perthousand\", \"questiondown\", \"grave\", \"acute\", \"circumflex\", \"tilde\", \"macron\", \"breve\", \"dotaccent\", \"dieresis\", \"ring\", \"cedilla\", \"hungarumlaut\", \"ogonek\", \"caron\", \"emdash\", \"AE\", \"ordfeminine\", \"Lslash\", \"Oslash\", \"OE\", \"ordmasculine\", \"ae\", \"dotlessi\", \"lslash\", \"oslash\", \"oe\", \"germandbls\", \"onesuperior\", \"logicalnot\", \"mu\", \"trademark\", \"Eth\", \"onehalf\", \"plusminus\", \"Thorn\", \"onequarter\", \"divide\", \"brokenbar\", \"degree\", \"thorn\", \"threequarters\", \"twosuperior\", \"registered\", \"minus\", \"eth\", \"multiply\", \"threesuperior\", \"copyright\", \"Aacute\", \"Acircumflex\", \"Adieresis\", \"Agrave\", \"Aring\", \"Atilde\", \"Ccedilla\", \"Eacute\", \"Ecircumflex\", \"Edieresis\", \"Egrave\", \"Iacute\", \"Icircumflex\", \"Idieresis\", \"Igrave\", \"Ntilde\", \"Oacute\", \"Ocircumflex\", \"Odieresis\", \"Ograve\", \"Otilde\", \"Scaron\", \"Uacute\", \"Ucircumflex\", \"Udieresis\", \"Ugrave\", \"Yacute\", \"Ydieresis\", \"Zcaron\", \"aacute\", \"acircumflex\", \"adieresis\", \"agrave\", \"aring\", \"atilde\", \"ccedilla\", \"eacute\", \"ecircumflex\", \"edieresis\", \"egrave\", \"iacute\", \"icircumflex\", \"idieresis\", \"igrave\", \"ntilde\", \"oacute\", \"ocircumflex\", \"odieresis\", \"ograve\", \"otilde\", \"scaron\", \"uacute\", \"ucircumflex\", \"udieresis\", \"ugrave\", \"yacute\", \"ydieresis\", \"zcaron\"],\n  li = [\".notdef\", \"space\", \"exclamsmall\", \"Hungarumlautsmall\", \"dollaroldstyle\", \"dollarsuperior\", \"ampersandsmall\", \"Acutesmall\", \"parenleftsuperior\", \"parenrightsuperior\", \"twodotenleader\", \"onedotenleader\", \"comma\", \"hyphen\", \"period\", \"fraction\", \"zerooldstyle\", \"oneoldstyle\", \"twooldstyle\", \"threeoldstyle\", \"fouroldstyle\", \"fiveoldstyle\", \"sixoldstyle\", \"sevenoldstyle\", \"eightoldstyle\", \"nineoldstyle\", \"colon\", \"semicolon\", \"commasuperior\", \"threequartersemdash\", \"periodsuperior\", \"questionsmall\", \"asuperior\", \"bsuperior\", \"centsuperior\", \"dsuperior\", \"esuperior\", \"isuperior\", \"lsuperior\", \"msuperior\", \"nsuperior\", \"osuperior\", \"rsuperior\", \"ssuperior\", \"tsuperior\", \"ff\", \"fi\", \"fl\", \"ffi\", \"ffl\", \"parenleftinferior\", \"parenrightinferior\", \"Circumflexsmall\", \"hyphensuperior\", \"Gravesmall\", \"Asmall\", \"Bsmall\", \"Csmall\", \"Dsmall\", \"Esmall\", \"Fsmall\", \"Gsmall\", \"Hsmall\", \"Ismall\", \"Jsmall\", \"Ksmall\", \"Lsmall\", \"Msmall\", \"Nsmall\", \"Osmall\", \"Psmall\", \"Qsmall\", \"Rsmall\", \"Ssmall\", \"Tsmall\", \"Usmall\", \"Vsmall\", \"Wsmall\", \"Xsmall\", \"Ysmall\", \"Zsmall\", \"colonmonetary\", \"onefitted\", \"rupiah\", \"Tildesmall\", \"exclamdownsmall\", \"centoldstyle\", \"Lslashsmall\", \"Scaronsmall\", \"Zcaronsmall\", \"Dieresissmall\", \"Brevesmall\", \"Caronsmall\", \"Dotaccentsmall\", \"Macronsmall\", \"figuredash\", \"hypheninferior\", \"Ogoneksmall\", \"Ringsmall\", \"Cedillasmall\", \"onequarter\", \"onehalf\", \"threequarters\", \"questiondownsmall\", \"oneeighth\", \"threeeighths\", \"fiveeighths\", \"seveneighths\", \"onethird\", \"twothirds\", \"zerosuperior\", \"onesuperior\", \"twosuperior\", \"threesuperior\", \"foursuperior\", \"fivesuperior\", \"sixsuperior\", \"sevensuperior\", \"eightsuperior\", \"ninesuperior\", \"zeroinferior\", \"oneinferior\", \"twoinferior\", \"threeinferior\", \"fourinferior\", \"fiveinferior\", \"sixinferior\", \"seveninferior\", \"eightinferior\", \"nineinferior\", \"centinferior\", \"dollarinferior\", \"periodinferior\", \"commainferior\", \"Agravesmall\", \"Aacutesmall\", \"Acircumflexsmall\", \"Atildesmall\", \"Adieresissmall\", \"Aringsmall\", \"AEsmall\", \"Ccedillasmall\", \"Egravesmall\", \"Eacutesmall\", \"Ecircumflexsmall\", \"Edieresissmall\", \"Igravesmall\", \"Iacutesmall\", \"Icircumflexsmall\", \"Idieresissmall\", \"Ethsmall\", \"Ntildesmall\", \"Ogravesmall\", \"Oacutesmall\", \"Ocircumflexsmall\", \"Otildesmall\", \"Odieresissmall\", \"OEsmall\", \"Oslashsmall\", \"Ugravesmall\", \"Uacutesmall\", \"Ucircumflexsmall\", \"Udieresissmall\", \"Yacutesmall\", \"Thornsmall\", \"Ydieresissmall\"],\n  Qi = [\".notdef\", \"space\", \"dollaroldstyle\", \"dollarsuperior\", \"parenleftsuperior\", \"parenrightsuperior\", \"twodotenleader\", \"onedotenleader\", \"comma\", \"hyphen\", \"period\", \"fraction\", \"zerooldstyle\", \"oneoldstyle\", \"twooldstyle\", \"threeoldstyle\", \"fouroldstyle\", \"fiveoldstyle\", \"sixoldstyle\", \"sevenoldstyle\", \"eightoldstyle\", \"nineoldstyle\", \"colon\", \"semicolon\", \"commasuperior\", \"threequartersemdash\", \"periodsuperior\", \"asuperior\", \"bsuperior\", \"centsuperior\", \"dsuperior\", \"esuperior\", \"isuperior\", \"lsuperior\", \"msuperior\", \"nsuperior\", \"osuperior\", \"rsuperior\", \"ssuperior\", \"tsuperior\", \"ff\", \"fi\", \"fl\", \"ffi\", \"ffl\", \"parenleftinferior\", \"parenrightinferior\", \"hyphensuperior\", \"colonmonetary\", \"onefitted\", \"rupiah\", \"centoldstyle\", \"figuredash\", \"hypheninferior\", \"onequarter\", \"onehalf\", \"threequarters\", \"oneeighth\", \"threeeighths\", \"fiveeighths\", \"seveneighths\", \"onethird\", \"twothirds\", \"zerosuperior\", \"onesuperior\", \"twosuperior\", \"threesuperior\", \"foursuperior\", \"fivesuperior\", \"sixsuperior\", \"sevensuperior\", \"eightsuperior\", \"ninesuperior\", \"zeroinferior\", \"oneinferior\", \"twoinferior\", \"threeinferior\", \"fourinferior\", \"fiveinferior\", \"sixinferior\", \"seveninferior\", \"eightinferior\", \"nineinferior\", \"centinferior\", \"dollarinferior\", \"periodinferior\", \"commainferior\"],\n  Ei = [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"space\", \"exclamsmall\", \"Hungarumlautsmall\", \"\", \"dollaroldstyle\", \"dollarsuperior\", \"ampersandsmall\", \"Acutesmall\", \"parenleftsuperior\", \"parenrightsuperior\", \"twodotenleader\", \"onedotenleader\", \"comma\", \"hyphen\", \"period\", \"fraction\", \"zerooldstyle\", \"oneoldstyle\", \"twooldstyle\", \"threeoldstyle\", \"fouroldstyle\", \"fiveoldstyle\", \"sixoldstyle\", \"sevenoldstyle\", \"eightoldstyle\", \"nineoldstyle\", \"colon\", \"semicolon\", \"commasuperior\", \"threequartersemdash\", \"periodsuperior\", \"questionsmall\", \"\", \"asuperior\", \"bsuperior\", \"centsuperior\", \"dsuperior\", \"esuperior\", \"\", \"\", \"\", \"isuperior\", \"\", \"\", \"lsuperior\", \"msuperior\", \"nsuperior\", \"osuperior\", \"\", \"\", \"rsuperior\", \"ssuperior\", \"tsuperior\", \"\", \"ff\", \"fi\", \"fl\", \"ffi\", \"ffl\", \"parenleftinferior\", \"\", \"parenrightinferior\", \"Circumflexsmall\", \"hyphensuperior\", \"Gravesmall\", \"Asmall\", \"Bsmall\", \"Csmall\", \"Dsmall\", \"Esmall\", \"Fsmall\", \"Gsmall\", \"Hsmall\", \"Ismall\", \"Jsmall\", \"Ksmall\", \"Lsmall\", \"Msmall\", \"Nsmall\", \"Osmall\", \"Psmall\", \"Qsmall\", \"Rsmall\", \"Ssmall\", \"Tsmall\", \"Usmall\", \"Vsmall\", \"Wsmall\", \"Xsmall\", \"Ysmall\", \"Zsmall\", \"colonmonetary\", \"onefitted\", \"rupiah\", \"Tildesmall\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"exclamdownsmall\", \"centoldstyle\", \"Lslashsmall\", \"\", \"\", \"Scaronsmall\", \"Zcaronsmall\", \"Dieresissmall\", \"Brevesmall\", \"Caronsmall\", \"\", \"Dotaccentsmall\", \"\", \"\", \"Macronsmall\", \"\", \"\", \"figuredash\", \"hypheninferior\", \"\", \"\", \"Ogoneksmall\", \"Ringsmall\", \"Cedillasmall\", \"\", \"\", \"\", \"onequarter\", \"onehalf\", \"threequarters\", \"questiondownsmall\", \"oneeighth\", \"threeeighths\", \"fiveeighths\", \"seveneighths\", \"onethird\", \"twothirds\", \"\", \"\", \"zerosuperior\", \"onesuperior\", \"twosuperior\", \"threesuperior\", \"foursuperior\", \"fivesuperior\", \"sixsuperior\", \"sevensuperior\", \"eightsuperior\", \"ninesuperior\", \"zeroinferior\", \"oneinferior\", \"twoinferior\", \"threeinferior\", \"fourinferior\", \"fiveinferior\", \"sixinferior\", \"seveninferior\", \"eightinferior\", \"nineinferior\", \"centinferior\", \"dollarinferior\", \"periodinferior\", \"commainferior\", \"Agravesmall\", \"Aacutesmall\", \"Acircumflexsmall\", \"Atildesmall\", \"Adieresissmall\", \"Aringsmall\", \"AEsmall\", \"Ccedillasmall\", \"Egravesmall\", \"Eacutesmall\", \"Ecircumflexsmall\", \"Edieresissmall\", \"Igravesmall\", \"Iacutesmall\", \"Icircumflexsmall\", \"Idieresissmall\", \"Ethsmall\", \"Ntildesmall\", \"Ogravesmall\", \"Oacutesmall\", \"Ocircumflexsmall\", \"Otildesmall\", \"Odieresissmall\", \"OEsmall\", \"Oslashsmall\", \"Ugravesmall\", \"Uacutesmall\", \"Ucircumflexsmall\", \"Udieresissmall\", \"Yacutesmall\", \"Thornsmall\", \"Ydieresissmall\"],\n  ui = [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"space\", \"exclamsmall\", \"Hungarumlautsmall\", \"centoldstyle\", \"dollaroldstyle\", \"dollarsuperior\", \"ampersandsmall\", \"Acutesmall\", \"parenleftsuperior\", \"parenrightsuperior\", \"twodotenleader\", \"onedotenleader\", \"comma\", \"hyphen\", \"period\", \"fraction\", \"zerooldstyle\", \"oneoldstyle\", \"twooldstyle\", \"threeoldstyle\", \"fouroldstyle\", \"fiveoldstyle\", \"sixoldstyle\", \"sevenoldstyle\", \"eightoldstyle\", \"nineoldstyle\", \"colon\", \"semicolon\", \"\", \"threequartersemdash\", \"\", \"questionsmall\", \"\", \"\", \"\", \"\", \"Ethsmall\", \"\", \"\", \"onequarter\", \"onehalf\", \"threequarters\", \"oneeighth\", \"threeeighths\", \"fiveeighths\", \"seveneighths\", \"onethird\", \"twothirds\", \"\", \"\", \"\", \"\", \"\", \"\", \"ff\", \"fi\", \"fl\", \"ffi\", \"ffl\", \"parenleftinferior\", \"\", \"parenrightinferior\", \"Circumflexsmall\", \"hypheninferior\", \"Gravesmall\", \"Asmall\", \"Bsmall\", \"Csmall\", \"Dsmall\", \"Esmall\", \"Fsmall\", \"Gsmall\", \"Hsmall\", \"Ismall\", \"Jsmall\", \"Ksmall\", \"Lsmall\", \"Msmall\", \"Nsmall\", \"Osmall\", \"Psmall\", \"Qsmall\", \"Rsmall\", \"Ssmall\", \"Tsmall\", \"Usmall\", \"Vsmall\", \"Wsmall\", \"Xsmall\", \"Ysmall\", \"Zsmall\", \"colonmonetary\", \"onefitted\", \"rupiah\", \"Tildesmall\", \"\", \"\", \"asuperior\", \"centsuperior\", \"\", \"\", \"\", \"\", \"Aacutesmall\", \"Agravesmall\", \"Acircumflexsmall\", \"Adieresissmall\", \"Atildesmall\", \"Aringsmall\", \"Ccedillasmall\", \"Eacutesmall\", \"Egravesmall\", \"Ecircumflexsmall\", \"Edieresissmall\", \"Iacutesmall\", \"Igravesmall\", \"Icircumflexsmall\", \"Idieresissmall\", \"Ntildesmall\", \"Oacutesmall\", \"Ogravesmall\", \"Ocircumflexsmall\", \"Odieresissmall\", \"Otildesmall\", \"Uacutesmall\", \"Ugravesmall\", \"Ucircumflexsmall\", \"Udieresissmall\", \"\", \"eightsuperior\", \"fourinferior\", \"threeinferior\", \"sixinferior\", \"eightinferior\", \"seveninferior\", \"Scaronsmall\", \"\", \"centinferior\", \"twoinferior\", \"\", \"Dieresissmall\", \"\", \"Caronsmall\", \"osuperior\", \"fiveinferior\", \"\", \"commainferior\", \"periodinferior\", \"Yacutesmall\", \"\", \"dollarinferior\", \"\", \"\", \"Thornsmall\", \"\", \"nineinferior\", \"zeroinferior\", \"Zcaronsmall\", \"AEsmall\", \"Oslashsmall\", \"questiondownsmall\", \"oneinferior\", \"Lslashsmall\", \"\", \"\", \"\", \"\", \"\", \"\", \"Cedillasmall\", \"\", \"\", \"\", \"\", \"\", \"OEsmall\", \"figuredash\", \"hyphensuperior\", \"\", \"\", \"\", \"\", \"exclamdownsmall\", \"\", \"Ydieresissmall\", \"\", \"onesuperior\", \"twosuperior\", \"threesuperior\", \"foursuperior\", \"fivesuperior\", \"sixsuperior\", \"sevensuperior\", \"ninesuperior\", \"zerosuperior\", \"\", \"esuperior\", \"rsuperior\", \"tsuperior\", \"\", \"\", \"isuperior\", \"ssuperior\", \"dsuperior\", \"\", \"\", \"\", \"\", \"\", \"lsuperior\", \"Ogoneksmall\", \"Brevesmall\", \"Macronsmall\", \"bsuperior\", \"nsuperior\", \"msuperior\", \"commasuperior\", \"periodsuperior\", \"Dotaccentsmall\", \"Ringsmall\", \"\", \"\", \"\", \"\"],\n  di = [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"space\", \"exclam\", \"quotedbl\", \"numbersign\", \"dollar\", \"percent\", \"ampersand\", \"quotesingle\", \"parenleft\", \"parenright\", \"asterisk\", \"plus\", \"comma\", \"hyphen\", \"period\", \"slash\", \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"colon\", \"semicolon\", \"less\", \"equal\", \"greater\", \"question\", \"at\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"bracketleft\", \"backslash\", \"bracketright\", \"asciicircum\", \"underscore\", \"grave\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"braceleft\", \"bar\", \"braceright\", \"asciitilde\", \"\", \"Adieresis\", \"Aring\", \"Ccedilla\", \"Eacute\", \"Ntilde\", \"Odieresis\", \"Udieresis\", \"aacute\", \"agrave\", \"acircumflex\", \"adieresis\", \"atilde\", \"aring\", \"ccedilla\", \"eacute\", \"egrave\", \"ecircumflex\", \"edieresis\", \"iacute\", \"igrave\", \"icircumflex\", \"idieresis\", \"ntilde\", \"oacute\", \"ograve\", \"ocircumflex\", \"odieresis\", \"otilde\", \"uacute\", \"ugrave\", \"ucircumflex\", \"udieresis\", \"dagger\", \"degree\", \"cent\", \"sterling\", \"section\", \"bullet\", \"paragraph\", \"germandbls\", \"registered\", \"copyright\", \"trademark\", \"acute\", \"dieresis\", \"notequal\", \"AE\", \"Oslash\", \"infinity\", \"plusminus\", \"lessequal\", \"greaterequal\", \"yen\", \"mu\", \"partialdiff\", \"summation\", \"product\", \"pi\", \"integral\", \"ordfeminine\", \"ordmasculine\", \"Omega\", \"ae\", \"oslash\", \"questiondown\", \"exclamdown\", \"logicalnot\", \"radical\", \"florin\", \"approxequal\", \"Delta\", \"guillemotleft\", \"guillemotright\", \"ellipsis\", \"space\", \"Agrave\", \"Atilde\", \"Otilde\", \"OE\", \"oe\", \"endash\", \"emdash\", \"quotedblleft\", \"quotedblright\", \"quoteleft\", \"quoteright\", \"divide\", \"lozenge\", \"ydieresis\", \"Ydieresis\", \"fraction\", \"currency\", \"guilsinglleft\", \"guilsinglright\", \"fi\", \"fl\", \"daggerdbl\", \"periodcentered\", \"quotesinglbase\", \"quotedblbase\", \"perthousand\", \"Acircumflex\", \"Ecircumflex\", \"Aacute\", \"Edieresis\", \"Egrave\", \"Iacute\", \"Icircumflex\", \"Idieresis\", \"Igrave\", \"Oacute\", \"Ocircumflex\", \"apple\", \"Ograve\", \"Uacute\", \"Ucircumflex\", \"Ugrave\", \"dotlessi\", \"circumflex\", \"tilde\", \"macron\", \"breve\", \"dotaccent\", \"ring\", \"cedilla\", \"hungarumlaut\", \"ogonek\", \"caron\"],\n  fi = [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"space\", \"exclam\", \"quotedbl\", \"numbersign\", \"dollar\", \"percent\", \"ampersand\", \"quoteright\", \"parenleft\", \"parenright\", \"asterisk\", \"plus\", \"comma\", \"hyphen\", \"period\", \"slash\", \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"colon\", \"semicolon\", \"less\", \"equal\", \"greater\", \"question\", \"at\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"bracketleft\", \"backslash\", \"bracketright\", \"asciicircum\", \"underscore\", \"quoteleft\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"braceleft\", \"bar\", \"braceright\", \"asciitilde\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"exclamdown\", \"cent\", \"sterling\", \"fraction\", \"yen\", \"florin\", \"section\", \"currency\", \"quotesingle\", \"quotedblleft\", \"guillemotleft\", \"guilsinglleft\", \"guilsinglright\", \"fi\", \"fl\", \"\", \"endash\", \"dagger\", \"daggerdbl\", \"periodcentered\", \"\", \"paragraph\", \"bullet\", \"quotesinglbase\", \"quotedblbase\", \"quotedblright\", \"guillemotright\", \"ellipsis\", \"perthousand\", \"\", \"questiondown\", \"\", \"grave\", \"acute\", \"circumflex\", \"tilde\", \"macron\", \"breve\", \"dotaccent\", \"dieresis\", \"\", \"ring\", \"cedilla\", \"\", \"hungarumlaut\", \"ogonek\", \"caron\", \"emdash\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"AE\", \"\", \"ordfeminine\", \"\", \"\", \"\", \"\", \"Lslash\", \"Oslash\", \"OE\", \"ordmasculine\", \"\", \"\", \"\", \"\", \"\", \"ae\", \"\", \"\", \"\", \"dotlessi\", \"\", \"\", \"lslash\", \"oslash\", \"oe\", \"germandbls\", \"\", \"\", \"\", \"\"],\n  pi = [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"space\", \"exclam\", \"quotedbl\", \"numbersign\", \"dollar\", \"percent\", \"ampersand\", \"quotesingle\", \"parenleft\", \"parenright\", \"asterisk\", \"plus\", \"comma\", \"hyphen\", \"period\", \"slash\", \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"colon\", \"semicolon\", \"less\", \"equal\", \"greater\", \"question\", \"at\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"bracketleft\", \"backslash\", \"bracketright\", \"asciicircum\", \"underscore\", \"grave\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"braceleft\", \"bar\", \"braceright\", \"asciitilde\", \"bullet\", \"Euro\", \"bullet\", \"quotesinglbase\", \"florin\", \"quotedblbase\", \"ellipsis\", \"dagger\", \"daggerdbl\", \"circumflex\", \"perthousand\", \"Scaron\", \"guilsinglleft\", \"OE\", \"bullet\", \"Zcaron\", \"bullet\", \"bullet\", \"quoteleft\", \"quoteright\", \"quotedblleft\", \"quotedblright\", \"bullet\", \"endash\", \"emdash\", \"tilde\", \"trademark\", \"scaron\", \"guilsinglright\", \"oe\", \"bullet\", \"zcaron\", \"Ydieresis\", \"space\", \"exclamdown\", \"cent\", \"sterling\", \"currency\", \"yen\", \"brokenbar\", \"section\", \"dieresis\", \"copyright\", \"ordfeminine\", \"guillemotleft\", \"logicalnot\", \"hyphen\", \"registered\", \"macron\", \"degree\", \"plusminus\", \"twosuperior\", \"threesuperior\", \"acute\", \"mu\", \"paragraph\", \"periodcentered\", \"cedilla\", \"onesuperior\", \"ordmasculine\", \"guillemotright\", \"onequarter\", \"onehalf\", \"threequarters\", \"questiondown\", \"Agrave\", \"Aacute\", \"Acircumflex\", \"Atilde\", \"Adieresis\", \"Aring\", \"AE\", \"Ccedilla\", \"Egrave\", \"Eacute\", \"Ecircumflex\", \"Edieresis\", \"Igrave\", \"Iacute\", \"Icircumflex\", \"Idieresis\", \"Eth\", \"Ntilde\", \"Ograve\", \"Oacute\", \"Ocircumflex\", \"Otilde\", \"Odieresis\", \"multiply\", \"Oslash\", \"Ugrave\", \"Uacute\", \"Ucircumflex\", \"Udieresis\", \"Yacute\", \"Thorn\", \"germandbls\", \"agrave\", \"aacute\", \"acircumflex\", \"atilde\", \"adieresis\", \"aring\", \"ae\", \"ccedilla\", \"egrave\", \"eacute\", \"ecircumflex\", \"edieresis\", \"igrave\", \"iacute\", \"icircumflex\", \"idieresis\", \"eth\", \"ntilde\", \"ograve\", \"oacute\", \"ocircumflex\", \"otilde\", \"odieresis\", \"divide\", \"oslash\", \"ugrave\", \"uacute\", \"ucircumflex\", \"udieresis\", \"yacute\", \"thorn\", \"ydieresis\"],\n  mi = [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"space\", \"exclam\", \"universal\", \"numbersign\", \"existential\", \"percent\", \"ampersand\", \"suchthat\", \"parenleft\", \"parenright\", \"asteriskmath\", \"plus\", \"comma\", \"minus\", \"period\", \"slash\", \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"colon\", \"semicolon\", \"less\", \"equal\", \"greater\", \"question\", \"congruent\", \"Alpha\", \"Beta\", \"Chi\", \"Delta\", \"Epsilon\", \"Phi\", \"Gamma\", \"Eta\", \"Iota\", \"theta1\", \"Kappa\", \"Lambda\", \"Mu\", \"Nu\", \"Omicron\", \"Pi\", \"Theta\", \"Rho\", \"Sigma\", \"Tau\", \"Upsilon\", \"sigma1\", \"Omega\", \"Xi\", \"Psi\", \"Zeta\", \"bracketleft\", \"therefore\", \"bracketright\", \"perpendicular\", \"underscore\", \"radicalex\", \"alpha\", \"beta\", \"chi\", \"delta\", \"epsilon\", \"phi\", \"gamma\", \"eta\", \"iota\", \"phi1\", \"kappa\", \"lambda\", \"mu\", \"nu\", \"omicron\", \"pi\", \"theta\", \"rho\", \"sigma\", \"tau\", \"upsilon\", \"omega1\", \"omega\", \"xi\", \"psi\", \"zeta\", \"braceleft\", \"bar\", \"braceright\", \"similar\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"Euro\", \"Upsilon1\", \"minute\", \"lessequal\", \"fraction\", \"infinity\", \"florin\", \"club\", \"diamond\", \"heart\", \"spade\", \"arrowboth\", \"arrowleft\", \"arrowup\", \"arrowright\", \"arrowdown\", \"degree\", \"plusminus\", \"second\", \"greaterequal\", \"multiply\", \"proportional\", \"partialdiff\", \"bullet\", \"divide\", \"notequal\", \"equivalence\", \"approxequal\", \"ellipsis\", \"arrowvertex\", \"arrowhorizex\", \"carriagereturn\", \"aleph\", \"Ifraktur\", \"Rfraktur\", \"weierstrass\", \"circlemultiply\", \"circleplus\", \"emptyset\", \"intersection\", \"union\", \"propersuperset\", \"reflexsuperset\", \"notsubset\", \"propersubset\", \"reflexsubset\", \"element\", \"notelement\", \"angle\", \"gradient\", \"registerserif\", \"copyrightserif\", \"trademarkserif\", \"product\", \"radical\", \"dotmath\", \"logicalnot\", \"logicaland\", \"logicalor\", \"arrowdblboth\", \"arrowdblleft\", \"arrowdblup\", \"arrowdblright\", \"arrowdbldown\", \"lozenge\", \"angleleft\", \"registersans\", \"copyrightsans\", \"trademarksans\", \"summation\", \"parenlefttp\", \"parenleftex\", \"parenleftbt\", \"bracketlefttp\", \"bracketleftex\", \"bracketleftbt\", \"bracelefttp\", \"braceleftmid\", \"braceleftbt\", \"braceex\", \"\", \"angleright\", \"integral\", \"integraltp\", \"integralex\", \"integralbt\", \"parenrighttp\", \"parenrightex\", \"parenrightbt\", \"bracketrighttp\", \"bracketrightex\", \"bracketrightbt\", \"bracerighttp\", \"bracerightmid\", \"bracerightbt\", \"\"],\n  yi = [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"space\", \"a1\", \"a2\", \"a202\", \"a3\", \"a4\", \"a5\", \"a119\", \"a118\", \"a117\", \"a11\", \"a12\", \"a13\", \"a14\", \"a15\", \"a16\", \"a105\", \"a17\", \"a18\", \"a19\", \"a20\", \"a21\", \"a22\", \"a23\", \"a24\", \"a25\", \"a26\", \"a27\", \"a28\", \"a6\", \"a7\", \"a8\", \"a9\", \"a10\", \"a29\", \"a30\", \"a31\", \"a32\", \"a33\", \"a34\", \"a35\", \"a36\", \"a37\", \"a38\", \"a39\", \"a40\", \"a41\", \"a42\", \"a43\", \"a44\", \"a45\", \"a46\", \"a47\", \"a48\", \"a49\", \"a50\", \"a51\", \"a52\", \"a53\", \"a54\", \"a55\", \"a56\", \"a57\", \"a58\", \"a59\", \"a60\", \"a61\", \"a62\", \"a63\", \"a64\", \"a65\", \"a66\", \"a67\", \"a68\", \"a69\", \"a70\", \"a71\", \"a72\", \"a73\", \"a74\", \"a203\", \"a75\", \"a204\", \"a76\", \"a77\", \"a78\", \"a79\", \"a81\", \"a82\", \"a83\", \"a84\", \"a97\", \"a98\", \"a99\", \"a100\", \"\", \"a89\", \"a90\", \"a93\", \"a94\", \"a91\", \"a92\", \"a205\", \"a85\", \"a206\", \"a86\", \"a87\", \"a88\", \"a95\", \"a96\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"a101\", \"a102\", \"a103\", \"a104\", \"a106\", \"a107\", \"a108\", \"a112\", \"a111\", \"a110\", \"a109\", \"a120\", \"a121\", \"a122\", \"a123\", \"a124\", \"a125\", \"a126\", \"a127\", \"a128\", \"a129\", \"a130\", \"a131\", \"a132\", \"a133\", \"a134\", \"a135\", \"a136\", \"a137\", \"a138\", \"a139\", \"a140\", \"a141\", \"a142\", \"a143\", \"a144\", \"a145\", \"a146\", \"a147\", \"a148\", \"a149\", \"a150\", \"a151\", \"a152\", \"a153\", \"a154\", \"a155\", \"a156\", \"a157\", \"a158\", \"a159\", \"a160\", \"a161\", \"a163\", \"a164\", \"a196\", \"a165\", \"a192\", \"a166\", \"a167\", \"a168\", \"a169\", \"a170\", \"a171\", \"a172\", \"a173\", \"a162\", \"a174\", \"a175\", \"a176\", \"a177\", \"a178\", \"a179\", \"a193\", \"a180\", \"a199\", \"a181\", \"a200\", \"a182\", \"\", \"a201\", \"a183\", \"a184\", \"a197\", \"a185\", \"a194\", \"a198\", \"a186\", \"a195\", \"a187\", \"a188\", \"a189\", \"a190\", \"a191\", \"\"];\nfunction getEncoding(e) {\n  switch (e) {\n    case \"WinAnsiEncoding\":\n      return pi;\n    case \"StandardEncoding\":\n      return fi;\n    case \"MacRomanEncoding\":\n      return di;\n    case \"SymbolSetEncoding\":\n      return mi;\n    case \"ZapfDingbatsEncoding\":\n      return yi;\n    case \"ExpertEncoding\":\n      return Ei;\n    case \"MacExpertEncoding\":\n      return ui;\n    default:\n      return null;\n  }\n}\nconst wi = [\".notdef\", \"space\", \"exclam\", \"quotedbl\", \"numbersign\", \"dollar\", \"percent\", \"ampersand\", \"quoteright\", \"parenleft\", \"parenright\", \"asterisk\", \"plus\", \"comma\", \"hyphen\", \"period\", \"slash\", \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"colon\", \"semicolon\", \"less\", \"equal\", \"greater\", \"question\", \"at\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"bracketleft\", \"backslash\", \"bracketright\", \"asciicircum\", \"underscore\", \"quoteleft\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"braceleft\", \"bar\", \"braceright\", \"asciitilde\", \"exclamdown\", \"cent\", \"sterling\", \"fraction\", \"yen\", \"florin\", \"section\", \"currency\", \"quotesingle\", \"quotedblleft\", \"guillemotleft\", \"guilsinglleft\", \"guilsinglright\", \"fi\", \"fl\", \"endash\", \"dagger\", \"daggerdbl\", \"periodcentered\", \"paragraph\", \"bullet\", \"quotesinglbase\", \"quotedblbase\", \"quotedblright\", \"guillemotright\", \"ellipsis\", \"perthousand\", \"questiondown\", \"grave\", \"acute\", \"circumflex\", \"tilde\", \"macron\", \"breve\", \"dotaccent\", \"dieresis\", \"ring\", \"cedilla\", \"hungarumlaut\", \"ogonek\", \"caron\", \"emdash\", \"AE\", \"ordfeminine\", \"Lslash\", \"Oslash\", \"OE\", \"ordmasculine\", \"ae\", \"dotlessi\", \"lslash\", \"oslash\", \"oe\", \"germandbls\", \"onesuperior\", \"logicalnot\", \"mu\", \"trademark\", \"Eth\", \"onehalf\", \"plusminus\", \"Thorn\", \"onequarter\", \"divide\", \"brokenbar\", \"degree\", \"thorn\", \"threequarters\", \"twosuperior\", \"registered\", \"minus\", \"eth\", \"multiply\", \"threesuperior\", \"copyright\", \"Aacute\", \"Acircumflex\", \"Adieresis\", \"Agrave\", \"Aring\", \"Atilde\", \"Ccedilla\", \"Eacute\", \"Ecircumflex\", \"Edieresis\", \"Egrave\", \"Iacute\", \"Icircumflex\", \"Idieresis\", \"Igrave\", \"Ntilde\", \"Oacute\", \"Ocircumflex\", \"Odieresis\", \"Ograve\", \"Otilde\", \"Scaron\", \"Uacute\", \"Ucircumflex\", \"Udieresis\", \"Ugrave\", \"Yacute\", \"Ydieresis\", \"Zcaron\", \"aacute\", \"acircumflex\", \"adieresis\", \"agrave\", \"aring\", \"atilde\", \"ccedilla\", \"eacute\", \"ecircumflex\", \"edieresis\", \"egrave\", \"iacute\", \"icircumflex\", \"idieresis\", \"igrave\", \"ntilde\", \"oacute\", \"ocircumflex\", \"odieresis\", \"ograve\", \"otilde\", \"scaron\", \"uacute\", \"ucircumflex\", \"udieresis\", \"ugrave\", \"yacute\", \"ydieresis\", \"zcaron\", \"exclamsmall\", \"Hungarumlautsmall\", \"dollaroldstyle\", \"dollarsuperior\", \"ampersandsmall\", \"Acutesmall\", \"parenleftsuperior\", \"parenrightsuperior\", \"twodotenleader\", \"onedotenleader\", \"zerooldstyle\", \"oneoldstyle\", \"twooldstyle\", \"threeoldstyle\", \"fouroldstyle\", \"fiveoldstyle\", \"sixoldstyle\", \"sevenoldstyle\", \"eightoldstyle\", \"nineoldstyle\", \"commasuperior\", \"threequartersemdash\", \"periodsuperior\", \"questionsmall\", \"asuperior\", \"bsuperior\", \"centsuperior\", \"dsuperior\", \"esuperior\", \"isuperior\", \"lsuperior\", \"msuperior\", \"nsuperior\", \"osuperior\", \"rsuperior\", \"ssuperior\", \"tsuperior\", \"ff\", \"ffi\", \"ffl\", \"parenleftinferior\", \"parenrightinferior\", \"Circumflexsmall\", \"hyphensuperior\", \"Gravesmall\", \"Asmall\", \"Bsmall\", \"Csmall\", \"Dsmall\", \"Esmall\", \"Fsmall\", \"Gsmall\", \"Hsmall\", \"Ismall\", \"Jsmall\", \"Ksmall\", \"Lsmall\", \"Msmall\", \"Nsmall\", \"Osmall\", \"Psmall\", \"Qsmall\", \"Rsmall\", \"Ssmall\", \"Tsmall\", \"Usmall\", \"Vsmall\", \"Wsmall\", \"Xsmall\", \"Ysmall\", \"Zsmall\", \"colonmonetary\", \"onefitted\", \"rupiah\", \"Tildesmall\", \"exclamdownsmall\", \"centoldstyle\", \"Lslashsmall\", \"Scaronsmall\", \"Zcaronsmall\", \"Dieresissmall\", \"Brevesmall\", \"Caronsmall\", \"Dotaccentsmall\", \"Macronsmall\", \"figuredash\", \"hypheninferior\", \"Ogoneksmall\", \"Ringsmall\", \"Cedillasmall\", \"questiondownsmall\", \"oneeighth\", \"threeeighths\", \"fiveeighths\", \"seveneighths\", \"onethird\", \"twothirds\", \"zerosuperior\", \"foursuperior\", \"fivesuperior\", \"sixsuperior\", \"sevensuperior\", \"eightsuperior\", \"ninesuperior\", \"zeroinferior\", \"oneinferior\", \"twoinferior\", \"threeinferior\", \"fourinferior\", \"fiveinferior\", \"sixinferior\", \"seveninferior\", \"eightinferior\", \"nineinferior\", \"centinferior\", \"dollarinferior\", \"periodinferior\", \"commainferior\", \"Agravesmall\", \"Aacutesmall\", \"Acircumflexsmall\", \"Atildesmall\", \"Adieresissmall\", \"Aringsmall\", \"AEsmall\", \"Ccedillasmall\", \"Egravesmall\", \"Eacutesmall\", \"Ecircumflexsmall\", \"Edieresissmall\", \"Igravesmall\", \"Iacutesmall\", \"Icircumflexsmall\", \"Idieresissmall\", \"Ethsmall\", \"Ntildesmall\", \"Ogravesmall\", \"Oacutesmall\", \"Ocircumflexsmall\", \"Otildesmall\", \"Odieresissmall\", \"OEsmall\", \"Oslashsmall\", \"Ugravesmall\", \"Uacutesmall\", \"Ucircumflexsmall\", \"Udieresissmall\", \"Yacutesmall\", \"Thornsmall\", \"Ydieresissmall\", \"001.000\", \"001.001\", \"001.002\", \"001.003\", \"Black\", \"Bold\", \"Book\", \"Light\", \"Medium\", \"Regular\", \"Roman\", \"Semibold\"],\n  Di = 391,\n  bi = [null, {\n    id: \"hstem\",\n    min: 2,\n    stackClearing: !0,\n    stem: !0\n  }, null, {\n    id: \"vstem\",\n    min: 2,\n    stackClearing: !0,\n    stem: !0\n  }, {\n    id: \"vmoveto\",\n    min: 1,\n    stackClearing: !0\n  }, {\n    id: \"rlineto\",\n    min: 2,\n    resetStack: !0\n  }, {\n    id: \"hlineto\",\n    min: 1,\n    resetStack: !0\n  }, {\n    id: \"vlineto\",\n    min: 1,\n    resetStack: !0\n  }, {\n    id: \"rrcurveto\",\n    min: 6,\n    resetStack: !0\n  }, null, {\n    id: \"callsubr\",\n    min: 1,\n    undefStack: !0\n  }, {\n    id: \"return\",\n    min: 0,\n    undefStack: !0\n  }, null, null, {\n    id: \"endchar\",\n    min: 0,\n    stackClearing: !0\n  }, null, null, null, {\n    id: \"hstemhm\",\n    min: 2,\n    stackClearing: !0,\n    stem: !0\n  }, {\n    id: \"hintmask\",\n    min: 0,\n    stackClearing: !0\n  }, {\n    id: \"cntrmask\",\n    min: 0,\n    stackClearing: !0\n  }, {\n    id: \"rmoveto\",\n    min: 2,\n    stackClearing: !0\n  }, {\n    id: \"hmoveto\",\n    min: 1,\n    stackClearing: !0\n  }, {\n    id: \"vstemhm\",\n    min: 2,\n    stackClearing: !0,\n    stem: !0\n  }, {\n    id: \"rcurveline\",\n    min: 8,\n    resetStack: !0\n  }, {\n    id: \"rlinecurve\",\n    min: 8,\n    resetStack: !0\n  }, {\n    id: \"vvcurveto\",\n    min: 4,\n    resetStack: !0\n  }, {\n    id: \"hhcurveto\",\n    min: 4,\n    resetStack: !0\n  }, null, {\n    id: \"callgsubr\",\n    min: 1,\n    undefStack: !0\n  }, {\n    id: \"vhcurveto\",\n    min: 4,\n    resetStack: !0\n  }, {\n    id: \"hvcurveto\",\n    min: 4,\n    resetStack: !0\n  }],\n  Fi = [null, null, null, {\n    id: \"and\",\n    min: 2,\n    stackDelta: -1\n  }, {\n    id: \"or\",\n    min: 2,\n    stackDelta: -1\n  }, {\n    id: \"not\",\n    min: 1,\n    stackDelta: 0\n  }, null, null, null, {\n    id: \"abs\",\n    min: 1,\n    stackDelta: 0\n  }, {\n    id: \"add\",\n    min: 2,\n    stackDelta: -1,\n    stackFn(e, t) {\n      e[t - 2] = e[t - 2] + e[t - 1];\n    }\n  }, {\n    id: \"sub\",\n    min: 2,\n    stackDelta: -1,\n    stackFn(e, t) {\n      e[t - 2] = e[t - 2] - e[t - 1];\n    }\n  }, {\n    id: \"div\",\n    min: 2,\n    stackDelta: -1,\n    stackFn(e, t) {\n      e[t - 2] = e[t - 2] / e[t - 1];\n    }\n  }, null, {\n    id: \"neg\",\n    min: 1,\n    stackDelta: 0,\n    stackFn(e, t) {\n      e[t - 1] = -e[t - 1];\n    }\n  }, {\n    id: \"eq\",\n    min: 2,\n    stackDelta: -1\n  }, null, null, {\n    id: \"drop\",\n    min: 1,\n    stackDelta: -1\n  }, null, {\n    id: \"put\",\n    min: 2,\n    stackDelta: -2\n  }, {\n    id: \"get\",\n    min: 1,\n    stackDelta: 0\n  }, {\n    id: \"ifelse\",\n    min: 4,\n    stackDelta: -3\n  }, {\n    id: \"random\",\n    min: 0,\n    stackDelta: 1\n  }, {\n    id: \"mul\",\n    min: 2,\n    stackDelta: -1,\n    stackFn(e, t) {\n      e[t - 2] = e[t - 2] * e[t - 1];\n    }\n  }, null, {\n    id: \"sqrt\",\n    min: 1,\n    stackDelta: 0\n  }, {\n    id: \"dup\",\n    min: 1,\n    stackDelta: 1\n  }, {\n    id: \"exch\",\n    min: 2,\n    stackDelta: 0\n  }, {\n    id: \"index\",\n    min: 2,\n    stackDelta: 0\n  }, {\n    id: \"roll\",\n    min: 3,\n    stackDelta: -2\n  }, null, null, null, {\n    id: \"hflex\",\n    min: 7,\n    resetStack: !0\n  }, {\n    id: \"flex\",\n    min: 13,\n    resetStack: !0\n  }, {\n    id: \"hflex1\",\n    min: 9,\n    resetStack: !0\n  }, {\n    id: \"flex1\",\n    min: 11,\n    resetStack: !0\n  }];\nclass CFFParser {\n  constructor(e, t, i) {\n    this.bytes = e.getBytes();\n    this.properties = t;\n    this.seacAnalysisEnabled = !!i;\n  }\n  parse() {\n    const e = this.properties,\n      t = new CFF();\n    this.cff = t;\n    const i = this.parseHeader(),\n      a = this.parseIndex(i.endPos),\n      s = this.parseIndex(a.endPos),\n      r = this.parseIndex(s.endPos),\n      n = this.parseIndex(r.endPos),\n      g = this.parseDict(s.obj.get(0)),\n      o = this.createDict(CFFTopDict, g, t.strings);\n    t.header = i.obj;\n    t.names = this.parseNameIndex(a.obj);\n    t.strings = this.parseStringIndex(r.obj);\n    t.topDict = o;\n    t.globalSubrIndex = n.obj;\n    this.parsePrivateDict(t.topDict);\n    t.isCIDFont = o.hasName(\"ROS\");\n    const c = o.getByName(\"CharStrings\"),\n      C = this.parseIndex(c).obj,\n      h = o.getByName(\"FontMatrix\");\n    h && (e.fontMatrix = h);\n    const l = o.getByName(\"FontBBox\");\n    if (l) {\n      e.ascent = Math.max(l[3], l[1]);\n      e.descent = Math.min(l[1], l[3]);\n      e.ascentScaled = !0;\n    }\n    let Q, E;\n    if (t.isCIDFont) {\n      const e = this.parseIndex(o.getByName(\"FDArray\")).obj;\n      for (let i = 0, a = e.count; i < a; ++i) {\n        const a = e.get(i),\n          s = this.createDict(CFFTopDict, this.parseDict(a), t.strings);\n        this.parsePrivateDict(s);\n        t.fdArray.push(s);\n      }\n      E = null;\n      Q = this.parseCharsets(o.getByName(\"charset\"), C.count, t.strings, !0);\n      t.fdSelect = this.parseFDSelect(o.getByName(\"FDSelect\"), C.count);\n    } else {\n      Q = this.parseCharsets(o.getByName(\"charset\"), C.count, t.strings, !1);\n      E = this.parseEncoding(o.getByName(\"Encoding\"), e, t.strings, Q.charset);\n    }\n    t.charset = Q;\n    t.encoding = E;\n    const u = this.parseCharStrings({\n      charStrings: C,\n      localSubrIndex: o.privateDict.subrsIndex,\n      globalSubrIndex: n.obj,\n      fdSelect: t.fdSelect,\n      fdArray: t.fdArray,\n      privateDict: o.privateDict\n    });\n    t.charStrings = u.charStrings;\n    t.seacs = u.seacs;\n    t.widths = u.widths;\n    return t;\n  }\n  parseHeader() {\n    let e = this.bytes;\n    const t = e.length;\n    let i = 0;\n    for (; i < t && 1 !== e[i];) ++i;\n    if (i >= t) throw new FormatError(\"Invalid CFF header\");\n    if (0 !== i) {\n      info(\"cff data is shifted\");\n      e = e.subarray(i);\n      this.bytes = e;\n    }\n    const a = e[0],\n      s = e[1],\n      r = e[2],\n      n = e[3];\n    return {\n      obj: new CFFHeader(a, s, r, n),\n      endPos: r\n    };\n  }\n  parseDict(e) {\n    let t = 0;\n    function parseOperand() {\n      let i = e[t++];\n      if (30 === i) return function parseFloatOperand() {\n        let i = \"\";\n        const a = 15,\n          s = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \".\", \"E\", \"E-\", null, \"-\"],\n          r = e.length;\n        for (; t < r;) {\n          const r = e[t++],\n            n = r >> 4,\n            g = 15 & r;\n          if (n === a) break;\n          i += s[n];\n          if (g === a) break;\n          i += s[g];\n        }\n        return parseFloat(i);\n      }();\n      if (28 === i) {\n        i = e[t++];\n        i = (i << 24 | e[t++] << 16) >> 16;\n        return i;\n      }\n      if (29 === i) {\n        i = e[t++];\n        i = i << 8 | e[t++];\n        i = i << 8 | e[t++];\n        i = i << 8 | e[t++];\n        return i;\n      }\n      if (i >= 32 && i <= 246) return i - 139;\n      if (i >= 247 && i <= 250) return 256 * (i - 247) + e[t++] + 108;\n      if (i >= 251 && i <= 254) return -256 * (i - 251) - e[t++] - 108;\n      warn('CFFParser_parseDict: \"' + i + '\" is a reserved command.');\n      return NaN;\n    }\n    let i = [];\n    const a = [];\n    t = 0;\n    const s = e.length;\n    for (; t < s;) {\n      let s = e[t];\n      if (s <= 21) {\n        12 === s && (s = s << 8 | e[++t]);\n        a.push([s, i]);\n        i = [];\n        ++t;\n      } else i.push(parseOperand());\n    }\n    return a;\n  }\n  parseIndex(e) {\n    const t = new CFFIndex(),\n      i = this.bytes,\n      a = i[e++] << 8 | i[e++],\n      s = [];\n    let r,\n      n,\n      g = e;\n    if (0 !== a) {\n      const t = i[e++],\n        o = e + (a + 1) * t - 1;\n      for (r = 0, n = a + 1; r < n; ++r) {\n        let a = 0;\n        for (let s = 0; s < t; ++s) {\n          a <<= 8;\n          a += i[e++];\n        }\n        s.push(o + a);\n      }\n      g = s[a];\n    }\n    for (r = 0, n = s.length - 1; r < n; ++r) {\n      const e = s[r],\n        a = s[r + 1];\n      t.add(i.subarray(e, a));\n    }\n    return {\n      obj: t,\n      endPos: g\n    };\n  }\n  parseNameIndex(e) {\n    const t = [];\n    for (let i = 0, a = e.count; i < a; ++i) {\n      const a = e.get(i);\n      t.push(bytesToString(a));\n    }\n    return t;\n  }\n  parseStringIndex(e) {\n    const t = new CFFStrings();\n    for (let i = 0, a = e.count; i < a; ++i) {\n      const a = e.get(i);\n      t.add(bytesToString(a));\n    }\n    return t;\n  }\n  createDict(e, t, i) {\n    const a = new e(i);\n    for (const [e, i] of t) a.setByKey(e, i);\n    return a;\n  }\n  parseCharString(e, t, i, a) {\n    if (!t || e.callDepth > 10) return !1;\n    let s = e.stackSize;\n    const r = e.stack;\n    let n = t.length;\n    for (let g = 0; g < n;) {\n      const o = t[g++];\n      let c = null;\n      if (12 === o) {\n        const e = t[g++];\n        if (0 === e) {\n          t[g - 2] = 139;\n          t[g - 1] = 22;\n          s = 0;\n        } else c = Fi[e];\n      } else if (28 === o) {\n        r[s] = (t[g] << 24 | t[g + 1] << 16) >> 16;\n        g += 2;\n        s++;\n      } else if (14 === o) {\n        if (s >= 4) {\n          s -= 4;\n          if (this.seacAnalysisEnabled) {\n            e.seac = r.slice(s, s + 4);\n            return !1;\n          }\n        }\n        c = bi[o];\n      } else if (o >= 32 && o <= 246) {\n        r[s] = o - 139;\n        s++;\n      } else if (o >= 247 && o <= 254) {\n        r[s] = o < 251 ? (o - 247 << 8) + t[g] + 108 : -(o - 251 << 8) - t[g] - 108;\n        g++;\n        s++;\n      } else if (255 === o) {\n        r[s] = (t[g] << 24 | t[g + 1] << 16 | t[g + 2] << 8 | t[g + 3]) / 65536;\n        g += 4;\n        s++;\n      } else if (19 === o || 20 === o) {\n        e.hints += s >> 1;\n        if (0 === e.hints) {\n          t.copyWithin(g - 1, g, -1);\n          g -= 1;\n          n -= 1;\n          continue;\n        }\n        g += e.hints + 7 >> 3;\n        s %= 2;\n        c = bi[o];\n      } else {\n        if (10 === o || 29 === o) {\n          const t = 10 === o ? i : a;\n          if (!t) {\n            c = bi[o];\n            warn(\"Missing subrsIndex for \" + c.id);\n            return !1;\n          }\n          let n = 32768;\n          t.count < 1240 ? n = 107 : t.count < 33900 && (n = 1131);\n          const g = r[--s] + n;\n          if (g < 0 || g >= t.count || isNaN(g)) {\n            c = bi[o];\n            warn(\"Out of bounds subrIndex for \" + c.id);\n            return !1;\n          }\n          e.stackSize = s;\n          e.callDepth++;\n          if (!this.parseCharString(e, t.get(g), i, a)) return !1;\n          e.callDepth--;\n          s = e.stackSize;\n          continue;\n        }\n        if (11 === o) {\n          e.stackSize = s;\n          return !0;\n        }\n        if (0 === o && g === t.length) {\n          t[g - 1] = 14;\n          c = bi[14];\n        } else {\n          if (9 === o) {\n            t.copyWithin(g - 1, g, -1);\n            g -= 1;\n            n -= 1;\n            continue;\n          }\n          c = bi[o];\n        }\n      }\n      if (c) {\n        if (c.stem) {\n          e.hints += s >> 1;\n          if (3 === o || 23 === o) e.hasVStems = !0;else if (e.hasVStems && (1 === o || 18 === o)) {\n            warn(\"CFF stem hints are in wrong order\");\n            t[g - 1] = 1 === o ? 3 : 23;\n          }\n        }\n        if (\"min\" in c && !e.undefStack && s < c.min) {\n          warn(\"Not enough parameters for \" + c.id + \"; actual: \" + s + \", expected: \" + c.min);\n          if (0 === s) {\n            t[g - 1] = 14;\n            return !0;\n          }\n          return !1;\n        }\n        if (e.firstStackClearing && c.stackClearing) {\n          e.firstStackClearing = !1;\n          s -= c.min;\n          s >= 2 && c.stem ? s %= 2 : s > 1 && warn(\"Found too many parameters for stack-clearing command\");\n          s > 0 && (e.width = r[s - 1]);\n        }\n        if (\"stackDelta\" in c) {\n          \"stackFn\" in c && c.stackFn(r, s);\n          s += c.stackDelta;\n        } else if (c.stackClearing) s = 0;else if (c.resetStack) {\n          s = 0;\n          e.undefStack = !1;\n        } else if (c.undefStack) {\n          s = 0;\n          e.undefStack = !0;\n          e.firstStackClearing = !1;\n        }\n      }\n    }\n    n < t.length && t.fill(14, n);\n    e.stackSize = s;\n    return !0;\n  }\n  parseCharStrings({\n    charStrings: e,\n    localSubrIndex: t,\n    globalSubrIndex: i,\n    fdSelect: a,\n    fdArray: s,\n    privateDict: r\n  }) {\n    const n = [],\n      g = [],\n      o = e.count;\n    for (let c = 0; c < o; c++) {\n      const o = e.get(c),\n        C = {\n          callDepth: 0,\n          stackSize: 0,\n          stack: [],\n          undefStack: !0,\n          hints: 0,\n          firstStackClearing: !0,\n          seac: null,\n          width: null,\n          hasVStems: !1\n        };\n      let h = !0,\n        l = null,\n        Q = r;\n      if (a && s.length) {\n        const e = a.getFDIndex(c);\n        if (-1 === e) {\n          warn(\"Glyph index is not in fd select.\");\n          h = !1;\n        }\n        if (e >= s.length) {\n          warn(\"Invalid fd index for glyph index.\");\n          h = !1;\n        }\n        if (h) {\n          Q = s[e].privateDict;\n          l = Q.subrsIndex;\n        }\n      } else t && (l = t);\n      h && (h = this.parseCharString(C, o, l, i));\n      if (null !== C.width) {\n        const e = Q.getByName(\"nominalWidthX\");\n        g[c] = e + C.width;\n      } else {\n        const e = Q.getByName(\"defaultWidthX\");\n        g[c] = e;\n      }\n      null !== C.seac && (n[c] = C.seac);\n      h || e.set(c, new Uint8Array([14]));\n    }\n    return {\n      charStrings: e,\n      seacs: n,\n      widths: g\n    };\n  }\n  emptyPrivateDictionary(e) {\n    const t = this.createDict(CFFPrivateDict, [], e.strings);\n    e.setByKey(18, [0, 0]);\n    e.privateDict = t;\n  }\n  parsePrivateDict(e) {\n    if (!e.hasName(\"Private\")) {\n      this.emptyPrivateDictionary(e);\n      return;\n    }\n    const t = e.getByName(\"Private\");\n    if (!Array.isArray(t) || 2 !== t.length) {\n      e.removeByName(\"Private\");\n      return;\n    }\n    const i = t[0],\n      a = t[1];\n    if (0 === i || a >= this.bytes.length) {\n      this.emptyPrivateDictionary(e);\n      return;\n    }\n    const s = a + i,\n      r = this.bytes.subarray(a, s),\n      n = this.parseDict(r),\n      g = this.createDict(CFFPrivateDict, n, e.strings);\n    e.privateDict = g;\n    0 === g.getByName(\"ExpansionFactor\") && g.setByName(\"ExpansionFactor\", .06);\n    if (!g.getByName(\"Subrs\")) return;\n    const o = g.getByName(\"Subrs\"),\n      c = a + o;\n    if (0 === o || c >= this.bytes.length) {\n      this.emptyPrivateDictionary(e);\n      return;\n    }\n    const C = this.parseIndex(c);\n    g.subrsIndex = C.obj;\n  }\n  parseCharsets(e, t, i, a) {\n    if (0 === e) return new CFFCharset(!0, Ri.ISO_ADOBE, Bi);\n    if (1 === e) return new CFFCharset(!0, Ri.EXPERT, li);\n    if (2 === e) return new CFFCharset(!0, Ri.EXPERT_SUBSET, Qi);\n    const s = this.bytes,\n      r = e,\n      n = s[e++],\n      g = [a ? 0 : \".notdef\"];\n    let o, c, C;\n    t -= 1;\n    switch (n) {\n      case 0:\n        for (C = 0; C < t; C++) {\n          o = s[e++] << 8 | s[e++];\n          g.push(a ? o : i.get(o));\n        }\n        break;\n      case 1:\n        for (; g.length <= t;) {\n          o = s[e++] << 8 | s[e++];\n          c = s[e++];\n          for (C = 0; C <= c; C++) g.push(a ? o++ : i.get(o++));\n        }\n        break;\n      case 2:\n        for (; g.length <= t;) {\n          o = s[e++] << 8 | s[e++];\n          c = s[e++] << 8 | s[e++];\n          for (C = 0; C <= c; C++) g.push(a ? o++ : i.get(o++));\n        }\n        break;\n      default:\n        throw new FormatError(\"Unknown charset format\");\n    }\n    const h = e,\n      l = s.subarray(r, h);\n    return new CFFCharset(!1, n, g, l);\n  }\n  parseEncoding(e, t, i, a) {\n    const s = Object.create(null),\n      r = this.bytes;\n    let n,\n      g,\n      o,\n      c = !1,\n      C = null;\n    if (0 === e || 1 === e) {\n      c = !0;\n      n = e;\n      const t = e ? Ei : fi;\n      for (g = 0, o = a.length; g < o; g++) {\n        const e = t.indexOf(a[g]);\n        -1 !== e && (s[e] = g);\n      }\n    } else {\n      const t = e;\n      n = r[e++];\n      switch (127 & n) {\n        case 0:\n          const t = r[e++];\n          for (g = 1; g <= t; g++) s[r[e++]] = g;\n          break;\n        case 1:\n          const i = r[e++];\n          let a = 1;\n          for (g = 0; g < i; g++) {\n            const t = r[e++],\n              i = r[e++];\n            for (let e = t; e <= t + i; e++) s[e] = a++;\n          }\n          break;\n        default:\n          throw new FormatError(`Unknown encoding format: ${n} in CFF`);\n      }\n      const o = e;\n      if (128 & n) {\n        r[t] &= 127;\n        !function readSupplement() {\n          const t = r[e++];\n          for (g = 0; g < t; g++) {\n            const t = r[e++],\n              n = (r[e++] << 8) + (255 & r[e++]);\n            s[t] = a.indexOf(i.get(n));\n          }\n        }();\n      }\n      C = r.subarray(t, o);\n    }\n    n &= 127;\n    return new CFFEncoding(c, n, s, C);\n  }\n  parseFDSelect(e, t) {\n    const i = this.bytes,\n      a = i[e++],\n      s = [];\n    let r;\n    switch (a) {\n      case 0:\n        for (r = 0; r < t; ++r) {\n          const t = i[e++];\n          s.push(t);\n        }\n        break;\n      case 3:\n        const n = i[e++] << 8 | i[e++];\n        for (r = 0; r < n; ++r) {\n          let t = i[e++] << 8 | i[e++];\n          if (0 === r && 0 !== t) {\n            warn(\"parseFDSelect: The first range must have a first GID of 0 -- trying to recover.\");\n            t = 0;\n          }\n          const a = i[e++],\n            n = i[e] << 8 | i[e + 1];\n          for (let e = t; e < n; ++e) s.push(a);\n        }\n        e += 2;\n        break;\n      default:\n        throw new FormatError(`parseFDSelect: Unknown format \"${a}\".`);\n    }\n    if (s.length !== t) throw new FormatError(\"parseFDSelect: Invalid font data.\");\n    return new CFFFDSelect(a, s);\n  }\n}\nclass CFF {\n  constructor() {\n    this.header = null;\n    this.names = [];\n    this.topDict = null;\n    this.strings = new CFFStrings();\n    this.globalSubrIndex = null;\n    this.encoding = null;\n    this.charset = null;\n    this.charStrings = null;\n    this.fdArray = [];\n    this.fdSelect = null;\n    this.isCIDFont = !1;\n  }\n  duplicateFirstGlyph() {\n    if (this.charStrings.count >= 65535) {\n      warn(\"Not enough space in charstrings to duplicate first glyph.\");\n      return;\n    }\n    const e = this.charStrings.get(0);\n    this.charStrings.add(e);\n    this.isCIDFont && this.fdSelect.fdSelect.push(this.fdSelect.fdSelect[0]);\n  }\n  hasGlyphId(e) {\n    if (e < 0 || e >= this.charStrings.count) return !1;\n    return this.charStrings.get(e).length > 0;\n  }\n}\nclass CFFHeader {\n  constructor(e, t, i, a) {\n    this.major = e;\n    this.minor = t;\n    this.hdrSize = i;\n    this.offSize = a;\n  }\n}\nclass CFFStrings {\n  constructor() {\n    this.strings = [];\n  }\n  get(e) {\n    return e >= 0 && e <= 390 ? wi[e] : e - Di <= this.strings.length ? this.strings[e - Di] : wi[0];\n  }\n  getSID(e) {\n    let t = wi.indexOf(e);\n    if (-1 !== t) return t;\n    t = this.strings.indexOf(e);\n    return -1 !== t ? t + Di : -1;\n  }\n  add(e) {\n    this.strings.push(e);\n  }\n  get count() {\n    return this.strings.length;\n  }\n}\nclass CFFIndex {\n  constructor() {\n    this.objects = [];\n    this.length = 0;\n  }\n  add(e) {\n    this.length += e.length;\n    this.objects.push(e);\n  }\n  set(e, t) {\n    this.length += t.length - this.objects[e].length;\n    this.objects[e] = t;\n  }\n  get(e) {\n    return this.objects[e];\n  }\n  get count() {\n    return this.objects.length;\n  }\n}\nclass CFFDict {\n  constructor(e, t) {\n    this.keyToNameMap = e.keyToNameMap;\n    this.nameToKeyMap = e.nameToKeyMap;\n    this.defaults = e.defaults;\n    this.types = e.types;\n    this.opcodes = e.opcodes;\n    this.order = e.order;\n    this.strings = t;\n    this.values = Object.create(null);\n  }\n  setByKey(e, t) {\n    if (!(e in this.keyToNameMap)) return !1;\n    if (0 === t.length) return !0;\n    for (const i of t) if (isNaN(i)) {\n      warn(`Invalid CFFDict value: \"${t}\" for key \"${e}\".`);\n      return !0;\n    }\n    const i = this.types[e];\n    \"num\" !== i && \"sid\" !== i && \"offset\" !== i || (t = t[0]);\n    this.values[e] = t;\n    return !0;\n  }\n  setByName(e, t) {\n    if (!(e in this.nameToKeyMap)) throw new FormatError(`Invalid dictionary name \"${e}\"`);\n    this.values[this.nameToKeyMap[e]] = t;\n  }\n  hasName(e) {\n    return this.nameToKeyMap[e] in this.values;\n  }\n  getByName(e) {\n    if (!(e in this.nameToKeyMap)) throw new FormatError(`Invalid dictionary name ${e}\"`);\n    const t = this.nameToKeyMap[e];\n    return t in this.values ? this.values[t] : this.defaults[t];\n  }\n  removeByName(e) {\n    delete this.values[this.nameToKeyMap[e]];\n  }\n  static createTables(e) {\n    const t = {\n      keyToNameMap: {},\n      nameToKeyMap: {},\n      defaults: {},\n      types: {},\n      opcodes: {},\n      order: []\n    };\n    for (const i of e) {\n      const e = Array.isArray(i[0]) ? (i[0][0] << 8) + i[0][1] : i[0];\n      t.keyToNameMap[e] = i[1];\n      t.nameToKeyMap[i[1]] = e;\n      t.types[e] = i[2];\n      t.defaults[e] = i[3];\n      t.opcodes[e] = Array.isArray(i[0]) ? i[0] : [i[0]];\n      t.order.push(e);\n    }\n    return t;\n  }\n}\nconst Si = [[[12, 30], \"ROS\", [\"sid\", \"sid\", \"num\"], null], [[12, 20], \"SyntheticBase\", \"num\", null], [0, \"version\", \"sid\", null], [1, \"Notice\", \"sid\", null], [[12, 0], \"Copyright\", \"sid\", null], [2, \"FullName\", \"sid\", null], [3, \"FamilyName\", \"sid\", null], [4, \"Weight\", \"sid\", null], [[12, 1], \"isFixedPitch\", \"num\", 0], [[12, 2], \"ItalicAngle\", \"num\", 0], [[12, 3], \"UnderlinePosition\", \"num\", -100], [[12, 4], \"UnderlineThickness\", \"num\", 50], [[12, 5], \"PaintType\", \"num\", 0], [[12, 6], \"CharstringType\", \"num\", 2], [[12, 7], \"FontMatrix\", [\"num\", \"num\", \"num\", \"num\", \"num\", \"num\"], [.001, 0, 0, .001, 0, 0]], [13, \"UniqueID\", \"num\", null], [5, \"FontBBox\", [\"num\", \"num\", \"num\", \"num\"], [0, 0, 0, 0]], [[12, 8], \"StrokeWidth\", \"num\", 0], [14, \"XUID\", \"array\", null], [15, \"charset\", \"offset\", 0], [16, \"Encoding\", \"offset\", 0], [17, \"CharStrings\", \"offset\", 0], [18, \"Private\", [\"offset\", \"offset\"], null], [[12, 21], \"PostScript\", \"sid\", null], [[12, 22], \"BaseFontName\", \"sid\", null], [[12, 23], \"BaseFontBlend\", \"delta\", null], [[12, 31], \"CIDFontVersion\", \"num\", 0], [[12, 32], \"CIDFontRevision\", \"num\", 0], [[12, 33], \"CIDFontType\", \"num\", 0], [[12, 34], \"CIDCount\", \"num\", 8720], [[12, 35], \"UIDBase\", \"num\", null], [[12, 37], \"FDSelect\", \"offset\", null], [[12, 36], \"FDArray\", \"offset\", null], [[12, 38], \"FontName\", \"sid\", null]];\nclass CFFTopDict extends CFFDict {\n  static get tables() {\n    return shadow(this, \"tables\", this.createTables(Si));\n  }\n  constructor(e) {\n    super(CFFTopDict.tables, e);\n    this.privateDict = null;\n  }\n}\nconst ki = [[6, \"BlueValues\", \"delta\", null], [7, \"OtherBlues\", \"delta\", null], [8, \"FamilyBlues\", \"delta\", null], [9, \"FamilyOtherBlues\", \"delta\", null], [[12, 9], \"BlueScale\", \"num\", .039625], [[12, 10], \"BlueShift\", \"num\", 7], [[12, 11], \"BlueFuzz\", \"num\", 1], [10, \"StdHW\", \"num\", null], [11, \"StdVW\", \"num\", null], [[12, 12], \"StemSnapH\", \"delta\", null], [[12, 13], \"StemSnapV\", \"delta\", null], [[12, 14], \"ForceBold\", \"num\", 0], [[12, 17], \"LanguageGroup\", \"num\", 0], [[12, 18], \"ExpansionFactor\", \"num\", .06], [[12, 19], \"initialRandomSeed\", \"num\", 0], [20, \"defaultWidthX\", \"num\", 0], [21, \"nominalWidthX\", \"num\", 0], [19, \"Subrs\", \"offset\", null]];\nclass CFFPrivateDict extends CFFDict {\n  static get tables() {\n    return shadow(this, \"tables\", this.createTables(ki));\n  }\n  constructor(e) {\n    super(CFFPrivateDict.tables, e);\n    this.subrsIndex = null;\n  }\n}\nconst Ri = {\n  ISO_ADOBE: 0,\n  EXPERT: 1,\n  EXPERT_SUBSET: 2\n};\nclass CFFCharset {\n  constructor(e, t, i, a) {\n    this.predefined = e;\n    this.format = t;\n    this.charset = i;\n    this.raw = a;\n  }\n}\nclass CFFEncoding {\n  constructor(e, t, i, a) {\n    this.predefined = e;\n    this.format = t;\n    this.encoding = i;\n    this.raw = a;\n  }\n}\nclass CFFFDSelect {\n  constructor(e, t) {\n    this.format = e;\n    this.fdSelect = t;\n  }\n  getFDIndex(e) {\n    return e < 0 || e >= this.fdSelect.length ? -1 : this.fdSelect[e];\n  }\n}\nclass CFFOffsetTracker {\n  constructor() {\n    this.offsets = Object.create(null);\n  }\n  isTracking(e) {\n    return e in this.offsets;\n  }\n  track(e, t) {\n    if (e in this.offsets) throw new FormatError(`Already tracking location of ${e}`);\n    this.offsets[e] = t;\n  }\n  offset(e) {\n    for (const t in this.offsets) this.offsets[t] += e;\n  }\n  setEntryLocation(e, t, i) {\n    if (!(e in this.offsets)) throw new FormatError(`Not tracking location of ${e}`);\n    const a = i.data,\n      s = this.offsets[e];\n    for (let e = 0, i = t.length; e < i; ++e) {\n      const i = 5 * e + s,\n        r = i + 1,\n        n = i + 2,\n        g = i + 3,\n        o = i + 4;\n      if (29 !== a[i] || 0 !== a[r] || 0 !== a[n] || 0 !== a[g] || 0 !== a[o]) throw new FormatError(\"writing to an offset that is not empty\");\n      const c = t[e];\n      a[i] = 29;\n      a[r] = c >> 24 & 255;\n      a[n] = c >> 16 & 255;\n      a[g] = c >> 8 & 255;\n      a[o] = 255 & c;\n    }\n  }\n}\nclass CFFCompiler {\n  constructor(e) {\n    this.cff = e;\n  }\n  compile() {\n    const e = this.cff,\n      t = {\n        data: [],\n        length: 0,\n        add(e) {\n          try {\n            this.data.push(...e);\n          } catch {\n            this.data = this.data.concat(e);\n          }\n          this.length = this.data.length;\n        }\n      },\n      i = this.compileHeader(e.header);\n    t.add(i);\n    const a = this.compileNameIndex(e.names);\n    t.add(a);\n    if (e.isCIDFont && e.topDict.hasName(\"FontMatrix\")) {\n      const t = e.topDict.getByName(\"FontMatrix\");\n      e.topDict.removeByName(\"FontMatrix\");\n      for (const i of e.fdArray) {\n        let e = t.slice(0);\n        i.hasName(\"FontMatrix\") && (e = Util.transform(e, i.getByName(\"FontMatrix\")));\n        i.setByName(\"FontMatrix\", e);\n      }\n    }\n    const s = e.topDict.getByName(\"XUID\");\n    s?.length > 16 && e.topDict.removeByName(\"XUID\");\n    e.topDict.setByName(\"charset\", 0);\n    let r = this.compileTopDicts([e.topDict], t.length, e.isCIDFont);\n    t.add(r.output);\n    const n = r.trackers[0],\n      g = this.compileStringIndex(e.strings.strings);\n    t.add(g);\n    const o = this.compileIndex(e.globalSubrIndex);\n    t.add(o);\n    if (e.encoding && e.topDict.hasName(\"Encoding\")) if (e.encoding.predefined) n.setEntryLocation(\"Encoding\", [e.encoding.format], t);else {\n      const i = this.compileEncoding(e.encoding);\n      n.setEntryLocation(\"Encoding\", [t.length], t);\n      t.add(i);\n    }\n    const c = this.compileCharset(e.charset, e.charStrings.count, e.strings, e.isCIDFont);\n    n.setEntryLocation(\"charset\", [t.length], t);\n    t.add(c);\n    const C = this.compileCharStrings(e.charStrings);\n    n.setEntryLocation(\"CharStrings\", [t.length], t);\n    t.add(C);\n    if (e.isCIDFont) {\n      n.setEntryLocation(\"FDSelect\", [t.length], t);\n      const i = this.compileFDSelect(e.fdSelect);\n      t.add(i);\n      r = this.compileTopDicts(e.fdArray, t.length, !0);\n      n.setEntryLocation(\"FDArray\", [t.length], t);\n      t.add(r.output);\n      const a = r.trackers;\n      this.compilePrivateDicts(e.fdArray, a, t);\n    }\n    this.compilePrivateDicts([e.topDict], [n], t);\n    t.add([0]);\n    return t.data;\n  }\n  encodeNumber(e) {\n    return Number.isInteger(e) ? this.encodeInteger(e) : this.encodeFloat(e);\n  }\n  static get EncodeFloatRegExp() {\n    return shadow(this, \"EncodeFloatRegExp\", /\\.(\\d*?)(?:9{5,20}|0{5,20})\\d{0,2}(?:e(.+)|$)/);\n  }\n  encodeFloat(e) {\n    let t = e.toString();\n    const i = CFFCompiler.EncodeFloatRegExp.exec(t);\n    if (i) {\n      const a = parseFloat(\"1e\" + ((i[2] ? +i[2] : 0) + i[1].length));\n      t = (Math.round(e * a) / a).toString();\n    }\n    let a,\n      s,\n      r = \"\";\n    for (a = 0, s = t.length; a < s; ++a) {\n      const e = t[a];\n      r += \"e\" === e ? \"-\" === t[++a] ? \"c\" : \"b\" : \".\" === e ? \"a\" : \"-\" === e ? \"e\" : e;\n    }\n    r += 1 & r.length ? \"f\" : \"ff\";\n    const n = [30];\n    for (a = 0, s = r.length; a < s; a += 2) n.push(parseInt(r.substring(a, a + 2), 16));\n    return n;\n  }\n  encodeInteger(e) {\n    let t;\n    t = e >= -107 && e <= 107 ? [e + 139] : e >= 108 && e <= 1131 ? [247 + ((e -= 108) >> 8), 255 & e] : e >= -1131 && e <= -108 ? [251 + ((e = -e - 108) >> 8), 255 & e] : e >= -32768 && e <= 32767 ? [28, e >> 8 & 255, 255 & e] : [29, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e];\n    return t;\n  }\n  compileHeader(e) {\n    return [e.major, e.minor, 4, e.offSize];\n  }\n  compileNameIndex(e) {\n    const t = new CFFIndex();\n    for (const i of e) {\n      const e = Math.min(i.length, 127);\n      let a = new Array(e);\n      for (let t = 0; t < e; t++) {\n        let e = i[t];\n        (e < \"!\" || e > \"~\" || \"[\" === e || \"]\" === e || \"(\" === e || \")\" === e || \"{\" === e || \"}\" === e || \"<\" === e || \">\" === e || \"/\" === e || \"%\" === e) && (e = \"_\");\n        a[t] = e;\n      }\n      a = a.join(\"\");\n      \"\" === a && (a = \"Bad_Font_Name\");\n      t.add(stringToBytes(a));\n    }\n    return this.compileIndex(t);\n  }\n  compileTopDicts(e, t, i) {\n    const a = [];\n    let s = new CFFIndex();\n    for (const r of e) {\n      if (i) {\n        r.removeByName(\"CIDFontVersion\");\n        r.removeByName(\"CIDFontRevision\");\n        r.removeByName(\"CIDFontType\");\n        r.removeByName(\"CIDCount\");\n        r.removeByName(\"UIDBase\");\n      }\n      const e = new CFFOffsetTracker(),\n        n = this.compileDict(r, e);\n      a.push(e);\n      s.add(n);\n      e.offset(t);\n    }\n    s = this.compileIndex(s, a);\n    return {\n      trackers: a,\n      output: s\n    };\n  }\n  compilePrivateDicts(e, t, i) {\n    for (let a = 0, s = e.length; a < s; ++a) {\n      const s = e[a],\n        r = s.privateDict;\n      if (!r || !s.hasName(\"Private\")) throw new FormatError(\"There must be a private dictionary.\");\n      const n = new CFFOffsetTracker(),\n        g = this.compileDict(r, n);\n      let o = i.length;\n      n.offset(o);\n      g.length || (o = 0);\n      t[a].setEntryLocation(\"Private\", [g.length, o], i);\n      i.add(g);\n      if (r.subrsIndex && r.hasName(\"Subrs\")) {\n        const e = this.compileIndex(r.subrsIndex);\n        n.setEntryLocation(\"Subrs\", [g.length], i);\n        i.add(e);\n      }\n    }\n  }\n  compileDict(e, t) {\n    const i = [];\n    for (const a of e.order) {\n      if (!(a in e.values)) continue;\n      let s = e.values[a],\n        r = e.types[a];\n      Array.isArray(r) || (r = [r]);\n      Array.isArray(s) || (s = [s]);\n      if (0 !== s.length) {\n        for (let n = 0, g = r.length; n < g; ++n) {\n          const g = r[n],\n            o = s[n];\n          switch (g) {\n            case \"num\":\n            case \"sid\":\n              i.push(...this.encodeNumber(o));\n              break;\n            case \"offset\":\n              const r = e.keyToNameMap[a];\n              t.isTracking(r) || t.track(r, i.length);\n              i.push(29, 0, 0, 0, 0);\n              break;\n            case \"array\":\n            case \"delta\":\n              i.push(...this.encodeNumber(o));\n              for (let e = 1, t = s.length; e < t; ++e) i.push(...this.encodeNumber(s[e]));\n              break;\n            default:\n              throw new FormatError(`Unknown data type of ${g}`);\n          }\n        }\n        i.push(...e.opcodes[a]);\n      }\n    }\n    return i;\n  }\n  compileStringIndex(e) {\n    const t = new CFFIndex();\n    for (const i of e) t.add(stringToBytes(i));\n    return this.compileIndex(t);\n  }\n  compileCharStrings(e) {\n    const t = new CFFIndex();\n    for (let i = 0; i < e.count; i++) {\n      const a = e.get(i);\n      0 !== a.length ? t.add(a) : t.add(new Uint8Array([139, 14]));\n    }\n    return this.compileIndex(t);\n  }\n  compileCharset(e, t, i, a) {\n    let s;\n    const r = t - 1;\n    if (a) s = new Uint8Array([2, 0, 0, r >> 8 & 255, 255 & r]);else {\n      s = new Uint8Array(1 + 2 * r);\n      s[0] = 0;\n      let t = 0;\n      const a = e.charset.length;\n      let n = !1;\n      for (let r = 1; r < s.length; r += 2) {\n        let g = 0;\n        if (t < a) {\n          const a = e.charset[t++];\n          g = i.getSID(a);\n          if (-1 === g) {\n            g = 0;\n            if (!n) {\n              n = !0;\n              warn(`Couldn't find ${a} in CFF strings`);\n            }\n          }\n        }\n        s[r] = g >> 8 & 255;\n        s[r + 1] = 255 & g;\n      }\n    }\n    return this.compileTypedArray(s);\n  }\n  compileEncoding(e) {\n    return this.compileTypedArray(e.raw);\n  }\n  compileFDSelect(e) {\n    const t = e.format;\n    let i, a;\n    switch (t) {\n      case 0:\n        i = new Uint8Array(1 + e.fdSelect.length);\n        i[0] = t;\n        for (a = 0; a < e.fdSelect.length; a++) i[a + 1] = e.fdSelect[a];\n        break;\n      case 3:\n        const s = 0;\n        let r = e.fdSelect[0];\n        const n = [t, 0, 0, s >> 8 & 255, 255 & s, r];\n        for (a = 1; a < e.fdSelect.length; a++) {\n          const t = e.fdSelect[a];\n          if (t !== r) {\n            n.push(a >> 8 & 255, 255 & a, t);\n            r = t;\n          }\n        }\n        const g = (n.length - 3) / 3;\n        n[1] = g >> 8 & 255;\n        n[2] = 255 & g;\n        n.push(a >> 8 & 255, 255 & a);\n        i = new Uint8Array(n);\n    }\n    return this.compileTypedArray(i);\n  }\n  compileTypedArray(e) {\n    return Array.from(e);\n  }\n  compileIndex(e, t = []) {\n    const i = e.objects,\n      a = i.length;\n    if (0 === a) return [0, 0];\n    const s = [a >> 8 & 255, 255 & a];\n    let r,\n      n,\n      g = 1;\n    for (r = 0; r < a; ++r) g += i[r].length;\n    n = g < 256 ? 1 : g < 65536 ? 2 : g < 16777216 ? 3 : 4;\n    s.push(n);\n    let o = 1;\n    for (r = 0; r < a + 1; r++) {\n      1 === n ? s.push(255 & o) : 2 === n ? s.push(o >> 8 & 255, 255 & o) : 3 === n ? s.push(o >> 16 & 255, o >> 8 & 255, 255 & o) : s.push(o >>> 24 & 255, o >> 16 & 255, o >> 8 & 255, 255 & o);\n      i[r] && (o += i[r].length);\n    }\n    for (r = 0; r < a; r++) {\n      t[r] && t[r].offset(s.length);\n      s.push(...i[r]);\n    }\n    return s;\n  }\n}\nconst Ni = getLookupTableFactory(function (e) {\n    e.A = 65;\n    e.AE = 198;\n    e.AEacute = 508;\n    e.AEmacron = 482;\n    e.AEsmall = 63462;\n    e.Aacute = 193;\n    e.Aacutesmall = 63457;\n    e.Abreve = 258;\n    e.Abreveacute = 7854;\n    e.Abrevecyrillic = 1232;\n    e.Abrevedotbelow = 7862;\n    e.Abrevegrave = 7856;\n    e.Abrevehookabove = 7858;\n    e.Abrevetilde = 7860;\n    e.Acaron = 461;\n    e.Acircle = 9398;\n    e.Acircumflex = 194;\n    e.Acircumflexacute = 7844;\n    e.Acircumflexdotbelow = 7852;\n    e.Acircumflexgrave = 7846;\n    e.Acircumflexhookabove = 7848;\n    e.Acircumflexsmall = 63458;\n    e.Acircumflextilde = 7850;\n    e.Acute = 63177;\n    e.Acutesmall = 63412;\n    e.Acyrillic = 1040;\n    e.Adblgrave = 512;\n    e.Adieresis = 196;\n    e.Adieresiscyrillic = 1234;\n    e.Adieresismacron = 478;\n    e.Adieresissmall = 63460;\n    e.Adotbelow = 7840;\n    e.Adotmacron = 480;\n    e.Agrave = 192;\n    e.Agravesmall = 63456;\n    e.Ahookabove = 7842;\n    e.Aiecyrillic = 1236;\n    e.Ainvertedbreve = 514;\n    e.Alpha = 913;\n    e.Alphatonos = 902;\n    e.Amacron = 256;\n    e.Amonospace = 65313;\n    e.Aogonek = 260;\n    e.Aring = 197;\n    e.Aringacute = 506;\n    e.Aringbelow = 7680;\n    e.Aringsmall = 63461;\n    e.Asmall = 63329;\n    e.Atilde = 195;\n    e.Atildesmall = 63459;\n    e.Aybarmenian = 1329;\n    e.B = 66;\n    e.Bcircle = 9399;\n    e.Bdotaccent = 7682;\n    e.Bdotbelow = 7684;\n    e.Becyrillic = 1041;\n    e.Benarmenian = 1330;\n    e.Beta = 914;\n    e.Bhook = 385;\n    e.Blinebelow = 7686;\n    e.Bmonospace = 65314;\n    e.Brevesmall = 63220;\n    e.Bsmall = 63330;\n    e.Btopbar = 386;\n    e.C = 67;\n    e.Caarmenian = 1342;\n    e.Cacute = 262;\n    e.Caron = 63178;\n    e.Caronsmall = 63221;\n    e.Ccaron = 268;\n    e.Ccedilla = 199;\n    e.Ccedillaacute = 7688;\n    e.Ccedillasmall = 63463;\n    e.Ccircle = 9400;\n    e.Ccircumflex = 264;\n    e.Cdot = 266;\n    e.Cdotaccent = 266;\n    e.Cedillasmall = 63416;\n    e.Chaarmenian = 1353;\n    e.Cheabkhasiancyrillic = 1212;\n    e.Checyrillic = 1063;\n    e.Chedescenderabkhasiancyrillic = 1214;\n    e.Chedescendercyrillic = 1206;\n    e.Chedieresiscyrillic = 1268;\n    e.Cheharmenian = 1347;\n    e.Chekhakassiancyrillic = 1227;\n    e.Cheverticalstrokecyrillic = 1208;\n    e.Chi = 935;\n    e.Chook = 391;\n    e.Circumflexsmall = 63222;\n    e.Cmonospace = 65315;\n    e.Coarmenian = 1361;\n    e.Csmall = 63331;\n    e.D = 68;\n    e.DZ = 497;\n    e.DZcaron = 452;\n    e.Daarmenian = 1332;\n    e.Dafrican = 393;\n    e.Dcaron = 270;\n    e.Dcedilla = 7696;\n    e.Dcircle = 9401;\n    e.Dcircumflexbelow = 7698;\n    e.Dcroat = 272;\n    e.Ddotaccent = 7690;\n    e.Ddotbelow = 7692;\n    e.Decyrillic = 1044;\n    e.Deicoptic = 1006;\n    e.Delta = 8710;\n    e.Deltagreek = 916;\n    e.Dhook = 394;\n    e.Dieresis = 63179;\n    e.DieresisAcute = 63180;\n    e.DieresisGrave = 63181;\n    e.Dieresissmall = 63400;\n    e.Digammagreek = 988;\n    e.Djecyrillic = 1026;\n    e.Dlinebelow = 7694;\n    e.Dmonospace = 65316;\n    e.Dotaccentsmall = 63223;\n    e.Dslash = 272;\n    e.Dsmall = 63332;\n    e.Dtopbar = 395;\n    e.Dz = 498;\n    e.Dzcaron = 453;\n    e.Dzeabkhasiancyrillic = 1248;\n    e.Dzecyrillic = 1029;\n    e.Dzhecyrillic = 1039;\n    e.E = 69;\n    e.Eacute = 201;\n    e.Eacutesmall = 63465;\n    e.Ebreve = 276;\n    e.Ecaron = 282;\n    e.Ecedillabreve = 7708;\n    e.Echarmenian = 1333;\n    e.Ecircle = 9402;\n    e.Ecircumflex = 202;\n    e.Ecircumflexacute = 7870;\n    e.Ecircumflexbelow = 7704;\n    e.Ecircumflexdotbelow = 7878;\n    e.Ecircumflexgrave = 7872;\n    e.Ecircumflexhookabove = 7874;\n    e.Ecircumflexsmall = 63466;\n    e.Ecircumflextilde = 7876;\n    e.Ecyrillic = 1028;\n    e.Edblgrave = 516;\n    e.Edieresis = 203;\n    e.Edieresissmall = 63467;\n    e.Edot = 278;\n    e.Edotaccent = 278;\n    e.Edotbelow = 7864;\n    e.Efcyrillic = 1060;\n    e.Egrave = 200;\n    e.Egravesmall = 63464;\n    e.Eharmenian = 1335;\n    e.Ehookabove = 7866;\n    e.Eightroman = 8551;\n    e.Einvertedbreve = 518;\n    e.Eiotifiedcyrillic = 1124;\n    e.Elcyrillic = 1051;\n    e.Elevenroman = 8554;\n    e.Emacron = 274;\n    e.Emacronacute = 7702;\n    e.Emacrongrave = 7700;\n    e.Emcyrillic = 1052;\n    e.Emonospace = 65317;\n    e.Encyrillic = 1053;\n    e.Endescendercyrillic = 1186;\n    e.Eng = 330;\n    e.Enghecyrillic = 1188;\n    e.Enhookcyrillic = 1223;\n    e.Eogonek = 280;\n    e.Eopen = 400;\n    e.Epsilon = 917;\n    e.Epsilontonos = 904;\n    e.Ercyrillic = 1056;\n    e.Ereversed = 398;\n    e.Ereversedcyrillic = 1069;\n    e.Escyrillic = 1057;\n    e.Esdescendercyrillic = 1194;\n    e.Esh = 425;\n    e.Esmall = 63333;\n    e.Eta = 919;\n    e.Etarmenian = 1336;\n    e.Etatonos = 905;\n    e.Eth = 208;\n    e.Ethsmall = 63472;\n    e.Etilde = 7868;\n    e.Etildebelow = 7706;\n    e.Euro = 8364;\n    e.Ezh = 439;\n    e.Ezhcaron = 494;\n    e.Ezhreversed = 440;\n    e.F = 70;\n    e.Fcircle = 9403;\n    e.Fdotaccent = 7710;\n    e.Feharmenian = 1366;\n    e.Feicoptic = 996;\n    e.Fhook = 401;\n    e.Fitacyrillic = 1138;\n    e.Fiveroman = 8548;\n    e.Fmonospace = 65318;\n    e.Fourroman = 8547;\n    e.Fsmall = 63334;\n    e.G = 71;\n    e.GBsquare = 13191;\n    e.Gacute = 500;\n    e.Gamma = 915;\n    e.Gammaafrican = 404;\n    e.Gangiacoptic = 1002;\n    e.Gbreve = 286;\n    e.Gcaron = 486;\n    e.Gcedilla = 290;\n    e.Gcircle = 9404;\n    e.Gcircumflex = 284;\n    e.Gcommaaccent = 290;\n    e.Gdot = 288;\n    e.Gdotaccent = 288;\n    e.Gecyrillic = 1043;\n    e.Ghadarmenian = 1346;\n    e.Ghemiddlehookcyrillic = 1172;\n    e.Ghestrokecyrillic = 1170;\n    e.Gheupturncyrillic = 1168;\n    e.Ghook = 403;\n    e.Gimarmenian = 1331;\n    e.Gjecyrillic = 1027;\n    e.Gmacron = 7712;\n    e.Gmonospace = 65319;\n    e.Grave = 63182;\n    e.Gravesmall = 63328;\n    e.Gsmall = 63335;\n    e.Gsmallhook = 667;\n    e.Gstroke = 484;\n    e.H = 72;\n    e.H18533 = 9679;\n    e.H18543 = 9642;\n    e.H18551 = 9643;\n    e.H22073 = 9633;\n    e.HPsquare = 13259;\n    e.Haabkhasiancyrillic = 1192;\n    e.Hadescendercyrillic = 1202;\n    e.Hardsigncyrillic = 1066;\n    e.Hbar = 294;\n    e.Hbrevebelow = 7722;\n    e.Hcedilla = 7720;\n    e.Hcircle = 9405;\n    e.Hcircumflex = 292;\n    e.Hdieresis = 7718;\n    e.Hdotaccent = 7714;\n    e.Hdotbelow = 7716;\n    e.Hmonospace = 65320;\n    e.Hoarmenian = 1344;\n    e.Horicoptic = 1e3;\n    e.Hsmall = 63336;\n    e.Hungarumlaut = 63183;\n    e.Hungarumlautsmall = 63224;\n    e.Hzsquare = 13200;\n    e.I = 73;\n    e.IAcyrillic = 1071;\n    e.IJ = 306;\n    e.IUcyrillic = 1070;\n    e.Iacute = 205;\n    e.Iacutesmall = 63469;\n    e.Ibreve = 300;\n    e.Icaron = 463;\n    e.Icircle = 9406;\n    e.Icircumflex = 206;\n    e.Icircumflexsmall = 63470;\n    e.Icyrillic = 1030;\n    e.Idblgrave = 520;\n    e.Idieresis = 207;\n    e.Idieresisacute = 7726;\n    e.Idieresiscyrillic = 1252;\n    e.Idieresissmall = 63471;\n    e.Idot = 304;\n    e.Idotaccent = 304;\n    e.Idotbelow = 7882;\n    e.Iebrevecyrillic = 1238;\n    e.Iecyrillic = 1045;\n    e.Ifraktur = 8465;\n    e.Igrave = 204;\n    e.Igravesmall = 63468;\n    e.Ihookabove = 7880;\n    e.Iicyrillic = 1048;\n    e.Iinvertedbreve = 522;\n    e.Iishortcyrillic = 1049;\n    e.Imacron = 298;\n    e.Imacroncyrillic = 1250;\n    e.Imonospace = 65321;\n    e.Iniarmenian = 1339;\n    e.Iocyrillic = 1025;\n    e.Iogonek = 302;\n    e.Iota = 921;\n    e.Iotaafrican = 406;\n    e.Iotadieresis = 938;\n    e.Iotatonos = 906;\n    e.Ismall = 63337;\n    e.Istroke = 407;\n    e.Itilde = 296;\n    e.Itildebelow = 7724;\n    e.Izhitsacyrillic = 1140;\n    e.Izhitsadblgravecyrillic = 1142;\n    e.J = 74;\n    e.Jaarmenian = 1345;\n    e.Jcircle = 9407;\n    e.Jcircumflex = 308;\n    e.Jecyrillic = 1032;\n    e.Jheharmenian = 1355;\n    e.Jmonospace = 65322;\n    e.Jsmall = 63338;\n    e.K = 75;\n    e.KBsquare = 13189;\n    e.KKsquare = 13261;\n    e.Kabashkircyrillic = 1184;\n    e.Kacute = 7728;\n    e.Kacyrillic = 1050;\n    e.Kadescendercyrillic = 1178;\n    e.Kahookcyrillic = 1219;\n    e.Kappa = 922;\n    e.Kastrokecyrillic = 1182;\n    e.Kaverticalstrokecyrillic = 1180;\n    e.Kcaron = 488;\n    e.Kcedilla = 310;\n    e.Kcircle = 9408;\n    e.Kcommaaccent = 310;\n    e.Kdotbelow = 7730;\n    e.Keharmenian = 1364;\n    e.Kenarmenian = 1343;\n    e.Khacyrillic = 1061;\n    e.Kheicoptic = 998;\n    e.Khook = 408;\n    e.Kjecyrillic = 1036;\n    e.Klinebelow = 7732;\n    e.Kmonospace = 65323;\n    e.Koppacyrillic = 1152;\n    e.Koppagreek = 990;\n    e.Ksicyrillic = 1134;\n    e.Ksmall = 63339;\n    e.L = 76;\n    e.LJ = 455;\n    e.LL = 63167;\n    e.Lacute = 313;\n    e.Lambda = 923;\n    e.Lcaron = 317;\n    e.Lcedilla = 315;\n    e.Lcircle = 9409;\n    e.Lcircumflexbelow = 7740;\n    e.Lcommaaccent = 315;\n    e.Ldot = 319;\n    e.Ldotaccent = 319;\n    e.Ldotbelow = 7734;\n    e.Ldotbelowmacron = 7736;\n    e.Liwnarmenian = 1340;\n    e.Lj = 456;\n    e.Ljecyrillic = 1033;\n    e.Llinebelow = 7738;\n    e.Lmonospace = 65324;\n    e.Lslash = 321;\n    e.Lslashsmall = 63225;\n    e.Lsmall = 63340;\n    e.M = 77;\n    e.MBsquare = 13190;\n    e.Macron = 63184;\n    e.Macronsmall = 63407;\n    e.Macute = 7742;\n    e.Mcircle = 9410;\n    e.Mdotaccent = 7744;\n    e.Mdotbelow = 7746;\n    e.Menarmenian = 1348;\n    e.Mmonospace = 65325;\n    e.Msmall = 63341;\n    e.Mturned = 412;\n    e.Mu = 924;\n    e.N = 78;\n    e.NJ = 458;\n    e.Nacute = 323;\n    e.Ncaron = 327;\n    e.Ncedilla = 325;\n    e.Ncircle = 9411;\n    e.Ncircumflexbelow = 7754;\n    e.Ncommaaccent = 325;\n    e.Ndotaccent = 7748;\n    e.Ndotbelow = 7750;\n    e.Nhookleft = 413;\n    e.Nineroman = 8552;\n    e.Nj = 459;\n    e.Njecyrillic = 1034;\n    e.Nlinebelow = 7752;\n    e.Nmonospace = 65326;\n    e.Nowarmenian = 1350;\n    e.Nsmall = 63342;\n    e.Ntilde = 209;\n    e.Ntildesmall = 63473;\n    e.Nu = 925;\n    e.O = 79;\n    e.OE = 338;\n    e.OEsmall = 63226;\n    e.Oacute = 211;\n    e.Oacutesmall = 63475;\n    e.Obarredcyrillic = 1256;\n    e.Obarreddieresiscyrillic = 1258;\n    e.Obreve = 334;\n    e.Ocaron = 465;\n    e.Ocenteredtilde = 415;\n    e.Ocircle = 9412;\n    e.Ocircumflex = 212;\n    e.Ocircumflexacute = 7888;\n    e.Ocircumflexdotbelow = 7896;\n    e.Ocircumflexgrave = 7890;\n    e.Ocircumflexhookabove = 7892;\n    e.Ocircumflexsmall = 63476;\n    e.Ocircumflextilde = 7894;\n    e.Ocyrillic = 1054;\n    e.Odblacute = 336;\n    e.Odblgrave = 524;\n    e.Odieresis = 214;\n    e.Odieresiscyrillic = 1254;\n    e.Odieresissmall = 63478;\n    e.Odotbelow = 7884;\n    e.Ogoneksmall = 63227;\n    e.Ograve = 210;\n    e.Ogravesmall = 63474;\n    e.Oharmenian = 1365;\n    e.Ohm = 8486;\n    e.Ohookabove = 7886;\n    e.Ohorn = 416;\n    e.Ohornacute = 7898;\n    e.Ohorndotbelow = 7906;\n    e.Ohorngrave = 7900;\n    e.Ohornhookabove = 7902;\n    e.Ohorntilde = 7904;\n    e.Ohungarumlaut = 336;\n    e.Oi = 418;\n    e.Oinvertedbreve = 526;\n    e.Omacron = 332;\n    e.Omacronacute = 7762;\n    e.Omacrongrave = 7760;\n    e.Omega = 8486;\n    e.Omegacyrillic = 1120;\n    e.Omegagreek = 937;\n    e.Omegaroundcyrillic = 1146;\n    e.Omegatitlocyrillic = 1148;\n    e.Omegatonos = 911;\n    e.Omicron = 927;\n    e.Omicrontonos = 908;\n    e.Omonospace = 65327;\n    e.Oneroman = 8544;\n    e.Oogonek = 490;\n    e.Oogonekmacron = 492;\n    e.Oopen = 390;\n    e.Oslash = 216;\n    e.Oslashacute = 510;\n    e.Oslashsmall = 63480;\n    e.Osmall = 63343;\n    e.Ostrokeacute = 510;\n    e.Otcyrillic = 1150;\n    e.Otilde = 213;\n    e.Otildeacute = 7756;\n    e.Otildedieresis = 7758;\n    e.Otildesmall = 63477;\n    e.P = 80;\n    e.Pacute = 7764;\n    e.Pcircle = 9413;\n    e.Pdotaccent = 7766;\n    e.Pecyrillic = 1055;\n    e.Peharmenian = 1354;\n    e.Pemiddlehookcyrillic = 1190;\n    e.Phi = 934;\n    e.Phook = 420;\n    e.Pi = 928;\n    e.Piwrarmenian = 1363;\n    e.Pmonospace = 65328;\n    e.Psi = 936;\n    e.Psicyrillic = 1136;\n    e.Psmall = 63344;\n    e.Q = 81;\n    e.Qcircle = 9414;\n    e.Qmonospace = 65329;\n    e.Qsmall = 63345;\n    e.R = 82;\n    e.Raarmenian = 1356;\n    e.Racute = 340;\n    e.Rcaron = 344;\n    e.Rcedilla = 342;\n    e.Rcircle = 9415;\n    e.Rcommaaccent = 342;\n    e.Rdblgrave = 528;\n    e.Rdotaccent = 7768;\n    e.Rdotbelow = 7770;\n    e.Rdotbelowmacron = 7772;\n    e.Reharmenian = 1360;\n    e.Rfraktur = 8476;\n    e.Rho = 929;\n    e.Ringsmall = 63228;\n    e.Rinvertedbreve = 530;\n    e.Rlinebelow = 7774;\n    e.Rmonospace = 65330;\n    e.Rsmall = 63346;\n    e.Rsmallinverted = 641;\n    e.Rsmallinvertedsuperior = 694;\n    e.S = 83;\n    e.SF010000 = 9484;\n    e.SF020000 = 9492;\n    e.SF030000 = 9488;\n    e.SF040000 = 9496;\n    e.SF050000 = 9532;\n    e.SF060000 = 9516;\n    e.SF070000 = 9524;\n    e.SF080000 = 9500;\n    e.SF090000 = 9508;\n    e.SF100000 = 9472;\n    e.SF110000 = 9474;\n    e.SF190000 = 9569;\n    e.SF200000 = 9570;\n    e.SF210000 = 9558;\n    e.SF220000 = 9557;\n    e.SF230000 = 9571;\n    e.SF240000 = 9553;\n    e.SF250000 = 9559;\n    e.SF260000 = 9565;\n    e.SF270000 = 9564;\n    e.SF280000 = 9563;\n    e.SF360000 = 9566;\n    e.SF370000 = 9567;\n    e.SF380000 = 9562;\n    e.SF390000 = 9556;\n    e.SF400000 = 9577;\n    e.SF410000 = 9574;\n    e.SF420000 = 9568;\n    e.SF430000 = 9552;\n    e.SF440000 = 9580;\n    e.SF450000 = 9575;\n    e.SF460000 = 9576;\n    e.SF470000 = 9572;\n    e.SF480000 = 9573;\n    e.SF490000 = 9561;\n    e.SF500000 = 9560;\n    e.SF510000 = 9554;\n    e.SF520000 = 9555;\n    e.SF530000 = 9579;\n    e.SF540000 = 9578;\n    e.Sacute = 346;\n    e.Sacutedotaccent = 7780;\n    e.Sampigreek = 992;\n    e.Scaron = 352;\n    e.Scarondotaccent = 7782;\n    e.Scaronsmall = 63229;\n    e.Scedilla = 350;\n    e.Schwa = 399;\n    e.Schwacyrillic = 1240;\n    e.Schwadieresiscyrillic = 1242;\n    e.Scircle = 9416;\n    e.Scircumflex = 348;\n    e.Scommaaccent = 536;\n    e.Sdotaccent = 7776;\n    e.Sdotbelow = 7778;\n    e.Sdotbelowdotaccent = 7784;\n    e.Seharmenian = 1357;\n    e.Sevenroman = 8550;\n    e.Shaarmenian = 1351;\n    e.Shacyrillic = 1064;\n    e.Shchacyrillic = 1065;\n    e.Sheicoptic = 994;\n    e.Shhacyrillic = 1210;\n    e.Shimacoptic = 1004;\n    e.Sigma = 931;\n    e.Sixroman = 8549;\n    e.Smonospace = 65331;\n    e.Softsigncyrillic = 1068;\n    e.Ssmall = 63347;\n    e.Stigmagreek = 986;\n    e.T = 84;\n    e.Tau = 932;\n    e.Tbar = 358;\n    e.Tcaron = 356;\n    e.Tcedilla = 354;\n    e.Tcircle = 9417;\n    e.Tcircumflexbelow = 7792;\n    e.Tcommaaccent = 354;\n    e.Tdotaccent = 7786;\n    e.Tdotbelow = 7788;\n    e.Tecyrillic = 1058;\n    e.Tedescendercyrillic = 1196;\n    e.Tenroman = 8553;\n    e.Tetsecyrillic = 1204;\n    e.Theta = 920;\n    e.Thook = 428;\n    e.Thorn = 222;\n    e.Thornsmall = 63486;\n    e.Threeroman = 8546;\n    e.Tildesmall = 63230;\n    e.Tiwnarmenian = 1359;\n    e.Tlinebelow = 7790;\n    e.Tmonospace = 65332;\n    e.Toarmenian = 1337;\n    e.Tonefive = 444;\n    e.Tonesix = 388;\n    e.Tonetwo = 423;\n    e.Tretroflexhook = 430;\n    e.Tsecyrillic = 1062;\n    e.Tshecyrillic = 1035;\n    e.Tsmall = 63348;\n    e.Twelveroman = 8555;\n    e.Tworoman = 8545;\n    e.U = 85;\n    e.Uacute = 218;\n    e.Uacutesmall = 63482;\n    e.Ubreve = 364;\n    e.Ucaron = 467;\n    e.Ucircle = 9418;\n    e.Ucircumflex = 219;\n    e.Ucircumflexbelow = 7798;\n    e.Ucircumflexsmall = 63483;\n    e.Ucyrillic = 1059;\n    e.Udblacute = 368;\n    e.Udblgrave = 532;\n    e.Udieresis = 220;\n    e.Udieresisacute = 471;\n    e.Udieresisbelow = 7794;\n    e.Udieresiscaron = 473;\n    e.Udieresiscyrillic = 1264;\n    e.Udieresisgrave = 475;\n    e.Udieresismacron = 469;\n    e.Udieresissmall = 63484;\n    e.Udotbelow = 7908;\n    e.Ugrave = 217;\n    e.Ugravesmall = 63481;\n    e.Uhookabove = 7910;\n    e.Uhorn = 431;\n    e.Uhornacute = 7912;\n    e.Uhorndotbelow = 7920;\n    e.Uhorngrave = 7914;\n    e.Uhornhookabove = 7916;\n    e.Uhorntilde = 7918;\n    e.Uhungarumlaut = 368;\n    e.Uhungarumlautcyrillic = 1266;\n    e.Uinvertedbreve = 534;\n    e.Ukcyrillic = 1144;\n    e.Umacron = 362;\n    e.Umacroncyrillic = 1262;\n    e.Umacrondieresis = 7802;\n    e.Umonospace = 65333;\n    e.Uogonek = 370;\n    e.Upsilon = 933;\n    e.Upsilon1 = 978;\n    e.Upsilonacutehooksymbolgreek = 979;\n    e.Upsilonafrican = 433;\n    e.Upsilondieresis = 939;\n    e.Upsilondieresishooksymbolgreek = 980;\n    e.Upsilonhooksymbol = 978;\n    e.Upsilontonos = 910;\n    e.Uring = 366;\n    e.Ushortcyrillic = 1038;\n    e.Usmall = 63349;\n    e.Ustraightcyrillic = 1198;\n    e.Ustraightstrokecyrillic = 1200;\n    e.Utilde = 360;\n    e.Utildeacute = 7800;\n    e.Utildebelow = 7796;\n    e.V = 86;\n    e.Vcircle = 9419;\n    e.Vdotbelow = 7806;\n    e.Vecyrillic = 1042;\n    e.Vewarmenian = 1358;\n    e.Vhook = 434;\n    e.Vmonospace = 65334;\n    e.Voarmenian = 1352;\n    e.Vsmall = 63350;\n    e.Vtilde = 7804;\n    e.W = 87;\n    e.Wacute = 7810;\n    e.Wcircle = 9420;\n    e.Wcircumflex = 372;\n    e.Wdieresis = 7812;\n    e.Wdotaccent = 7814;\n    e.Wdotbelow = 7816;\n    e.Wgrave = 7808;\n    e.Wmonospace = 65335;\n    e.Wsmall = 63351;\n    e.X = 88;\n    e.Xcircle = 9421;\n    e.Xdieresis = 7820;\n    e.Xdotaccent = 7818;\n    e.Xeharmenian = 1341;\n    e.Xi = 926;\n    e.Xmonospace = 65336;\n    e.Xsmall = 63352;\n    e.Y = 89;\n    e.Yacute = 221;\n    e.Yacutesmall = 63485;\n    e.Yatcyrillic = 1122;\n    e.Ycircle = 9422;\n    e.Ycircumflex = 374;\n    e.Ydieresis = 376;\n    e.Ydieresissmall = 63487;\n    e.Ydotaccent = 7822;\n    e.Ydotbelow = 7924;\n    e.Yericyrillic = 1067;\n    e.Yerudieresiscyrillic = 1272;\n    e.Ygrave = 7922;\n    e.Yhook = 435;\n    e.Yhookabove = 7926;\n    e.Yiarmenian = 1349;\n    e.Yicyrillic = 1031;\n    e.Yiwnarmenian = 1362;\n    e.Ymonospace = 65337;\n    e.Ysmall = 63353;\n    e.Ytilde = 7928;\n    e.Yusbigcyrillic = 1130;\n    e.Yusbigiotifiedcyrillic = 1132;\n    e.Yuslittlecyrillic = 1126;\n    e.Yuslittleiotifiedcyrillic = 1128;\n    e.Z = 90;\n    e.Zaarmenian = 1334;\n    e.Zacute = 377;\n    e.Zcaron = 381;\n    e.Zcaronsmall = 63231;\n    e.Zcircle = 9423;\n    e.Zcircumflex = 7824;\n    e.Zdot = 379;\n    e.Zdotaccent = 379;\n    e.Zdotbelow = 7826;\n    e.Zecyrillic = 1047;\n    e.Zedescendercyrillic = 1176;\n    e.Zedieresiscyrillic = 1246;\n    e.Zeta = 918;\n    e.Zhearmenian = 1338;\n    e.Zhebrevecyrillic = 1217;\n    e.Zhecyrillic = 1046;\n    e.Zhedescendercyrillic = 1174;\n    e.Zhedieresiscyrillic = 1244;\n    e.Zlinebelow = 7828;\n    e.Zmonospace = 65338;\n    e.Zsmall = 63354;\n    e.Zstroke = 437;\n    e.a = 97;\n    e.aabengali = 2438;\n    e.aacute = 225;\n    e.aadeva = 2310;\n    e.aagujarati = 2694;\n    e.aagurmukhi = 2566;\n    e.aamatragurmukhi = 2622;\n    e.aarusquare = 13059;\n    e.aavowelsignbengali = 2494;\n    e.aavowelsigndeva = 2366;\n    e.aavowelsigngujarati = 2750;\n    e.abbreviationmarkarmenian = 1375;\n    e.abbreviationsigndeva = 2416;\n    e.abengali = 2437;\n    e.abopomofo = 12570;\n    e.abreve = 259;\n    e.abreveacute = 7855;\n    e.abrevecyrillic = 1233;\n    e.abrevedotbelow = 7863;\n    e.abrevegrave = 7857;\n    e.abrevehookabove = 7859;\n    e.abrevetilde = 7861;\n    e.acaron = 462;\n    e.acircle = 9424;\n    e.acircumflex = 226;\n    e.acircumflexacute = 7845;\n    e.acircumflexdotbelow = 7853;\n    e.acircumflexgrave = 7847;\n    e.acircumflexhookabove = 7849;\n    e.acircumflextilde = 7851;\n    e.acute = 180;\n    e.acutebelowcmb = 791;\n    e.acutecmb = 769;\n    e.acutecomb = 769;\n    e.acutedeva = 2388;\n    e.acutelowmod = 719;\n    e.acutetonecmb = 833;\n    e.acyrillic = 1072;\n    e.adblgrave = 513;\n    e.addakgurmukhi = 2673;\n    e.adeva = 2309;\n    e.adieresis = 228;\n    e.adieresiscyrillic = 1235;\n    e.adieresismacron = 479;\n    e.adotbelow = 7841;\n    e.adotmacron = 481;\n    e.ae = 230;\n    e.aeacute = 509;\n    e.aekorean = 12624;\n    e.aemacron = 483;\n    e.afii00208 = 8213;\n    e.afii08941 = 8356;\n    e.afii10017 = 1040;\n    e.afii10018 = 1041;\n    e.afii10019 = 1042;\n    e.afii10020 = 1043;\n    e.afii10021 = 1044;\n    e.afii10022 = 1045;\n    e.afii10023 = 1025;\n    e.afii10024 = 1046;\n    e.afii10025 = 1047;\n    e.afii10026 = 1048;\n    e.afii10027 = 1049;\n    e.afii10028 = 1050;\n    e.afii10029 = 1051;\n    e.afii10030 = 1052;\n    e.afii10031 = 1053;\n    e.afii10032 = 1054;\n    e.afii10033 = 1055;\n    e.afii10034 = 1056;\n    e.afii10035 = 1057;\n    e.afii10036 = 1058;\n    e.afii10037 = 1059;\n    e.afii10038 = 1060;\n    e.afii10039 = 1061;\n    e.afii10040 = 1062;\n    e.afii10041 = 1063;\n    e.afii10042 = 1064;\n    e.afii10043 = 1065;\n    e.afii10044 = 1066;\n    e.afii10045 = 1067;\n    e.afii10046 = 1068;\n    e.afii10047 = 1069;\n    e.afii10048 = 1070;\n    e.afii10049 = 1071;\n    e.afii10050 = 1168;\n    e.afii10051 = 1026;\n    e.afii10052 = 1027;\n    e.afii10053 = 1028;\n    e.afii10054 = 1029;\n    e.afii10055 = 1030;\n    e.afii10056 = 1031;\n    e.afii10057 = 1032;\n    e.afii10058 = 1033;\n    e.afii10059 = 1034;\n    e.afii10060 = 1035;\n    e.afii10061 = 1036;\n    e.afii10062 = 1038;\n    e.afii10063 = 63172;\n    e.afii10064 = 63173;\n    e.afii10065 = 1072;\n    e.afii10066 = 1073;\n    e.afii10067 = 1074;\n    e.afii10068 = 1075;\n    e.afii10069 = 1076;\n    e.afii10070 = 1077;\n    e.afii10071 = 1105;\n    e.afii10072 = 1078;\n    e.afii10073 = 1079;\n    e.afii10074 = 1080;\n    e.afii10075 = 1081;\n    e.afii10076 = 1082;\n    e.afii10077 = 1083;\n    e.afii10078 = 1084;\n    e.afii10079 = 1085;\n    e.afii10080 = 1086;\n    e.afii10081 = 1087;\n    e.afii10082 = 1088;\n    e.afii10083 = 1089;\n    e.afii10084 = 1090;\n    e.afii10085 = 1091;\n    e.afii10086 = 1092;\n    e.afii10087 = 1093;\n    e.afii10088 = 1094;\n    e.afii10089 = 1095;\n    e.afii10090 = 1096;\n    e.afii10091 = 1097;\n    e.afii10092 = 1098;\n    e.afii10093 = 1099;\n    e.afii10094 = 1100;\n    e.afii10095 = 1101;\n    e.afii10096 = 1102;\n    e.afii10097 = 1103;\n    e.afii10098 = 1169;\n    e.afii10099 = 1106;\n    e.afii10100 = 1107;\n    e.afii10101 = 1108;\n    e.afii10102 = 1109;\n    e.afii10103 = 1110;\n    e.afii10104 = 1111;\n    e.afii10105 = 1112;\n    e.afii10106 = 1113;\n    e.afii10107 = 1114;\n    e.afii10108 = 1115;\n    e.afii10109 = 1116;\n    e.afii10110 = 1118;\n    e.afii10145 = 1039;\n    e.afii10146 = 1122;\n    e.afii10147 = 1138;\n    e.afii10148 = 1140;\n    e.afii10192 = 63174;\n    e.afii10193 = 1119;\n    e.afii10194 = 1123;\n    e.afii10195 = 1139;\n    e.afii10196 = 1141;\n    e.afii10831 = 63175;\n    e.afii10832 = 63176;\n    e.afii10846 = 1241;\n    e.afii299 = 8206;\n    e.afii300 = 8207;\n    e.afii301 = 8205;\n    e.afii57381 = 1642;\n    e.afii57388 = 1548;\n    e.afii57392 = 1632;\n    e.afii57393 = 1633;\n    e.afii57394 = 1634;\n    e.afii57395 = 1635;\n    e.afii57396 = 1636;\n    e.afii57397 = 1637;\n    e.afii57398 = 1638;\n    e.afii57399 = 1639;\n    e.afii57400 = 1640;\n    e.afii57401 = 1641;\n    e.afii57403 = 1563;\n    e.afii57407 = 1567;\n    e.afii57409 = 1569;\n    e.afii57410 = 1570;\n    e.afii57411 = 1571;\n    e.afii57412 = 1572;\n    e.afii57413 = 1573;\n    e.afii57414 = 1574;\n    e.afii57415 = 1575;\n    e.afii57416 = 1576;\n    e.afii57417 = 1577;\n    e.afii57418 = 1578;\n    e.afii57419 = 1579;\n    e.afii57420 = 1580;\n    e.afii57421 = 1581;\n    e.afii57422 = 1582;\n    e.afii57423 = 1583;\n    e.afii57424 = 1584;\n    e.afii57425 = 1585;\n    e.afii57426 = 1586;\n    e.afii57427 = 1587;\n    e.afii57428 = 1588;\n    e.afii57429 = 1589;\n    e.afii57430 = 1590;\n    e.afii57431 = 1591;\n    e.afii57432 = 1592;\n    e.afii57433 = 1593;\n    e.afii57434 = 1594;\n    e.afii57440 = 1600;\n    e.afii57441 = 1601;\n    e.afii57442 = 1602;\n    e.afii57443 = 1603;\n    e.afii57444 = 1604;\n    e.afii57445 = 1605;\n    e.afii57446 = 1606;\n    e.afii57448 = 1608;\n    e.afii57449 = 1609;\n    e.afii57450 = 1610;\n    e.afii57451 = 1611;\n    e.afii57452 = 1612;\n    e.afii57453 = 1613;\n    e.afii57454 = 1614;\n    e.afii57455 = 1615;\n    e.afii57456 = 1616;\n    e.afii57457 = 1617;\n    e.afii57458 = 1618;\n    e.afii57470 = 1607;\n    e.afii57505 = 1700;\n    e.afii57506 = 1662;\n    e.afii57507 = 1670;\n    e.afii57508 = 1688;\n    e.afii57509 = 1711;\n    e.afii57511 = 1657;\n    e.afii57512 = 1672;\n    e.afii57513 = 1681;\n    e.afii57514 = 1722;\n    e.afii57519 = 1746;\n    e.afii57534 = 1749;\n    e.afii57636 = 8362;\n    e.afii57645 = 1470;\n    e.afii57658 = 1475;\n    e.afii57664 = 1488;\n    e.afii57665 = 1489;\n    e.afii57666 = 1490;\n    e.afii57667 = 1491;\n    e.afii57668 = 1492;\n    e.afii57669 = 1493;\n    e.afii57670 = 1494;\n    e.afii57671 = 1495;\n    e.afii57672 = 1496;\n    e.afii57673 = 1497;\n    e.afii57674 = 1498;\n    e.afii57675 = 1499;\n    e.afii57676 = 1500;\n    e.afii57677 = 1501;\n    e.afii57678 = 1502;\n    e.afii57679 = 1503;\n    e.afii57680 = 1504;\n    e.afii57681 = 1505;\n    e.afii57682 = 1506;\n    e.afii57683 = 1507;\n    e.afii57684 = 1508;\n    e.afii57685 = 1509;\n    e.afii57686 = 1510;\n    e.afii57687 = 1511;\n    e.afii57688 = 1512;\n    e.afii57689 = 1513;\n    e.afii57690 = 1514;\n    e.afii57694 = 64298;\n    e.afii57695 = 64299;\n    e.afii57700 = 64331;\n    e.afii57705 = 64287;\n    e.afii57716 = 1520;\n    e.afii57717 = 1521;\n    e.afii57718 = 1522;\n    e.afii57723 = 64309;\n    e.afii57793 = 1460;\n    e.afii57794 = 1461;\n    e.afii57795 = 1462;\n    e.afii57796 = 1467;\n    e.afii57797 = 1464;\n    e.afii57798 = 1463;\n    e.afii57799 = 1456;\n    e.afii57800 = 1458;\n    e.afii57801 = 1457;\n    e.afii57802 = 1459;\n    e.afii57803 = 1474;\n    e.afii57804 = 1473;\n    e.afii57806 = 1465;\n    e.afii57807 = 1468;\n    e.afii57839 = 1469;\n    e.afii57841 = 1471;\n    e.afii57842 = 1472;\n    e.afii57929 = 700;\n    e.afii61248 = 8453;\n    e.afii61289 = 8467;\n    e.afii61352 = 8470;\n    e.afii61573 = 8236;\n    e.afii61574 = 8237;\n    e.afii61575 = 8238;\n    e.afii61664 = 8204;\n    e.afii63167 = 1645;\n    e.afii64937 = 701;\n    e.agrave = 224;\n    e.agujarati = 2693;\n    e.agurmukhi = 2565;\n    e.ahiragana = 12354;\n    e.ahookabove = 7843;\n    e.aibengali = 2448;\n    e.aibopomofo = 12574;\n    e.aideva = 2320;\n    e.aiecyrillic = 1237;\n    e.aigujarati = 2704;\n    e.aigurmukhi = 2576;\n    e.aimatragurmukhi = 2632;\n    e.ainarabic = 1593;\n    e.ainfinalarabic = 65226;\n    e.aininitialarabic = 65227;\n    e.ainmedialarabic = 65228;\n    e.ainvertedbreve = 515;\n    e.aivowelsignbengali = 2504;\n    e.aivowelsigndeva = 2376;\n    e.aivowelsigngujarati = 2760;\n    e.akatakana = 12450;\n    e.akatakanahalfwidth = 65393;\n    e.akorean = 12623;\n    e.alef = 1488;\n    e.alefarabic = 1575;\n    e.alefdageshhebrew = 64304;\n    e.aleffinalarabic = 65166;\n    e.alefhamzaabovearabic = 1571;\n    e.alefhamzaabovefinalarabic = 65156;\n    e.alefhamzabelowarabic = 1573;\n    e.alefhamzabelowfinalarabic = 65160;\n    e.alefhebrew = 1488;\n    e.aleflamedhebrew = 64335;\n    e.alefmaddaabovearabic = 1570;\n    e.alefmaddaabovefinalarabic = 65154;\n    e.alefmaksuraarabic = 1609;\n    e.alefmaksurafinalarabic = 65264;\n    e.alefmaksurainitialarabic = 65267;\n    e.alefmaksuramedialarabic = 65268;\n    e.alefpatahhebrew = 64302;\n    e.alefqamatshebrew = 64303;\n    e.aleph = 8501;\n    e.allequal = 8780;\n    e.alpha = 945;\n    e.alphatonos = 940;\n    e.amacron = 257;\n    e.amonospace = 65345;\n    e.ampersand = 38;\n    e.ampersandmonospace = 65286;\n    e.ampersandsmall = 63270;\n    e.amsquare = 13250;\n    e.anbopomofo = 12578;\n    e.angbopomofo = 12580;\n    e.angbracketleft = 12296;\n    e.angbracketright = 12297;\n    e.angkhankhuthai = 3674;\n    e.angle = 8736;\n    e.anglebracketleft = 12296;\n    e.anglebracketleftvertical = 65087;\n    e.anglebracketright = 12297;\n    e.anglebracketrightvertical = 65088;\n    e.angleleft = 9001;\n    e.angleright = 9002;\n    e.angstrom = 8491;\n    e.anoteleia = 903;\n    e.anudattadeva = 2386;\n    e.anusvarabengali = 2434;\n    e.anusvaradeva = 2306;\n    e.anusvaragujarati = 2690;\n    e.aogonek = 261;\n    e.apaatosquare = 13056;\n    e.aparen = 9372;\n    e.apostrophearmenian = 1370;\n    e.apostrophemod = 700;\n    e.apple = 63743;\n    e.approaches = 8784;\n    e.approxequal = 8776;\n    e.approxequalorimage = 8786;\n    e.approximatelyequal = 8773;\n    e.araeaekorean = 12686;\n    e.araeakorean = 12685;\n    e.arc = 8978;\n    e.arighthalfring = 7834;\n    e.aring = 229;\n    e.aringacute = 507;\n    e.aringbelow = 7681;\n    e.arrowboth = 8596;\n    e.arrowdashdown = 8675;\n    e.arrowdashleft = 8672;\n    e.arrowdashright = 8674;\n    e.arrowdashup = 8673;\n    e.arrowdblboth = 8660;\n    e.arrowdbldown = 8659;\n    e.arrowdblleft = 8656;\n    e.arrowdblright = 8658;\n    e.arrowdblup = 8657;\n    e.arrowdown = 8595;\n    e.arrowdownleft = 8601;\n    e.arrowdownright = 8600;\n    e.arrowdownwhite = 8681;\n    e.arrowheaddownmod = 709;\n    e.arrowheadleftmod = 706;\n    e.arrowheadrightmod = 707;\n    e.arrowheadupmod = 708;\n    e.arrowhorizex = 63719;\n    e.arrowleft = 8592;\n    e.arrowleftdbl = 8656;\n    e.arrowleftdblstroke = 8653;\n    e.arrowleftoverright = 8646;\n    e.arrowleftwhite = 8678;\n    e.arrowright = 8594;\n    e.arrowrightdblstroke = 8655;\n    e.arrowrightheavy = 10142;\n    e.arrowrightoverleft = 8644;\n    e.arrowrightwhite = 8680;\n    e.arrowtableft = 8676;\n    e.arrowtabright = 8677;\n    e.arrowup = 8593;\n    e.arrowupdn = 8597;\n    e.arrowupdnbse = 8616;\n    e.arrowupdownbase = 8616;\n    e.arrowupleft = 8598;\n    e.arrowupleftofdown = 8645;\n    e.arrowupright = 8599;\n    e.arrowupwhite = 8679;\n    e.arrowvertex = 63718;\n    e.asciicircum = 94;\n    e.asciicircummonospace = 65342;\n    e.asciitilde = 126;\n    e.asciitildemonospace = 65374;\n    e.ascript = 593;\n    e.ascriptturned = 594;\n    e.asmallhiragana = 12353;\n    e.asmallkatakana = 12449;\n    e.asmallkatakanahalfwidth = 65383;\n    e.asterisk = 42;\n    e.asteriskaltonearabic = 1645;\n    e.asteriskarabic = 1645;\n    e.asteriskmath = 8727;\n    e.asteriskmonospace = 65290;\n    e.asterisksmall = 65121;\n    e.asterism = 8258;\n    e.asuperior = 63209;\n    e.asymptoticallyequal = 8771;\n    e.at = 64;\n    e.atilde = 227;\n    e.atmonospace = 65312;\n    e.atsmall = 65131;\n    e.aturned = 592;\n    e.aubengali = 2452;\n    e.aubopomofo = 12576;\n    e.audeva = 2324;\n    e.augujarati = 2708;\n    e.augurmukhi = 2580;\n    e.aulengthmarkbengali = 2519;\n    e.aumatragurmukhi = 2636;\n    e.auvowelsignbengali = 2508;\n    e.auvowelsigndeva = 2380;\n    e.auvowelsigngujarati = 2764;\n    e.avagrahadeva = 2365;\n    e.aybarmenian = 1377;\n    e.ayin = 1506;\n    e.ayinaltonehebrew = 64288;\n    e.ayinhebrew = 1506;\n    e.b = 98;\n    e.babengali = 2476;\n    e.backslash = 92;\n    e.backslashmonospace = 65340;\n    e.badeva = 2348;\n    e.bagujarati = 2732;\n    e.bagurmukhi = 2604;\n    e.bahiragana = 12400;\n    e.bahtthai = 3647;\n    e.bakatakana = 12496;\n    e.bar = 124;\n    e.barmonospace = 65372;\n    e.bbopomofo = 12549;\n    e.bcircle = 9425;\n    e.bdotaccent = 7683;\n    e.bdotbelow = 7685;\n    e.beamedsixteenthnotes = 9836;\n    e.because = 8757;\n    e.becyrillic = 1073;\n    e.beharabic = 1576;\n    e.behfinalarabic = 65168;\n    e.behinitialarabic = 65169;\n    e.behiragana = 12409;\n    e.behmedialarabic = 65170;\n    e.behmeeminitialarabic = 64671;\n    e.behmeemisolatedarabic = 64520;\n    e.behnoonfinalarabic = 64621;\n    e.bekatakana = 12505;\n    e.benarmenian = 1378;\n    e.bet = 1489;\n    e.beta = 946;\n    e.betasymbolgreek = 976;\n    e.betdagesh = 64305;\n    e.betdageshhebrew = 64305;\n    e.bethebrew = 1489;\n    e.betrafehebrew = 64332;\n    e.bhabengali = 2477;\n    e.bhadeva = 2349;\n    e.bhagujarati = 2733;\n    e.bhagurmukhi = 2605;\n    e.bhook = 595;\n    e.bihiragana = 12403;\n    e.bikatakana = 12499;\n    e.bilabialclick = 664;\n    e.bindigurmukhi = 2562;\n    e.birusquare = 13105;\n    e.blackcircle = 9679;\n    e.blackdiamond = 9670;\n    e.blackdownpointingtriangle = 9660;\n    e.blackleftpointingpointer = 9668;\n    e.blackleftpointingtriangle = 9664;\n    e.blacklenticularbracketleft = 12304;\n    e.blacklenticularbracketleftvertical = 65083;\n    e.blacklenticularbracketright = 12305;\n    e.blacklenticularbracketrightvertical = 65084;\n    e.blacklowerlefttriangle = 9699;\n    e.blacklowerrighttriangle = 9698;\n    e.blackrectangle = 9644;\n    e.blackrightpointingpointer = 9658;\n    e.blackrightpointingtriangle = 9654;\n    e.blacksmallsquare = 9642;\n    e.blacksmilingface = 9787;\n    e.blacksquare = 9632;\n    e.blackstar = 9733;\n    e.blackupperlefttriangle = 9700;\n    e.blackupperrighttriangle = 9701;\n    e.blackuppointingsmalltriangle = 9652;\n    e.blackuppointingtriangle = 9650;\n    e.blank = 9251;\n    e.blinebelow = 7687;\n    e.block = 9608;\n    e.bmonospace = 65346;\n    e.bobaimaithai = 3610;\n    e.bohiragana = 12412;\n    e.bokatakana = 12508;\n    e.bparen = 9373;\n    e.bqsquare = 13251;\n    e.braceex = 63732;\n    e.braceleft = 123;\n    e.braceleftbt = 63731;\n    e.braceleftmid = 63730;\n    e.braceleftmonospace = 65371;\n    e.braceleftsmall = 65115;\n    e.bracelefttp = 63729;\n    e.braceleftvertical = 65079;\n    e.braceright = 125;\n    e.bracerightbt = 63742;\n    e.bracerightmid = 63741;\n    e.bracerightmonospace = 65373;\n    e.bracerightsmall = 65116;\n    e.bracerighttp = 63740;\n    e.bracerightvertical = 65080;\n    e.bracketleft = 91;\n    e.bracketleftbt = 63728;\n    e.bracketleftex = 63727;\n    e.bracketleftmonospace = 65339;\n    e.bracketlefttp = 63726;\n    e.bracketright = 93;\n    e.bracketrightbt = 63739;\n    e.bracketrightex = 63738;\n    e.bracketrightmonospace = 65341;\n    e.bracketrighttp = 63737;\n    e.breve = 728;\n    e.brevebelowcmb = 814;\n    e.brevecmb = 774;\n    e.breveinvertedbelowcmb = 815;\n    e.breveinvertedcmb = 785;\n    e.breveinverteddoublecmb = 865;\n    e.bridgebelowcmb = 810;\n    e.bridgeinvertedbelowcmb = 826;\n    e.brokenbar = 166;\n    e.bstroke = 384;\n    e.bsuperior = 63210;\n    e.btopbar = 387;\n    e.buhiragana = 12406;\n    e.bukatakana = 12502;\n    e.bullet = 8226;\n    e.bulletinverse = 9688;\n    e.bulletoperator = 8729;\n    e.bullseye = 9678;\n    e.c = 99;\n    e.caarmenian = 1390;\n    e.cabengali = 2458;\n    e.cacute = 263;\n    e.cadeva = 2330;\n    e.cagujarati = 2714;\n    e.cagurmukhi = 2586;\n    e.calsquare = 13192;\n    e.candrabindubengali = 2433;\n    e.candrabinducmb = 784;\n    e.candrabindudeva = 2305;\n    e.candrabindugujarati = 2689;\n    e.capslock = 8682;\n    e.careof = 8453;\n    e.caron = 711;\n    e.caronbelowcmb = 812;\n    e.caroncmb = 780;\n    e.carriagereturn = 8629;\n    e.cbopomofo = 12568;\n    e.ccaron = 269;\n    e.ccedilla = 231;\n    e.ccedillaacute = 7689;\n    e.ccircle = 9426;\n    e.ccircumflex = 265;\n    e.ccurl = 597;\n    e.cdot = 267;\n    e.cdotaccent = 267;\n    e.cdsquare = 13253;\n    e.cedilla = 184;\n    e.cedillacmb = 807;\n    e.cent = 162;\n    e.centigrade = 8451;\n    e.centinferior = 63199;\n    e.centmonospace = 65504;\n    e.centoldstyle = 63394;\n    e.centsuperior = 63200;\n    e.chaarmenian = 1401;\n    e.chabengali = 2459;\n    e.chadeva = 2331;\n    e.chagujarati = 2715;\n    e.chagurmukhi = 2587;\n    e.chbopomofo = 12564;\n    e.cheabkhasiancyrillic = 1213;\n    e.checkmark = 10003;\n    e.checyrillic = 1095;\n    e.chedescenderabkhasiancyrillic = 1215;\n    e.chedescendercyrillic = 1207;\n    e.chedieresiscyrillic = 1269;\n    e.cheharmenian = 1395;\n    e.chekhakassiancyrillic = 1228;\n    e.cheverticalstrokecyrillic = 1209;\n    e.chi = 967;\n    e.chieuchacirclekorean = 12919;\n    e.chieuchaparenkorean = 12823;\n    e.chieuchcirclekorean = 12905;\n    e.chieuchkorean = 12618;\n    e.chieuchparenkorean = 12809;\n    e.chochangthai = 3594;\n    e.chochanthai = 3592;\n    e.chochingthai = 3593;\n    e.chochoethai = 3596;\n    e.chook = 392;\n    e.cieucacirclekorean = 12918;\n    e.cieucaparenkorean = 12822;\n    e.cieuccirclekorean = 12904;\n    e.cieuckorean = 12616;\n    e.cieucparenkorean = 12808;\n    e.cieucuparenkorean = 12828;\n    e.circle = 9675;\n    e.circlecopyrt = 169;\n    e.circlemultiply = 8855;\n    e.circleot = 8857;\n    e.circleplus = 8853;\n    e.circlepostalmark = 12342;\n    e.circlewithlefthalfblack = 9680;\n    e.circlewithrighthalfblack = 9681;\n    e.circumflex = 710;\n    e.circumflexbelowcmb = 813;\n    e.circumflexcmb = 770;\n    e.clear = 8999;\n    e.clickalveolar = 450;\n    e.clickdental = 448;\n    e.clicklateral = 449;\n    e.clickretroflex = 451;\n    e.club = 9827;\n    e.clubsuitblack = 9827;\n    e.clubsuitwhite = 9831;\n    e.cmcubedsquare = 13220;\n    e.cmonospace = 65347;\n    e.cmsquaredsquare = 13216;\n    e.coarmenian = 1409;\n    e.colon = 58;\n    e.colonmonetary = 8353;\n    e.colonmonospace = 65306;\n    e.colonsign = 8353;\n    e.colonsmall = 65109;\n    e.colontriangularhalfmod = 721;\n    e.colontriangularmod = 720;\n    e.comma = 44;\n    e.commaabovecmb = 787;\n    e.commaaboverightcmb = 789;\n    e.commaaccent = 63171;\n    e.commaarabic = 1548;\n    e.commaarmenian = 1373;\n    e.commainferior = 63201;\n    e.commamonospace = 65292;\n    e.commareversedabovecmb = 788;\n    e.commareversedmod = 701;\n    e.commasmall = 65104;\n    e.commasuperior = 63202;\n    e.commaturnedabovecmb = 786;\n    e.commaturnedmod = 699;\n    e.compass = 9788;\n    e.congruent = 8773;\n    e.contourintegral = 8750;\n    e.control = 8963;\n    e.controlACK = 6;\n    e.controlBEL = 7;\n    e.controlBS = 8;\n    e.controlCAN = 24;\n    e.controlCR = 13;\n    e.controlDC1 = 17;\n    e.controlDC2 = 18;\n    e.controlDC3 = 19;\n    e.controlDC4 = 20;\n    e.controlDEL = 127;\n    e.controlDLE = 16;\n    e.controlEM = 25;\n    e.controlENQ = 5;\n    e.controlEOT = 4;\n    e.controlESC = 27;\n    e.controlETB = 23;\n    e.controlETX = 3;\n    e.controlFF = 12;\n    e.controlFS = 28;\n    e.controlGS = 29;\n    e.controlHT = 9;\n    e.controlLF = 10;\n    e.controlNAK = 21;\n    e.controlNULL = 0;\n    e.controlRS = 30;\n    e.controlSI = 15;\n    e.controlSO = 14;\n    e.controlSOT = 2;\n    e.controlSTX = 1;\n    e.controlSUB = 26;\n    e.controlSYN = 22;\n    e.controlUS = 31;\n    e.controlVT = 11;\n    e.copyright = 169;\n    e.copyrightsans = 63721;\n    e.copyrightserif = 63193;\n    e.cornerbracketleft = 12300;\n    e.cornerbracketlefthalfwidth = 65378;\n    e.cornerbracketleftvertical = 65089;\n    e.cornerbracketright = 12301;\n    e.cornerbracketrighthalfwidth = 65379;\n    e.cornerbracketrightvertical = 65090;\n    e.corporationsquare = 13183;\n    e.cosquare = 13255;\n    e.coverkgsquare = 13254;\n    e.cparen = 9374;\n    e.cruzeiro = 8354;\n    e.cstretched = 663;\n    e.curlyand = 8911;\n    e.curlyor = 8910;\n    e.currency = 164;\n    e.cyrBreve = 63185;\n    e.cyrFlex = 63186;\n    e.cyrbreve = 63188;\n    e.cyrflex = 63189;\n    e.d = 100;\n    e.daarmenian = 1380;\n    e.dabengali = 2470;\n    e.dadarabic = 1590;\n    e.dadeva = 2342;\n    e.dadfinalarabic = 65214;\n    e.dadinitialarabic = 65215;\n    e.dadmedialarabic = 65216;\n    e.dagesh = 1468;\n    e.dageshhebrew = 1468;\n    e.dagger = 8224;\n    e.daggerdbl = 8225;\n    e.dagujarati = 2726;\n    e.dagurmukhi = 2598;\n    e.dahiragana = 12384;\n    e.dakatakana = 12480;\n    e.dalarabic = 1583;\n    e.dalet = 1491;\n    e.daletdagesh = 64307;\n    e.daletdageshhebrew = 64307;\n    e.dalethebrew = 1491;\n    e.dalfinalarabic = 65194;\n    e.dammaarabic = 1615;\n    e.dammalowarabic = 1615;\n    e.dammatanaltonearabic = 1612;\n    e.dammatanarabic = 1612;\n    e.danda = 2404;\n    e.dargahebrew = 1447;\n    e.dargalefthebrew = 1447;\n    e.dasiapneumatacyrilliccmb = 1157;\n    e.dblGrave = 63187;\n    e.dblanglebracketleft = 12298;\n    e.dblanglebracketleftvertical = 65085;\n    e.dblanglebracketright = 12299;\n    e.dblanglebracketrightvertical = 65086;\n    e.dblarchinvertedbelowcmb = 811;\n    e.dblarrowleft = 8660;\n    e.dblarrowright = 8658;\n    e.dbldanda = 2405;\n    e.dblgrave = 63190;\n    e.dblgravecmb = 783;\n    e.dblintegral = 8748;\n    e.dbllowline = 8215;\n    e.dbllowlinecmb = 819;\n    e.dbloverlinecmb = 831;\n    e.dblprimemod = 698;\n    e.dblverticalbar = 8214;\n    e.dblverticallineabovecmb = 782;\n    e.dbopomofo = 12553;\n    e.dbsquare = 13256;\n    e.dcaron = 271;\n    e.dcedilla = 7697;\n    e.dcircle = 9427;\n    e.dcircumflexbelow = 7699;\n    e.dcroat = 273;\n    e.ddabengali = 2465;\n    e.ddadeva = 2337;\n    e.ddagujarati = 2721;\n    e.ddagurmukhi = 2593;\n    e.ddalarabic = 1672;\n    e.ddalfinalarabic = 64393;\n    e.dddhadeva = 2396;\n    e.ddhabengali = 2466;\n    e.ddhadeva = 2338;\n    e.ddhagujarati = 2722;\n    e.ddhagurmukhi = 2594;\n    e.ddotaccent = 7691;\n    e.ddotbelow = 7693;\n    e.decimalseparatorarabic = 1643;\n    e.decimalseparatorpersian = 1643;\n    e.decyrillic = 1076;\n    e.degree = 176;\n    e.dehihebrew = 1453;\n    e.dehiragana = 12391;\n    e.deicoptic = 1007;\n    e.dekatakana = 12487;\n    e.deleteleft = 9003;\n    e.deleteright = 8998;\n    e.delta = 948;\n    e.deltaturned = 397;\n    e.denominatorminusonenumeratorbengali = 2552;\n    e.dezh = 676;\n    e.dhabengali = 2471;\n    e.dhadeva = 2343;\n    e.dhagujarati = 2727;\n    e.dhagurmukhi = 2599;\n    e.dhook = 599;\n    e.dialytikatonos = 901;\n    e.dialytikatonoscmb = 836;\n    e.diamond = 9830;\n    e.diamondsuitwhite = 9826;\n    e.dieresis = 168;\n    e.dieresisacute = 63191;\n    e.dieresisbelowcmb = 804;\n    e.dieresiscmb = 776;\n    e.dieresisgrave = 63192;\n    e.dieresistonos = 901;\n    e.dihiragana = 12386;\n    e.dikatakana = 12482;\n    e.dittomark = 12291;\n    e.divide = 247;\n    e.divides = 8739;\n    e.divisionslash = 8725;\n    e.djecyrillic = 1106;\n    e.dkshade = 9619;\n    e.dlinebelow = 7695;\n    e.dlsquare = 13207;\n    e.dmacron = 273;\n    e.dmonospace = 65348;\n    e.dnblock = 9604;\n    e.dochadathai = 3598;\n    e.dodekthai = 3604;\n    e.dohiragana = 12393;\n    e.dokatakana = 12489;\n    e.dollar = 36;\n    e.dollarinferior = 63203;\n    e.dollarmonospace = 65284;\n    e.dollaroldstyle = 63268;\n    e.dollarsmall = 65129;\n    e.dollarsuperior = 63204;\n    e.dong = 8363;\n    e.dorusquare = 13094;\n    e.dotaccent = 729;\n    e.dotaccentcmb = 775;\n    e.dotbelowcmb = 803;\n    e.dotbelowcomb = 803;\n    e.dotkatakana = 12539;\n    e.dotlessi = 305;\n    e.dotlessj = 63166;\n    e.dotlessjstrokehook = 644;\n    e.dotmath = 8901;\n    e.dottedcircle = 9676;\n    e.doubleyodpatah = 64287;\n    e.doubleyodpatahhebrew = 64287;\n    e.downtackbelowcmb = 798;\n    e.downtackmod = 725;\n    e.dparen = 9375;\n    e.dsuperior = 63211;\n    e.dtail = 598;\n    e.dtopbar = 396;\n    e.duhiragana = 12389;\n    e.dukatakana = 12485;\n    e.dz = 499;\n    e.dzaltone = 675;\n    e.dzcaron = 454;\n    e.dzcurl = 677;\n    e.dzeabkhasiancyrillic = 1249;\n    e.dzecyrillic = 1109;\n    e.dzhecyrillic = 1119;\n    e.e = 101;\n    e.eacute = 233;\n    e.earth = 9793;\n    e.ebengali = 2447;\n    e.ebopomofo = 12572;\n    e.ebreve = 277;\n    e.ecandradeva = 2317;\n    e.ecandragujarati = 2701;\n    e.ecandravowelsigndeva = 2373;\n    e.ecandravowelsigngujarati = 2757;\n    e.ecaron = 283;\n    e.ecedillabreve = 7709;\n    e.echarmenian = 1381;\n    e.echyiwnarmenian = 1415;\n    e.ecircle = 9428;\n    e.ecircumflex = 234;\n    e.ecircumflexacute = 7871;\n    e.ecircumflexbelow = 7705;\n    e.ecircumflexdotbelow = 7879;\n    e.ecircumflexgrave = 7873;\n    e.ecircumflexhookabove = 7875;\n    e.ecircumflextilde = 7877;\n    e.ecyrillic = 1108;\n    e.edblgrave = 517;\n    e.edeva = 2319;\n    e.edieresis = 235;\n    e.edot = 279;\n    e.edotaccent = 279;\n    e.edotbelow = 7865;\n    e.eegurmukhi = 2575;\n    e.eematragurmukhi = 2631;\n    e.efcyrillic = 1092;\n    e.egrave = 232;\n    e.egujarati = 2703;\n    e.eharmenian = 1383;\n    e.ehbopomofo = 12573;\n    e.ehiragana = 12360;\n    e.ehookabove = 7867;\n    e.eibopomofo = 12575;\n    e.eight = 56;\n    e.eightarabic = 1640;\n    e.eightbengali = 2542;\n    e.eightcircle = 9319;\n    e.eightcircleinversesansserif = 10129;\n    e.eightdeva = 2414;\n    e.eighteencircle = 9329;\n    e.eighteenparen = 9349;\n    e.eighteenperiod = 9369;\n    e.eightgujarati = 2798;\n    e.eightgurmukhi = 2670;\n    e.eighthackarabic = 1640;\n    e.eighthangzhou = 12328;\n    e.eighthnotebeamed = 9835;\n    e.eightideographicparen = 12839;\n    e.eightinferior = 8328;\n    e.eightmonospace = 65304;\n    e.eightoldstyle = 63288;\n    e.eightparen = 9339;\n    e.eightperiod = 9359;\n    e.eightpersian = 1784;\n    e.eightroman = 8567;\n    e.eightsuperior = 8312;\n    e.eightthai = 3672;\n    e.einvertedbreve = 519;\n    e.eiotifiedcyrillic = 1125;\n    e.ekatakana = 12456;\n    e.ekatakanahalfwidth = 65396;\n    e.ekonkargurmukhi = 2676;\n    e.ekorean = 12628;\n    e.elcyrillic = 1083;\n    e.element = 8712;\n    e.elevencircle = 9322;\n    e.elevenparen = 9342;\n    e.elevenperiod = 9362;\n    e.elevenroman = 8570;\n    e.ellipsis = 8230;\n    e.ellipsisvertical = 8942;\n    e.emacron = 275;\n    e.emacronacute = 7703;\n    e.emacrongrave = 7701;\n    e.emcyrillic = 1084;\n    e.emdash = 8212;\n    e.emdashvertical = 65073;\n    e.emonospace = 65349;\n    e.emphasismarkarmenian = 1371;\n    e.emptyset = 8709;\n    e.enbopomofo = 12579;\n    e.encyrillic = 1085;\n    e.endash = 8211;\n    e.endashvertical = 65074;\n    e.endescendercyrillic = 1187;\n    e.eng = 331;\n    e.engbopomofo = 12581;\n    e.enghecyrillic = 1189;\n    e.enhookcyrillic = 1224;\n    e.enspace = 8194;\n    e.eogonek = 281;\n    e.eokorean = 12627;\n    e.eopen = 603;\n    e.eopenclosed = 666;\n    e.eopenreversed = 604;\n    e.eopenreversedclosed = 606;\n    e.eopenreversedhook = 605;\n    e.eparen = 9376;\n    e.epsilon = 949;\n    e.epsilontonos = 941;\n    e.equal = 61;\n    e.equalmonospace = 65309;\n    e.equalsmall = 65126;\n    e.equalsuperior = 8316;\n    e.equivalence = 8801;\n    e.erbopomofo = 12582;\n    e.ercyrillic = 1088;\n    e.ereversed = 600;\n    e.ereversedcyrillic = 1101;\n    e.escyrillic = 1089;\n    e.esdescendercyrillic = 1195;\n    e.esh = 643;\n    e.eshcurl = 646;\n    e.eshortdeva = 2318;\n    e.eshortvowelsigndeva = 2374;\n    e.eshreversedloop = 426;\n    e.eshsquatreversed = 645;\n    e.esmallhiragana = 12359;\n    e.esmallkatakana = 12455;\n    e.esmallkatakanahalfwidth = 65386;\n    e.estimated = 8494;\n    e.esuperior = 63212;\n    e.eta = 951;\n    e.etarmenian = 1384;\n    e.etatonos = 942;\n    e.eth = 240;\n    e.etilde = 7869;\n    e.etildebelow = 7707;\n    e.etnahtafoukhhebrew = 1425;\n    e.etnahtafoukhlefthebrew = 1425;\n    e.etnahtahebrew = 1425;\n    e.etnahtalefthebrew = 1425;\n    e.eturned = 477;\n    e.eukorean = 12641;\n    e.euro = 8364;\n    e.evowelsignbengali = 2503;\n    e.evowelsigndeva = 2375;\n    e.evowelsigngujarati = 2759;\n    e.exclam = 33;\n    e.exclamarmenian = 1372;\n    e.exclamdbl = 8252;\n    e.exclamdown = 161;\n    e.exclamdownsmall = 63393;\n    e.exclammonospace = 65281;\n    e.exclamsmall = 63265;\n    e.existential = 8707;\n    e.ezh = 658;\n    e.ezhcaron = 495;\n    e.ezhcurl = 659;\n    e.ezhreversed = 441;\n    e.ezhtail = 442;\n    e.f = 102;\n    e.fadeva = 2398;\n    e.fagurmukhi = 2654;\n    e.fahrenheit = 8457;\n    e.fathaarabic = 1614;\n    e.fathalowarabic = 1614;\n    e.fathatanarabic = 1611;\n    e.fbopomofo = 12552;\n    e.fcircle = 9429;\n    e.fdotaccent = 7711;\n    e.feharabic = 1601;\n    e.feharmenian = 1414;\n    e.fehfinalarabic = 65234;\n    e.fehinitialarabic = 65235;\n    e.fehmedialarabic = 65236;\n    e.feicoptic = 997;\n    e.female = 9792;\n    e.ff = 64256;\n    e.f_f = 64256;\n    e.ffi = 64259;\n    e.f_f_i = 64259;\n    e.ffl = 64260;\n    e.f_f_l = 64260;\n    e.fi = 64257;\n    e.f_i = 64257;\n    e.fifteencircle = 9326;\n    e.fifteenparen = 9346;\n    e.fifteenperiod = 9366;\n    e.figuredash = 8210;\n    e.filledbox = 9632;\n    e.filledrect = 9644;\n    e.finalkaf = 1498;\n    e.finalkafdagesh = 64314;\n    e.finalkafdageshhebrew = 64314;\n    e.finalkafhebrew = 1498;\n    e.finalmem = 1501;\n    e.finalmemhebrew = 1501;\n    e.finalnun = 1503;\n    e.finalnunhebrew = 1503;\n    e.finalpe = 1507;\n    e.finalpehebrew = 1507;\n    e.finaltsadi = 1509;\n    e.finaltsadihebrew = 1509;\n    e.firsttonechinese = 713;\n    e.fisheye = 9673;\n    e.fitacyrillic = 1139;\n    e.five = 53;\n    e.fivearabic = 1637;\n    e.fivebengali = 2539;\n    e.fivecircle = 9316;\n    e.fivecircleinversesansserif = 10126;\n    e.fivedeva = 2411;\n    e.fiveeighths = 8541;\n    e.fivegujarati = 2795;\n    e.fivegurmukhi = 2667;\n    e.fivehackarabic = 1637;\n    e.fivehangzhou = 12325;\n    e.fiveideographicparen = 12836;\n    e.fiveinferior = 8325;\n    e.fivemonospace = 65301;\n    e.fiveoldstyle = 63285;\n    e.fiveparen = 9336;\n    e.fiveperiod = 9356;\n    e.fivepersian = 1781;\n    e.fiveroman = 8564;\n    e.fivesuperior = 8309;\n    e.fivethai = 3669;\n    e.fl = 64258;\n    e.f_l = 64258;\n    e.florin = 402;\n    e.fmonospace = 65350;\n    e.fmsquare = 13209;\n    e.fofanthai = 3615;\n    e.fofathai = 3613;\n    e.fongmanthai = 3663;\n    e.forall = 8704;\n    e.four = 52;\n    e.fourarabic = 1636;\n    e.fourbengali = 2538;\n    e.fourcircle = 9315;\n    e.fourcircleinversesansserif = 10125;\n    e.fourdeva = 2410;\n    e.fourgujarati = 2794;\n    e.fourgurmukhi = 2666;\n    e.fourhackarabic = 1636;\n    e.fourhangzhou = 12324;\n    e.fourideographicparen = 12835;\n    e.fourinferior = 8324;\n    e.fourmonospace = 65300;\n    e.fournumeratorbengali = 2551;\n    e.fouroldstyle = 63284;\n    e.fourparen = 9335;\n    e.fourperiod = 9355;\n    e.fourpersian = 1780;\n    e.fourroman = 8563;\n    e.foursuperior = 8308;\n    e.fourteencircle = 9325;\n    e.fourteenparen = 9345;\n    e.fourteenperiod = 9365;\n    e.fourthai = 3668;\n    e.fourthtonechinese = 715;\n    e.fparen = 9377;\n    e.fraction = 8260;\n    e.franc = 8355;\n    e.g = 103;\n    e.gabengali = 2455;\n    e.gacute = 501;\n    e.gadeva = 2327;\n    e.gafarabic = 1711;\n    e.gaffinalarabic = 64403;\n    e.gafinitialarabic = 64404;\n    e.gafmedialarabic = 64405;\n    e.gagujarati = 2711;\n    e.gagurmukhi = 2583;\n    e.gahiragana = 12364;\n    e.gakatakana = 12460;\n    e.gamma = 947;\n    e.gammalatinsmall = 611;\n    e.gammasuperior = 736;\n    e.gangiacoptic = 1003;\n    e.gbopomofo = 12557;\n    e.gbreve = 287;\n    e.gcaron = 487;\n    e.gcedilla = 291;\n    e.gcircle = 9430;\n    e.gcircumflex = 285;\n    e.gcommaaccent = 291;\n    e.gdot = 289;\n    e.gdotaccent = 289;\n    e.gecyrillic = 1075;\n    e.gehiragana = 12370;\n    e.gekatakana = 12466;\n    e.geometricallyequal = 8785;\n    e.gereshaccenthebrew = 1436;\n    e.gereshhebrew = 1523;\n    e.gereshmuqdamhebrew = 1437;\n    e.germandbls = 223;\n    e.gershayimaccenthebrew = 1438;\n    e.gershayimhebrew = 1524;\n    e.getamark = 12307;\n    e.ghabengali = 2456;\n    e.ghadarmenian = 1394;\n    e.ghadeva = 2328;\n    e.ghagujarati = 2712;\n    e.ghagurmukhi = 2584;\n    e.ghainarabic = 1594;\n    e.ghainfinalarabic = 65230;\n    e.ghaininitialarabic = 65231;\n    e.ghainmedialarabic = 65232;\n    e.ghemiddlehookcyrillic = 1173;\n    e.ghestrokecyrillic = 1171;\n    e.gheupturncyrillic = 1169;\n    e.ghhadeva = 2394;\n    e.ghhagurmukhi = 2650;\n    e.ghook = 608;\n    e.ghzsquare = 13203;\n    e.gihiragana = 12366;\n    e.gikatakana = 12462;\n    e.gimarmenian = 1379;\n    e.gimel = 1490;\n    e.gimeldagesh = 64306;\n    e.gimeldageshhebrew = 64306;\n    e.gimelhebrew = 1490;\n    e.gjecyrillic = 1107;\n    e.glottalinvertedstroke = 446;\n    e.glottalstop = 660;\n    e.glottalstopinverted = 662;\n    e.glottalstopmod = 704;\n    e.glottalstopreversed = 661;\n    e.glottalstopreversedmod = 705;\n    e.glottalstopreversedsuperior = 740;\n    e.glottalstopstroke = 673;\n    e.glottalstopstrokereversed = 674;\n    e.gmacron = 7713;\n    e.gmonospace = 65351;\n    e.gohiragana = 12372;\n    e.gokatakana = 12468;\n    e.gparen = 9378;\n    e.gpasquare = 13228;\n    e.gradient = 8711;\n    e.grave = 96;\n    e.gravebelowcmb = 790;\n    e.gravecmb = 768;\n    e.gravecomb = 768;\n    e.gravedeva = 2387;\n    e.gravelowmod = 718;\n    e.gravemonospace = 65344;\n    e.gravetonecmb = 832;\n    e.greater = 62;\n    e.greaterequal = 8805;\n    e.greaterequalorless = 8923;\n    e.greatermonospace = 65310;\n    e.greaterorequivalent = 8819;\n    e.greaterorless = 8823;\n    e.greateroverequal = 8807;\n    e.greatersmall = 65125;\n    e.gscript = 609;\n    e.gstroke = 485;\n    e.guhiragana = 12368;\n    e.guillemotleft = 171;\n    e.guillemotright = 187;\n    e.guilsinglleft = 8249;\n    e.guilsinglright = 8250;\n    e.gukatakana = 12464;\n    e.guramusquare = 13080;\n    e.gysquare = 13257;\n    e.h = 104;\n    e.haabkhasiancyrillic = 1193;\n    e.haaltonearabic = 1729;\n    e.habengali = 2489;\n    e.hadescendercyrillic = 1203;\n    e.hadeva = 2361;\n    e.hagujarati = 2745;\n    e.hagurmukhi = 2617;\n    e.haharabic = 1581;\n    e.hahfinalarabic = 65186;\n    e.hahinitialarabic = 65187;\n    e.hahiragana = 12399;\n    e.hahmedialarabic = 65188;\n    e.haitusquare = 13098;\n    e.hakatakana = 12495;\n    e.hakatakanahalfwidth = 65418;\n    e.halantgurmukhi = 2637;\n    e.hamzaarabic = 1569;\n    e.hamzalowarabic = 1569;\n    e.hangulfiller = 12644;\n    e.hardsigncyrillic = 1098;\n    e.harpoonleftbarbup = 8636;\n    e.harpoonrightbarbup = 8640;\n    e.hasquare = 13258;\n    e.hatafpatah = 1458;\n    e.hatafpatah16 = 1458;\n    e.hatafpatah23 = 1458;\n    e.hatafpatah2f = 1458;\n    e.hatafpatahhebrew = 1458;\n    e.hatafpatahnarrowhebrew = 1458;\n    e.hatafpatahquarterhebrew = 1458;\n    e.hatafpatahwidehebrew = 1458;\n    e.hatafqamats = 1459;\n    e.hatafqamats1b = 1459;\n    e.hatafqamats28 = 1459;\n    e.hatafqamats34 = 1459;\n    e.hatafqamatshebrew = 1459;\n    e.hatafqamatsnarrowhebrew = 1459;\n    e.hatafqamatsquarterhebrew = 1459;\n    e.hatafqamatswidehebrew = 1459;\n    e.hatafsegol = 1457;\n    e.hatafsegol17 = 1457;\n    e.hatafsegol24 = 1457;\n    e.hatafsegol30 = 1457;\n    e.hatafsegolhebrew = 1457;\n    e.hatafsegolnarrowhebrew = 1457;\n    e.hatafsegolquarterhebrew = 1457;\n    e.hatafsegolwidehebrew = 1457;\n    e.hbar = 295;\n    e.hbopomofo = 12559;\n    e.hbrevebelow = 7723;\n    e.hcedilla = 7721;\n    e.hcircle = 9431;\n    e.hcircumflex = 293;\n    e.hdieresis = 7719;\n    e.hdotaccent = 7715;\n    e.hdotbelow = 7717;\n    e.he = 1492;\n    e.heart = 9829;\n    e.heartsuitblack = 9829;\n    e.heartsuitwhite = 9825;\n    e.hedagesh = 64308;\n    e.hedageshhebrew = 64308;\n    e.hehaltonearabic = 1729;\n    e.heharabic = 1607;\n    e.hehebrew = 1492;\n    e.hehfinalaltonearabic = 64423;\n    e.hehfinalalttwoarabic = 65258;\n    e.hehfinalarabic = 65258;\n    e.hehhamzaabovefinalarabic = 64421;\n    e.hehhamzaaboveisolatedarabic = 64420;\n    e.hehinitialaltonearabic = 64424;\n    e.hehinitialarabic = 65259;\n    e.hehiragana = 12408;\n    e.hehmedialaltonearabic = 64425;\n    e.hehmedialarabic = 65260;\n    e.heiseierasquare = 13179;\n    e.hekatakana = 12504;\n    e.hekatakanahalfwidth = 65421;\n    e.hekutaarusquare = 13110;\n    e.henghook = 615;\n    e.herutusquare = 13113;\n    e.het = 1495;\n    e.hethebrew = 1495;\n    e.hhook = 614;\n    e.hhooksuperior = 689;\n    e.hieuhacirclekorean = 12923;\n    e.hieuhaparenkorean = 12827;\n    e.hieuhcirclekorean = 12909;\n    e.hieuhkorean = 12622;\n    e.hieuhparenkorean = 12813;\n    e.hihiragana = 12402;\n    e.hikatakana = 12498;\n    e.hikatakanahalfwidth = 65419;\n    e.hiriq = 1460;\n    e.hiriq14 = 1460;\n    e.hiriq21 = 1460;\n    e.hiriq2d = 1460;\n    e.hiriqhebrew = 1460;\n    e.hiriqnarrowhebrew = 1460;\n    e.hiriqquarterhebrew = 1460;\n    e.hiriqwidehebrew = 1460;\n    e.hlinebelow = 7830;\n    e.hmonospace = 65352;\n    e.hoarmenian = 1392;\n    e.hohipthai = 3627;\n    e.hohiragana = 12411;\n    e.hokatakana = 12507;\n    e.hokatakanahalfwidth = 65422;\n    e.holam = 1465;\n    e.holam19 = 1465;\n    e.holam26 = 1465;\n    e.holam32 = 1465;\n    e.holamhebrew = 1465;\n    e.holamnarrowhebrew = 1465;\n    e.holamquarterhebrew = 1465;\n    e.holamwidehebrew = 1465;\n    e.honokhukthai = 3630;\n    e.hookabovecomb = 777;\n    e.hookcmb = 777;\n    e.hookpalatalizedbelowcmb = 801;\n    e.hookretroflexbelowcmb = 802;\n    e.hoonsquare = 13122;\n    e.horicoptic = 1001;\n    e.horizontalbar = 8213;\n    e.horncmb = 795;\n    e.hotsprings = 9832;\n    e.house = 8962;\n    e.hparen = 9379;\n    e.hsuperior = 688;\n    e.hturned = 613;\n    e.huhiragana = 12405;\n    e.huiitosquare = 13107;\n    e.hukatakana = 12501;\n    e.hukatakanahalfwidth = 65420;\n    e.hungarumlaut = 733;\n    e.hungarumlautcmb = 779;\n    e.hv = 405;\n    e.hyphen = 45;\n    e.hypheninferior = 63205;\n    e.hyphenmonospace = 65293;\n    e.hyphensmall = 65123;\n    e.hyphensuperior = 63206;\n    e.hyphentwo = 8208;\n    e.i = 105;\n    e.iacute = 237;\n    e.iacyrillic = 1103;\n    e.ibengali = 2439;\n    e.ibopomofo = 12583;\n    e.ibreve = 301;\n    e.icaron = 464;\n    e.icircle = 9432;\n    e.icircumflex = 238;\n    e.icyrillic = 1110;\n    e.idblgrave = 521;\n    e.ideographearthcircle = 12943;\n    e.ideographfirecircle = 12939;\n    e.ideographicallianceparen = 12863;\n    e.ideographiccallparen = 12858;\n    e.ideographiccentrecircle = 12965;\n    e.ideographicclose = 12294;\n    e.ideographiccomma = 12289;\n    e.ideographiccommaleft = 65380;\n    e.ideographiccongratulationparen = 12855;\n    e.ideographiccorrectcircle = 12963;\n    e.ideographicearthparen = 12847;\n    e.ideographicenterpriseparen = 12861;\n    e.ideographicexcellentcircle = 12957;\n    e.ideographicfestivalparen = 12864;\n    e.ideographicfinancialcircle = 12950;\n    e.ideographicfinancialparen = 12854;\n    e.ideographicfireparen = 12843;\n    e.ideographichaveparen = 12850;\n    e.ideographichighcircle = 12964;\n    e.ideographiciterationmark = 12293;\n    e.ideographiclaborcircle = 12952;\n    e.ideographiclaborparen = 12856;\n    e.ideographicleftcircle = 12967;\n    e.ideographiclowcircle = 12966;\n    e.ideographicmedicinecircle = 12969;\n    e.ideographicmetalparen = 12846;\n    e.ideographicmoonparen = 12842;\n    e.ideographicnameparen = 12852;\n    e.ideographicperiod = 12290;\n    e.ideographicprintcircle = 12958;\n    e.ideographicreachparen = 12867;\n    e.ideographicrepresentparen = 12857;\n    e.ideographicresourceparen = 12862;\n    e.ideographicrightcircle = 12968;\n    e.ideographicsecretcircle = 12953;\n    e.ideographicselfparen = 12866;\n    e.ideographicsocietyparen = 12851;\n    e.ideographicspace = 12288;\n    e.ideographicspecialparen = 12853;\n    e.ideographicstockparen = 12849;\n    e.ideographicstudyparen = 12859;\n    e.ideographicsunparen = 12848;\n    e.ideographicsuperviseparen = 12860;\n    e.ideographicwaterparen = 12844;\n    e.ideographicwoodparen = 12845;\n    e.ideographiczero = 12295;\n    e.ideographmetalcircle = 12942;\n    e.ideographmooncircle = 12938;\n    e.ideographnamecircle = 12948;\n    e.ideographsuncircle = 12944;\n    e.ideographwatercircle = 12940;\n    e.ideographwoodcircle = 12941;\n    e.ideva = 2311;\n    e.idieresis = 239;\n    e.idieresisacute = 7727;\n    e.idieresiscyrillic = 1253;\n    e.idotbelow = 7883;\n    e.iebrevecyrillic = 1239;\n    e.iecyrillic = 1077;\n    e.ieungacirclekorean = 12917;\n    e.ieungaparenkorean = 12821;\n    e.ieungcirclekorean = 12903;\n    e.ieungkorean = 12615;\n    e.ieungparenkorean = 12807;\n    e.igrave = 236;\n    e.igujarati = 2695;\n    e.igurmukhi = 2567;\n    e.ihiragana = 12356;\n    e.ihookabove = 7881;\n    e.iibengali = 2440;\n    e.iicyrillic = 1080;\n    e.iideva = 2312;\n    e.iigujarati = 2696;\n    e.iigurmukhi = 2568;\n    e.iimatragurmukhi = 2624;\n    e.iinvertedbreve = 523;\n    e.iishortcyrillic = 1081;\n    e.iivowelsignbengali = 2496;\n    e.iivowelsigndeva = 2368;\n    e.iivowelsigngujarati = 2752;\n    e.ij = 307;\n    e.ikatakana = 12452;\n    e.ikatakanahalfwidth = 65394;\n    e.ikorean = 12643;\n    e.ilde = 732;\n    e.iluyhebrew = 1452;\n    e.imacron = 299;\n    e.imacroncyrillic = 1251;\n    e.imageorapproximatelyequal = 8787;\n    e.imatragurmukhi = 2623;\n    e.imonospace = 65353;\n    e.increment = 8710;\n    e.infinity = 8734;\n    e.iniarmenian = 1387;\n    e.integral = 8747;\n    e.integralbottom = 8993;\n    e.integralbt = 8993;\n    e.integralex = 63733;\n    e.integraltop = 8992;\n    e.integraltp = 8992;\n    e.intersection = 8745;\n    e.intisquare = 13061;\n    e.invbullet = 9688;\n    e.invcircle = 9689;\n    e.invsmileface = 9787;\n    e.iocyrillic = 1105;\n    e.iogonek = 303;\n    e.iota = 953;\n    e.iotadieresis = 970;\n    e.iotadieresistonos = 912;\n    e.iotalatin = 617;\n    e.iotatonos = 943;\n    e.iparen = 9380;\n    e.irigurmukhi = 2674;\n    e.ismallhiragana = 12355;\n    e.ismallkatakana = 12451;\n    e.ismallkatakanahalfwidth = 65384;\n    e.issharbengali = 2554;\n    e.istroke = 616;\n    e.isuperior = 63213;\n    e.iterationhiragana = 12445;\n    e.iterationkatakana = 12541;\n    e.itilde = 297;\n    e.itildebelow = 7725;\n    e.iubopomofo = 12585;\n    e.iucyrillic = 1102;\n    e.ivowelsignbengali = 2495;\n    e.ivowelsigndeva = 2367;\n    e.ivowelsigngujarati = 2751;\n    e.izhitsacyrillic = 1141;\n    e.izhitsadblgravecyrillic = 1143;\n    e.j = 106;\n    e.jaarmenian = 1393;\n    e.jabengali = 2460;\n    e.jadeva = 2332;\n    e.jagujarati = 2716;\n    e.jagurmukhi = 2588;\n    e.jbopomofo = 12560;\n    e.jcaron = 496;\n    e.jcircle = 9433;\n    e.jcircumflex = 309;\n    e.jcrossedtail = 669;\n    e.jdotlessstroke = 607;\n    e.jecyrillic = 1112;\n    e.jeemarabic = 1580;\n    e.jeemfinalarabic = 65182;\n    e.jeeminitialarabic = 65183;\n    e.jeemmedialarabic = 65184;\n    e.jeharabic = 1688;\n    e.jehfinalarabic = 64395;\n    e.jhabengali = 2461;\n    e.jhadeva = 2333;\n    e.jhagujarati = 2717;\n    e.jhagurmukhi = 2589;\n    e.jheharmenian = 1403;\n    e.jis = 12292;\n    e.jmonospace = 65354;\n    e.jparen = 9381;\n    e.jsuperior = 690;\n    e.k = 107;\n    e.kabashkircyrillic = 1185;\n    e.kabengali = 2453;\n    e.kacute = 7729;\n    e.kacyrillic = 1082;\n    e.kadescendercyrillic = 1179;\n    e.kadeva = 2325;\n    e.kaf = 1499;\n    e.kafarabic = 1603;\n    e.kafdagesh = 64315;\n    e.kafdageshhebrew = 64315;\n    e.kaffinalarabic = 65242;\n    e.kafhebrew = 1499;\n    e.kafinitialarabic = 65243;\n    e.kafmedialarabic = 65244;\n    e.kafrafehebrew = 64333;\n    e.kagujarati = 2709;\n    e.kagurmukhi = 2581;\n    e.kahiragana = 12363;\n    e.kahookcyrillic = 1220;\n    e.kakatakana = 12459;\n    e.kakatakanahalfwidth = 65398;\n    e.kappa = 954;\n    e.kappasymbolgreek = 1008;\n    e.kapyeounmieumkorean = 12657;\n    e.kapyeounphieuphkorean = 12676;\n    e.kapyeounpieupkorean = 12664;\n    e.kapyeounssangpieupkorean = 12665;\n    e.karoriisquare = 13069;\n    e.kashidaautoarabic = 1600;\n    e.kashidaautonosidebearingarabic = 1600;\n    e.kasmallkatakana = 12533;\n    e.kasquare = 13188;\n    e.kasraarabic = 1616;\n    e.kasratanarabic = 1613;\n    e.kastrokecyrillic = 1183;\n    e.katahiraprolongmarkhalfwidth = 65392;\n    e.kaverticalstrokecyrillic = 1181;\n    e.kbopomofo = 12558;\n    e.kcalsquare = 13193;\n    e.kcaron = 489;\n    e.kcedilla = 311;\n    e.kcircle = 9434;\n    e.kcommaaccent = 311;\n    e.kdotbelow = 7731;\n    e.keharmenian = 1412;\n    e.kehiragana = 12369;\n    e.kekatakana = 12465;\n    e.kekatakanahalfwidth = 65401;\n    e.kenarmenian = 1391;\n    e.kesmallkatakana = 12534;\n    e.kgreenlandic = 312;\n    e.khabengali = 2454;\n    e.khacyrillic = 1093;\n    e.khadeva = 2326;\n    e.khagujarati = 2710;\n    e.khagurmukhi = 2582;\n    e.khaharabic = 1582;\n    e.khahfinalarabic = 65190;\n    e.khahinitialarabic = 65191;\n    e.khahmedialarabic = 65192;\n    e.kheicoptic = 999;\n    e.khhadeva = 2393;\n    e.khhagurmukhi = 2649;\n    e.khieukhacirclekorean = 12920;\n    e.khieukhaparenkorean = 12824;\n    e.khieukhcirclekorean = 12906;\n    e.khieukhkorean = 12619;\n    e.khieukhparenkorean = 12810;\n    e.khokhaithai = 3586;\n    e.khokhonthai = 3589;\n    e.khokhuatthai = 3587;\n    e.khokhwaithai = 3588;\n    e.khomutthai = 3675;\n    e.khook = 409;\n    e.khorakhangthai = 3590;\n    e.khzsquare = 13201;\n    e.kihiragana = 12365;\n    e.kikatakana = 12461;\n    e.kikatakanahalfwidth = 65399;\n    e.kiroguramusquare = 13077;\n    e.kiromeetorusquare = 13078;\n    e.kirosquare = 13076;\n    e.kiyeokacirclekorean = 12910;\n    e.kiyeokaparenkorean = 12814;\n    e.kiyeokcirclekorean = 12896;\n    e.kiyeokkorean = 12593;\n    e.kiyeokparenkorean = 12800;\n    e.kiyeoksioskorean = 12595;\n    e.kjecyrillic = 1116;\n    e.klinebelow = 7733;\n    e.klsquare = 13208;\n    e.kmcubedsquare = 13222;\n    e.kmonospace = 65355;\n    e.kmsquaredsquare = 13218;\n    e.kohiragana = 12371;\n    e.kohmsquare = 13248;\n    e.kokaithai = 3585;\n    e.kokatakana = 12467;\n    e.kokatakanahalfwidth = 65402;\n    e.kooposquare = 13086;\n    e.koppacyrillic = 1153;\n    e.koreanstandardsymbol = 12927;\n    e.koroniscmb = 835;\n    e.kparen = 9382;\n    e.kpasquare = 13226;\n    e.ksicyrillic = 1135;\n    e.ktsquare = 13263;\n    e.kturned = 670;\n    e.kuhiragana = 12367;\n    e.kukatakana = 12463;\n    e.kukatakanahalfwidth = 65400;\n    e.kvsquare = 13240;\n    e.kwsquare = 13246;\n    e.l = 108;\n    e.labengali = 2482;\n    e.lacute = 314;\n    e.ladeva = 2354;\n    e.lagujarati = 2738;\n    e.lagurmukhi = 2610;\n    e.lakkhangyaothai = 3653;\n    e.lamaleffinalarabic = 65276;\n    e.lamalefhamzaabovefinalarabic = 65272;\n    e.lamalefhamzaaboveisolatedarabic = 65271;\n    e.lamalefhamzabelowfinalarabic = 65274;\n    e.lamalefhamzabelowisolatedarabic = 65273;\n    e.lamalefisolatedarabic = 65275;\n    e.lamalefmaddaabovefinalarabic = 65270;\n    e.lamalefmaddaaboveisolatedarabic = 65269;\n    e.lamarabic = 1604;\n    e.lambda = 955;\n    e.lambdastroke = 411;\n    e.lamed = 1500;\n    e.lameddagesh = 64316;\n    e.lameddageshhebrew = 64316;\n    e.lamedhebrew = 1500;\n    e.lamfinalarabic = 65246;\n    e.lamhahinitialarabic = 64714;\n    e.laminitialarabic = 65247;\n    e.lamjeeminitialarabic = 64713;\n    e.lamkhahinitialarabic = 64715;\n    e.lamlamhehisolatedarabic = 65010;\n    e.lammedialarabic = 65248;\n    e.lammeemhahinitialarabic = 64904;\n    e.lammeeminitialarabic = 64716;\n    e.largecircle = 9711;\n    e.lbar = 410;\n    e.lbelt = 620;\n    e.lbopomofo = 12556;\n    e.lcaron = 318;\n    e.lcedilla = 316;\n    e.lcircle = 9435;\n    e.lcircumflexbelow = 7741;\n    e.lcommaaccent = 316;\n    e.ldot = 320;\n    e.ldotaccent = 320;\n    e.ldotbelow = 7735;\n    e.ldotbelowmacron = 7737;\n    e.leftangleabovecmb = 794;\n    e.lefttackbelowcmb = 792;\n    e.less = 60;\n    e.lessequal = 8804;\n    e.lessequalorgreater = 8922;\n    e.lessmonospace = 65308;\n    e.lessorequivalent = 8818;\n    e.lessorgreater = 8822;\n    e.lessoverequal = 8806;\n    e.lesssmall = 65124;\n    e.lezh = 622;\n    e.lfblock = 9612;\n    e.lhookretroflex = 621;\n    e.lira = 8356;\n    e.liwnarmenian = 1388;\n    e.lj = 457;\n    e.ljecyrillic = 1113;\n    e.ll = 63168;\n    e.lladeva = 2355;\n    e.llagujarati = 2739;\n    e.llinebelow = 7739;\n    e.llladeva = 2356;\n    e.llvocalicbengali = 2529;\n    e.llvocalicdeva = 2401;\n    e.llvocalicvowelsignbengali = 2531;\n    e.llvocalicvowelsigndeva = 2403;\n    e.lmiddletilde = 619;\n    e.lmonospace = 65356;\n    e.lmsquare = 13264;\n    e.lochulathai = 3628;\n    e.logicaland = 8743;\n    e.logicalnot = 172;\n    e.logicalnotreversed = 8976;\n    e.logicalor = 8744;\n    e.lolingthai = 3621;\n    e.longs = 383;\n    e.lowlinecenterline = 65102;\n    e.lowlinecmb = 818;\n    e.lowlinedashed = 65101;\n    e.lozenge = 9674;\n    e.lparen = 9383;\n    e.lslash = 322;\n    e.lsquare = 8467;\n    e.lsuperior = 63214;\n    e.ltshade = 9617;\n    e.luthai = 3622;\n    e.lvocalicbengali = 2444;\n    e.lvocalicdeva = 2316;\n    e.lvocalicvowelsignbengali = 2530;\n    e.lvocalicvowelsigndeva = 2402;\n    e.lxsquare = 13267;\n    e.m = 109;\n    e.mabengali = 2478;\n    e.macron = 175;\n    e.macronbelowcmb = 817;\n    e.macroncmb = 772;\n    e.macronlowmod = 717;\n    e.macronmonospace = 65507;\n    e.macute = 7743;\n    e.madeva = 2350;\n    e.magujarati = 2734;\n    e.magurmukhi = 2606;\n    e.mahapakhhebrew = 1444;\n    e.mahapakhlefthebrew = 1444;\n    e.mahiragana = 12414;\n    e.maichattawalowleftthai = 63637;\n    e.maichattawalowrightthai = 63636;\n    e.maichattawathai = 3659;\n    e.maichattawaupperleftthai = 63635;\n    e.maieklowleftthai = 63628;\n    e.maieklowrightthai = 63627;\n    e.maiekthai = 3656;\n    e.maiekupperleftthai = 63626;\n    e.maihanakatleftthai = 63620;\n    e.maihanakatthai = 3633;\n    e.maitaikhuleftthai = 63625;\n    e.maitaikhuthai = 3655;\n    e.maitholowleftthai = 63631;\n    e.maitholowrightthai = 63630;\n    e.maithothai = 3657;\n    e.maithoupperleftthai = 63629;\n    e.maitrilowleftthai = 63634;\n    e.maitrilowrightthai = 63633;\n    e.maitrithai = 3658;\n    e.maitriupperleftthai = 63632;\n    e.maiyamokthai = 3654;\n    e.makatakana = 12510;\n    e.makatakanahalfwidth = 65423;\n    e.male = 9794;\n    e.mansyonsquare = 13127;\n    e.maqafhebrew = 1470;\n    e.mars = 9794;\n    e.masoracirclehebrew = 1455;\n    e.masquare = 13187;\n    e.mbopomofo = 12551;\n    e.mbsquare = 13268;\n    e.mcircle = 9436;\n    e.mcubedsquare = 13221;\n    e.mdotaccent = 7745;\n    e.mdotbelow = 7747;\n    e.meemarabic = 1605;\n    e.meemfinalarabic = 65250;\n    e.meeminitialarabic = 65251;\n    e.meemmedialarabic = 65252;\n    e.meemmeeminitialarabic = 64721;\n    e.meemmeemisolatedarabic = 64584;\n    e.meetorusquare = 13133;\n    e.mehiragana = 12417;\n    e.meizierasquare = 13182;\n    e.mekatakana = 12513;\n    e.mekatakanahalfwidth = 65426;\n    e.mem = 1502;\n    e.memdagesh = 64318;\n    e.memdageshhebrew = 64318;\n    e.memhebrew = 1502;\n    e.menarmenian = 1396;\n    e.merkhahebrew = 1445;\n    e.merkhakefulahebrew = 1446;\n    e.merkhakefulalefthebrew = 1446;\n    e.merkhalefthebrew = 1445;\n    e.mhook = 625;\n    e.mhzsquare = 13202;\n    e.middledotkatakanahalfwidth = 65381;\n    e.middot = 183;\n    e.mieumacirclekorean = 12914;\n    e.mieumaparenkorean = 12818;\n    e.mieumcirclekorean = 12900;\n    e.mieumkorean = 12609;\n    e.mieumpansioskorean = 12656;\n    e.mieumparenkorean = 12804;\n    e.mieumpieupkorean = 12654;\n    e.mieumsioskorean = 12655;\n    e.mihiragana = 12415;\n    e.mikatakana = 12511;\n    e.mikatakanahalfwidth = 65424;\n    e.minus = 8722;\n    e.minusbelowcmb = 800;\n    e.minuscircle = 8854;\n    e.minusmod = 727;\n    e.minusplus = 8723;\n    e.minute = 8242;\n    e.miribaarusquare = 13130;\n    e.mirisquare = 13129;\n    e.mlonglegturned = 624;\n    e.mlsquare = 13206;\n    e.mmcubedsquare = 13219;\n    e.mmonospace = 65357;\n    e.mmsquaredsquare = 13215;\n    e.mohiragana = 12418;\n    e.mohmsquare = 13249;\n    e.mokatakana = 12514;\n    e.mokatakanahalfwidth = 65427;\n    e.molsquare = 13270;\n    e.momathai = 3617;\n    e.moverssquare = 13223;\n    e.moverssquaredsquare = 13224;\n    e.mparen = 9384;\n    e.mpasquare = 13227;\n    e.mssquare = 13235;\n    e.msuperior = 63215;\n    e.mturned = 623;\n    e.mu = 181;\n    e.mu1 = 181;\n    e.muasquare = 13186;\n    e.muchgreater = 8811;\n    e.muchless = 8810;\n    e.mufsquare = 13196;\n    e.mugreek = 956;\n    e.mugsquare = 13197;\n    e.muhiragana = 12416;\n    e.mukatakana = 12512;\n    e.mukatakanahalfwidth = 65425;\n    e.mulsquare = 13205;\n    e.multiply = 215;\n    e.mumsquare = 13211;\n    e.munahhebrew = 1443;\n    e.munahlefthebrew = 1443;\n    e.musicalnote = 9834;\n    e.musicalnotedbl = 9835;\n    e.musicflatsign = 9837;\n    e.musicsharpsign = 9839;\n    e.mussquare = 13234;\n    e.muvsquare = 13238;\n    e.muwsquare = 13244;\n    e.mvmegasquare = 13241;\n    e.mvsquare = 13239;\n    e.mwmegasquare = 13247;\n    e.mwsquare = 13245;\n    e.n = 110;\n    e.nabengali = 2472;\n    e.nabla = 8711;\n    e.nacute = 324;\n    e.nadeva = 2344;\n    e.nagujarati = 2728;\n    e.nagurmukhi = 2600;\n    e.nahiragana = 12394;\n    e.nakatakana = 12490;\n    e.nakatakanahalfwidth = 65413;\n    e.napostrophe = 329;\n    e.nasquare = 13185;\n    e.nbopomofo = 12555;\n    e.nbspace = 160;\n    e.ncaron = 328;\n    e.ncedilla = 326;\n    e.ncircle = 9437;\n    e.ncircumflexbelow = 7755;\n    e.ncommaaccent = 326;\n    e.ndotaccent = 7749;\n    e.ndotbelow = 7751;\n    e.nehiragana = 12397;\n    e.nekatakana = 12493;\n    e.nekatakanahalfwidth = 65416;\n    e.newsheqelsign = 8362;\n    e.nfsquare = 13195;\n    e.ngabengali = 2457;\n    e.ngadeva = 2329;\n    e.ngagujarati = 2713;\n    e.ngagurmukhi = 2585;\n    e.ngonguthai = 3591;\n    e.nhiragana = 12435;\n    e.nhookleft = 626;\n    e.nhookretroflex = 627;\n    e.nieunacirclekorean = 12911;\n    e.nieunaparenkorean = 12815;\n    e.nieuncieuckorean = 12597;\n    e.nieuncirclekorean = 12897;\n    e.nieunhieuhkorean = 12598;\n    e.nieunkorean = 12596;\n    e.nieunpansioskorean = 12648;\n    e.nieunparenkorean = 12801;\n    e.nieunsioskorean = 12647;\n    e.nieuntikeutkorean = 12646;\n    e.nihiragana = 12395;\n    e.nikatakana = 12491;\n    e.nikatakanahalfwidth = 65414;\n    e.nikhahitleftthai = 63641;\n    e.nikhahitthai = 3661;\n    e.nine = 57;\n    e.ninearabic = 1641;\n    e.ninebengali = 2543;\n    e.ninecircle = 9320;\n    e.ninecircleinversesansserif = 10130;\n    e.ninedeva = 2415;\n    e.ninegujarati = 2799;\n    e.ninegurmukhi = 2671;\n    e.ninehackarabic = 1641;\n    e.ninehangzhou = 12329;\n    e.nineideographicparen = 12840;\n    e.nineinferior = 8329;\n    e.ninemonospace = 65305;\n    e.nineoldstyle = 63289;\n    e.nineparen = 9340;\n    e.nineperiod = 9360;\n    e.ninepersian = 1785;\n    e.nineroman = 8568;\n    e.ninesuperior = 8313;\n    e.nineteencircle = 9330;\n    e.nineteenparen = 9350;\n    e.nineteenperiod = 9370;\n    e.ninethai = 3673;\n    e.nj = 460;\n    e.njecyrillic = 1114;\n    e.nkatakana = 12531;\n    e.nkatakanahalfwidth = 65437;\n    e.nlegrightlong = 414;\n    e.nlinebelow = 7753;\n    e.nmonospace = 65358;\n    e.nmsquare = 13210;\n    e.nnabengali = 2467;\n    e.nnadeva = 2339;\n    e.nnagujarati = 2723;\n    e.nnagurmukhi = 2595;\n    e.nnnadeva = 2345;\n    e.nohiragana = 12398;\n    e.nokatakana = 12494;\n    e.nokatakanahalfwidth = 65417;\n    e.nonbreakingspace = 160;\n    e.nonenthai = 3603;\n    e.nonuthai = 3609;\n    e.noonarabic = 1606;\n    e.noonfinalarabic = 65254;\n    e.noonghunnaarabic = 1722;\n    e.noonghunnafinalarabic = 64415;\n    e.nooninitialarabic = 65255;\n    e.noonjeeminitialarabic = 64722;\n    e.noonjeemisolatedarabic = 64587;\n    e.noonmedialarabic = 65256;\n    e.noonmeeminitialarabic = 64725;\n    e.noonmeemisolatedarabic = 64590;\n    e.noonnoonfinalarabic = 64653;\n    e.notcontains = 8716;\n    e.notelement = 8713;\n    e.notelementof = 8713;\n    e.notequal = 8800;\n    e.notgreater = 8815;\n    e.notgreaternorequal = 8817;\n    e.notgreaternorless = 8825;\n    e.notidentical = 8802;\n    e.notless = 8814;\n    e.notlessnorequal = 8816;\n    e.notparallel = 8742;\n    e.notprecedes = 8832;\n    e.notsubset = 8836;\n    e.notsucceeds = 8833;\n    e.notsuperset = 8837;\n    e.nowarmenian = 1398;\n    e.nparen = 9385;\n    e.nssquare = 13233;\n    e.nsuperior = 8319;\n    e.ntilde = 241;\n    e.nu = 957;\n    e.nuhiragana = 12396;\n    e.nukatakana = 12492;\n    e.nukatakanahalfwidth = 65415;\n    e.nuktabengali = 2492;\n    e.nuktadeva = 2364;\n    e.nuktagujarati = 2748;\n    e.nuktagurmukhi = 2620;\n    e.numbersign = 35;\n    e.numbersignmonospace = 65283;\n    e.numbersignsmall = 65119;\n    e.numeralsigngreek = 884;\n    e.numeralsignlowergreek = 885;\n    e.numero = 8470;\n    e.nun = 1504;\n    e.nundagesh = 64320;\n    e.nundageshhebrew = 64320;\n    e.nunhebrew = 1504;\n    e.nvsquare = 13237;\n    e.nwsquare = 13243;\n    e.nyabengali = 2462;\n    e.nyadeva = 2334;\n    e.nyagujarati = 2718;\n    e.nyagurmukhi = 2590;\n    e.o = 111;\n    e.oacute = 243;\n    e.oangthai = 3629;\n    e.obarred = 629;\n    e.obarredcyrillic = 1257;\n    e.obarreddieresiscyrillic = 1259;\n    e.obengali = 2451;\n    e.obopomofo = 12571;\n    e.obreve = 335;\n    e.ocandradeva = 2321;\n    e.ocandragujarati = 2705;\n    e.ocandravowelsigndeva = 2377;\n    e.ocandravowelsigngujarati = 2761;\n    e.ocaron = 466;\n    e.ocircle = 9438;\n    e.ocircumflex = 244;\n    e.ocircumflexacute = 7889;\n    e.ocircumflexdotbelow = 7897;\n    e.ocircumflexgrave = 7891;\n    e.ocircumflexhookabove = 7893;\n    e.ocircumflextilde = 7895;\n    e.ocyrillic = 1086;\n    e.odblacute = 337;\n    e.odblgrave = 525;\n    e.odeva = 2323;\n    e.odieresis = 246;\n    e.odieresiscyrillic = 1255;\n    e.odotbelow = 7885;\n    e.oe = 339;\n    e.oekorean = 12634;\n    e.ogonek = 731;\n    e.ogonekcmb = 808;\n    e.ograve = 242;\n    e.ogujarati = 2707;\n    e.oharmenian = 1413;\n    e.ohiragana = 12362;\n    e.ohookabove = 7887;\n    e.ohorn = 417;\n    e.ohornacute = 7899;\n    e.ohorndotbelow = 7907;\n    e.ohorngrave = 7901;\n    e.ohornhookabove = 7903;\n    e.ohorntilde = 7905;\n    e.ohungarumlaut = 337;\n    e.oi = 419;\n    e.oinvertedbreve = 527;\n    e.okatakana = 12458;\n    e.okatakanahalfwidth = 65397;\n    e.okorean = 12631;\n    e.olehebrew = 1451;\n    e.omacron = 333;\n    e.omacronacute = 7763;\n    e.omacrongrave = 7761;\n    e.omdeva = 2384;\n    e.omega = 969;\n    e.omega1 = 982;\n    e.omegacyrillic = 1121;\n    e.omegalatinclosed = 631;\n    e.omegaroundcyrillic = 1147;\n    e.omegatitlocyrillic = 1149;\n    e.omegatonos = 974;\n    e.omgujarati = 2768;\n    e.omicron = 959;\n    e.omicrontonos = 972;\n    e.omonospace = 65359;\n    e.one = 49;\n    e.onearabic = 1633;\n    e.onebengali = 2535;\n    e.onecircle = 9312;\n    e.onecircleinversesansserif = 10122;\n    e.onedeva = 2407;\n    e.onedotenleader = 8228;\n    e.oneeighth = 8539;\n    e.onefitted = 63196;\n    e.onegujarati = 2791;\n    e.onegurmukhi = 2663;\n    e.onehackarabic = 1633;\n    e.onehalf = 189;\n    e.onehangzhou = 12321;\n    e.oneideographicparen = 12832;\n    e.oneinferior = 8321;\n    e.onemonospace = 65297;\n    e.onenumeratorbengali = 2548;\n    e.oneoldstyle = 63281;\n    e.oneparen = 9332;\n    e.oneperiod = 9352;\n    e.onepersian = 1777;\n    e.onequarter = 188;\n    e.oneroman = 8560;\n    e.onesuperior = 185;\n    e.onethai = 3665;\n    e.onethird = 8531;\n    e.oogonek = 491;\n    e.oogonekmacron = 493;\n    e.oogurmukhi = 2579;\n    e.oomatragurmukhi = 2635;\n    e.oopen = 596;\n    e.oparen = 9386;\n    e.openbullet = 9702;\n    e.option = 8997;\n    e.ordfeminine = 170;\n    e.ordmasculine = 186;\n    e.orthogonal = 8735;\n    e.oshortdeva = 2322;\n    e.oshortvowelsigndeva = 2378;\n    e.oslash = 248;\n    e.oslashacute = 511;\n    e.osmallhiragana = 12361;\n    e.osmallkatakana = 12457;\n    e.osmallkatakanahalfwidth = 65387;\n    e.ostrokeacute = 511;\n    e.osuperior = 63216;\n    e.otcyrillic = 1151;\n    e.otilde = 245;\n    e.otildeacute = 7757;\n    e.otildedieresis = 7759;\n    e.oubopomofo = 12577;\n    e.overline = 8254;\n    e.overlinecenterline = 65098;\n    e.overlinecmb = 773;\n    e.overlinedashed = 65097;\n    e.overlinedblwavy = 65100;\n    e.overlinewavy = 65099;\n    e.overscore = 175;\n    e.ovowelsignbengali = 2507;\n    e.ovowelsigndeva = 2379;\n    e.ovowelsigngujarati = 2763;\n    e.p = 112;\n    e.paampssquare = 13184;\n    e.paasentosquare = 13099;\n    e.pabengali = 2474;\n    e.pacute = 7765;\n    e.padeva = 2346;\n    e.pagedown = 8671;\n    e.pageup = 8670;\n    e.pagujarati = 2730;\n    e.pagurmukhi = 2602;\n    e.pahiragana = 12401;\n    e.paiyannoithai = 3631;\n    e.pakatakana = 12497;\n    e.palatalizationcyrilliccmb = 1156;\n    e.palochkacyrillic = 1216;\n    e.pansioskorean = 12671;\n    e.paragraph = 182;\n    e.parallel = 8741;\n    e.parenleft = 40;\n    e.parenleftaltonearabic = 64830;\n    e.parenleftbt = 63725;\n    e.parenleftex = 63724;\n    e.parenleftinferior = 8333;\n    e.parenleftmonospace = 65288;\n    e.parenleftsmall = 65113;\n    e.parenleftsuperior = 8317;\n    e.parenlefttp = 63723;\n    e.parenleftvertical = 65077;\n    e.parenright = 41;\n    e.parenrightaltonearabic = 64831;\n    e.parenrightbt = 63736;\n    e.parenrightex = 63735;\n    e.parenrightinferior = 8334;\n    e.parenrightmonospace = 65289;\n    e.parenrightsmall = 65114;\n    e.parenrightsuperior = 8318;\n    e.parenrighttp = 63734;\n    e.parenrightvertical = 65078;\n    e.partialdiff = 8706;\n    e.paseqhebrew = 1472;\n    e.pashtahebrew = 1433;\n    e.pasquare = 13225;\n    e.patah = 1463;\n    e.patah11 = 1463;\n    e.patah1d = 1463;\n    e.patah2a = 1463;\n    e.patahhebrew = 1463;\n    e.patahnarrowhebrew = 1463;\n    e.patahquarterhebrew = 1463;\n    e.patahwidehebrew = 1463;\n    e.pazerhebrew = 1441;\n    e.pbopomofo = 12550;\n    e.pcircle = 9439;\n    e.pdotaccent = 7767;\n    e.pe = 1508;\n    e.pecyrillic = 1087;\n    e.pedagesh = 64324;\n    e.pedageshhebrew = 64324;\n    e.peezisquare = 13115;\n    e.pefinaldageshhebrew = 64323;\n    e.peharabic = 1662;\n    e.peharmenian = 1402;\n    e.pehebrew = 1508;\n    e.pehfinalarabic = 64343;\n    e.pehinitialarabic = 64344;\n    e.pehiragana = 12410;\n    e.pehmedialarabic = 64345;\n    e.pekatakana = 12506;\n    e.pemiddlehookcyrillic = 1191;\n    e.perafehebrew = 64334;\n    e.percent = 37;\n    e.percentarabic = 1642;\n    e.percentmonospace = 65285;\n    e.percentsmall = 65130;\n    e.period = 46;\n    e.periodarmenian = 1417;\n    e.periodcentered = 183;\n    e.periodhalfwidth = 65377;\n    e.periodinferior = 63207;\n    e.periodmonospace = 65294;\n    e.periodsmall = 65106;\n    e.periodsuperior = 63208;\n    e.perispomenigreekcmb = 834;\n    e.perpendicular = 8869;\n    e.perthousand = 8240;\n    e.peseta = 8359;\n    e.pfsquare = 13194;\n    e.phabengali = 2475;\n    e.phadeva = 2347;\n    e.phagujarati = 2731;\n    e.phagurmukhi = 2603;\n    e.phi = 966;\n    e.phi1 = 981;\n    e.phieuphacirclekorean = 12922;\n    e.phieuphaparenkorean = 12826;\n    e.phieuphcirclekorean = 12908;\n    e.phieuphkorean = 12621;\n    e.phieuphparenkorean = 12812;\n    e.philatin = 632;\n    e.phinthuthai = 3642;\n    e.phisymbolgreek = 981;\n    e.phook = 421;\n    e.phophanthai = 3614;\n    e.phophungthai = 3612;\n    e.phosamphaothai = 3616;\n    e.pi = 960;\n    e.pieupacirclekorean = 12915;\n    e.pieupaparenkorean = 12819;\n    e.pieupcieuckorean = 12662;\n    e.pieupcirclekorean = 12901;\n    e.pieupkiyeokkorean = 12658;\n    e.pieupkorean = 12610;\n    e.pieupparenkorean = 12805;\n    e.pieupsioskiyeokkorean = 12660;\n    e.pieupsioskorean = 12612;\n    e.pieupsiostikeutkorean = 12661;\n    e.pieupthieuthkorean = 12663;\n    e.pieuptikeutkorean = 12659;\n    e.pihiragana = 12404;\n    e.pikatakana = 12500;\n    e.pisymbolgreek = 982;\n    e.piwrarmenian = 1411;\n    e.planckover2pi = 8463;\n    e.planckover2pi1 = 8463;\n    e.plus = 43;\n    e.plusbelowcmb = 799;\n    e.pluscircle = 8853;\n    e.plusminus = 177;\n    e.plusmod = 726;\n    e.plusmonospace = 65291;\n    e.plussmall = 65122;\n    e.plussuperior = 8314;\n    e.pmonospace = 65360;\n    e.pmsquare = 13272;\n    e.pohiragana = 12413;\n    e.pointingindexdownwhite = 9759;\n    e.pointingindexleftwhite = 9756;\n    e.pointingindexrightwhite = 9758;\n    e.pointingindexupwhite = 9757;\n    e.pokatakana = 12509;\n    e.poplathai = 3611;\n    e.postalmark = 12306;\n    e.postalmarkface = 12320;\n    e.pparen = 9387;\n    e.precedes = 8826;\n    e.prescription = 8478;\n    e.primemod = 697;\n    e.primereversed = 8245;\n    e.product = 8719;\n    e.projective = 8965;\n    e.prolongedkana = 12540;\n    e.propellor = 8984;\n    e.propersubset = 8834;\n    e.propersuperset = 8835;\n    e.proportion = 8759;\n    e.proportional = 8733;\n    e.psi = 968;\n    e.psicyrillic = 1137;\n    e.psilipneumatacyrilliccmb = 1158;\n    e.pssquare = 13232;\n    e.puhiragana = 12407;\n    e.pukatakana = 12503;\n    e.pvsquare = 13236;\n    e.pwsquare = 13242;\n    e.q = 113;\n    e.qadeva = 2392;\n    e.qadmahebrew = 1448;\n    e.qafarabic = 1602;\n    e.qaffinalarabic = 65238;\n    e.qafinitialarabic = 65239;\n    e.qafmedialarabic = 65240;\n    e.qamats = 1464;\n    e.qamats10 = 1464;\n    e.qamats1a = 1464;\n    e.qamats1c = 1464;\n    e.qamats27 = 1464;\n    e.qamats29 = 1464;\n    e.qamats33 = 1464;\n    e.qamatsde = 1464;\n    e.qamatshebrew = 1464;\n    e.qamatsnarrowhebrew = 1464;\n    e.qamatsqatanhebrew = 1464;\n    e.qamatsqatannarrowhebrew = 1464;\n    e.qamatsqatanquarterhebrew = 1464;\n    e.qamatsqatanwidehebrew = 1464;\n    e.qamatsquarterhebrew = 1464;\n    e.qamatswidehebrew = 1464;\n    e.qarneyparahebrew = 1439;\n    e.qbopomofo = 12561;\n    e.qcircle = 9440;\n    e.qhook = 672;\n    e.qmonospace = 65361;\n    e.qof = 1511;\n    e.qofdagesh = 64327;\n    e.qofdageshhebrew = 64327;\n    e.qofhebrew = 1511;\n    e.qparen = 9388;\n    e.quarternote = 9833;\n    e.qubuts = 1467;\n    e.qubuts18 = 1467;\n    e.qubuts25 = 1467;\n    e.qubuts31 = 1467;\n    e.qubutshebrew = 1467;\n    e.qubutsnarrowhebrew = 1467;\n    e.qubutsquarterhebrew = 1467;\n    e.qubutswidehebrew = 1467;\n    e.question = 63;\n    e.questionarabic = 1567;\n    e.questionarmenian = 1374;\n    e.questiondown = 191;\n    e.questiondownsmall = 63423;\n    e.questiongreek = 894;\n    e.questionmonospace = 65311;\n    e.questionsmall = 63295;\n    e.quotedbl = 34;\n    e.quotedblbase = 8222;\n    e.quotedblleft = 8220;\n    e.quotedblmonospace = 65282;\n    e.quotedblprime = 12318;\n    e.quotedblprimereversed = 12317;\n    e.quotedblright = 8221;\n    e.quoteleft = 8216;\n    e.quoteleftreversed = 8219;\n    e.quotereversed = 8219;\n    e.quoteright = 8217;\n    e.quoterightn = 329;\n    e.quotesinglbase = 8218;\n    e.quotesingle = 39;\n    e.quotesinglemonospace = 65287;\n    e.r = 114;\n    e.raarmenian = 1404;\n    e.rabengali = 2480;\n    e.racute = 341;\n    e.radeva = 2352;\n    e.radical = 8730;\n    e.radicalex = 63717;\n    e.radoverssquare = 13230;\n    e.radoverssquaredsquare = 13231;\n    e.radsquare = 13229;\n    e.rafe = 1471;\n    e.rafehebrew = 1471;\n    e.ragujarati = 2736;\n    e.ragurmukhi = 2608;\n    e.rahiragana = 12425;\n    e.rakatakana = 12521;\n    e.rakatakanahalfwidth = 65431;\n    e.ralowerdiagonalbengali = 2545;\n    e.ramiddlediagonalbengali = 2544;\n    e.ramshorn = 612;\n    e.ratio = 8758;\n    e.rbopomofo = 12566;\n    e.rcaron = 345;\n    e.rcedilla = 343;\n    e.rcircle = 9441;\n    e.rcommaaccent = 343;\n    e.rdblgrave = 529;\n    e.rdotaccent = 7769;\n    e.rdotbelow = 7771;\n    e.rdotbelowmacron = 7773;\n    e.referencemark = 8251;\n    e.reflexsubset = 8838;\n    e.reflexsuperset = 8839;\n    e.registered = 174;\n    e.registersans = 63720;\n    e.registerserif = 63194;\n    e.reharabic = 1585;\n    e.reharmenian = 1408;\n    e.rehfinalarabic = 65198;\n    e.rehiragana = 12428;\n    e.rekatakana = 12524;\n    e.rekatakanahalfwidth = 65434;\n    e.resh = 1512;\n    e.reshdageshhebrew = 64328;\n    e.reshhebrew = 1512;\n    e.reversedtilde = 8765;\n    e.reviahebrew = 1431;\n    e.reviamugrashhebrew = 1431;\n    e.revlogicalnot = 8976;\n    e.rfishhook = 638;\n    e.rfishhookreversed = 639;\n    e.rhabengali = 2525;\n    e.rhadeva = 2397;\n    e.rho = 961;\n    e.rhook = 637;\n    e.rhookturned = 635;\n    e.rhookturnedsuperior = 693;\n    e.rhosymbolgreek = 1009;\n    e.rhotichookmod = 734;\n    e.rieulacirclekorean = 12913;\n    e.rieulaparenkorean = 12817;\n    e.rieulcirclekorean = 12899;\n    e.rieulhieuhkorean = 12608;\n    e.rieulkiyeokkorean = 12602;\n    e.rieulkiyeoksioskorean = 12649;\n    e.rieulkorean = 12601;\n    e.rieulmieumkorean = 12603;\n    e.rieulpansioskorean = 12652;\n    e.rieulparenkorean = 12803;\n    e.rieulphieuphkorean = 12607;\n    e.rieulpieupkorean = 12604;\n    e.rieulpieupsioskorean = 12651;\n    e.rieulsioskorean = 12605;\n    e.rieulthieuthkorean = 12606;\n    e.rieultikeutkorean = 12650;\n    e.rieulyeorinhieuhkorean = 12653;\n    e.rightangle = 8735;\n    e.righttackbelowcmb = 793;\n    e.righttriangle = 8895;\n    e.rihiragana = 12426;\n    e.rikatakana = 12522;\n    e.rikatakanahalfwidth = 65432;\n    e.ring = 730;\n    e.ringbelowcmb = 805;\n    e.ringcmb = 778;\n    e.ringhalfleft = 703;\n    e.ringhalfleftarmenian = 1369;\n    e.ringhalfleftbelowcmb = 796;\n    e.ringhalfleftcentered = 723;\n    e.ringhalfright = 702;\n    e.ringhalfrightbelowcmb = 825;\n    e.ringhalfrightcentered = 722;\n    e.rinvertedbreve = 531;\n    e.rittorusquare = 13137;\n    e.rlinebelow = 7775;\n    e.rlongleg = 636;\n    e.rlonglegturned = 634;\n    e.rmonospace = 65362;\n    e.rohiragana = 12429;\n    e.rokatakana = 12525;\n    e.rokatakanahalfwidth = 65435;\n    e.roruathai = 3619;\n    e.rparen = 9389;\n    e.rrabengali = 2524;\n    e.rradeva = 2353;\n    e.rragurmukhi = 2652;\n    e.rreharabic = 1681;\n    e.rrehfinalarabic = 64397;\n    e.rrvocalicbengali = 2528;\n    e.rrvocalicdeva = 2400;\n    e.rrvocalicgujarati = 2784;\n    e.rrvocalicvowelsignbengali = 2500;\n    e.rrvocalicvowelsigndeva = 2372;\n    e.rrvocalicvowelsigngujarati = 2756;\n    e.rsuperior = 63217;\n    e.rtblock = 9616;\n    e.rturned = 633;\n    e.rturnedsuperior = 692;\n    e.ruhiragana = 12427;\n    e.rukatakana = 12523;\n    e.rukatakanahalfwidth = 65433;\n    e.rupeemarkbengali = 2546;\n    e.rupeesignbengali = 2547;\n    e.rupiah = 63197;\n    e.ruthai = 3620;\n    e.rvocalicbengali = 2443;\n    e.rvocalicdeva = 2315;\n    e.rvocalicgujarati = 2699;\n    e.rvocalicvowelsignbengali = 2499;\n    e.rvocalicvowelsigndeva = 2371;\n    e.rvocalicvowelsigngujarati = 2755;\n    e.s = 115;\n    e.sabengali = 2488;\n    e.sacute = 347;\n    e.sacutedotaccent = 7781;\n    e.sadarabic = 1589;\n    e.sadeva = 2360;\n    e.sadfinalarabic = 65210;\n    e.sadinitialarabic = 65211;\n    e.sadmedialarabic = 65212;\n    e.sagujarati = 2744;\n    e.sagurmukhi = 2616;\n    e.sahiragana = 12373;\n    e.sakatakana = 12469;\n    e.sakatakanahalfwidth = 65403;\n    e.sallallahoualayhewasallamarabic = 65018;\n    e.samekh = 1505;\n    e.samekhdagesh = 64321;\n    e.samekhdageshhebrew = 64321;\n    e.samekhhebrew = 1505;\n    e.saraaathai = 3634;\n    e.saraaethai = 3649;\n    e.saraaimaimalaithai = 3652;\n    e.saraaimaimuanthai = 3651;\n    e.saraamthai = 3635;\n    e.saraathai = 3632;\n    e.saraethai = 3648;\n    e.saraiileftthai = 63622;\n    e.saraiithai = 3637;\n    e.saraileftthai = 63621;\n    e.saraithai = 3636;\n    e.saraothai = 3650;\n    e.saraueeleftthai = 63624;\n    e.saraueethai = 3639;\n    e.saraueleftthai = 63623;\n    e.sarauethai = 3638;\n    e.sarauthai = 3640;\n    e.sarauuthai = 3641;\n    e.sbopomofo = 12569;\n    e.scaron = 353;\n    e.scarondotaccent = 7783;\n    e.scedilla = 351;\n    e.schwa = 601;\n    e.schwacyrillic = 1241;\n    e.schwadieresiscyrillic = 1243;\n    e.schwahook = 602;\n    e.scircle = 9442;\n    e.scircumflex = 349;\n    e.scommaaccent = 537;\n    e.sdotaccent = 7777;\n    e.sdotbelow = 7779;\n    e.sdotbelowdotaccent = 7785;\n    e.seagullbelowcmb = 828;\n    e.second = 8243;\n    e.secondtonechinese = 714;\n    e.section = 167;\n    e.seenarabic = 1587;\n    e.seenfinalarabic = 65202;\n    e.seeninitialarabic = 65203;\n    e.seenmedialarabic = 65204;\n    e.segol = 1462;\n    e.segol13 = 1462;\n    e.segol1f = 1462;\n    e.segol2c = 1462;\n    e.segolhebrew = 1462;\n    e.segolnarrowhebrew = 1462;\n    e.segolquarterhebrew = 1462;\n    e.segoltahebrew = 1426;\n    e.segolwidehebrew = 1462;\n    e.seharmenian = 1405;\n    e.sehiragana = 12379;\n    e.sekatakana = 12475;\n    e.sekatakanahalfwidth = 65406;\n    e.semicolon = 59;\n    e.semicolonarabic = 1563;\n    e.semicolonmonospace = 65307;\n    e.semicolonsmall = 65108;\n    e.semivoicedmarkkana = 12444;\n    e.semivoicedmarkkanahalfwidth = 65439;\n    e.sentisquare = 13090;\n    e.sentosquare = 13091;\n    e.seven = 55;\n    e.sevenarabic = 1639;\n    e.sevenbengali = 2541;\n    e.sevencircle = 9318;\n    e.sevencircleinversesansserif = 10128;\n    e.sevendeva = 2413;\n    e.seveneighths = 8542;\n    e.sevengujarati = 2797;\n    e.sevengurmukhi = 2669;\n    e.sevenhackarabic = 1639;\n    e.sevenhangzhou = 12327;\n    e.sevenideographicparen = 12838;\n    e.seveninferior = 8327;\n    e.sevenmonospace = 65303;\n    e.sevenoldstyle = 63287;\n    e.sevenparen = 9338;\n    e.sevenperiod = 9358;\n    e.sevenpersian = 1783;\n    e.sevenroman = 8566;\n    e.sevensuperior = 8311;\n    e.seventeencircle = 9328;\n    e.seventeenparen = 9348;\n    e.seventeenperiod = 9368;\n    e.seventhai = 3671;\n    e.sfthyphen = 173;\n    e.shaarmenian = 1399;\n    e.shabengali = 2486;\n    e.shacyrillic = 1096;\n    e.shaddaarabic = 1617;\n    e.shaddadammaarabic = 64609;\n    e.shaddadammatanarabic = 64606;\n    e.shaddafathaarabic = 64608;\n    e.shaddakasraarabic = 64610;\n    e.shaddakasratanarabic = 64607;\n    e.shade = 9618;\n    e.shadedark = 9619;\n    e.shadelight = 9617;\n    e.shademedium = 9618;\n    e.shadeva = 2358;\n    e.shagujarati = 2742;\n    e.shagurmukhi = 2614;\n    e.shalshelethebrew = 1427;\n    e.shbopomofo = 12565;\n    e.shchacyrillic = 1097;\n    e.sheenarabic = 1588;\n    e.sheenfinalarabic = 65206;\n    e.sheeninitialarabic = 65207;\n    e.sheenmedialarabic = 65208;\n    e.sheicoptic = 995;\n    e.sheqel = 8362;\n    e.sheqelhebrew = 8362;\n    e.sheva = 1456;\n    e.sheva115 = 1456;\n    e.sheva15 = 1456;\n    e.sheva22 = 1456;\n    e.sheva2e = 1456;\n    e.shevahebrew = 1456;\n    e.shevanarrowhebrew = 1456;\n    e.shevaquarterhebrew = 1456;\n    e.shevawidehebrew = 1456;\n    e.shhacyrillic = 1211;\n    e.shimacoptic = 1005;\n    e.shin = 1513;\n    e.shindagesh = 64329;\n    e.shindageshhebrew = 64329;\n    e.shindageshshindot = 64300;\n    e.shindageshshindothebrew = 64300;\n    e.shindageshsindot = 64301;\n    e.shindageshsindothebrew = 64301;\n    e.shindothebrew = 1473;\n    e.shinhebrew = 1513;\n    e.shinshindot = 64298;\n    e.shinshindothebrew = 64298;\n    e.shinsindot = 64299;\n    e.shinsindothebrew = 64299;\n    e.shook = 642;\n    e.sigma = 963;\n    e.sigma1 = 962;\n    e.sigmafinal = 962;\n    e.sigmalunatesymbolgreek = 1010;\n    e.sihiragana = 12375;\n    e.sikatakana = 12471;\n    e.sikatakanahalfwidth = 65404;\n    e.siluqhebrew = 1469;\n    e.siluqlefthebrew = 1469;\n    e.similar = 8764;\n    e.sindothebrew = 1474;\n    e.siosacirclekorean = 12916;\n    e.siosaparenkorean = 12820;\n    e.sioscieuckorean = 12670;\n    e.sioscirclekorean = 12902;\n    e.sioskiyeokkorean = 12666;\n    e.sioskorean = 12613;\n    e.siosnieunkorean = 12667;\n    e.siosparenkorean = 12806;\n    e.siospieupkorean = 12669;\n    e.siostikeutkorean = 12668;\n    e.six = 54;\n    e.sixarabic = 1638;\n    e.sixbengali = 2540;\n    e.sixcircle = 9317;\n    e.sixcircleinversesansserif = 10127;\n    e.sixdeva = 2412;\n    e.sixgujarati = 2796;\n    e.sixgurmukhi = 2668;\n    e.sixhackarabic = 1638;\n    e.sixhangzhou = 12326;\n    e.sixideographicparen = 12837;\n    e.sixinferior = 8326;\n    e.sixmonospace = 65302;\n    e.sixoldstyle = 63286;\n    e.sixparen = 9337;\n    e.sixperiod = 9357;\n    e.sixpersian = 1782;\n    e.sixroman = 8565;\n    e.sixsuperior = 8310;\n    e.sixteencircle = 9327;\n    e.sixteencurrencydenominatorbengali = 2553;\n    e.sixteenparen = 9347;\n    e.sixteenperiod = 9367;\n    e.sixthai = 3670;\n    e.slash = 47;\n    e.slashmonospace = 65295;\n    e.slong = 383;\n    e.slongdotaccent = 7835;\n    e.smileface = 9786;\n    e.smonospace = 65363;\n    e.sofpasuqhebrew = 1475;\n    e.softhyphen = 173;\n    e.softsigncyrillic = 1100;\n    e.sohiragana = 12381;\n    e.sokatakana = 12477;\n    e.sokatakanahalfwidth = 65407;\n    e.soliduslongoverlaycmb = 824;\n    e.solidusshortoverlaycmb = 823;\n    e.sorusithai = 3625;\n    e.sosalathai = 3624;\n    e.sosothai = 3595;\n    e.sosuathai = 3626;\n    e.space = 32;\n    e.spacehackarabic = 32;\n    e.spade = 9824;\n    e.spadesuitblack = 9824;\n    e.spadesuitwhite = 9828;\n    e.sparen = 9390;\n    e.squarebelowcmb = 827;\n    e.squarecc = 13252;\n    e.squarecm = 13213;\n    e.squarediagonalcrosshatchfill = 9641;\n    e.squarehorizontalfill = 9636;\n    e.squarekg = 13199;\n    e.squarekm = 13214;\n    e.squarekmcapital = 13262;\n    e.squareln = 13265;\n    e.squarelog = 13266;\n    e.squaremg = 13198;\n    e.squaremil = 13269;\n    e.squaremm = 13212;\n    e.squaremsquared = 13217;\n    e.squareorthogonalcrosshatchfill = 9638;\n    e.squareupperlefttolowerrightfill = 9639;\n    e.squareupperrighttolowerleftfill = 9640;\n    e.squareverticalfill = 9637;\n    e.squarewhitewithsmallblack = 9635;\n    e.srsquare = 13275;\n    e.ssabengali = 2487;\n    e.ssadeva = 2359;\n    e.ssagujarati = 2743;\n    e.ssangcieuckorean = 12617;\n    e.ssanghieuhkorean = 12677;\n    e.ssangieungkorean = 12672;\n    e.ssangkiyeokkorean = 12594;\n    e.ssangnieunkorean = 12645;\n    e.ssangpieupkorean = 12611;\n    e.ssangsioskorean = 12614;\n    e.ssangtikeutkorean = 12600;\n    e.ssuperior = 63218;\n    e.sterling = 163;\n    e.sterlingmonospace = 65505;\n    e.strokelongoverlaycmb = 822;\n    e.strokeshortoverlaycmb = 821;\n    e.subset = 8834;\n    e.subsetnotequal = 8842;\n    e.subsetorequal = 8838;\n    e.succeeds = 8827;\n    e.suchthat = 8715;\n    e.suhiragana = 12377;\n    e.sukatakana = 12473;\n    e.sukatakanahalfwidth = 65405;\n    e.sukunarabic = 1618;\n    e.summation = 8721;\n    e.sun = 9788;\n    e.superset = 8835;\n    e.supersetnotequal = 8843;\n    e.supersetorequal = 8839;\n    e.svsquare = 13276;\n    e.syouwaerasquare = 13180;\n    e.t = 116;\n    e.tabengali = 2468;\n    e.tackdown = 8868;\n    e.tackleft = 8867;\n    e.tadeva = 2340;\n    e.tagujarati = 2724;\n    e.tagurmukhi = 2596;\n    e.taharabic = 1591;\n    e.tahfinalarabic = 65218;\n    e.tahinitialarabic = 65219;\n    e.tahiragana = 12383;\n    e.tahmedialarabic = 65220;\n    e.taisyouerasquare = 13181;\n    e.takatakana = 12479;\n    e.takatakanahalfwidth = 65408;\n    e.tatweelarabic = 1600;\n    e.tau = 964;\n    e.tav = 1514;\n    e.tavdages = 64330;\n    e.tavdagesh = 64330;\n    e.tavdageshhebrew = 64330;\n    e.tavhebrew = 1514;\n    e.tbar = 359;\n    e.tbopomofo = 12554;\n    e.tcaron = 357;\n    e.tccurl = 680;\n    e.tcedilla = 355;\n    e.tcheharabic = 1670;\n    e.tchehfinalarabic = 64379;\n    e.tchehinitialarabic = 64380;\n    e.tchehmedialarabic = 64381;\n    e.tcircle = 9443;\n    e.tcircumflexbelow = 7793;\n    e.tcommaaccent = 355;\n    e.tdieresis = 7831;\n    e.tdotaccent = 7787;\n    e.tdotbelow = 7789;\n    e.tecyrillic = 1090;\n    e.tedescendercyrillic = 1197;\n    e.teharabic = 1578;\n    e.tehfinalarabic = 65174;\n    e.tehhahinitialarabic = 64674;\n    e.tehhahisolatedarabic = 64524;\n    e.tehinitialarabic = 65175;\n    e.tehiragana = 12390;\n    e.tehjeeminitialarabic = 64673;\n    e.tehjeemisolatedarabic = 64523;\n    e.tehmarbutaarabic = 1577;\n    e.tehmarbutafinalarabic = 65172;\n    e.tehmedialarabic = 65176;\n    e.tehmeeminitialarabic = 64676;\n    e.tehmeemisolatedarabic = 64526;\n    e.tehnoonfinalarabic = 64627;\n    e.tekatakana = 12486;\n    e.tekatakanahalfwidth = 65411;\n    e.telephone = 8481;\n    e.telephoneblack = 9742;\n    e.telishagedolahebrew = 1440;\n    e.telishaqetanahebrew = 1449;\n    e.tencircle = 9321;\n    e.tenideographicparen = 12841;\n    e.tenparen = 9341;\n    e.tenperiod = 9361;\n    e.tenroman = 8569;\n    e.tesh = 679;\n    e.tet = 1496;\n    e.tetdagesh = 64312;\n    e.tetdageshhebrew = 64312;\n    e.tethebrew = 1496;\n    e.tetsecyrillic = 1205;\n    e.tevirhebrew = 1435;\n    e.tevirlefthebrew = 1435;\n    e.thabengali = 2469;\n    e.thadeva = 2341;\n    e.thagujarati = 2725;\n    e.thagurmukhi = 2597;\n    e.thalarabic = 1584;\n    e.thalfinalarabic = 65196;\n    e.thanthakhatlowleftthai = 63640;\n    e.thanthakhatlowrightthai = 63639;\n    e.thanthakhatthai = 3660;\n    e.thanthakhatupperleftthai = 63638;\n    e.theharabic = 1579;\n    e.thehfinalarabic = 65178;\n    e.thehinitialarabic = 65179;\n    e.thehmedialarabic = 65180;\n    e.thereexists = 8707;\n    e.therefore = 8756;\n    e.theta = 952;\n    e.theta1 = 977;\n    e.thetasymbolgreek = 977;\n    e.thieuthacirclekorean = 12921;\n    e.thieuthaparenkorean = 12825;\n    e.thieuthcirclekorean = 12907;\n    e.thieuthkorean = 12620;\n    e.thieuthparenkorean = 12811;\n    e.thirteencircle = 9324;\n    e.thirteenparen = 9344;\n    e.thirteenperiod = 9364;\n    e.thonangmonthothai = 3601;\n    e.thook = 429;\n    e.thophuthaothai = 3602;\n    e.thorn = 254;\n    e.thothahanthai = 3607;\n    e.thothanthai = 3600;\n    e.thothongthai = 3608;\n    e.thothungthai = 3606;\n    e.thousandcyrillic = 1154;\n    e.thousandsseparatorarabic = 1644;\n    e.thousandsseparatorpersian = 1644;\n    e.three = 51;\n    e.threearabic = 1635;\n    e.threebengali = 2537;\n    e.threecircle = 9314;\n    e.threecircleinversesansserif = 10124;\n    e.threedeva = 2409;\n    e.threeeighths = 8540;\n    e.threegujarati = 2793;\n    e.threegurmukhi = 2665;\n    e.threehackarabic = 1635;\n    e.threehangzhou = 12323;\n    e.threeideographicparen = 12834;\n    e.threeinferior = 8323;\n    e.threemonospace = 65299;\n    e.threenumeratorbengali = 2550;\n    e.threeoldstyle = 63283;\n    e.threeparen = 9334;\n    e.threeperiod = 9354;\n    e.threepersian = 1779;\n    e.threequarters = 190;\n    e.threequartersemdash = 63198;\n    e.threeroman = 8562;\n    e.threesuperior = 179;\n    e.threethai = 3667;\n    e.thzsquare = 13204;\n    e.tihiragana = 12385;\n    e.tikatakana = 12481;\n    e.tikatakanahalfwidth = 65409;\n    e.tikeutacirclekorean = 12912;\n    e.tikeutaparenkorean = 12816;\n    e.tikeutcirclekorean = 12898;\n    e.tikeutkorean = 12599;\n    e.tikeutparenkorean = 12802;\n    e.tilde = 732;\n    e.tildebelowcmb = 816;\n    e.tildecmb = 771;\n    e.tildecomb = 771;\n    e.tildedoublecmb = 864;\n    e.tildeoperator = 8764;\n    e.tildeoverlaycmb = 820;\n    e.tildeverticalcmb = 830;\n    e.timescircle = 8855;\n    e.tipehahebrew = 1430;\n    e.tipehalefthebrew = 1430;\n    e.tippigurmukhi = 2672;\n    e.titlocyrilliccmb = 1155;\n    e.tiwnarmenian = 1407;\n    e.tlinebelow = 7791;\n    e.tmonospace = 65364;\n    e.toarmenian = 1385;\n    e.tohiragana = 12392;\n    e.tokatakana = 12488;\n    e.tokatakanahalfwidth = 65412;\n    e.tonebarextrahighmod = 741;\n    e.tonebarextralowmod = 745;\n    e.tonebarhighmod = 742;\n    e.tonebarlowmod = 744;\n    e.tonebarmidmod = 743;\n    e.tonefive = 445;\n    e.tonesix = 389;\n    e.tonetwo = 424;\n    e.tonos = 900;\n    e.tonsquare = 13095;\n    e.topatakthai = 3599;\n    e.tortoiseshellbracketleft = 12308;\n    e.tortoiseshellbracketleftsmall = 65117;\n    e.tortoiseshellbracketleftvertical = 65081;\n    e.tortoiseshellbracketright = 12309;\n    e.tortoiseshellbracketrightsmall = 65118;\n    e.tortoiseshellbracketrightvertical = 65082;\n    e.totaothai = 3605;\n    e.tpalatalhook = 427;\n    e.tparen = 9391;\n    e.trademark = 8482;\n    e.trademarksans = 63722;\n    e.trademarkserif = 63195;\n    e.tretroflexhook = 648;\n    e.triagdn = 9660;\n    e.triaglf = 9668;\n    e.triagrt = 9658;\n    e.triagup = 9650;\n    e.ts = 678;\n    e.tsadi = 1510;\n    e.tsadidagesh = 64326;\n    e.tsadidageshhebrew = 64326;\n    e.tsadihebrew = 1510;\n    e.tsecyrillic = 1094;\n    e.tsere = 1461;\n    e.tsere12 = 1461;\n    e.tsere1e = 1461;\n    e.tsere2b = 1461;\n    e.tserehebrew = 1461;\n    e.tserenarrowhebrew = 1461;\n    e.tserequarterhebrew = 1461;\n    e.tserewidehebrew = 1461;\n    e.tshecyrillic = 1115;\n    e.tsuperior = 63219;\n    e.ttabengali = 2463;\n    e.ttadeva = 2335;\n    e.ttagujarati = 2719;\n    e.ttagurmukhi = 2591;\n    e.tteharabic = 1657;\n    e.ttehfinalarabic = 64359;\n    e.ttehinitialarabic = 64360;\n    e.ttehmedialarabic = 64361;\n    e.tthabengali = 2464;\n    e.tthadeva = 2336;\n    e.tthagujarati = 2720;\n    e.tthagurmukhi = 2592;\n    e.tturned = 647;\n    e.tuhiragana = 12388;\n    e.tukatakana = 12484;\n    e.tukatakanahalfwidth = 65410;\n    e.tusmallhiragana = 12387;\n    e.tusmallkatakana = 12483;\n    e.tusmallkatakanahalfwidth = 65391;\n    e.twelvecircle = 9323;\n    e.twelveparen = 9343;\n    e.twelveperiod = 9363;\n    e.twelveroman = 8571;\n    e.twentycircle = 9331;\n    e.twentyhangzhou = 21316;\n    e.twentyparen = 9351;\n    e.twentyperiod = 9371;\n    e.two = 50;\n    e.twoarabic = 1634;\n    e.twobengali = 2536;\n    e.twocircle = 9313;\n    e.twocircleinversesansserif = 10123;\n    e.twodeva = 2408;\n    e.twodotenleader = 8229;\n    e.twodotleader = 8229;\n    e.twodotleadervertical = 65072;\n    e.twogujarati = 2792;\n    e.twogurmukhi = 2664;\n    e.twohackarabic = 1634;\n    e.twohangzhou = 12322;\n    e.twoideographicparen = 12833;\n    e.twoinferior = 8322;\n    e.twomonospace = 65298;\n    e.twonumeratorbengali = 2549;\n    e.twooldstyle = 63282;\n    e.twoparen = 9333;\n    e.twoperiod = 9353;\n    e.twopersian = 1778;\n    e.tworoman = 8561;\n    e.twostroke = 443;\n    e.twosuperior = 178;\n    e.twothai = 3666;\n    e.twothirds = 8532;\n    e.u = 117;\n    e.uacute = 250;\n    e.ubar = 649;\n    e.ubengali = 2441;\n    e.ubopomofo = 12584;\n    e.ubreve = 365;\n    e.ucaron = 468;\n    e.ucircle = 9444;\n    e.ucircumflex = 251;\n    e.ucircumflexbelow = 7799;\n    e.ucyrillic = 1091;\n    e.udattadeva = 2385;\n    e.udblacute = 369;\n    e.udblgrave = 533;\n    e.udeva = 2313;\n    e.udieresis = 252;\n    e.udieresisacute = 472;\n    e.udieresisbelow = 7795;\n    e.udieresiscaron = 474;\n    e.udieresiscyrillic = 1265;\n    e.udieresisgrave = 476;\n    e.udieresismacron = 470;\n    e.udotbelow = 7909;\n    e.ugrave = 249;\n    e.ugujarati = 2697;\n    e.ugurmukhi = 2569;\n    e.uhiragana = 12358;\n    e.uhookabove = 7911;\n    e.uhorn = 432;\n    e.uhornacute = 7913;\n    e.uhorndotbelow = 7921;\n    e.uhorngrave = 7915;\n    e.uhornhookabove = 7917;\n    e.uhorntilde = 7919;\n    e.uhungarumlaut = 369;\n    e.uhungarumlautcyrillic = 1267;\n    e.uinvertedbreve = 535;\n    e.ukatakana = 12454;\n    e.ukatakanahalfwidth = 65395;\n    e.ukcyrillic = 1145;\n    e.ukorean = 12636;\n    e.umacron = 363;\n    e.umacroncyrillic = 1263;\n    e.umacrondieresis = 7803;\n    e.umatragurmukhi = 2625;\n    e.umonospace = 65365;\n    e.underscore = 95;\n    e.underscoredbl = 8215;\n    e.underscoremonospace = 65343;\n    e.underscorevertical = 65075;\n    e.underscorewavy = 65103;\n    e.union = 8746;\n    e.universal = 8704;\n    e.uogonek = 371;\n    e.uparen = 9392;\n    e.upblock = 9600;\n    e.upperdothebrew = 1476;\n    e.upsilon = 965;\n    e.upsilondieresis = 971;\n    e.upsilondieresistonos = 944;\n    e.upsilonlatin = 650;\n    e.upsilontonos = 973;\n    e.uptackbelowcmb = 797;\n    e.uptackmod = 724;\n    e.uragurmukhi = 2675;\n    e.uring = 367;\n    e.ushortcyrillic = 1118;\n    e.usmallhiragana = 12357;\n    e.usmallkatakana = 12453;\n    e.usmallkatakanahalfwidth = 65385;\n    e.ustraightcyrillic = 1199;\n    e.ustraightstrokecyrillic = 1201;\n    e.utilde = 361;\n    e.utildeacute = 7801;\n    e.utildebelow = 7797;\n    e.uubengali = 2442;\n    e.uudeva = 2314;\n    e.uugujarati = 2698;\n    e.uugurmukhi = 2570;\n    e.uumatragurmukhi = 2626;\n    e.uuvowelsignbengali = 2498;\n    e.uuvowelsigndeva = 2370;\n    e.uuvowelsigngujarati = 2754;\n    e.uvowelsignbengali = 2497;\n    e.uvowelsigndeva = 2369;\n    e.uvowelsigngujarati = 2753;\n    e.v = 118;\n    e.vadeva = 2357;\n    e.vagujarati = 2741;\n    e.vagurmukhi = 2613;\n    e.vakatakana = 12535;\n    e.vav = 1493;\n    e.vavdagesh = 64309;\n    e.vavdagesh65 = 64309;\n    e.vavdageshhebrew = 64309;\n    e.vavhebrew = 1493;\n    e.vavholam = 64331;\n    e.vavholamhebrew = 64331;\n    e.vavvavhebrew = 1520;\n    e.vavyodhebrew = 1521;\n    e.vcircle = 9445;\n    e.vdotbelow = 7807;\n    e.vecyrillic = 1074;\n    e.veharabic = 1700;\n    e.vehfinalarabic = 64363;\n    e.vehinitialarabic = 64364;\n    e.vehmedialarabic = 64365;\n    e.vekatakana = 12537;\n    e.venus = 9792;\n    e.verticalbar = 124;\n    e.verticallineabovecmb = 781;\n    e.verticallinebelowcmb = 809;\n    e.verticallinelowmod = 716;\n    e.verticallinemod = 712;\n    e.vewarmenian = 1406;\n    e.vhook = 651;\n    e.vikatakana = 12536;\n    e.viramabengali = 2509;\n    e.viramadeva = 2381;\n    e.viramagujarati = 2765;\n    e.visargabengali = 2435;\n    e.visargadeva = 2307;\n    e.visargagujarati = 2691;\n    e.vmonospace = 65366;\n    e.voarmenian = 1400;\n    e.voicediterationhiragana = 12446;\n    e.voicediterationkatakana = 12542;\n    e.voicedmarkkana = 12443;\n    e.voicedmarkkanahalfwidth = 65438;\n    e.vokatakana = 12538;\n    e.vparen = 9393;\n    e.vtilde = 7805;\n    e.vturned = 652;\n    e.vuhiragana = 12436;\n    e.vukatakana = 12532;\n    e.w = 119;\n    e.wacute = 7811;\n    e.waekorean = 12633;\n    e.wahiragana = 12431;\n    e.wakatakana = 12527;\n    e.wakatakanahalfwidth = 65436;\n    e.wakorean = 12632;\n    e.wasmallhiragana = 12430;\n    e.wasmallkatakana = 12526;\n    e.wattosquare = 13143;\n    e.wavedash = 12316;\n    e.wavyunderscorevertical = 65076;\n    e.wawarabic = 1608;\n    e.wawfinalarabic = 65262;\n    e.wawhamzaabovearabic = 1572;\n    e.wawhamzaabovefinalarabic = 65158;\n    e.wbsquare = 13277;\n    e.wcircle = 9446;\n    e.wcircumflex = 373;\n    e.wdieresis = 7813;\n    e.wdotaccent = 7815;\n    e.wdotbelow = 7817;\n    e.wehiragana = 12433;\n    e.weierstrass = 8472;\n    e.wekatakana = 12529;\n    e.wekorean = 12638;\n    e.weokorean = 12637;\n    e.wgrave = 7809;\n    e.whitebullet = 9702;\n    e.whitecircle = 9675;\n    e.whitecircleinverse = 9689;\n    e.whitecornerbracketleft = 12302;\n    e.whitecornerbracketleftvertical = 65091;\n    e.whitecornerbracketright = 12303;\n    e.whitecornerbracketrightvertical = 65092;\n    e.whitediamond = 9671;\n    e.whitediamondcontainingblacksmalldiamond = 9672;\n    e.whitedownpointingsmalltriangle = 9663;\n    e.whitedownpointingtriangle = 9661;\n    e.whiteleftpointingsmalltriangle = 9667;\n    e.whiteleftpointingtriangle = 9665;\n    e.whitelenticularbracketleft = 12310;\n    e.whitelenticularbracketright = 12311;\n    e.whiterightpointingsmalltriangle = 9657;\n    e.whiterightpointingtriangle = 9655;\n    e.whitesmallsquare = 9643;\n    e.whitesmilingface = 9786;\n    e.whitesquare = 9633;\n    e.whitestar = 9734;\n    e.whitetelephone = 9743;\n    e.whitetortoiseshellbracketleft = 12312;\n    e.whitetortoiseshellbracketright = 12313;\n    e.whiteuppointingsmalltriangle = 9653;\n    e.whiteuppointingtriangle = 9651;\n    e.wihiragana = 12432;\n    e.wikatakana = 12528;\n    e.wikorean = 12639;\n    e.wmonospace = 65367;\n    e.wohiragana = 12434;\n    e.wokatakana = 12530;\n    e.wokatakanahalfwidth = 65382;\n    e.won = 8361;\n    e.wonmonospace = 65510;\n    e.wowaenthai = 3623;\n    e.wparen = 9394;\n    e.wring = 7832;\n    e.wsuperior = 695;\n    e.wturned = 653;\n    e.wynn = 447;\n    e.x = 120;\n    e.xabovecmb = 829;\n    e.xbopomofo = 12562;\n    e.xcircle = 9447;\n    e.xdieresis = 7821;\n    e.xdotaccent = 7819;\n    e.xeharmenian = 1389;\n    e.xi = 958;\n    e.xmonospace = 65368;\n    e.xparen = 9395;\n    e.xsuperior = 739;\n    e.y = 121;\n    e.yaadosquare = 13134;\n    e.yabengali = 2479;\n    e.yacute = 253;\n    e.yadeva = 2351;\n    e.yaekorean = 12626;\n    e.yagujarati = 2735;\n    e.yagurmukhi = 2607;\n    e.yahiragana = 12420;\n    e.yakatakana = 12516;\n    e.yakatakanahalfwidth = 65428;\n    e.yakorean = 12625;\n    e.yamakkanthai = 3662;\n    e.yasmallhiragana = 12419;\n    e.yasmallkatakana = 12515;\n    e.yasmallkatakanahalfwidth = 65388;\n    e.yatcyrillic = 1123;\n    e.ycircle = 9448;\n    e.ycircumflex = 375;\n    e.ydieresis = 255;\n    e.ydotaccent = 7823;\n    e.ydotbelow = 7925;\n    e.yeharabic = 1610;\n    e.yehbarreearabic = 1746;\n    e.yehbarreefinalarabic = 64431;\n    e.yehfinalarabic = 65266;\n    e.yehhamzaabovearabic = 1574;\n    e.yehhamzaabovefinalarabic = 65162;\n    e.yehhamzaaboveinitialarabic = 65163;\n    e.yehhamzaabovemedialarabic = 65164;\n    e.yehinitialarabic = 65267;\n    e.yehmedialarabic = 65268;\n    e.yehmeeminitialarabic = 64733;\n    e.yehmeemisolatedarabic = 64600;\n    e.yehnoonfinalarabic = 64660;\n    e.yehthreedotsbelowarabic = 1745;\n    e.yekorean = 12630;\n    e.yen = 165;\n    e.yenmonospace = 65509;\n    e.yeokorean = 12629;\n    e.yeorinhieuhkorean = 12678;\n    e.yerahbenyomohebrew = 1450;\n    e.yerahbenyomolefthebrew = 1450;\n    e.yericyrillic = 1099;\n    e.yerudieresiscyrillic = 1273;\n    e.yesieungkorean = 12673;\n    e.yesieungpansioskorean = 12675;\n    e.yesieungsioskorean = 12674;\n    e.yetivhebrew = 1434;\n    e.ygrave = 7923;\n    e.yhook = 436;\n    e.yhookabove = 7927;\n    e.yiarmenian = 1397;\n    e.yicyrillic = 1111;\n    e.yikorean = 12642;\n    e.yinyang = 9775;\n    e.yiwnarmenian = 1410;\n    e.ymonospace = 65369;\n    e.yod = 1497;\n    e.yoddagesh = 64313;\n    e.yoddageshhebrew = 64313;\n    e.yodhebrew = 1497;\n    e.yodyodhebrew = 1522;\n    e.yodyodpatahhebrew = 64287;\n    e.yohiragana = 12424;\n    e.yoikorean = 12681;\n    e.yokatakana = 12520;\n    e.yokatakanahalfwidth = 65430;\n    e.yokorean = 12635;\n    e.yosmallhiragana = 12423;\n    e.yosmallkatakana = 12519;\n    e.yosmallkatakanahalfwidth = 65390;\n    e.yotgreek = 1011;\n    e.yoyaekorean = 12680;\n    e.yoyakorean = 12679;\n    e.yoyakthai = 3618;\n    e.yoyingthai = 3597;\n    e.yparen = 9396;\n    e.ypogegrammeni = 890;\n    e.ypogegrammenigreekcmb = 837;\n    e.yr = 422;\n    e.yring = 7833;\n    e.ysuperior = 696;\n    e.ytilde = 7929;\n    e.yturned = 654;\n    e.yuhiragana = 12422;\n    e.yuikorean = 12684;\n    e.yukatakana = 12518;\n    e.yukatakanahalfwidth = 65429;\n    e.yukorean = 12640;\n    e.yusbigcyrillic = 1131;\n    e.yusbigiotifiedcyrillic = 1133;\n    e.yuslittlecyrillic = 1127;\n    e.yuslittleiotifiedcyrillic = 1129;\n    e.yusmallhiragana = 12421;\n    e.yusmallkatakana = 12517;\n    e.yusmallkatakanahalfwidth = 65389;\n    e.yuyekorean = 12683;\n    e.yuyeokorean = 12682;\n    e.yyabengali = 2527;\n    e.yyadeva = 2399;\n    e.z = 122;\n    e.zaarmenian = 1382;\n    e.zacute = 378;\n    e.zadeva = 2395;\n    e.zagurmukhi = 2651;\n    e.zaharabic = 1592;\n    e.zahfinalarabic = 65222;\n    e.zahinitialarabic = 65223;\n    e.zahiragana = 12374;\n    e.zahmedialarabic = 65224;\n    e.zainarabic = 1586;\n    e.zainfinalarabic = 65200;\n    e.zakatakana = 12470;\n    e.zaqefgadolhebrew = 1429;\n    e.zaqefqatanhebrew = 1428;\n    e.zarqahebrew = 1432;\n    e.zayin = 1494;\n    e.zayindagesh = 64310;\n    e.zayindageshhebrew = 64310;\n    e.zayinhebrew = 1494;\n    e.zbopomofo = 12567;\n    e.zcaron = 382;\n    e.zcircle = 9449;\n    e.zcircumflex = 7825;\n    e.zcurl = 657;\n    e.zdot = 380;\n    e.zdotaccent = 380;\n    e.zdotbelow = 7827;\n    e.zecyrillic = 1079;\n    e.zedescendercyrillic = 1177;\n    e.zedieresiscyrillic = 1247;\n    e.zehiragana = 12380;\n    e.zekatakana = 12476;\n    e.zero = 48;\n    e.zeroarabic = 1632;\n    e.zerobengali = 2534;\n    e.zerodeva = 2406;\n    e.zerogujarati = 2790;\n    e.zerogurmukhi = 2662;\n    e.zerohackarabic = 1632;\n    e.zeroinferior = 8320;\n    e.zeromonospace = 65296;\n    e.zerooldstyle = 63280;\n    e.zeropersian = 1776;\n    e.zerosuperior = 8304;\n    e.zerothai = 3664;\n    e.zerowidthjoiner = 65279;\n    e.zerowidthnonjoiner = 8204;\n    e.zerowidthspace = 8203;\n    e.zeta = 950;\n    e.zhbopomofo = 12563;\n    e.zhearmenian = 1386;\n    e.zhebrevecyrillic = 1218;\n    e.zhecyrillic = 1078;\n    e.zhedescendercyrillic = 1175;\n    e.zhedieresiscyrillic = 1245;\n    e.zihiragana = 12376;\n    e.zikatakana = 12472;\n    e.zinorhebrew = 1454;\n    e.zlinebelow = 7829;\n    e.zmonospace = 65370;\n    e.zohiragana = 12382;\n    e.zokatakana = 12478;\n    e.zparen = 9397;\n    e.zretroflexhook = 656;\n    e.zstroke = 438;\n    e.zuhiragana = 12378;\n    e.zukatakana = 12474;\n    e[\".notdef\"] = 0;\n    e.angbracketleftbig = 9001;\n    e.angbracketleftBig = 9001;\n    e.angbracketleftbigg = 9001;\n    e.angbracketleftBigg = 9001;\n    e.angbracketrightBig = 9002;\n    e.angbracketrightbig = 9002;\n    e.angbracketrightBigg = 9002;\n    e.angbracketrightbigg = 9002;\n    e.arrowhookleft = 8618;\n    e.arrowhookright = 8617;\n    e.arrowlefttophalf = 8636;\n    e.arrowleftbothalf = 8637;\n    e.arrownortheast = 8599;\n    e.arrownorthwest = 8598;\n    e.arrowrighttophalf = 8640;\n    e.arrowrightbothalf = 8641;\n    e.arrowsoutheast = 8600;\n    e.arrowsouthwest = 8601;\n    e.backslashbig = 8726;\n    e.backslashBig = 8726;\n    e.backslashBigg = 8726;\n    e.backslashbigg = 8726;\n    e.bardbl = 8214;\n    e.bracehtipdownleft = 65079;\n    e.bracehtipdownright = 65079;\n    e.bracehtipupleft = 65080;\n    e.bracehtipupright = 65080;\n    e.braceleftBig = 123;\n    e.braceleftbig = 123;\n    e.braceleftbigg = 123;\n    e.braceleftBigg = 123;\n    e.bracerightBig = 125;\n    e.bracerightbig = 125;\n    e.bracerightbigg = 125;\n    e.bracerightBigg = 125;\n    e.bracketleftbig = 91;\n    e.bracketleftBig = 91;\n    e.bracketleftbigg = 91;\n    e.bracketleftBigg = 91;\n    e.bracketrightBig = 93;\n    e.bracketrightbig = 93;\n    e.bracketrightbigg = 93;\n    e.bracketrightBigg = 93;\n    e.ceilingleftbig = 8968;\n    e.ceilingleftBig = 8968;\n    e.ceilingleftBigg = 8968;\n    e.ceilingleftbigg = 8968;\n    e.ceilingrightbig = 8969;\n    e.ceilingrightBig = 8969;\n    e.ceilingrightbigg = 8969;\n    e.ceilingrightBigg = 8969;\n    e.circledotdisplay = 8857;\n    e.circledottext = 8857;\n    e.circlemultiplydisplay = 8855;\n    e.circlemultiplytext = 8855;\n    e.circleplusdisplay = 8853;\n    e.circleplustext = 8853;\n    e.contintegraldisplay = 8750;\n    e.contintegraltext = 8750;\n    e.coproductdisplay = 8720;\n    e.coproducttext = 8720;\n    e.floorleftBig = 8970;\n    e.floorleftbig = 8970;\n    e.floorleftbigg = 8970;\n    e.floorleftBigg = 8970;\n    e.floorrightbig = 8971;\n    e.floorrightBig = 8971;\n    e.floorrightBigg = 8971;\n    e.floorrightbigg = 8971;\n    e.hatwide = 770;\n    e.hatwider = 770;\n    e.hatwidest = 770;\n    e.intercal = 7488;\n    e.integraldisplay = 8747;\n    e.integraltext = 8747;\n    e.intersectiondisplay = 8898;\n    e.intersectiontext = 8898;\n    e.logicalanddisplay = 8743;\n    e.logicalandtext = 8743;\n    e.logicalordisplay = 8744;\n    e.logicalortext = 8744;\n    e.parenleftBig = 40;\n    e.parenleftbig = 40;\n    e.parenleftBigg = 40;\n    e.parenleftbigg = 40;\n    e.parenrightBig = 41;\n    e.parenrightbig = 41;\n    e.parenrightBigg = 41;\n    e.parenrightbigg = 41;\n    e.prime = 8242;\n    e.productdisplay = 8719;\n    e.producttext = 8719;\n    e.radicalbig = 8730;\n    e.radicalBig = 8730;\n    e.radicalBigg = 8730;\n    e.radicalbigg = 8730;\n    e.radicalbt = 8730;\n    e.radicaltp = 8730;\n    e.radicalvertex = 8730;\n    e.slashbig = 47;\n    e.slashBig = 47;\n    e.slashBigg = 47;\n    e.slashbigg = 47;\n    e.summationdisplay = 8721;\n    e.summationtext = 8721;\n    e.tildewide = 732;\n    e.tildewider = 732;\n    e.tildewidest = 732;\n    e.uniondisplay = 8899;\n    e.unionmultidisplay = 8846;\n    e.unionmultitext = 8846;\n    e.unionsqdisplay = 8852;\n    e.unionsqtext = 8852;\n    e.uniontext = 8899;\n    e.vextenddouble = 8741;\n    e.vextendsingle = 8739;\n  }),\n  Gi = getLookupTableFactory(function (e) {\n    e.space = 32;\n    e.a1 = 9985;\n    e.a2 = 9986;\n    e.a202 = 9987;\n    e.a3 = 9988;\n    e.a4 = 9742;\n    e.a5 = 9990;\n    e.a119 = 9991;\n    e.a118 = 9992;\n    e.a117 = 9993;\n    e.a11 = 9755;\n    e.a12 = 9758;\n    e.a13 = 9996;\n    e.a14 = 9997;\n    e.a15 = 9998;\n    e.a16 = 9999;\n    e.a105 = 1e4;\n    e.a17 = 10001;\n    e.a18 = 10002;\n    e.a19 = 10003;\n    e.a20 = 10004;\n    e.a21 = 10005;\n    e.a22 = 10006;\n    e.a23 = 10007;\n    e.a24 = 10008;\n    e.a25 = 10009;\n    e.a26 = 10010;\n    e.a27 = 10011;\n    e.a28 = 10012;\n    e.a6 = 10013;\n    e.a7 = 10014;\n    e.a8 = 10015;\n    e.a9 = 10016;\n    e.a10 = 10017;\n    e.a29 = 10018;\n    e.a30 = 10019;\n    e.a31 = 10020;\n    e.a32 = 10021;\n    e.a33 = 10022;\n    e.a34 = 10023;\n    e.a35 = 9733;\n    e.a36 = 10025;\n    e.a37 = 10026;\n    e.a38 = 10027;\n    e.a39 = 10028;\n    e.a40 = 10029;\n    e.a41 = 10030;\n    e.a42 = 10031;\n    e.a43 = 10032;\n    e.a44 = 10033;\n    e.a45 = 10034;\n    e.a46 = 10035;\n    e.a47 = 10036;\n    e.a48 = 10037;\n    e.a49 = 10038;\n    e.a50 = 10039;\n    e.a51 = 10040;\n    e.a52 = 10041;\n    e.a53 = 10042;\n    e.a54 = 10043;\n    e.a55 = 10044;\n    e.a56 = 10045;\n    e.a57 = 10046;\n    e.a58 = 10047;\n    e.a59 = 10048;\n    e.a60 = 10049;\n    e.a61 = 10050;\n    e.a62 = 10051;\n    e.a63 = 10052;\n    e.a64 = 10053;\n    e.a65 = 10054;\n    e.a66 = 10055;\n    e.a67 = 10056;\n    e.a68 = 10057;\n    e.a69 = 10058;\n    e.a70 = 10059;\n    e.a71 = 9679;\n    e.a72 = 10061;\n    e.a73 = 9632;\n    e.a74 = 10063;\n    e.a203 = 10064;\n    e.a75 = 10065;\n    e.a204 = 10066;\n    e.a76 = 9650;\n    e.a77 = 9660;\n    e.a78 = 9670;\n    e.a79 = 10070;\n    e.a81 = 9687;\n    e.a82 = 10072;\n    e.a83 = 10073;\n    e.a84 = 10074;\n    e.a97 = 10075;\n    e.a98 = 10076;\n    e.a99 = 10077;\n    e.a100 = 10078;\n    e.a101 = 10081;\n    e.a102 = 10082;\n    e.a103 = 10083;\n    e.a104 = 10084;\n    e.a106 = 10085;\n    e.a107 = 10086;\n    e.a108 = 10087;\n    e.a112 = 9827;\n    e.a111 = 9830;\n    e.a110 = 9829;\n    e.a109 = 9824;\n    e.a120 = 9312;\n    e.a121 = 9313;\n    e.a122 = 9314;\n    e.a123 = 9315;\n    e.a124 = 9316;\n    e.a125 = 9317;\n    e.a126 = 9318;\n    e.a127 = 9319;\n    e.a128 = 9320;\n    e.a129 = 9321;\n    e.a130 = 10102;\n    e.a131 = 10103;\n    e.a132 = 10104;\n    e.a133 = 10105;\n    e.a134 = 10106;\n    e.a135 = 10107;\n    e.a136 = 10108;\n    e.a137 = 10109;\n    e.a138 = 10110;\n    e.a139 = 10111;\n    e.a140 = 10112;\n    e.a141 = 10113;\n    e.a142 = 10114;\n    e.a143 = 10115;\n    e.a144 = 10116;\n    e.a145 = 10117;\n    e.a146 = 10118;\n    e.a147 = 10119;\n    e.a148 = 10120;\n    e.a149 = 10121;\n    e.a150 = 10122;\n    e.a151 = 10123;\n    e.a152 = 10124;\n    e.a153 = 10125;\n    e.a154 = 10126;\n    e.a155 = 10127;\n    e.a156 = 10128;\n    e.a157 = 10129;\n    e.a158 = 10130;\n    e.a159 = 10131;\n    e.a160 = 10132;\n    e.a161 = 8594;\n    e.a163 = 8596;\n    e.a164 = 8597;\n    e.a196 = 10136;\n    e.a165 = 10137;\n    e.a192 = 10138;\n    e.a166 = 10139;\n    e.a167 = 10140;\n    e.a168 = 10141;\n    e.a169 = 10142;\n    e.a170 = 10143;\n    e.a171 = 10144;\n    e.a172 = 10145;\n    e.a173 = 10146;\n    e.a162 = 10147;\n    e.a174 = 10148;\n    e.a175 = 10149;\n    e.a176 = 10150;\n    e.a177 = 10151;\n    e.a178 = 10152;\n    e.a179 = 10153;\n    e.a193 = 10154;\n    e.a180 = 10155;\n    e.a199 = 10156;\n    e.a181 = 10157;\n    e.a200 = 10158;\n    e.a182 = 10159;\n    e.a201 = 10161;\n    e.a183 = 10162;\n    e.a184 = 10163;\n    e.a197 = 10164;\n    e.a185 = 10165;\n    e.a194 = 10166;\n    e.a198 = 10167;\n    e.a186 = 10168;\n    e.a195 = 10169;\n    e.a187 = 10170;\n    e.a188 = 10171;\n    e.a189 = 10172;\n    e.a190 = 10173;\n    e.a191 = 10174;\n    e.a89 = 10088;\n    e.a90 = 10089;\n    e.a93 = 10090;\n    e.a94 = 10091;\n    e.a91 = 10092;\n    e.a92 = 10093;\n    e.a205 = 10094;\n    e.a85 = 10095;\n    e.a206 = 10096;\n    e.a86 = 10097;\n    e.a87 = 10098;\n    e.a88 = 10099;\n    e.a95 = 10100;\n    e.a96 = 10101;\n    e[\".notdef\"] = 0;\n  }),\n  xi = getLookupTableFactory(function (e) {\n    e[63721] = 169;\n    e[63193] = 169;\n    e[63720] = 174;\n    e[63194] = 174;\n    e[63722] = 8482;\n    e[63195] = 8482;\n    e[63729] = 9127;\n    e[63730] = 9128;\n    e[63731] = 9129;\n    e[63740] = 9131;\n    e[63741] = 9132;\n    e[63742] = 9133;\n    e[63726] = 9121;\n    e[63727] = 9122;\n    e[63728] = 9123;\n    e[63737] = 9124;\n    e[63738] = 9125;\n    e[63739] = 9126;\n    e[63723] = 9115;\n    e[63724] = 9116;\n    e[63725] = 9117;\n    e[63734] = 9118;\n    e[63735] = 9119;\n    e[63736] = 9120;\n  });\nfunction getUnicodeForGlyph(e, t) {\n  let i = t[e];\n  if (void 0 !== i) return i;\n  if (!e) return -1;\n  if (\"u\" === e[0]) {\n    const t = e.length;\n    let a;\n    if (7 === t && \"n\" === e[1] && \"i\" === e[2]) a = e.substring(3);else {\n      if (!(t >= 5 && t <= 7)) return -1;\n      a = e.substring(1);\n    }\n    if (a === a.toUpperCase()) {\n      i = parseInt(a, 16);\n      if (i >= 0) return i;\n    }\n  }\n  return -1;\n}\nconst Mi = [[0, 127], [128, 255], [256, 383], [384, 591], [592, 687, 7424, 7551, 7552, 7615], [688, 767, 42752, 42783], [768, 879, 7616, 7679], [880, 1023], [11392, 11519], [1024, 1279, 1280, 1327, 11744, 11775, 42560, 42655], [1328, 1423], [1424, 1535], [42240, 42559], [1536, 1791, 1872, 1919], [1984, 2047], [2304, 2431], [2432, 2559], [2560, 2687], [2688, 2815], [2816, 2943], [2944, 3071], [3072, 3199], [3200, 3327], [3328, 3455], [3584, 3711], [3712, 3839], [4256, 4351, 11520, 11567], [6912, 7039], [4352, 4607], [7680, 7935, 11360, 11391, 42784, 43007], [7936, 8191], [8192, 8303, 11776, 11903], [8304, 8351], [8352, 8399], [8400, 8447], [8448, 8527], [8528, 8591], [8592, 8703, 10224, 10239, 10496, 10623, 11008, 11263], [8704, 8959, 10752, 11007, 10176, 10223, 10624, 10751], [8960, 9215], [9216, 9279], [9280, 9311], [9312, 9471], [9472, 9599], [9600, 9631], [9632, 9727], [9728, 9983], [9984, 10175], [12288, 12351], [12352, 12447], [12448, 12543, 12784, 12799], [12544, 12591, 12704, 12735], [12592, 12687], [43072, 43135], [12800, 13055], [13056, 13311], [44032, 55215], [55296, 57343], [67840, 67871], [19968, 40959, 11904, 12031, 12032, 12255, 12272, 12287, 13312, 19903, 131072, 173791, 12688, 12703], [57344, 63743], [12736, 12783, 63744, 64255, 194560, 195103], [64256, 64335], [64336, 65023], [65056, 65071], [65040, 65055], [65104, 65135], [65136, 65279], [65280, 65519], [65520, 65535], [3840, 4095], [1792, 1871], [1920, 1983], [3456, 3583], [4096, 4255], [4608, 4991, 4992, 5023, 11648, 11743], [5024, 5119], [5120, 5759], [5760, 5791], [5792, 5887], [6016, 6143], [6144, 6319], [10240, 10495], [40960, 42127], [5888, 5919, 5920, 5951, 5952, 5983, 5984, 6015], [66304, 66351], [66352, 66383], [66560, 66639], [118784, 119039, 119040, 119295, 119296, 119375], [119808, 120831], [1044480, 1048573], [65024, 65039, 917760, 917999], [917504, 917631], [6400, 6479], [6480, 6527], [6528, 6623], [6656, 6687], [11264, 11359], [11568, 11647], [19904, 19967], [43008, 43055], [65536, 65663, 65664, 65791, 65792, 65855], [65856, 65935], [66432, 66463], [66464, 66527], [66640, 66687], [66688, 66735], [67584, 67647], [68096, 68191], [119552, 119647], [73728, 74751, 74752, 74879], [119648, 119679], [7040, 7103], [7168, 7247], [7248, 7295], [43136, 43231], [43264, 43311], [43312, 43359], [43520, 43615], [65936, 65999], [66e3, 66047], [66208, 66271, 66176, 66207, 67872, 67903], [127024, 127135, 126976, 127023]];\nfunction getUnicodeRangeFor(e, t = -1) {\n  if (-1 !== t) {\n    const i = Mi[t];\n    for (let a = 0, s = i.length; a < s; a += 2) if (e >= i[a] && e <= i[a + 1]) return t;\n  }\n  for (let t = 0, i = Mi.length; t < i; t++) {\n    const i = Mi[t];\n    for (let a = 0, s = i.length; a < s; a += 2) if (e >= i[a] && e <= i[a + 1]) return t;\n  }\n  return -1;\n}\nconst Hi = new RegExp(\"^(\\\\s)|(\\\\p{Mn})|(\\\\p{Cf})$\", \"u\"),\n  Ji = new Map();\nconst Yi = !0,\n  vi = 1,\n  Ki = 2,\n  Ti = 4,\n  qi = 32,\n  Oi = [\".notdef\", \".null\", \"nonmarkingreturn\", \"space\", \"exclam\", \"quotedbl\", \"numbersign\", \"dollar\", \"percent\", \"ampersand\", \"quotesingle\", \"parenleft\", \"parenright\", \"asterisk\", \"plus\", \"comma\", \"hyphen\", \"period\", \"slash\", \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"colon\", \"semicolon\", \"less\", \"equal\", \"greater\", \"question\", \"at\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"bracketleft\", \"backslash\", \"bracketright\", \"asciicircum\", \"underscore\", \"grave\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"braceleft\", \"bar\", \"braceright\", \"asciitilde\", \"Adieresis\", \"Aring\", \"Ccedilla\", \"Eacute\", \"Ntilde\", \"Odieresis\", \"Udieresis\", \"aacute\", \"agrave\", \"acircumflex\", \"adieresis\", \"atilde\", \"aring\", \"ccedilla\", \"eacute\", \"egrave\", \"ecircumflex\", \"edieresis\", \"iacute\", \"igrave\", \"icircumflex\", \"idieresis\", \"ntilde\", \"oacute\", \"ograve\", \"ocircumflex\", \"odieresis\", \"otilde\", \"uacute\", \"ugrave\", \"ucircumflex\", \"udieresis\", \"dagger\", \"degree\", \"cent\", \"sterling\", \"section\", \"bullet\", \"paragraph\", \"germandbls\", \"registered\", \"copyright\", \"trademark\", \"acute\", \"dieresis\", \"notequal\", \"AE\", \"Oslash\", \"infinity\", \"plusminus\", \"lessequal\", \"greaterequal\", \"yen\", \"mu\", \"partialdiff\", \"summation\", \"product\", \"pi\", \"integral\", \"ordfeminine\", \"ordmasculine\", \"Omega\", \"ae\", \"oslash\", \"questiondown\", \"exclamdown\", \"logicalnot\", \"radical\", \"florin\", \"approxequal\", \"Delta\", \"guillemotleft\", \"guillemotright\", \"ellipsis\", \"nonbreakingspace\", \"Agrave\", \"Atilde\", \"Otilde\", \"OE\", \"oe\", \"endash\", \"emdash\", \"quotedblleft\", \"quotedblright\", \"quoteleft\", \"quoteright\", \"divide\", \"lozenge\", \"ydieresis\", \"Ydieresis\", \"fraction\", \"currency\", \"guilsinglleft\", \"guilsinglright\", \"fi\", \"fl\", \"daggerdbl\", \"periodcentered\", \"quotesinglbase\", \"quotedblbase\", \"perthousand\", \"Acircumflex\", \"Ecircumflex\", \"Aacute\", \"Edieresis\", \"Egrave\", \"Iacute\", \"Icircumflex\", \"Idieresis\", \"Igrave\", \"Oacute\", \"Ocircumflex\", \"apple\", \"Ograve\", \"Uacute\", \"Ucircumflex\", \"Ugrave\", \"dotlessi\", \"circumflex\", \"tilde\", \"macron\", \"breve\", \"dotaccent\", \"ring\", \"cedilla\", \"hungarumlaut\", \"ogonek\", \"caron\", \"Lslash\", \"lslash\", \"Scaron\", \"scaron\", \"Zcaron\", \"zcaron\", \"brokenbar\", \"Eth\", \"eth\", \"Yacute\", \"yacute\", \"Thorn\", \"thorn\", \"minus\", \"multiply\", \"onesuperior\", \"twosuperior\", \"threesuperior\", \"onehalf\", \"onequarter\", \"threequarters\", \"franc\", \"Gbreve\", \"gbreve\", \"Idotaccent\", \"Scedilla\", \"scedilla\", \"Cacute\", \"cacute\", \"Ccaron\", \"ccaron\", \"dcroat\"];\nfunction recoverGlyphName(e, t) {\n  if (void 0 !== t[e]) return e;\n  const i = getUnicodeForGlyph(e, t);\n  if (-1 !== i) for (const e in t) if (t[e] === i) return e;\n  info(\"Unable to recover a standard glyph name for: \" + e);\n  return e;\n}\nfunction type1FontGlyphMapping(e, t, i) {\n  const a = Object.create(null);\n  let s, r, n;\n  const g = !!(e.flags & Ti);\n  if (e.isInternalFont) {\n    n = t;\n    for (r = 0; r < n.length; r++) {\n      s = i.indexOf(n[r]);\n      a[r] = s >= 0 ? s : 0;\n    }\n  } else if (e.baseEncodingName) {\n    n = getEncoding(e.baseEncodingName);\n    for (r = 0; r < n.length; r++) {\n      s = i.indexOf(n[r]);\n      a[r] = s >= 0 ? s : 0;\n    }\n  } else if (g) for (r in t) a[r] = t[r];else {\n    n = fi;\n    for (r = 0; r < n.length; r++) {\n      s = i.indexOf(n[r]);\n      a[r] = s >= 0 ? s : 0;\n    }\n  }\n  const o = e.differences;\n  let c;\n  if (o) for (r in o) {\n    const e = o[r];\n    s = i.indexOf(e);\n    if (-1 === s) {\n      c || (c = Ni());\n      const t = recoverGlyphName(e, c);\n      t !== e && (s = i.indexOf(t));\n    }\n    a[r] = s >= 0 ? s : 0;\n  }\n  return a;\n}\nfunction normalizeFontName(e) {\n  return e.replaceAll(/[,_]/g, \"-\").replaceAll(/\\s/g, \"\");\n}\nconst Pi = getLookupTableFactory(function (e) {\n    e[\"Times-Roman\"] = \"Times-Roman\";\n    e.Helvetica = \"Helvetica\";\n    e.Courier = \"Courier\";\n    e.Symbol = \"Symbol\";\n    e[\"Times-Bold\"] = \"Times-Bold\";\n    e[\"Helvetica-Bold\"] = \"Helvetica-Bold\";\n    e[\"Courier-Bold\"] = \"Courier-Bold\";\n    e.ZapfDingbats = \"ZapfDingbats\";\n    e[\"Times-Italic\"] = \"Times-Italic\";\n    e[\"Helvetica-Oblique\"] = \"Helvetica-Oblique\";\n    e[\"Courier-Oblique\"] = \"Courier-Oblique\";\n    e[\"Times-BoldItalic\"] = \"Times-BoldItalic\";\n    e[\"Helvetica-BoldOblique\"] = \"Helvetica-BoldOblique\";\n    e[\"Courier-BoldOblique\"] = \"Courier-BoldOblique\";\n    e.ArialNarrow = \"Helvetica\";\n    e[\"ArialNarrow-Bold\"] = \"Helvetica-Bold\";\n    e[\"ArialNarrow-BoldItalic\"] = \"Helvetica-BoldOblique\";\n    e[\"ArialNarrow-Italic\"] = \"Helvetica-Oblique\";\n    e.ArialBlack = \"Helvetica\";\n    e[\"ArialBlack-Bold\"] = \"Helvetica-Bold\";\n    e[\"ArialBlack-BoldItalic\"] = \"Helvetica-BoldOblique\";\n    e[\"ArialBlack-Italic\"] = \"Helvetica-Oblique\";\n    e[\"Arial-Black\"] = \"Helvetica\";\n    e[\"Arial-Black-Bold\"] = \"Helvetica-Bold\";\n    e[\"Arial-Black-BoldItalic\"] = \"Helvetica-BoldOblique\";\n    e[\"Arial-Black-Italic\"] = \"Helvetica-Oblique\";\n    e.Arial = \"Helvetica\";\n    e[\"Arial-Bold\"] = \"Helvetica-Bold\";\n    e[\"Arial-BoldItalic\"] = \"Helvetica-BoldOblique\";\n    e[\"Arial-Italic\"] = \"Helvetica-Oblique\";\n    e.ArialMT = \"Helvetica\";\n    e[\"Arial-BoldItalicMT\"] = \"Helvetica-BoldOblique\";\n    e[\"Arial-BoldMT\"] = \"Helvetica-Bold\";\n    e[\"Arial-ItalicMT\"] = \"Helvetica-Oblique\";\n    e[\"Arial-BoldItalicMT-BoldItalic\"] = \"Helvetica-BoldOblique\";\n    e[\"Arial-BoldMT-Bold\"] = \"Helvetica-Bold\";\n    e[\"Arial-ItalicMT-Italic\"] = \"Helvetica-Oblique\";\n    e.ArialUnicodeMS = \"Helvetica\";\n    e[\"ArialUnicodeMS-Bold\"] = \"Helvetica-Bold\";\n    e[\"ArialUnicodeMS-BoldItalic\"] = \"Helvetica-BoldOblique\";\n    e[\"ArialUnicodeMS-Italic\"] = \"Helvetica-Oblique\";\n    e[\"Courier-BoldItalic\"] = \"Courier-BoldOblique\";\n    e[\"Courier-Italic\"] = \"Courier-Oblique\";\n    e.CourierNew = \"Courier\";\n    e[\"CourierNew-Bold\"] = \"Courier-Bold\";\n    e[\"CourierNew-BoldItalic\"] = \"Courier-BoldOblique\";\n    e[\"CourierNew-Italic\"] = \"Courier-Oblique\";\n    e[\"CourierNewPS-BoldItalicMT\"] = \"Courier-BoldOblique\";\n    e[\"CourierNewPS-BoldMT\"] = \"Courier-Bold\";\n    e[\"CourierNewPS-ItalicMT\"] = \"Courier-Oblique\";\n    e.CourierNewPSMT = \"Courier\";\n    e[\"Helvetica-BoldItalic\"] = \"Helvetica-BoldOblique\";\n    e[\"Helvetica-Italic\"] = \"Helvetica-Oblique\";\n    e[\"Symbol-Bold\"] = \"Symbol\";\n    e[\"Symbol-BoldItalic\"] = \"Symbol\";\n    e[\"Symbol-Italic\"] = \"Symbol\";\n    e.TimesNewRoman = \"Times-Roman\";\n    e[\"TimesNewRoman-Bold\"] = \"Times-Bold\";\n    e[\"TimesNewRoman-BoldItalic\"] = \"Times-BoldItalic\";\n    e[\"TimesNewRoman-Italic\"] = \"Times-Italic\";\n    e.TimesNewRomanPS = \"Times-Roman\";\n    e[\"TimesNewRomanPS-Bold\"] = \"Times-Bold\";\n    e[\"TimesNewRomanPS-BoldItalic\"] = \"Times-BoldItalic\";\n    e[\"TimesNewRomanPS-BoldItalicMT\"] = \"Times-BoldItalic\";\n    e[\"TimesNewRomanPS-BoldMT\"] = \"Times-Bold\";\n    e[\"TimesNewRomanPS-Italic\"] = \"Times-Italic\";\n    e[\"TimesNewRomanPS-ItalicMT\"] = \"Times-Italic\";\n    e.TimesNewRomanPSMT = \"Times-Roman\";\n    e[\"TimesNewRomanPSMT-Bold\"] = \"Times-Bold\";\n    e[\"TimesNewRomanPSMT-BoldItalic\"] = \"Times-BoldItalic\";\n    e[\"TimesNewRomanPSMT-Italic\"] = \"Times-Italic\";\n  }),\n  Wi = getLookupTableFactory(function (e) {\n    e.Courier = \"FoxitFixed.pfb\";\n    e[\"Courier-Bold\"] = \"FoxitFixedBold.pfb\";\n    e[\"Courier-BoldOblique\"] = \"FoxitFixedBoldItalic.pfb\";\n    e[\"Courier-Oblique\"] = \"FoxitFixedItalic.pfb\";\n    e.Helvetica = \"LiberationSans-Regular.ttf\";\n    e[\"Helvetica-Bold\"] = \"LiberationSans-Bold.ttf\";\n    e[\"Helvetica-BoldOblique\"] = \"LiberationSans-BoldItalic.ttf\";\n    e[\"Helvetica-Oblique\"] = \"LiberationSans-Italic.ttf\";\n    e[\"Times-Roman\"] = \"FoxitSerif.pfb\";\n    e[\"Times-Bold\"] = \"FoxitSerifBold.pfb\";\n    e[\"Times-BoldItalic\"] = \"FoxitSerifBoldItalic.pfb\";\n    e[\"Times-Italic\"] = \"FoxitSerifItalic.pfb\";\n    e.Symbol = \"FoxitSymbol.pfb\";\n    e.ZapfDingbats = \"FoxitDingbats.pfb\";\n    e[\"LiberationSans-Regular\"] = \"LiberationSans-Regular.ttf\";\n    e[\"LiberationSans-Bold\"] = \"LiberationSans-Bold.ttf\";\n    e[\"LiberationSans-Italic\"] = \"LiberationSans-Italic.ttf\";\n    e[\"LiberationSans-BoldItalic\"] = \"LiberationSans-BoldItalic.ttf\";\n  }),\n  ji = getLookupTableFactory(function (e) {\n    e.Calibri = \"Helvetica\";\n    e[\"Calibri-Bold\"] = \"Helvetica-Bold\";\n    e[\"Calibri-BoldItalic\"] = \"Helvetica-BoldOblique\";\n    e[\"Calibri-Italic\"] = \"Helvetica-Oblique\";\n    e.CenturyGothic = \"Helvetica\";\n    e[\"CenturyGothic-Bold\"] = \"Helvetica-Bold\";\n    e[\"CenturyGothic-BoldItalic\"] = \"Helvetica-BoldOblique\";\n    e[\"CenturyGothic-Italic\"] = \"Helvetica-Oblique\";\n    e.ComicSansMS = \"Comic Sans MS\";\n    e[\"ComicSansMS-Bold\"] = \"Comic Sans MS-Bold\";\n    e[\"ComicSansMS-BoldItalic\"] = \"Comic Sans MS-BoldItalic\";\n    e[\"ComicSansMS-Italic\"] = \"Comic Sans MS-Italic\";\n    e.Impact = \"Helvetica\";\n    e[\"ItcSymbol-Bold\"] = \"Helvetica-Bold\";\n    e[\"ItcSymbol-BoldItalic\"] = \"Helvetica-BoldOblique\";\n    e[\"ItcSymbol-Book\"] = \"Helvetica\";\n    e[\"ItcSymbol-BookItalic\"] = \"Helvetica-Oblique\";\n    e[\"ItcSymbol-Medium\"] = \"Helvetica\";\n    e[\"ItcSymbol-MediumItalic\"] = \"Helvetica-Oblique\";\n    e.LucidaConsole = \"Courier\";\n    e[\"LucidaConsole-Bold\"] = \"Courier-Bold\";\n    e[\"LucidaConsole-BoldItalic\"] = \"Courier-BoldOblique\";\n    e[\"LucidaConsole-Italic\"] = \"Courier-Oblique\";\n    e[\"LucidaSans-Demi\"] = \"Helvetica-Bold\";\n    e[\"MS-Gothic\"] = \"MS Gothic\";\n    e[\"MS-Gothic-Bold\"] = \"MS Gothic-Bold\";\n    e[\"MS-Gothic-BoldItalic\"] = \"MS Gothic-BoldItalic\";\n    e[\"MS-Gothic-Italic\"] = \"MS Gothic-Italic\";\n    e[\"MS-Mincho\"] = \"MS Mincho\";\n    e[\"MS-Mincho-Bold\"] = \"MS Mincho-Bold\";\n    e[\"MS-Mincho-BoldItalic\"] = \"MS Mincho-BoldItalic\";\n    e[\"MS-Mincho-Italic\"] = \"MS Mincho-Italic\";\n    e[\"MS-PGothic\"] = \"MS PGothic\";\n    e[\"MS-PGothic-Bold\"] = \"MS PGothic-Bold\";\n    e[\"MS-PGothic-BoldItalic\"] = \"MS PGothic-BoldItalic\";\n    e[\"MS-PGothic-Italic\"] = \"MS PGothic-Italic\";\n    e[\"MS-PMincho\"] = \"MS PMincho\";\n    e[\"MS-PMincho-Bold\"] = \"MS PMincho-Bold\";\n    e[\"MS-PMincho-BoldItalic\"] = \"MS PMincho-BoldItalic\";\n    e[\"MS-PMincho-Italic\"] = \"MS PMincho-Italic\";\n    e.NuptialScript = \"Times-Italic\";\n    e.SegoeUISymbol = \"Helvetica\";\n  }),\n  Xi = getLookupTableFactory(function (e) {\n    e[\"Adobe Jenson\"] = !0;\n    e[\"Adobe Text\"] = !0;\n    e.Albertus = !0;\n    e.Aldus = !0;\n    e.Alexandria = !0;\n    e.Algerian = !0;\n    e[\"American Typewriter\"] = !0;\n    e.Antiqua = !0;\n    e.Apex = !0;\n    e.Arno = !0;\n    e.Aster = !0;\n    e.Aurora = !0;\n    e.Baskerville = !0;\n    e.Bell = !0;\n    e.Bembo = !0;\n    e[\"Bembo Schoolbook\"] = !0;\n    e.Benguiat = !0;\n    e[\"Berkeley Old Style\"] = !0;\n    e[\"Bernhard Modern\"] = !0;\n    e[\"Berthold City\"] = !0;\n    e.Bodoni = !0;\n    e[\"Bauer Bodoni\"] = !0;\n    e[\"Book Antiqua\"] = !0;\n    e.Bookman = !0;\n    e[\"Bordeaux Roman\"] = !0;\n    e[\"Californian FB\"] = !0;\n    e.Calisto = !0;\n    e.Calvert = !0;\n    e.Capitals = !0;\n    e.Cambria = !0;\n    e.Cartier = !0;\n    e.Caslon = !0;\n    e.Catull = !0;\n    e.Centaur = !0;\n    e[\"Century Old Style\"] = !0;\n    e[\"Century Schoolbook\"] = !0;\n    e.Chaparral = !0;\n    e[\"Charis SIL\"] = !0;\n    e.Cheltenham = !0;\n    e[\"Cholla Slab\"] = !0;\n    e.Clarendon = !0;\n    e.Clearface = !0;\n    e.Cochin = !0;\n    e.Colonna = !0;\n    e[\"Computer Modern\"] = !0;\n    e[\"Concrete Roman\"] = !0;\n    e.Constantia = !0;\n    e[\"Cooper Black\"] = !0;\n    e.Corona = !0;\n    e.Ecotype = !0;\n    e.Egyptienne = !0;\n    e.Elephant = !0;\n    e.Excelsior = !0;\n    e.Fairfield = !0;\n    e[\"FF Scala\"] = !0;\n    e.Folkard = !0;\n    e.Footlight = !0;\n    e.FreeSerif = !0;\n    e[\"Friz Quadrata\"] = !0;\n    e.Garamond = !0;\n    e.Gentium = !0;\n    e.Georgia = !0;\n    e.Gloucester = !0;\n    e[\"Goudy Old Style\"] = !0;\n    e[\"Goudy Schoolbook\"] = !0;\n    e[\"Goudy Pro Font\"] = !0;\n    e.Granjon = !0;\n    e[\"Guardian Egyptian\"] = !0;\n    e.Heather = !0;\n    e.Hercules = !0;\n    e[\"High Tower Text\"] = !0;\n    e.Hiroshige = !0;\n    e[\"Hoefler Text\"] = !0;\n    e[\"Humana Serif\"] = !0;\n    e.Imprint = !0;\n    e[\"Ionic No. 5\"] = !0;\n    e.Janson = !0;\n    e.Joanna = !0;\n    e.Korinna = !0;\n    e.Lexicon = !0;\n    e.LiberationSerif = !0;\n    e[\"Liberation Serif\"] = !0;\n    e[\"Linux Libertine\"] = !0;\n    e.Literaturnaya = !0;\n    e.Lucida = !0;\n    e[\"Lucida Bright\"] = !0;\n    e.Melior = !0;\n    e.Memphis = !0;\n    e.Miller = !0;\n    e.Minion = !0;\n    e.Modern = !0;\n    e[\"Mona Lisa\"] = !0;\n    e[\"Mrs Eaves\"] = !0;\n    e[\"MS Serif\"] = !0;\n    e[\"Museo Slab\"] = !0;\n    e[\"New York\"] = !0;\n    e[\"Nimbus Roman\"] = !0;\n    e[\"NPS Rawlinson Roadway\"] = !0;\n    e.NuptialScript = !0;\n    e.Palatino = !0;\n    e.Perpetua = !0;\n    e.Plantin = !0;\n    e[\"Plantin Schoolbook\"] = !0;\n    e.Playbill = !0;\n    e[\"Poor Richard\"] = !0;\n    e[\"Rawlinson Roadway\"] = !0;\n    e.Renault = !0;\n    e.Requiem = !0;\n    e.Rockwell = !0;\n    e.Roman = !0;\n    e[\"Rotis Serif\"] = !0;\n    e.Sabon = !0;\n    e.Scala = !0;\n    e.Seagull = !0;\n    e.Sistina = !0;\n    e.Souvenir = !0;\n    e.STIX = !0;\n    e[\"Stone Informal\"] = !0;\n    e[\"Stone Serif\"] = !0;\n    e.Sylfaen = !0;\n    e.Times = !0;\n    e.Trajan = !0;\n    e[\"Trinité\"] = !0;\n    e[\"Trump Mediaeval\"] = !0;\n    e.Utopia = !0;\n    e[\"Vale Type\"] = !0;\n    e[\"Bitstream Vera\"] = !0;\n    e[\"Vera Serif\"] = !0;\n    e.Versailles = !0;\n    e.Wanted = !0;\n    e.Weiss = !0;\n    e[\"Wide Latin\"] = !0;\n    e.Windsor = !0;\n    e.XITS = !0;\n  }),\n  Zi = getLookupTableFactory(function (e) {\n    e.Dingbats = !0;\n    e.Symbol = !0;\n    e.ZapfDingbats = !0;\n    e.Wingdings = !0;\n    e[\"Wingdings-Bold\"] = !0;\n    e[\"Wingdings-Regular\"] = !0;\n  }),\n  Vi = getLookupTableFactory(function (e) {\n    e[2] = 10;\n    e[3] = 32;\n    e[4] = 33;\n    e[5] = 34;\n    e[6] = 35;\n    e[7] = 36;\n    e[8] = 37;\n    e[9] = 38;\n    e[10] = 39;\n    e[11] = 40;\n    e[12] = 41;\n    e[13] = 42;\n    e[14] = 43;\n    e[15] = 44;\n    e[16] = 45;\n    e[17] = 46;\n    e[18] = 47;\n    e[19] = 48;\n    e[20] = 49;\n    e[21] = 50;\n    e[22] = 51;\n    e[23] = 52;\n    e[24] = 53;\n    e[25] = 54;\n    e[26] = 55;\n    e[27] = 56;\n    e[28] = 57;\n    e[29] = 58;\n    e[30] = 894;\n    e[31] = 60;\n    e[32] = 61;\n    e[33] = 62;\n    e[34] = 63;\n    e[35] = 64;\n    e[36] = 65;\n    e[37] = 66;\n    e[38] = 67;\n    e[39] = 68;\n    e[40] = 69;\n    e[41] = 70;\n    e[42] = 71;\n    e[43] = 72;\n    e[44] = 73;\n    e[45] = 74;\n    e[46] = 75;\n    e[47] = 76;\n    e[48] = 77;\n    e[49] = 78;\n    e[50] = 79;\n    e[51] = 80;\n    e[52] = 81;\n    e[53] = 82;\n    e[54] = 83;\n    e[55] = 84;\n    e[56] = 85;\n    e[57] = 86;\n    e[58] = 87;\n    e[59] = 88;\n    e[60] = 89;\n    e[61] = 90;\n    e[62] = 91;\n    e[63] = 92;\n    e[64] = 93;\n    e[65] = 94;\n    e[66] = 95;\n    e[67] = 96;\n    e[68] = 97;\n    e[69] = 98;\n    e[70] = 99;\n    e[71] = 100;\n    e[72] = 101;\n    e[73] = 102;\n    e[74] = 103;\n    e[75] = 104;\n    e[76] = 105;\n    e[77] = 106;\n    e[78] = 107;\n    e[79] = 108;\n    e[80] = 109;\n    e[81] = 110;\n    e[82] = 111;\n    e[83] = 112;\n    e[84] = 113;\n    e[85] = 114;\n    e[86] = 115;\n    e[87] = 116;\n    e[88] = 117;\n    e[89] = 118;\n    e[90] = 119;\n    e[91] = 120;\n    e[92] = 121;\n    e[93] = 122;\n    e[94] = 123;\n    e[95] = 124;\n    e[96] = 125;\n    e[97] = 126;\n    e[98] = 196;\n    e[99] = 197;\n    e[100] = 199;\n    e[101] = 201;\n    e[102] = 209;\n    e[103] = 214;\n    e[104] = 220;\n    e[105] = 225;\n    e[106] = 224;\n    e[107] = 226;\n    e[108] = 228;\n    e[109] = 227;\n    e[110] = 229;\n    e[111] = 231;\n    e[112] = 233;\n    e[113] = 232;\n    e[114] = 234;\n    e[115] = 235;\n    e[116] = 237;\n    e[117] = 236;\n    e[118] = 238;\n    e[119] = 239;\n    e[120] = 241;\n    e[121] = 243;\n    e[122] = 242;\n    e[123] = 244;\n    e[124] = 246;\n    e[125] = 245;\n    e[126] = 250;\n    e[127] = 249;\n    e[128] = 251;\n    e[129] = 252;\n    e[130] = 8224;\n    e[131] = 176;\n    e[132] = 162;\n    e[133] = 163;\n    e[134] = 167;\n    e[135] = 8226;\n    e[136] = 182;\n    e[137] = 223;\n    e[138] = 174;\n    e[139] = 169;\n    e[140] = 8482;\n    e[141] = 180;\n    e[142] = 168;\n    e[143] = 8800;\n    e[144] = 198;\n    e[145] = 216;\n    e[146] = 8734;\n    e[147] = 177;\n    e[148] = 8804;\n    e[149] = 8805;\n    e[150] = 165;\n    e[151] = 181;\n    e[152] = 8706;\n    e[153] = 8721;\n    e[154] = 8719;\n    e[156] = 8747;\n    e[157] = 170;\n    e[158] = 186;\n    e[159] = 8486;\n    e[160] = 230;\n    e[161] = 248;\n    e[162] = 191;\n    e[163] = 161;\n    e[164] = 172;\n    e[165] = 8730;\n    e[166] = 402;\n    e[167] = 8776;\n    e[168] = 8710;\n    e[169] = 171;\n    e[170] = 187;\n    e[171] = 8230;\n    e[179] = 8220;\n    e[180] = 8221;\n    e[181] = 8216;\n    e[182] = 8217;\n    e[200] = 193;\n    e[203] = 205;\n    e[207] = 211;\n    e[210] = 218;\n    e[223] = 711;\n    e[224] = 321;\n    e[225] = 322;\n    e[226] = 352;\n    e[227] = 353;\n    e[228] = 381;\n    e[229] = 382;\n    e[233] = 221;\n    e[234] = 253;\n    e[252] = 263;\n    e[253] = 268;\n    e[254] = 269;\n    e[258] = 258;\n    e[260] = 260;\n    e[261] = 261;\n    e[265] = 280;\n    e[266] = 281;\n    e[267] = 282;\n    e[268] = 283;\n    e[269] = 313;\n    e[275] = 323;\n    e[276] = 324;\n    e[278] = 328;\n    e[283] = 344;\n    e[284] = 345;\n    e[285] = 346;\n    e[286] = 347;\n    e[292] = 367;\n    e[295] = 377;\n    e[296] = 378;\n    e[298] = 380;\n    e[305] = 963;\n    e[306] = 964;\n    e[307] = 966;\n    e[308] = 8215;\n    e[309] = 8252;\n    e[310] = 8319;\n    e[311] = 8359;\n    e[312] = 8592;\n    e[313] = 8593;\n    e[337] = 9552;\n    e[493] = 1039;\n    e[494] = 1040;\n    e[672] = 1488;\n    e[673] = 1489;\n    e[674] = 1490;\n    e[675] = 1491;\n    e[676] = 1492;\n    e[677] = 1493;\n    e[678] = 1494;\n    e[679] = 1495;\n    e[680] = 1496;\n    e[681] = 1497;\n    e[682] = 1498;\n    e[683] = 1499;\n    e[684] = 1500;\n    e[685] = 1501;\n    e[686] = 1502;\n    e[687] = 1503;\n    e[688] = 1504;\n    e[689] = 1505;\n    e[690] = 1506;\n    e[691] = 1507;\n    e[692] = 1508;\n    e[693] = 1509;\n    e[694] = 1510;\n    e[695] = 1511;\n    e[696] = 1512;\n    e[697] = 1513;\n    e[698] = 1514;\n    e[705] = 1524;\n    e[706] = 8362;\n    e[710] = 64288;\n    e[711] = 64298;\n    e[759] = 1617;\n    e[761] = 1776;\n    e[763] = 1778;\n    e[775] = 1652;\n    e[777] = 1764;\n    e[778] = 1780;\n    e[779] = 1781;\n    e[780] = 1782;\n    e[782] = 771;\n    e[783] = 64726;\n    e[786] = 8363;\n    e[788] = 8532;\n    e[790] = 768;\n    e[791] = 769;\n    e[792] = 768;\n    e[795] = 803;\n    e[797] = 64336;\n    e[798] = 64337;\n    e[799] = 64342;\n    e[800] = 64343;\n    e[801] = 64344;\n    e[802] = 64345;\n    e[803] = 64362;\n    e[804] = 64363;\n    e[805] = 64364;\n    e[2424] = 7821;\n    e[2425] = 7822;\n    e[2426] = 7823;\n    e[2427] = 7824;\n    e[2428] = 7825;\n    e[2429] = 7826;\n    e[2430] = 7827;\n    e[2433] = 7682;\n    e[2678] = 8045;\n    e[2679] = 8046;\n    e[2830] = 1552;\n    e[2838] = 686;\n    e[2840] = 751;\n    e[2842] = 753;\n    e[2843] = 754;\n    e[2844] = 755;\n    e[2846] = 757;\n    e[2856] = 767;\n    e[2857] = 848;\n    e[2858] = 849;\n    e[2862] = 853;\n    e[2863] = 854;\n    e[2864] = 855;\n    e[2865] = 861;\n    e[2866] = 862;\n    e[2906] = 7460;\n    e[2908] = 7462;\n    e[2909] = 7463;\n    e[2910] = 7464;\n    e[2912] = 7466;\n    e[2913] = 7467;\n    e[2914] = 7468;\n    e[2916] = 7470;\n    e[2917] = 7471;\n    e[2918] = 7472;\n    e[2920] = 7474;\n    e[2921] = 7475;\n    e[2922] = 7476;\n    e[2924] = 7478;\n    e[2925] = 7479;\n    e[2926] = 7480;\n    e[2928] = 7482;\n    e[2929] = 7483;\n    e[2930] = 7484;\n    e[2932] = 7486;\n    e[2933] = 7487;\n    e[2934] = 7488;\n    e[2936] = 7490;\n    e[2937] = 7491;\n    e[2938] = 7492;\n    e[2940] = 7494;\n    e[2941] = 7495;\n    e[2942] = 7496;\n    e[2944] = 7498;\n    e[2946] = 7500;\n    e[2948] = 7502;\n    e[2950] = 7504;\n    e[2951] = 7505;\n    e[2952] = 7506;\n    e[2954] = 7508;\n    e[2955] = 7509;\n    e[2956] = 7510;\n    e[2958] = 7512;\n    e[2959] = 7513;\n    e[2960] = 7514;\n    e[2962] = 7516;\n    e[2963] = 7517;\n    e[2964] = 7518;\n    e[2966] = 7520;\n    e[2967] = 7521;\n    e[2968] = 7522;\n    e[2970] = 7524;\n    e[2971] = 7525;\n    e[2972] = 7526;\n    e[2974] = 7528;\n    e[2975] = 7529;\n    e[2976] = 7530;\n    e[2978] = 1537;\n    e[2979] = 1538;\n    e[2980] = 1539;\n    e[2982] = 1549;\n    e[2983] = 1551;\n    e[2984] = 1552;\n    e[2986] = 1554;\n    e[2987] = 1555;\n    e[2988] = 1556;\n    e[2990] = 1623;\n    e[2991] = 1624;\n    e[2995] = 1775;\n    e[2999] = 1791;\n    e[3002] = 64290;\n    e[3003] = 64291;\n    e[3004] = 64292;\n    e[3006] = 64294;\n    e[3007] = 64295;\n    e[3008] = 64296;\n    e[3011] = 1900;\n    e[3014] = 8223;\n    e[3015] = 8244;\n    e[3017] = 7532;\n    e[3018] = 7533;\n    e[3019] = 7534;\n    e[3075] = 7590;\n    e[3076] = 7591;\n    e[3079] = 7594;\n    e[3080] = 7595;\n    e[3083] = 7598;\n    e[3084] = 7599;\n    e[3087] = 7602;\n    e[3088] = 7603;\n    e[3091] = 7606;\n    e[3092] = 7607;\n    e[3095] = 7610;\n    e[3096] = 7611;\n    e[3099] = 7614;\n    e[3100] = 7615;\n    e[3103] = 7618;\n    e[3104] = 7619;\n    e[3107] = 8337;\n    e[3108] = 8338;\n    e[3116] = 1884;\n    e[3119] = 1885;\n    e[3120] = 1885;\n    e[3123] = 1886;\n    e[3124] = 1886;\n    e[3127] = 1887;\n    e[3128] = 1887;\n    e[3131] = 1888;\n    e[3132] = 1888;\n    e[3135] = 1889;\n    e[3136] = 1889;\n    e[3139] = 1890;\n    e[3140] = 1890;\n    e[3143] = 1891;\n    e[3144] = 1891;\n    e[3147] = 1892;\n    e[3148] = 1892;\n    e[3153] = 580;\n    e[3154] = 581;\n    e[3157] = 584;\n    e[3158] = 585;\n    e[3161] = 588;\n    e[3162] = 589;\n    e[3165] = 891;\n    e[3166] = 892;\n    e[3169] = 1274;\n    e[3170] = 1275;\n    e[3173] = 1278;\n    e[3174] = 1279;\n    e[3181] = 7622;\n    e[3182] = 7623;\n    e[3282] = 11799;\n    e[3316] = 578;\n    e[3379] = 42785;\n    e[3393] = 1159;\n    e[3416] = 8377;\n  }),\n  zi = getLookupTableFactory(function (e) {\n    e[227] = 322;\n    e[264] = 261;\n    e[291] = 346;\n  }),\n  _i = getLookupTableFactory(function (e) {\n    e[1] = 32;\n    e[4] = 65;\n    e[5] = 192;\n    e[6] = 193;\n    e[9] = 196;\n    e[17] = 66;\n    e[18] = 67;\n    e[21] = 268;\n    e[24] = 68;\n    e[28] = 69;\n    e[29] = 200;\n    e[30] = 201;\n    e[32] = 282;\n    e[38] = 70;\n    e[39] = 71;\n    e[44] = 72;\n    e[47] = 73;\n    e[48] = 204;\n    e[49] = 205;\n    e[58] = 74;\n    e[60] = 75;\n    e[62] = 76;\n    e[68] = 77;\n    e[69] = 78;\n    e[75] = 79;\n    e[76] = 210;\n    e[80] = 214;\n    e[87] = 80;\n    e[89] = 81;\n    e[90] = 82;\n    e[92] = 344;\n    e[94] = 83;\n    e[97] = 352;\n    e[100] = 84;\n    e[104] = 85;\n    e[109] = 220;\n    e[115] = 86;\n    e[116] = 87;\n    e[121] = 88;\n    e[122] = 89;\n    e[124] = 221;\n    e[127] = 90;\n    e[129] = 381;\n    e[258] = 97;\n    e[259] = 224;\n    e[260] = 225;\n    e[263] = 228;\n    e[268] = 261;\n    e[271] = 98;\n    e[272] = 99;\n    e[273] = 263;\n    e[275] = 269;\n    e[282] = 100;\n    e[286] = 101;\n    e[287] = 232;\n    e[288] = 233;\n    e[290] = 283;\n    e[295] = 281;\n    e[296] = 102;\n    e[336] = 103;\n    e[346] = 104;\n    e[349] = 105;\n    e[350] = 236;\n    e[351] = 237;\n    e[361] = 106;\n    e[364] = 107;\n    e[367] = 108;\n    e[371] = 322;\n    e[373] = 109;\n    e[374] = 110;\n    e[381] = 111;\n    e[382] = 242;\n    e[383] = 243;\n    e[386] = 246;\n    e[393] = 112;\n    e[395] = 113;\n    e[396] = 114;\n    e[398] = 345;\n    e[400] = 115;\n    e[401] = 347;\n    e[403] = 353;\n    e[410] = 116;\n    e[437] = 117;\n    e[442] = 252;\n    e[448] = 118;\n    e[449] = 119;\n    e[454] = 120;\n    e[455] = 121;\n    e[457] = 253;\n    e[460] = 122;\n    e[462] = 382;\n    e[463] = 380;\n    e[853] = 44;\n    e[855] = 58;\n    e[856] = 46;\n    e[876] = 47;\n    e[878] = 45;\n    e[882] = 45;\n    e[894] = 40;\n    e[895] = 41;\n    e[896] = 91;\n    e[897] = 93;\n    e[923] = 64;\n    e[1004] = 48;\n    e[1005] = 49;\n    e[1006] = 50;\n    e[1007] = 51;\n    e[1008] = 52;\n    e[1009] = 53;\n    e[1010] = 54;\n    e[1011] = 55;\n    e[1012] = 56;\n    e[1013] = 57;\n    e[1081] = 37;\n    e[1085] = 43;\n    e[1086] = 45;\n  });\nfunction getStandardFontName(e) {\n  const t = normalizeFontName(e);\n  return Pi()[t];\n}\nfunction isKnownFontName(e) {\n  const t = normalizeFontName(e);\n  return !!(Pi()[t] || ji()[t] || Xi()[t] || Zi()[t]);\n}\nclass ToUnicodeMap {\n  constructor(e = []) {\n    this._map = e;\n  }\n  get length() {\n    return this._map.length;\n  }\n  forEach(e) {\n    for (const t in this._map) e(t, this._map[t].charCodeAt(0));\n  }\n  has(e) {\n    return void 0 !== this._map[e];\n  }\n  get(e) {\n    return this._map[e];\n  }\n  charCodeOf(e) {\n    const t = this._map;\n    if (t.length <= 65536) return t.indexOf(e);\n    for (const i in t) if (t[i] === e) return 0 | i;\n    return -1;\n  }\n  amend(e) {\n    for (const t in e) this._map[t] = e[t];\n  }\n}\nclass IdentityToUnicodeMap {\n  constructor(e, t) {\n    this.firstChar = e;\n    this.lastChar = t;\n  }\n  get length() {\n    return this.lastChar + 1 - this.firstChar;\n  }\n  forEach(e) {\n    for (let t = this.firstChar, i = this.lastChar; t <= i; t++) e(t, t);\n  }\n  has(e) {\n    return this.firstChar <= e && e <= this.lastChar;\n  }\n  get(e) {\n    if (this.firstChar <= e && e <= this.lastChar) return String.fromCharCode(e);\n  }\n  charCodeOf(e) {\n    return Number.isInteger(e) && e >= this.firstChar && e <= this.lastChar ? e : -1;\n  }\n  amend(e) {\n    unreachable(\"Should not call amend()\");\n  }\n}\nclass CFFFont {\n  constructor(e, t) {\n    this.properties = t;\n    const i = new CFFParser(e, t, Yi);\n    this.cff = i.parse();\n    this.cff.duplicateFirstGlyph();\n    const a = new CFFCompiler(this.cff);\n    this.seacs = this.cff.seacs;\n    try {\n      this.data = a.compile();\n    } catch {\n      warn(\"Failed to compile font \" + t.loadedName);\n      this.data = e;\n    }\n    this._createBuiltInEncoding();\n  }\n  get numGlyphs() {\n    return this.cff.charStrings.count;\n  }\n  getCharset() {\n    return this.cff.charset.charset;\n  }\n  getGlyphMapping() {\n    const e = this.cff,\n      t = this.properties,\n      {\n        cidToGidMap: i,\n        cMap: a\n      } = t,\n      s = e.charset.charset;\n    let r, n;\n    if (t.composite) {\n      let t, g;\n      if (i?.length > 0) {\n        t = Object.create(null);\n        for (let e = 0, a = i.length; e < a; e++) {\n          const a = i[e];\n          void 0 !== a && (t[a] = e);\n        }\n      }\n      r = Object.create(null);\n      if (e.isCIDFont) for (n = 0; n < s.length; n++) {\n        const e = s[n];\n        g = a.charCodeOf(e);\n        void 0 !== t?.[g] && (g = t[g]);\n        r[g] = n;\n      } else for (n = 0; n < e.charStrings.count; n++) {\n        g = a.charCodeOf(n);\n        r[g] = n;\n      }\n      return r;\n    }\n    let g = e.encoding ? e.encoding.encoding : null;\n    t.isInternalFont && (g = t.defaultEncoding);\n    r = type1FontGlyphMapping(t, g, s);\n    return r;\n  }\n  hasGlyphId(e) {\n    return this.cff.hasGlyphId(e);\n  }\n  _createBuiltInEncoding() {\n    const {\n      charset: e,\n      encoding: t\n    } = this.cff;\n    if (!e || !t) return;\n    const i = e.charset,\n      a = t.encoding,\n      s = [];\n    for (const e in a) {\n      const t = a[e];\n      if (t >= 0) {\n        const a = i[t];\n        a && (s[e] = a);\n      }\n    }\n    s.length > 0 && (this.properties.builtInEncoding = s);\n  }\n}\nfunction getUint32(e, t) {\n  return (e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]) >>> 0;\n}\nfunction getUint16(e, t) {\n  return e[t] << 8 | e[t + 1];\n}\nfunction getInt16(e, t) {\n  return (e[t] << 24 | e[t + 1] << 16) >> 16;\n}\nfunction getInt8(e, t) {\n  return e[t] << 24 >> 24;\n}\nfunction getFloat214(e, t) {\n  return getInt16(e, t) / 16384;\n}\nfunction getSubroutineBias(e) {\n  const t = e.length;\n  let i = 32768;\n  t < 1240 ? i = 107 : t < 33900 && (i = 1131);\n  return i;\n}\nfunction parseCmap(e, t, i) {\n  const a = 1 === getUint16(e, t + 2) ? getUint32(e, t + 8) : getUint32(e, t + 16),\n    s = getUint16(e, t + a);\n  let r, n, g;\n  if (4 === s) {\n    getUint16(e, t + a + 2);\n    const i = getUint16(e, t + a + 6) >> 1;\n    n = t + a + 14;\n    r = [];\n    for (g = 0; g < i; g++, n += 2) r[g] = {\n      end: getUint16(e, n)\n    };\n    n += 2;\n    for (g = 0; g < i; g++, n += 2) r[g].start = getUint16(e, n);\n    for (g = 0; g < i; g++, n += 2) r[g].idDelta = getUint16(e, n);\n    for (g = 0; g < i; g++, n += 2) {\n      let t = getUint16(e, n);\n      if (0 !== t) {\n        r[g].ids = [];\n        for (let i = 0, a = r[g].end - r[g].start + 1; i < a; i++) {\n          r[g].ids[i] = getUint16(e, n + t);\n          t += 2;\n        }\n      }\n    }\n    return r;\n  }\n  if (12 === s) {\n    const i = getUint32(e, t + a + 12);\n    n = t + a + 16;\n    r = [];\n    for (g = 0; g < i; g++) {\n      t = getUint32(e, n);\n      r.push({\n        start: t,\n        end: getUint32(e, n + 4),\n        idDelta: getUint32(e, n + 8) - t\n      });\n      n += 12;\n    }\n    return r;\n  }\n  throw new FormatError(`unsupported cmap: ${s}`);\n}\nfunction parseCff(e, t, i, a) {\n  const s = new CFFParser(new Stream(e, t, i - t), {}, a).parse();\n  return {\n    glyphs: s.charStrings.objects,\n    subrs: s.topDict.privateDict?.subrsIndex?.objects,\n    gsubrs: s.globalSubrIndex?.objects,\n    isCFFCIDFont: s.isCIDFont,\n    fdSelect: s.fdSelect,\n    fdArray: s.fdArray\n  };\n}\nfunction lookupCmap(e, t) {\n  const i = t.codePointAt(0);\n  let a = 0,\n    s = 0,\n    r = e.length - 1;\n  for (; s < r;) {\n    const t = s + r + 1 >> 1;\n    i < e[t].start ? r = t - 1 : s = t;\n  }\n  e[s].start <= i && i <= e[s].end && (a = e[s].idDelta + (e[s].ids ? e[s].ids[i - e[s].start] : i) & 65535);\n  return {\n    charCode: i,\n    glyphId: a\n  };\n}\nfunction compileGlyf(e, t, i) {\n  function moveTo(e, i) {\n    t.add(Ct, [e, i]);\n  }\n  function lineTo(e, i) {\n    t.add(ht, [e, i]);\n  }\n  function quadraticCurveTo(e, i, a, s) {\n    t.add(Bt, [e, i, a, s]);\n  }\n  let a = 0;\n  const s = getInt16(e, a);\n  let r,\n    n = 0,\n    g = 0;\n  a += 10;\n  if (s < 0) do {\n    r = getUint16(e, a);\n    const s = getUint16(e, a + 2);\n    a += 4;\n    let o, c;\n    if (1 & r) {\n      if (2 & r) {\n        o = getInt16(e, a);\n        c = getInt16(e, a + 2);\n      } else {\n        o = getUint16(e, a);\n        c = getUint16(e, a + 2);\n      }\n      a += 4;\n    } else if (2 & r) {\n      o = getInt8(e, a++);\n      c = getInt8(e, a++);\n    } else {\n      o = e[a++];\n      c = e[a++];\n    }\n    if (2 & r) {\n      n = o;\n      g = c;\n    } else {\n      n = 0;\n      g = 0;\n    }\n    let C = 1,\n      h = 1,\n      l = 0,\n      Q = 0;\n    if (8 & r) {\n      C = h = getFloat214(e, a);\n      a += 2;\n    } else if (64 & r) {\n      C = getFloat214(e, a);\n      h = getFloat214(e, a + 2);\n      a += 4;\n    } else if (128 & r) {\n      C = getFloat214(e, a);\n      l = getFloat214(e, a + 2);\n      Q = getFloat214(e, a + 4);\n      h = getFloat214(e, a + 6);\n      a += 8;\n    }\n    const E = i.glyphs[s];\n    if (E) {\n      t.add(Qt);\n      t.add(ut, [C, l, Q, h, n, g]);\n      compileGlyf(E, t, i);\n      t.add(lt);\n    }\n  } while (32 & r);else {\n    const t = [];\n    let i, o;\n    for (i = 0; i < s; i++) {\n      t.push(getUint16(e, a));\n      a += 2;\n    }\n    a += 2 + getUint16(e, a);\n    const c = t.at(-1) + 1,\n      C = [];\n    for (; C.length < c;) {\n      r = e[a++];\n      let t = 1;\n      8 & r && (t += e[a++]);\n      for (; t-- > 0;) C.push({\n        flags: r\n      });\n    }\n    for (i = 0; i < c; i++) {\n      switch (18 & C[i].flags) {\n        case 0:\n          n += getInt16(e, a);\n          a += 2;\n          break;\n        case 2:\n          n -= e[a++];\n          break;\n        case 18:\n          n += e[a++];\n      }\n      C[i].x = n;\n    }\n    for (i = 0; i < c; i++) {\n      switch (36 & C[i].flags) {\n        case 0:\n          g += getInt16(e, a);\n          a += 2;\n          break;\n        case 4:\n          g -= e[a++];\n          break;\n        case 36:\n          g += e[a++];\n      }\n      C[i].y = g;\n    }\n    let h = 0;\n    for (a = 0; a < s; a++) {\n      const e = t[a],\n        s = C.slice(h, e + 1);\n      if (1 & s[0].flags) s.push(s[0]);else if (1 & s.at(-1).flags) s.unshift(s.at(-1));else {\n        const e = {\n          flags: 1,\n          x: (s[0].x + s.at(-1).x) / 2,\n          y: (s[0].y + s.at(-1).y) / 2\n        };\n        s.unshift(e);\n        s.push(e);\n      }\n      moveTo(s[0].x, s[0].y);\n      for (i = 1, o = s.length; i < o; i++) if (1 & s[i].flags) lineTo(s[i].x, s[i].y);else if (1 & s[i + 1].flags) {\n        quadraticCurveTo(s[i].x, s[i].y, s[i + 1].x, s[i + 1].y);\n        i++;\n      } else quadraticCurveTo(s[i].x, s[i].y, (s[i].x + s[i + 1].x) / 2, (s[i].y + s[i + 1].y) / 2);\n      h = e + 1;\n    }\n  }\n}\nfunction compileCharString(e, t, i, a) {\n  function moveTo(e, i) {\n    t.add(Ct, [e, i]);\n  }\n  function lineTo(e, i) {\n    t.add(ht, [e, i]);\n  }\n  function bezierCurveTo(e, i, a, s, r, n) {\n    t.add(ct, [e, i, a, s, r, n]);\n  }\n  const s = [];\n  let r = 0,\n    n = 0,\n    g = 0;\n  !function parse(e) {\n    let o = 0;\n    for (; o < e.length;) {\n      let c,\n        C,\n        h,\n        l,\n        Q,\n        E,\n        u,\n        d,\n        f,\n        p = !1,\n        m = e[o++];\n      switch (m) {\n        case 1:\n        case 3:\n        case 18:\n        case 23:\n          g += s.length >> 1;\n          p = !0;\n          break;\n        case 4:\n          n += s.pop();\n          moveTo(r, n);\n          p = !0;\n          break;\n        case 5:\n          for (; s.length > 0;) {\n            r += s.shift();\n            n += s.shift();\n            lineTo(r, n);\n          }\n          break;\n        case 6:\n          for (; s.length > 0;) {\n            r += s.shift();\n            lineTo(r, n);\n            if (0 === s.length) break;\n            n += s.shift();\n            lineTo(r, n);\n          }\n          break;\n        case 7:\n          for (; s.length > 0;) {\n            n += s.shift();\n            lineTo(r, n);\n            if (0 === s.length) break;\n            r += s.shift();\n            lineTo(r, n);\n          }\n          break;\n        case 8:\n          for (; s.length > 0;) {\n            c = r + s.shift();\n            h = n + s.shift();\n            C = c + s.shift();\n            l = h + s.shift();\n            r = C + s.shift();\n            n = l + s.shift();\n            bezierCurveTo(c, h, C, l, r, n);\n          }\n          break;\n        case 10:\n          d = s.pop();\n          f = null;\n          if (i.isCFFCIDFont) {\n            const e = i.fdSelect.getFDIndex(a);\n            if (e >= 0 && e < i.fdArray.length) {\n              const t = i.fdArray[e];\n              let a;\n              t.privateDict?.subrsIndex && (a = t.privateDict.subrsIndex.objects);\n              if (a) {\n                d += getSubroutineBias(a);\n                f = a[d];\n              }\n            } else warn(\"Invalid fd index for glyph index.\");\n          } else f = i.subrs[d + i.subrsBias];\n          f && parse(f);\n          break;\n        case 11:\n          return;\n        case 12:\n          m = e[o++];\n          switch (m) {\n            case 34:\n              c = r + s.shift();\n              C = c + s.shift();\n              Q = n + s.shift();\n              r = C + s.shift();\n              bezierCurveTo(c, n, C, Q, r, Q);\n              c = r + s.shift();\n              C = c + s.shift();\n              r = C + s.shift();\n              bezierCurveTo(c, Q, C, n, r, n);\n              break;\n            case 35:\n              c = r + s.shift();\n              h = n + s.shift();\n              C = c + s.shift();\n              l = h + s.shift();\n              r = C + s.shift();\n              n = l + s.shift();\n              bezierCurveTo(c, h, C, l, r, n);\n              c = r + s.shift();\n              h = n + s.shift();\n              C = c + s.shift();\n              l = h + s.shift();\n              r = C + s.shift();\n              n = l + s.shift();\n              bezierCurveTo(c, h, C, l, r, n);\n              s.pop();\n              break;\n            case 36:\n              c = r + s.shift();\n              Q = n + s.shift();\n              C = c + s.shift();\n              E = Q + s.shift();\n              r = C + s.shift();\n              bezierCurveTo(c, Q, C, E, r, E);\n              c = r + s.shift();\n              C = c + s.shift();\n              u = E + s.shift();\n              r = C + s.shift();\n              bezierCurveTo(c, E, C, u, r, n);\n              break;\n            case 37:\n              const e = r,\n                t = n;\n              c = r + s.shift();\n              h = n + s.shift();\n              C = c + s.shift();\n              l = h + s.shift();\n              r = C + s.shift();\n              n = l + s.shift();\n              bezierCurveTo(c, h, C, l, r, n);\n              c = r + s.shift();\n              h = n + s.shift();\n              C = c + s.shift();\n              l = h + s.shift();\n              r = C;\n              n = l;\n              Math.abs(r - e) > Math.abs(n - t) ? r += s.shift() : n += s.shift();\n              bezierCurveTo(c, h, C, l, r, n);\n              break;\n            default:\n              throw new FormatError(`unknown operator: 12 ${m}`);\n          }\n          break;\n        case 14:\n          if (s.length >= 4) {\n            const e = s.pop(),\n              a = s.pop();\n            n = s.pop();\n            r = s.pop();\n            t.add(Qt);\n            t.add(dt, [r, n]);\n            let g = lookupCmap(i.cmap, String.fromCharCode(i.glyphNameMap[fi[e]]));\n            compileCharString(i.glyphs[g.glyphId], t, i, g.glyphId);\n            t.add(lt);\n            g = lookupCmap(i.cmap, String.fromCharCode(i.glyphNameMap[fi[a]]));\n            compileCharString(i.glyphs[g.glyphId], t, i, g.glyphId);\n          }\n          return;\n        case 19:\n        case 20:\n          g += s.length >> 1;\n          o += g + 7 >> 3;\n          p = !0;\n          break;\n        case 21:\n          n += s.pop();\n          r += s.pop();\n          moveTo(r, n);\n          p = !0;\n          break;\n        case 22:\n          r += s.pop();\n          moveTo(r, n);\n          p = !0;\n          break;\n        case 24:\n          for (; s.length > 2;) {\n            c = r + s.shift();\n            h = n + s.shift();\n            C = c + s.shift();\n            l = h + s.shift();\n            r = C + s.shift();\n            n = l + s.shift();\n            bezierCurveTo(c, h, C, l, r, n);\n          }\n          r += s.shift();\n          n += s.shift();\n          lineTo(r, n);\n          break;\n        case 25:\n          for (; s.length > 6;) {\n            r += s.shift();\n            n += s.shift();\n            lineTo(r, n);\n          }\n          c = r + s.shift();\n          h = n + s.shift();\n          C = c + s.shift();\n          l = h + s.shift();\n          r = C + s.shift();\n          n = l + s.shift();\n          bezierCurveTo(c, h, C, l, r, n);\n          break;\n        case 26:\n          s.length % 2 && (r += s.shift());\n          for (; s.length > 0;) {\n            c = r;\n            h = n + s.shift();\n            C = c + s.shift();\n            l = h + s.shift();\n            r = C;\n            n = l + s.shift();\n            bezierCurveTo(c, h, C, l, r, n);\n          }\n          break;\n        case 27:\n          s.length % 2 && (n += s.shift());\n          for (; s.length > 0;) {\n            c = r + s.shift();\n            h = n;\n            C = c + s.shift();\n            l = h + s.shift();\n            r = C + s.shift();\n            n = l;\n            bezierCurveTo(c, h, C, l, r, n);\n          }\n          break;\n        case 28:\n          s.push((e[o] << 24 | e[o + 1] << 16) >> 16);\n          o += 2;\n          break;\n        case 29:\n          d = s.pop() + i.gsubrsBias;\n          f = i.gsubrs[d];\n          f && parse(f);\n          break;\n        case 30:\n          for (; s.length > 0;) {\n            c = r;\n            h = n + s.shift();\n            C = c + s.shift();\n            l = h + s.shift();\n            r = C + s.shift();\n            n = l + (1 === s.length ? s.shift() : 0);\n            bezierCurveTo(c, h, C, l, r, n);\n            if (0 === s.length) break;\n            c = r + s.shift();\n            h = n;\n            C = c + s.shift();\n            l = h + s.shift();\n            n = l + s.shift();\n            r = C + (1 === s.length ? s.shift() : 0);\n            bezierCurveTo(c, h, C, l, r, n);\n          }\n          break;\n        case 31:\n          for (; s.length > 0;) {\n            c = r + s.shift();\n            h = n;\n            C = c + s.shift();\n            l = h + s.shift();\n            n = l + s.shift();\n            r = C + (1 === s.length ? s.shift() : 0);\n            bezierCurveTo(c, h, C, l, r, n);\n            if (0 === s.length) break;\n            c = r;\n            h = n + s.shift();\n            C = c + s.shift();\n            l = h + s.shift();\n            r = C + s.shift();\n            n = l + (1 === s.length ? s.shift() : 0);\n            bezierCurveTo(c, h, C, l, r, n);\n          }\n          break;\n        default:\n          if (m < 32) throw new FormatError(`unknown operator: ${m}`);\n          if (m < 247) s.push(m - 139);else if (m < 251) s.push(256 * (m - 247) + e[o++] + 108);else if (m < 255) s.push(256 * -(m - 251) - e[o++] - 108);else {\n            s.push((e[o] << 24 | e[o + 1] << 16 | e[o + 2] << 8 | e[o + 3]) / 65536);\n            o += 4;\n          }\n      }\n      p && (s.length = 0);\n    }\n  }(e);\n}\nconst $i = [];\nclass Commands {\n  cmds = [];\n  add(e, t) {\n    if (t) {\n      if (isNumberArray(t, null)) this.cmds.push(e, ...t);else {\n        warn(`Commands.add - \"${e}\" has at least one non-number arg: \"${t}\".`);\n        const i = t.map(e => \"number\" == typeof e ? e : 0);\n        this.cmds.push(e, ...i);\n      }\n    } else this.cmds.push(e);\n  }\n}\nclass CompiledFont {\n  constructor(e) {\n    this.constructor === CompiledFont && unreachable(\"Cannot initialize CompiledFont.\");\n    this.fontMatrix = e;\n    this.compiledGlyphs = Object.create(null);\n    this.compiledCharCodeToGlyphId = Object.create(null);\n  }\n  getPathJs(e) {\n    const {\n      charCode: t,\n      glyphId: i\n    } = lookupCmap(this.cmap, e);\n    let a,\n      s = this.compiledGlyphs[i];\n    if (!s) {\n      try {\n        s = this.compileGlyph(this.glyphs[i], i);\n      } catch (e) {\n        s = $i;\n        a = e;\n      }\n      this.compiledGlyphs[i] = s;\n    }\n    this.compiledCharCodeToGlyphId[t] ??= i;\n    if (a) throw a;\n    return s;\n  }\n  compileGlyph(e, t) {\n    if (!e || 0 === e.length || 14 === e[0]) return $i;\n    let i = this.fontMatrix;\n    if (this.isCFFCIDFont) {\n      const e = this.fdSelect.getFDIndex(t);\n      if (e >= 0 && e < this.fdArray.length) {\n        i = this.fdArray[e].getByName(\"FontMatrix\") || a;\n      } else warn(\"Invalid fd index for glyph index.\");\n    }\n    const s = new Commands();\n    s.add(Qt);\n    s.add(ut, i.slice());\n    s.add(Et);\n    this.compileGlyphImpl(e, s, t);\n    s.add(lt);\n    return s.cmds;\n  }\n  compileGlyphImpl() {\n    unreachable(\"Children classes should implement this.\");\n  }\n  hasBuiltPath(e) {\n    const {\n      charCode: t,\n      glyphId: i\n    } = lookupCmap(this.cmap, e);\n    return void 0 !== this.compiledGlyphs[i] && void 0 !== this.compiledCharCodeToGlyphId[t];\n  }\n}\nclass TrueTypeCompiled extends CompiledFont {\n  constructor(e, t, i) {\n    super(i || [488e-6, 0, 0, 488e-6, 0, 0]);\n    this.glyphs = e;\n    this.cmap = t;\n  }\n  compileGlyphImpl(e, t) {\n    compileGlyf(e, t, this);\n  }\n}\nclass Type2Compiled extends CompiledFont {\n  constructor(e, t, i, a) {\n    super(i || [.001, 0, 0, .001, 0, 0]);\n    this.glyphs = e.glyphs;\n    this.gsubrs = e.gsubrs || [];\n    this.subrs = e.subrs || [];\n    this.cmap = t;\n    this.glyphNameMap = a || Ni();\n    this.gsubrsBias = getSubroutineBias(this.gsubrs);\n    this.subrsBias = getSubroutineBias(this.subrs);\n    this.isCFFCIDFont = e.isCFFCIDFont;\n    this.fdSelect = e.fdSelect;\n    this.fdArray = e.fdArray;\n  }\n  compileGlyphImpl(e, t, i) {\n    compileCharString(e, t, this, i);\n  }\n}\nclass FontRendererFactory {\n  static create(e, t) {\n    const i = new Uint8Array(e.data);\n    let a, s, r, n, g, o;\n    const c = getUint16(i, 4);\n    for (let e = 0, C = 12; e < c; e++, C += 16) {\n      const e = bytesToString(i.subarray(C, C + 4)),\n        c = getUint32(i, C + 8),\n        h = getUint32(i, C + 12);\n      switch (e) {\n        case \"cmap\":\n          a = parseCmap(i, c);\n          break;\n        case \"glyf\":\n          s = i.subarray(c, c + h);\n          break;\n        case \"loca\":\n          r = i.subarray(c, c + h);\n          break;\n        case \"head\":\n          o = getUint16(i, c + 18);\n          g = getUint16(i, c + 50);\n          break;\n        case \"CFF \":\n          n = parseCff(i, c, c + h, t);\n      }\n    }\n    if (s) {\n      const t = o ? [1 / o, 0, 0, 1 / o, 0, 0] : e.fontMatrix;\n      return new TrueTypeCompiled(function parseGlyfTable(e, t, i) {\n        let a, s;\n        if (i) {\n          a = 4;\n          s = getUint32;\n        } else {\n          a = 2;\n          s = (e, t) => 2 * getUint16(e, t);\n        }\n        const r = [];\n        let n = s(t, 0);\n        for (let i = a; i < t.length; i += a) {\n          const a = s(t, i);\n          r.push(e.subarray(n, a));\n          n = a;\n        }\n        return r;\n      }(s, r, g), a, t);\n    }\n    return new Type2Compiled(n, a, e.fontMatrix, e.glyphNameMap);\n  }\n}\nconst Aa = getLookupTableFactory(function (e) {\n    e.Courier = 600;\n    e[\"Courier-Bold\"] = 600;\n    e[\"Courier-BoldOblique\"] = 600;\n    e[\"Courier-Oblique\"] = 600;\n    e.Helvetica = getLookupTableFactory(function (e) {\n      e.space = 278;\n      e.exclam = 278;\n      e.quotedbl = 355;\n      e.numbersign = 556;\n      e.dollar = 556;\n      e.percent = 889;\n      e.ampersand = 667;\n      e.quoteright = 222;\n      e.parenleft = 333;\n      e.parenright = 333;\n      e.asterisk = 389;\n      e.plus = 584;\n      e.comma = 278;\n      e.hyphen = 333;\n      e.period = 278;\n      e.slash = 278;\n      e.zero = 556;\n      e.one = 556;\n      e.two = 556;\n      e.three = 556;\n      e.four = 556;\n      e.five = 556;\n      e.six = 556;\n      e.seven = 556;\n      e.eight = 556;\n      e.nine = 556;\n      e.colon = 278;\n      e.semicolon = 278;\n      e.less = 584;\n      e.equal = 584;\n      e.greater = 584;\n      e.question = 556;\n      e.at = 1015;\n      e.A = 667;\n      e.B = 667;\n      e.C = 722;\n      e.D = 722;\n      e.E = 667;\n      e.F = 611;\n      e.G = 778;\n      e.H = 722;\n      e.I = 278;\n      e.J = 500;\n      e.K = 667;\n      e.L = 556;\n      e.M = 833;\n      e.N = 722;\n      e.O = 778;\n      e.P = 667;\n      e.Q = 778;\n      e.R = 722;\n      e.S = 667;\n      e.T = 611;\n      e.U = 722;\n      e.V = 667;\n      e.W = 944;\n      e.X = 667;\n      e.Y = 667;\n      e.Z = 611;\n      e.bracketleft = 278;\n      e.backslash = 278;\n      e.bracketright = 278;\n      e.asciicircum = 469;\n      e.underscore = 556;\n      e.quoteleft = 222;\n      e.a = 556;\n      e.b = 556;\n      e.c = 500;\n      e.d = 556;\n      e.e = 556;\n      e.f = 278;\n      e.g = 556;\n      e.h = 556;\n      e.i = 222;\n      e.j = 222;\n      e.k = 500;\n      e.l = 222;\n      e.m = 833;\n      e.n = 556;\n      e.o = 556;\n      e.p = 556;\n      e.q = 556;\n      e.r = 333;\n      e.s = 500;\n      e.t = 278;\n      e.u = 556;\n      e.v = 500;\n      e.w = 722;\n      e.x = 500;\n      e.y = 500;\n      e.z = 500;\n      e.braceleft = 334;\n      e.bar = 260;\n      e.braceright = 334;\n      e.asciitilde = 584;\n      e.exclamdown = 333;\n      e.cent = 556;\n      e.sterling = 556;\n      e.fraction = 167;\n      e.yen = 556;\n      e.florin = 556;\n      e.section = 556;\n      e.currency = 556;\n      e.quotesingle = 191;\n      e.quotedblleft = 333;\n      e.guillemotleft = 556;\n      e.guilsinglleft = 333;\n      e.guilsinglright = 333;\n      e.fi = 500;\n      e.fl = 500;\n      e.endash = 556;\n      e.dagger = 556;\n      e.daggerdbl = 556;\n      e.periodcentered = 278;\n      e.paragraph = 537;\n      e.bullet = 350;\n      e.quotesinglbase = 222;\n      e.quotedblbase = 333;\n      e.quotedblright = 333;\n      e.guillemotright = 556;\n      e.ellipsis = 1e3;\n      e.perthousand = 1e3;\n      e.questiondown = 611;\n      e.grave = 333;\n      e.acute = 333;\n      e.circumflex = 333;\n      e.tilde = 333;\n      e.macron = 333;\n      e.breve = 333;\n      e.dotaccent = 333;\n      e.dieresis = 333;\n      e.ring = 333;\n      e.cedilla = 333;\n      e.hungarumlaut = 333;\n      e.ogonek = 333;\n      e.caron = 333;\n      e.emdash = 1e3;\n      e.AE = 1e3;\n      e.ordfeminine = 370;\n      e.Lslash = 556;\n      e.Oslash = 778;\n      e.OE = 1e3;\n      e.ordmasculine = 365;\n      e.ae = 889;\n      e.dotlessi = 278;\n      e.lslash = 222;\n      e.oslash = 611;\n      e.oe = 944;\n      e.germandbls = 611;\n      e.Idieresis = 278;\n      e.eacute = 556;\n      e.abreve = 556;\n      e.uhungarumlaut = 556;\n      e.ecaron = 556;\n      e.Ydieresis = 667;\n      e.divide = 584;\n      e.Yacute = 667;\n      e.Acircumflex = 667;\n      e.aacute = 556;\n      e.Ucircumflex = 722;\n      e.yacute = 500;\n      e.scommaaccent = 500;\n      e.ecircumflex = 556;\n      e.Uring = 722;\n      e.Udieresis = 722;\n      e.aogonek = 556;\n      e.Uacute = 722;\n      e.uogonek = 556;\n      e.Edieresis = 667;\n      e.Dcroat = 722;\n      e.commaaccent = 250;\n      e.copyright = 737;\n      e.Emacron = 667;\n      e.ccaron = 500;\n      e.aring = 556;\n      e.Ncommaaccent = 722;\n      e.lacute = 222;\n      e.agrave = 556;\n      e.Tcommaaccent = 611;\n      e.Cacute = 722;\n      e.atilde = 556;\n      e.Edotaccent = 667;\n      e.scaron = 500;\n      e.scedilla = 500;\n      e.iacute = 278;\n      e.lozenge = 471;\n      e.Rcaron = 722;\n      e.Gcommaaccent = 778;\n      e.ucircumflex = 556;\n      e.acircumflex = 556;\n      e.Amacron = 667;\n      e.rcaron = 333;\n      e.ccedilla = 500;\n      e.Zdotaccent = 611;\n      e.Thorn = 667;\n      e.Omacron = 778;\n      e.Racute = 722;\n      e.Sacute = 667;\n      e.dcaron = 643;\n      e.Umacron = 722;\n      e.uring = 556;\n      e.threesuperior = 333;\n      e.Ograve = 778;\n      e.Agrave = 667;\n      e.Abreve = 667;\n      e.multiply = 584;\n      e.uacute = 556;\n      e.Tcaron = 611;\n      e.partialdiff = 476;\n      e.ydieresis = 500;\n      e.Nacute = 722;\n      e.icircumflex = 278;\n      e.Ecircumflex = 667;\n      e.adieresis = 556;\n      e.edieresis = 556;\n      e.cacute = 500;\n      e.nacute = 556;\n      e.umacron = 556;\n      e.Ncaron = 722;\n      e.Iacute = 278;\n      e.plusminus = 584;\n      e.brokenbar = 260;\n      e.registered = 737;\n      e.Gbreve = 778;\n      e.Idotaccent = 278;\n      e.summation = 600;\n      e.Egrave = 667;\n      e.racute = 333;\n      e.omacron = 556;\n      e.Zacute = 611;\n      e.Zcaron = 611;\n      e.greaterequal = 549;\n      e.Eth = 722;\n      e.Ccedilla = 722;\n      e.lcommaaccent = 222;\n      e.tcaron = 317;\n      e.eogonek = 556;\n      e.Uogonek = 722;\n      e.Aacute = 667;\n      e.Adieresis = 667;\n      e.egrave = 556;\n      e.zacute = 500;\n      e.iogonek = 222;\n      e.Oacute = 778;\n      e.oacute = 556;\n      e.amacron = 556;\n      e.sacute = 500;\n      e.idieresis = 278;\n      e.Ocircumflex = 778;\n      e.Ugrave = 722;\n      e.Delta = 612;\n      e.thorn = 556;\n      e.twosuperior = 333;\n      e.Odieresis = 778;\n      e.mu = 556;\n      e.igrave = 278;\n      e.ohungarumlaut = 556;\n      e.Eogonek = 667;\n      e.dcroat = 556;\n      e.threequarters = 834;\n      e.Scedilla = 667;\n      e.lcaron = 299;\n      e.Kcommaaccent = 667;\n      e.Lacute = 556;\n      e.trademark = 1e3;\n      e.edotaccent = 556;\n      e.Igrave = 278;\n      e.Imacron = 278;\n      e.Lcaron = 556;\n      e.onehalf = 834;\n      e.lessequal = 549;\n      e.ocircumflex = 556;\n      e.ntilde = 556;\n      e.Uhungarumlaut = 722;\n      e.Eacute = 667;\n      e.emacron = 556;\n      e.gbreve = 556;\n      e.onequarter = 834;\n      e.Scaron = 667;\n      e.Scommaaccent = 667;\n      e.Ohungarumlaut = 778;\n      e.degree = 400;\n      e.ograve = 556;\n      e.Ccaron = 722;\n      e.ugrave = 556;\n      e.radical = 453;\n      e.Dcaron = 722;\n      e.rcommaaccent = 333;\n      e.Ntilde = 722;\n      e.otilde = 556;\n      e.Rcommaaccent = 722;\n      e.Lcommaaccent = 556;\n      e.Atilde = 667;\n      e.Aogonek = 667;\n      e.Aring = 667;\n      e.Otilde = 778;\n      e.zdotaccent = 500;\n      e.Ecaron = 667;\n      e.Iogonek = 278;\n      e.kcommaaccent = 500;\n      e.minus = 584;\n      e.Icircumflex = 278;\n      e.ncaron = 556;\n      e.tcommaaccent = 278;\n      e.logicalnot = 584;\n      e.odieresis = 556;\n      e.udieresis = 556;\n      e.notequal = 549;\n      e.gcommaaccent = 556;\n      e.eth = 556;\n      e.zcaron = 500;\n      e.ncommaaccent = 556;\n      e.onesuperior = 333;\n      e.imacron = 278;\n      e.Euro = 556;\n    });\n    e[\"Helvetica-Bold\"] = getLookupTableFactory(function (e) {\n      e.space = 278;\n      e.exclam = 333;\n      e.quotedbl = 474;\n      e.numbersign = 556;\n      e.dollar = 556;\n      e.percent = 889;\n      e.ampersand = 722;\n      e.quoteright = 278;\n      e.parenleft = 333;\n      e.parenright = 333;\n      e.asterisk = 389;\n      e.plus = 584;\n      e.comma = 278;\n      e.hyphen = 333;\n      e.period = 278;\n      e.slash = 278;\n      e.zero = 556;\n      e.one = 556;\n      e.two = 556;\n      e.three = 556;\n      e.four = 556;\n      e.five = 556;\n      e.six = 556;\n      e.seven = 556;\n      e.eight = 556;\n      e.nine = 556;\n      e.colon = 333;\n      e.semicolon = 333;\n      e.less = 584;\n      e.equal = 584;\n      e.greater = 584;\n      e.question = 611;\n      e.at = 975;\n      e.A = 722;\n      e.B = 722;\n      e.C = 722;\n      e.D = 722;\n      e.E = 667;\n      e.F = 611;\n      e.G = 778;\n      e.H = 722;\n      e.I = 278;\n      e.J = 556;\n      e.K = 722;\n      e.L = 611;\n      e.M = 833;\n      e.N = 722;\n      e.O = 778;\n      e.P = 667;\n      e.Q = 778;\n      e.R = 722;\n      e.S = 667;\n      e.T = 611;\n      e.U = 722;\n      e.V = 667;\n      e.W = 944;\n      e.X = 667;\n      e.Y = 667;\n      e.Z = 611;\n      e.bracketleft = 333;\n      e.backslash = 278;\n      e.bracketright = 333;\n      e.asciicircum = 584;\n      e.underscore = 556;\n      e.quoteleft = 278;\n      e.a = 556;\n      e.b = 611;\n      e.c = 556;\n      e.d = 611;\n      e.e = 556;\n      e.f = 333;\n      e.g = 611;\n      e.h = 611;\n      e.i = 278;\n      e.j = 278;\n      e.k = 556;\n      e.l = 278;\n      e.m = 889;\n      e.n = 611;\n      e.o = 611;\n      e.p = 611;\n      e.q = 611;\n      e.r = 389;\n      e.s = 556;\n      e.t = 333;\n      e.u = 611;\n      e.v = 556;\n      e.w = 778;\n      e.x = 556;\n      e.y = 556;\n      e.z = 500;\n      e.braceleft = 389;\n      e.bar = 280;\n      e.braceright = 389;\n      e.asciitilde = 584;\n      e.exclamdown = 333;\n      e.cent = 556;\n      e.sterling = 556;\n      e.fraction = 167;\n      e.yen = 556;\n      e.florin = 556;\n      e.section = 556;\n      e.currency = 556;\n      e.quotesingle = 238;\n      e.quotedblleft = 500;\n      e.guillemotleft = 556;\n      e.guilsinglleft = 333;\n      e.guilsinglright = 333;\n      e.fi = 611;\n      e.fl = 611;\n      e.endash = 556;\n      e.dagger = 556;\n      e.daggerdbl = 556;\n      e.periodcentered = 278;\n      e.paragraph = 556;\n      e.bullet = 350;\n      e.quotesinglbase = 278;\n      e.quotedblbase = 500;\n      e.quotedblright = 500;\n      e.guillemotright = 556;\n      e.ellipsis = 1e3;\n      e.perthousand = 1e3;\n      e.questiondown = 611;\n      e.grave = 333;\n      e.acute = 333;\n      e.circumflex = 333;\n      e.tilde = 333;\n      e.macron = 333;\n      e.breve = 333;\n      e.dotaccent = 333;\n      e.dieresis = 333;\n      e.ring = 333;\n      e.cedilla = 333;\n      e.hungarumlaut = 333;\n      e.ogonek = 333;\n      e.caron = 333;\n      e.emdash = 1e3;\n      e.AE = 1e3;\n      e.ordfeminine = 370;\n      e.Lslash = 611;\n      e.Oslash = 778;\n      e.OE = 1e3;\n      e.ordmasculine = 365;\n      e.ae = 889;\n      e.dotlessi = 278;\n      e.lslash = 278;\n      e.oslash = 611;\n      e.oe = 944;\n      e.germandbls = 611;\n      e.Idieresis = 278;\n      e.eacute = 556;\n      e.abreve = 556;\n      e.uhungarumlaut = 611;\n      e.ecaron = 556;\n      e.Ydieresis = 667;\n      e.divide = 584;\n      e.Yacute = 667;\n      e.Acircumflex = 722;\n      e.aacute = 556;\n      e.Ucircumflex = 722;\n      e.yacute = 556;\n      e.scommaaccent = 556;\n      e.ecircumflex = 556;\n      e.Uring = 722;\n      e.Udieresis = 722;\n      e.aogonek = 556;\n      e.Uacute = 722;\n      e.uogonek = 611;\n      e.Edieresis = 667;\n      e.Dcroat = 722;\n      e.commaaccent = 250;\n      e.copyright = 737;\n      e.Emacron = 667;\n      e.ccaron = 556;\n      e.aring = 556;\n      e.Ncommaaccent = 722;\n      e.lacute = 278;\n      e.agrave = 556;\n      e.Tcommaaccent = 611;\n      e.Cacute = 722;\n      e.atilde = 556;\n      e.Edotaccent = 667;\n      e.scaron = 556;\n      e.scedilla = 556;\n      e.iacute = 278;\n      e.lozenge = 494;\n      e.Rcaron = 722;\n      e.Gcommaaccent = 778;\n      e.ucircumflex = 611;\n      e.acircumflex = 556;\n      e.Amacron = 722;\n      e.rcaron = 389;\n      e.ccedilla = 556;\n      e.Zdotaccent = 611;\n      e.Thorn = 667;\n      e.Omacron = 778;\n      e.Racute = 722;\n      e.Sacute = 667;\n      e.dcaron = 743;\n      e.Umacron = 722;\n      e.uring = 611;\n      e.threesuperior = 333;\n      e.Ograve = 778;\n      e.Agrave = 722;\n      e.Abreve = 722;\n      e.multiply = 584;\n      e.uacute = 611;\n      e.Tcaron = 611;\n      e.partialdiff = 494;\n      e.ydieresis = 556;\n      e.Nacute = 722;\n      e.icircumflex = 278;\n      e.Ecircumflex = 667;\n      e.adieresis = 556;\n      e.edieresis = 556;\n      e.cacute = 556;\n      e.nacute = 611;\n      e.umacron = 611;\n      e.Ncaron = 722;\n      e.Iacute = 278;\n      e.plusminus = 584;\n      e.brokenbar = 280;\n      e.registered = 737;\n      e.Gbreve = 778;\n      e.Idotaccent = 278;\n      e.summation = 600;\n      e.Egrave = 667;\n      e.racute = 389;\n      e.omacron = 611;\n      e.Zacute = 611;\n      e.Zcaron = 611;\n      e.greaterequal = 549;\n      e.Eth = 722;\n      e.Ccedilla = 722;\n      e.lcommaaccent = 278;\n      e.tcaron = 389;\n      e.eogonek = 556;\n      e.Uogonek = 722;\n      e.Aacute = 722;\n      e.Adieresis = 722;\n      e.egrave = 556;\n      e.zacute = 500;\n      e.iogonek = 278;\n      e.Oacute = 778;\n      e.oacute = 611;\n      e.amacron = 556;\n      e.sacute = 556;\n      e.idieresis = 278;\n      e.Ocircumflex = 778;\n      e.Ugrave = 722;\n      e.Delta = 612;\n      e.thorn = 611;\n      e.twosuperior = 333;\n      e.Odieresis = 778;\n      e.mu = 611;\n      e.igrave = 278;\n      e.ohungarumlaut = 611;\n      e.Eogonek = 667;\n      e.dcroat = 611;\n      e.threequarters = 834;\n      e.Scedilla = 667;\n      e.lcaron = 400;\n      e.Kcommaaccent = 722;\n      e.Lacute = 611;\n      e.trademark = 1e3;\n      e.edotaccent = 556;\n      e.Igrave = 278;\n      e.Imacron = 278;\n      e.Lcaron = 611;\n      e.onehalf = 834;\n      e.lessequal = 549;\n      e.ocircumflex = 611;\n      e.ntilde = 611;\n      e.Uhungarumlaut = 722;\n      e.Eacute = 667;\n      e.emacron = 556;\n      e.gbreve = 611;\n      e.onequarter = 834;\n      e.Scaron = 667;\n      e.Scommaaccent = 667;\n      e.Ohungarumlaut = 778;\n      e.degree = 400;\n      e.ograve = 611;\n      e.Ccaron = 722;\n      e.ugrave = 611;\n      e.radical = 549;\n      e.Dcaron = 722;\n      e.rcommaaccent = 389;\n      e.Ntilde = 722;\n      e.otilde = 611;\n      e.Rcommaaccent = 722;\n      e.Lcommaaccent = 611;\n      e.Atilde = 722;\n      e.Aogonek = 722;\n      e.Aring = 722;\n      e.Otilde = 778;\n      e.zdotaccent = 500;\n      e.Ecaron = 667;\n      e.Iogonek = 278;\n      e.kcommaaccent = 556;\n      e.minus = 584;\n      e.Icircumflex = 278;\n      e.ncaron = 611;\n      e.tcommaaccent = 333;\n      e.logicalnot = 584;\n      e.odieresis = 611;\n      e.udieresis = 611;\n      e.notequal = 549;\n      e.gcommaaccent = 611;\n      e.eth = 611;\n      e.zcaron = 500;\n      e.ncommaaccent = 611;\n      e.onesuperior = 333;\n      e.imacron = 278;\n      e.Euro = 556;\n    });\n    e[\"Helvetica-BoldOblique\"] = getLookupTableFactory(function (e) {\n      e.space = 278;\n      e.exclam = 333;\n      e.quotedbl = 474;\n      e.numbersign = 556;\n      e.dollar = 556;\n      e.percent = 889;\n      e.ampersand = 722;\n      e.quoteright = 278;\n      e.parenleft = 333;\n      e.parenright = 333;\n      e.asterisk = 389;\n      e.plus = 584;\n      e.comma = 278;\n      e.hyphen = 333;\n      e.period = 278;\n      e.slash = 278;\n      e.zero = 556;\n      e.one = 556;\n      e.two = 556;\n      e.three = 556;\n      e.four = 556;\n      e.five = 556;\n      e.six = 556;\n      e.seven = 556;\n      e.eight = 556;\n      e.nine = 556;\n      e.colon = 333;\n      e.semicolon = 333;\n      e.less = 584;\n      e.equal = 584;\n      e.greater = 584;\n      e.question = 611;\n      e.at = 975;\n      e.A = 722;\n      e.B = 722;\n      e.C = 722;\n      e.D = 722;\n      e.E = 667;\n      e.F = 611;\n      e.G = 778;\n      e.H = 722;\n      e.I = 278;\n      e.J = 556;\n      e.K = 722;\n      e.L = 611;\n      e.M = 833;\n      e.N = 722;\n      e.O = 778;\n      e.P = 667;\n      e.Q = 778;\n      e.R = 722;\n      e.S = 667;\n      e.T = 611;\n      e.U = 722;\n      e.V = 667;\n      e.W = 944;\n      e.X = 667;\n      e.Y = 667;\n      e.Z = 611;\n      e.bracketleft = 333;\n      e.backslash = 278;\n      e.bracketright = 333;\n      e.asciicircum = 584;\n      e.underscore = 556;\n      e.quoteleft = 278;\n      e.a = 556;\n      e.b = 611;\n      e.c = 556;\n      e.d = 611;\n      e.e = 556;\n      e.f = 333;\n      e.g = 611;\n      e.h = 611;\n      e.i = 278;\n      e.j = 278;\n      e.k = 556;\n      e.l = 278;\n      e.m = 889;\n      e.n = 611;\n      e.o = 611;\n      e.p = 611;\n      e.q = 611;\n      e.r = 389;\n      e.s = 556;\n      e.t = 333;\n      e.u = 611;\n      e.v = 556;\n      e.w = 778;\n      e.x = 556;\n      e.y = 556;\n      e.z = 500;\n      e.braceleft = 389;\n      e.bar = 280;\n      e.braceright = 389;\n      e.asciitilde = 584;\n      e.exclamdown = 333;\n      e.cent = 556;\n      e.sterling = 556;\n      e.fraction = 167;\n      e.yen = 556;\n      e.florin = 556;\n      e.section = 556;\n      e.currency = 556;\n      e.quotesingle = 238;\n      e.quotedblleft = 500;\n      e.guillemotleft = 556;\n      e.guilsinglleft = 333;\n      e.guilsinglright = 333;\n      e.fi = 611;\n      e.fl = 611;\n      e.endash = 556;\n      e.dagger = 556;\n      e.daggerdbl = 556;\n      e.periodcentered = 278;\n      e.paragraph = 556;\n      e.bullet = 350;\n      e.quotesinglbase = 278;\n      e.quotedblbase = 500;\n      e.quotedblright = 500;\n      e.guillemotright = 556;\n      e.ellipsis = 1e3;\n      e.perthousand = 1e3;\n      e.questiondown = 611;\n      e.grave = 333;\n      e.acute = 333;\n      e.circumflex = 333;\n      e.tilde = 333;\n      e.macron = 333;\n      e.breve = 333;\n      e.dotaccent = 333;\n      e.dieresis = 333;\n      e.ring = 333;\n      e.cedilla = 333;\n      e.hungarumlaut = 333;\n      e.ogonek = 333;\n      e.caron = 333;\n      e.emdash = 1e3;\n      e.AE = 1e3;\n      e.ordfeminine = 370;\n      e.Lslash = 611;\n      e.Oslash = 778;\n      e.OE = 1e3;\n      e.ordmasculine = 365;\n      e.ae = 889;\n      e.dotlessi = 278;\n      e.lslash = 278;\n      e.oslash = 611;\n      e.oe = 944;\n      e.germandbls = 611;\n      e.Idieresis = 278;\n      e.eacute = 556;\n      e.abreve = 556;\n      e.uhungarumlaut = 611;\n      e.ecaron = 556;\n      e.Ydieresis = 667;\n      e.divide = 584;\n      e.Yacute = 667;\n      e.Acircumflex = 722;\n      e.aacute = 556;\n      e.Ucircumflex = 722;\n      e.yacute = 556;\n      e.scommaaccent = 556;\n      e.ecircumflex = 556;\n      e.Uring = 722;\n      e.Udieresis = 722;\n      e.aogonek = 556;\n      e.Uacute = 722;\n      e.uogonek = 611;\n      e.Edieresis = 667;\n      e.Dcroat = 722;\n      e.commaaccent = 250;\n      e.copyright = 737;\n      e.Emacron = 667;\n      e.ccaron = 556;\n      e.aring = 556;\n      e.Ncommaaccent = 722;\n      e.lacute = 278;\n      e.agrave = 556;\n      e.Tcommaaccent = 611;\n      e.Cacute = 722;\n      e.atilde = 556;\n      e.Edotaccent = 667;\n      e.scaron = 556;\n      e.scedilla = 556;\n      e.iacute = 278;\n      e.lozenge = 494;\n      e.Rcaron = 722;\n      e.Gcommaaccent = 778;\n      e.ucircumflex = 611;\n      e.acircumflex = 556;\n      e.Amacron = 722;\n      e.rcaron = 389;\n      e.ccedilla = 556;\n      e.Zdotaccent = 611;\n      e.Thorn = 667;\n      e.Omacron = 778;\n      e.Racute = 722;\n      e.Sacute = 667;\n      e.dcaron = 743;\n      e.Umacron = 722;\n      e.uring = 611;\n      e.threesuperior = 333;\n      e.Ograve = 778;\n      e.Agrave = 722;\n      e.Abreve = 722;\n      e.multiply = 584;\n      e.uacute = 611;\n      e.Tcaron = 611;\n      e.partialdiff = 494;\n      e.ydieresis = 556;\n      e.Nacute = 722;\n      e.icircumflex = 278;\n      e.Ecircumflex = 667;\n      e.adieresis = 556;\n      e.edieresis = 556;\n      e.cacute = 556;\n      e.nacute = 611;\n      e.umacron = 611;\n      e.Ncaron = 722;\n      e.Iacute = 278;\n      e.plusminus = 584;\n      e.brokenbar = 280;\n      e.registered = 737;\n      e.Gbreve = 778;\n      e.Idotaccent = 278;\n      e.summation = 600;\n      e.Egrave = 667;\n      e.racute = 389;\n      e.omacron = 611;\n      e.Zacute = 611;\n      e.Zcaron = 611;\n      e.greaterequal = 549;\n      e.Eth = 722;\n      e.Ccedilla = 722;\n      e.lcommaaccent = 278;\n      e.tcaron = 389;\n      e.eogonek = 556;\n      e.Uogonek = 722;\n      e.Aacute = 722;\n      e.Adieresis = 722;\n      e.egrave = 556;\n      e.zacute = 500;\n      e.iogonek = 278;\n      e.Oacute = 778;\n      e.oacute = 611;\n      e.amacron = 556;\n      e.sacute = 556;\n      e.idieresis = 278;\n      e.Ocircumflex = 778;\n      e.Ugrave = 722;\n      e.Delta = 612;\n      e.thorn = 611;\n      e.twosuperior = 333;\n      e.Odieresis = 778;\n      e.mu = 611;\n      e.igrave = 278;\n      e.ohungarumlaut = 611;\n      e.Eogonek = 667;\n      e.dcroat = 611;\n      e.threequarters = 834;\n      e.Scedilla = 667;\n      e.lcaron = 400;\n      e.Kcommaaccent = 722;\n      e.Lacute = 611;\n      e.trademark = 1e3;\n      e.edotaccent = 556;\n      e.Igrave = 278;\n      e.Imacron = 278;\n      e.Lcaron = 611;\n      e.onehalf = 834;\n      e.lessequal = 549;\n      e.ocircumflex = 611;\n      e.ntilde = 611;\n      e.Uhungarumlaut = 722;\n      e.Eacute = 667;\n      e.emacron = 556;\n      e.gbreve = 611;\n      e.onequarter = 834;\n      e.Scaron = 667;\n      e.Scommaaccent = 667;\n      e.Ohungarumlaut = 778;\n      e.degree = 400;\n      e.ograve = 611;\n      e.Ccaron = 722;\n      e.ugrave = 611;\n      e.radical = 549;\n      e.Dcaron = 722;\n      e.rcommaaccent = 389;\n      e.Ntilde = 722;\n      e.otilde = 611;\n      e.Rcommaaccent = 722;\n      e.Lcommaaccent = 611;\n      e.Atilde = 722;\n      e.Aogonek = 722;\n      e.Aring = 722;\n      e.Otilde = 778;\n      e.zdotaccent = 500;\n      e.Ecaron = 667;\n      e.Iogonek = 278;\n      e.kcommaaccent = 556;\n      e.minus = 584;\n      e.Icircumflex = 278;\n      e.ncaron = 611;\n      e.tcommaaccent = 333;\n      e.logicalnot = 584;\n      e.odieresis = 611;\n      e.udieresis = 611;\n      e.notequal = 549;\n      e.gcommaaccent = 611;\n      e.eth = 611;\n      e.zcaron = 500;\n      e.ncommaaccent = 611;\n      e.onesuperior = 333;\n      e.imacron = 278;\n      e.Euro = 556;\n    });\n    e[\"Helvetica-Oblique\"] = getLookupTableFactory(function (e) {\n      e.space = 278;\n      e.exclam = 278;\n      e.quotedbl = 355;\n      e.numbersign = 556;\n      e.dollar = 556;\n      e.percent = 889;\n      e.ampersand = 667;\n      e.quoteright = 222;\n      e.parenleft = 333;\n      e.parenright = 333;\n      e.asterisk = 389;\n      e.plus = 584;\n      e.comma = 278;\n      e.hyphen = 333;\n      e.period = 278;\n      e.slash = 278;\n      e.zero = 556;\n      e.one = 556;\n      e.two = 556;\n      e.three = 556;\n      e.four = 556;\n      e.five = 556;\n      e.six = 556;\n      e.seven = 556;\n      e.eight = 556;\n      e.nine = 556;\n      e.colon = 278;\n      e.semicolon = 278;\n      e.less = 584;\n      e.equal = 584;\n      e.greater = 584;\n      e.question = 556;\n      e.at = 1015;\n      e.A = 667;\n      e.B = 667;\n      e.C = 722;\n      e.D = 722;\n      e.E = 667;\n      e.F = 611;\n      e.G = 778;\n      e.H = 722;\n      e.I = 278;\n      e.J = 500;\n      e.K = 667;\n      e.L = 556;\n      e.M = 833;\n      e.N = 722;\n      e.O = 778;\n      e.P = 667;\n      e.Q = 778;\n      e.R = 722;\n      e.S = 667;\n      e.T = 611;\n      e.U = 722;\n      e.V = 667;\n      e.W = 944;\n      e.X = 667;\n      e.Y = 667;\n      e.Z = 611;\n      e.bracketleft = 278;\n      e.backslash = 278;\n      e.bracketright = 278;\n      e.asciicircum = 469;\n      e.underscore = 556;\n      e.quoteleft = 222;\n      e.a = 556;\n      e.b = 556;\n      e.c = 500;\n      e.d = 556;\n      e.e = 556;\n      e.f = 278;\n      e.g = 556;\n      e.h = 556;\n      e.i = 222;\n      e.j = 222;\n      e.k = 500;\n      e.l = 222;\n      e.m = 833;\n      e.n = 556;\n      e.o = 556;\n      e.p = 556;\n      e.q = 556;\n      e.r = 333;\n      e.s = 500;\n      e.t = 278;\n      e.u = 556;\n      e.v = 500;\n      e.w = 722;\n      e.x = 500;\n      e.y = 500;\n      e.z = 500;\n      e.braceleft = 334;\n      e.bar = 260;\n      e.braceright = 334;\n      e.asciitilde = 584;\n      e.exclamdown = 333;\n      e.cent = 556;\n      e.sterling = 556;\n      e.fraction = 167;\n      e.yen = 556;\n      e.florin = 556;\n      e.section = 556;\n      e.currency = 556;\n      e.quotesingle = 191;\n      e.quotedblleft = 333;\n      e.guillemotleft = 556;\n      e.guilsinglleft = 333;\n      e.guilsinglright = 333;\n      e.fi = 500;\n      e.fl = 500;\n      e.endash = 556;\n      e.dagger = 556;\n      e.daggerdbl = 556;\n      e.periodcentered = 278;\n      e.paragraph = 537;\n      e.bullet = 350;\n      e.quotesinglbase = 222;\n      e.quotedblbase = 333;\n      e.quotedblright = 333;\n      e.guillemotright = 556;\n      e.ellipsis = 1e3;\n      e.perthousand = 1e3;\n      e.questiondown = 611;\n      e.grave = 333;\n      e.acute = 333;\n      e.circumflex = 333;\n      e.tilde = 333;\n      e.macron = 333;\n      e.breve = 333;\n      e.dotaccent = 333;\n      e.dieresis = 333;\n      e.ring = 333;\n      e.cedilla = 333;\n      e.hungarumlaut = 333;\n      e.ogonek = 333;\n      e.caron = 333;\n      e.emdash = 1e3;\n      e.AE = 1e3;\n      e.ordfeminine = 370;\n      e.Lslash = 556;\n      e.Oslash = 778;\n      e.OE = 1e3;\n      e.ordmasculine = 365;\n      e.ae = 889;\n      e.dotlessi = 278;\n      e.lslash = 222;\n      e.oslash = 611;\n      e.oe = 944;\n      e.germandbls = 611;\n      e.Idieresis = 278;\n      e.eacute = 556;\n      e.abreve = 556;\n      e.uhungarumlaut = 556;\n      e.ecaron = 556;\n      e.Ydieresis = 667;\n      e.divide = 584;\n      e.Yacute = 667;\n      e.Acircumflex = 667;\n      e.aacute = 556;\n      e.Ucircumflex = 722;\n      e.yacute = 500;\n      e.scommaaccent = 500;\n      e.ecircumflex = 556;\n      e.Uring = 722;\n      e.Udieresis = 722;\n      e.aogonek = 556;\n      e.Uacute = 722;\n      e.uogonek = 556;\n      e.Edieresis = 667;\n      e.Dcroat = 722;\n      e.commaaccent = 250;\n      e.copyright = 737;\n      e.Emacron = 667;\n      e.ccaron = 500;\n      e.aring = 556;\n      e.Ncommaaccent = 722;\n      e.lacute = 222;\n      e.agrave = 556;\n      e.Tcommaaccent = 611;\n      e.Cacute = 722;\n      e.atilde = 556;\n      e.Edotaccent = 667;\n      e.scaron = 500;\n      e.scedilla = 500;\n      e.iacute = 278;\n      e.lozenge = 471;\n      e.Rcaron = 722;\n      e.Gcommaaccent = 778;\n      e.ucircumflex = 556;\n      e.acircumflex = 556;\n      e.Amacron = 667;\n      e.rcaron = 333;\n      e.ccedilla = 500;\n      e.Zdotaccent = 611;\n      e.Thorn = 667;\n      e.Omacron = 778;\n      e.Racute = 722;\n      e.Sacute = 667;\n      e.dcaron = 643;\n      e.Umacron = 722;\n      e.uring = 556;\n      e.threesuperior = 333;\n      e.Ograve = 778;\n      e.Agrave = 667;\n      e.Abreve = 667;\n      e.multiply = 584;\n      e.uacute = 556;\n      e.Tcaron = 611;\n      e.partialdiff = 476;\n      e.ydieresis = 500;\n      e.Nacute = 722;\n      e.icircumflex = 278;\n      e.Ecircumflex = 667;\n      e.adieresis = 556;\n      e.edieresis = 556;\n      e.cacute = 500;\n      e.nacute = 556;\n      e.umacron = 556;\n      e.Ncaron = 722;\n      e.Iacute = 278;\n      e.plusminus = 584;\n      e.brokenbar = 260;\n      e.registered = 737;\n      e.Gbreve = 778;\n      e.Idotaccent = 278;\n      e.summation = 600;\n      e.Egrave = 667;\n      e.racute = 333;\n      e.omacron = 556;\n      e.Zacute = 611;\n      e.Zcaron = 611;\n      e.greaterequal = 549;\n      e.Eth = 722;\n      e.Ccedilla = 722;\n      e.lcommaaccent = 222;\n      e.tcaron = 317;\n      e.eogonek = 556;\n      e.Uogonek = 722;\n      e.Aacute = 667;\n      e.Adieresis = 667;\n      e.egrave = 556;\n      e.zacute = 500;\n      e.iogonek = 222;\n      e.Oacute = 778;\n      e.oacute = 556;\n      e.amacron = 556;\n      e.sacute = 500;\n      e.idieresis = 278;\n      e.Ocircumflex = 778;\n      e.Ugrave = 722;\n      e.Delta = 612;\n      e.thorn = 556;\n      e.twosuperior = 333;\n      e.Odieresis = 778;\n      e.mu = 556;\n      e.igrave = 278;\n      e.ohungarumlaut = 556;\n      e.Eogonek = 667;\n      e.dcroat = 556;\n      e.threequarters = 834;\n      e.Scedilla = 667;\n      e.lcaron = 299;\n      e.Kcommaaccent = 667;\n      e.Lacute = 556;\n      e.trademark = 1e3;\n      e.edotaccent = 556;\n      e.Igrave = 278;\n      e.Imacron = 278;\n      e.Lcaron = 556;\n      e.onehalf = 834;\n      e.lessequal = 549;\n      e.ocircumflex = 556;\n      e.ntilde = 556;\n      e.Uhungarumlaut = 722;\n      e.Eacute = 667;\n      e.emacron = 556;\n      e.gbreve = 556;\n      e.onequarter = 834;\n      e.Scaron = 667;\n      e.Scommaaccent = 667;\n      e.Ohungarumlaut = 778;\n      e.degree = 400;\n      e.ograve = 556;\n      e.Ccaron = 722;\n      e.ugrave = 556;\n      e.radical = 453;\n      e.Dcaron = 722;\n      e.rcommaaccent = 333;\n      e.Ntilde = 722;\n      e.otilde = 556;\n      e.Rcommaaccent = 722;\n      e.Lcommaaccent = 556;\n      e.Atilde = 667;\n      e.Aogonek = 667;\n      e.Aring = 667;\n      e.Otilde = 778;\n      e.zdotaccent = 500;\n      e.Ecaron = 667;\n      e.Iogonek = 278;\n      e.kcommaaccent = 500;\n      e.minus = 584;\n      e.Icircumflex = 278;\n      e.ncaron = 556;\n      e.tcommaaccent = 278;\n      e.logicalnot = 584;\n      e.odieresis = 556;\n      e.udieresis = 556;\n      e.notequal = 549;\n      e.gcommaaccent = 556;\n      e.eth = 556;\n      e.zcaron = 500;\n      e.ncommaaccent = 556;\n      e.onesuperior = 333;\n      e.imacron = 278;\n      e.Euro = 556;\n    });\n    e.Symbol = getLookupTableFactory(function (e) {\n      e.space = 250;\n      e.exclam = 333;\n      e.universal = 713;\n      e.numbersign = 500;\n      e.existential = 549;\n      e.percent = 833;\n      e.ampersand = 778;\n      e.suchthat = 439;\n      e.parenleft = 333;\n      e.parenright = 333;\n      e.asteriskmath = 500;\n      e.plus = 549;\n      e.comma = 250;\n      e.minus = 549;\n      e.period = 250;\n      e.slash = 278;\n      e.zero = 500;\n      e.one = 500;\n      e.two = 500;\n      e.three = 500;\n      e.four = 500;\n      e.five = 500;\n      e.six = 500;\n      e.seven = 500;\n      e.eight = 500;\n      e.nine = 500;\n      e.colon = 278;\n      e.semicolon = 278;\n      e.less = 549;\n      e.equal = 549;\n      e.greater = 549;\n      e.question = 444;\n      e.congruent = 549;\n      e.Alpha = 722;\n      e.Beta = 667;\n      e.Chi = 722;\n      e.Delta = 612;\n      e.Epsilon = 611;\n      e.Phi = 763;\n      e.Gamma = 603;\n      e.Eta = 722;\n      e.Iota = 333;\n      e.theta1 = 631;\n      e.Kappa = 722;\n      e.Lambda = 686;\n      e.Mu = 889;\n      e.Nu = 722;\n      e.Omicron = 722;\n      e.Pi = 768;\n      e.Theta = 741;\n      e.Rho = 556;\n      e.Sigma = 592;\n      e.Tau = 611;\n      e.Upsilon = 690;\n      e.sigma1 = 439;\n      e.Omega = 768;\n      e.Xi = 645;\n      e.Psi = 795;\n      e.Zeta = 611;\n      e.bracketleft = 333;\n      e.therefore = 863;\n      e.bracketright = 333;\n      e.perpendicular = 658;\n      e.underscore = 500;\n      e.radicalex = 500;\n      e.alpha = 631;\n      e.beta = 549;\n      e.chi = 549;\n      e.delta = 494;\n      e.epsilon = 439;\n      e.phi = 521;\n      e.gamma = 411;\n      e.eta = 603;\n      e.iota = 329;\n      e.phi1 = 603;\n      e.kappa = 549;\n      e.lambda = 549;\n      e.mu = 576;\n      e.nu = 521;\n      e.omicron = 549;\n      e.pi = 549;\n      e.theta = 521;\n      e.rho = 549;\n      e.sigma = 603;\n      e.tau = 439;\n      e.upsilon = 576;\n      e.omega1 = 713;\n      e.omega = 686;\n      e.xi = 493;\n      e.psi = 686;\n      e.zeta = 494;\n      e.braceleft = 480;\n      e.bar = 200;\n      e.braceright = 480;\n      e.similar = 549;\n      e.Euro = 750;\n      e.Upsilon1 = 620;\n      e.minute = 247;\n      e.lessequal = 549;\n      e.fraction = 167;\n      e.infinity = 713;\n      e.florin = 500;\n      e.club = 753;\n      e.diamond = 753;\n      e.heart = 753;\n      e.spade = 753;\n      e.arrowboth = 1042;\n      e.arrowleft = 987;\n      e.arrowup = 603;\n      e.arrowright = 987;\n      e.arrowdown = 603;\n      e.degree = 400;\n      e.plusminus = 549;\n      e.second = 411;\n      e.greaterequal = 549;\n      e.multiply = 549;\n      e.proportional = 713;\n      e.partialdiff = 494;\n      e.bullet = 460;\n      e.divide = 549;\n      e.notequal = 549;\n      e.equivalence = 549;\n      e.approxequal = 549;\n      e.ellipsis = 1e3;\n      e.arrowvertex = 603;\n      e.arrowhorizex = 1e3;\n      e.carriagereturn = 658;\n      e.aleph = 823;\n      e.Ifraktur = 686;\n      e.Rfraktur = 795;\n      e.weierstrass = 987;\n      e.circlemultiply = 768;\n      e.circleplus = 768;\n      e.emptyset = 823;\n      e.intersection = 768;\n      e.union = 768;\n      e.propersuperset = 713;\n      e.reflexsuperset = 713;\n      e.notsubset = 713;\n      e.propersubset = 713;\n      e.reflexsubset = 713;\n      e.element = 713;\n      e.notelement = 713;\n      e.angle = 768;\n      e.gradient = 713;\n      e.registerserif = 790;\n      e.copyrightserif = 790;\n      e.trademarkserif = 890;\n      e.product = 823;\n      e.radical = 549;\n      e.dotmath = 250;\n      e.logicalnot = 713;\n      e.logicaland = 603;\n      e.logicalor = 603;\n      e.arrowdblboth = 1042;\n      e.arrowdblleft = 987;\n      e.arrowdblup = 603;\n      e.arrowdblright = 987;\n      e.arrowdbldown = 603;\n      e.lozenge = 494;\n      e.angleleft = 329;\n      e.registersans = 790;\n      e.copyrightsans = 790;\n      e.trademarksans = 786;\n      e.summation = 713;\n      e.parenlefttp = 384;\n      e.parenleftex = 384;\n      e.parenleftbt = 384;\n      e.bracketlefttp = 384;\n      e.bracketleftex = 384;\n      e.bracketleftbt = 384;\n      e.bracelefttp = 494;\n      e.braceleftmid = 494;\n      e.braceleftbt = 494;\n      e.braceex = 494;\n      e.angleright = 329;\n      e.integral = 274;\n      e.integraltp = 686;\n      e.integralex = 686;\n      e.integralbt = 686;\n      e.parenrighttp = 384;\n      e.parenrightex = 384;\n      e.parenrightbt = 384;\n      e.bracketrighttp = 384;\n      e.bracketrightex = 384;\n      e.bracketrightbt = 384;\n      e.bracerighttp = 494;\n      e.bracerightmid = 494;\n      e.bracerightbt = 494;\n      e.apple = 790;\n    });\n    e[\"Times-Roman\"] = getLookupTableFactory(function (e) {\n      e.space = 250;\n      e.exclam = 333;\n      e.quotedbl = 408;\n      e.numbersign = 500;\n      e.dollar = 500;\n      e.percent = 833;\n      e.ampersand = 778;\n      e.quoteright = 333;\n      e.parenleft = 333;\n      e.parenright = 333;\n      e.asterisk = 500;\n      e.plus = 564;\n      e.comma = 250;\n      e.hyphen = 333;\n      e.period = 250;\n      e.slash = 278;\n      e.zero = 500;\n      e.one = 500;\n      e.two = 500;\n      e.three = 500;\n      e.four = 500;\n      e.five = 500;\n      e.six = 500;\n      e.seven = 500;\n      e.eight = 500;\n      e.nine = 500;\n      e.colon = 278;\n      e.semicolon = 278;\n      e.less = 564;\n      e.equal = 564;\n      e.greater = 564;\n      e.question = 444;\n      e.at = 921;\n      e.A = 722;\n      e.B = 667;\n      e.C = 667;\n      e.D = 722;\n      e.E = 611;\n      e.F = 556;\n      e.G = 722;\n      e.H = 722;\n      e.I = 333;\n      e.J = 389;\n      e.K = 722;\n      e.L = 611;\n      e.M = 889;\n      e.N = 722;\n      e.O = 722;\n      e.P = 556;\n      e.Q = 722;\n      e.R = 667;\n      e.S = 556;\n      e.T = 611;\n      e.U = 722;\n      e.V = 722;\n      e.W = 944;\n      e.X = 722;\n      e.Y = 722;\n      e.Z = 611;\n      e.bracketleft = 333;\n      e.backslash = 278;\n      e.bracketright = 333;\n      e.asciicircum = 469;\n      e.underscore = 500;\n      e.quoteleft = 333;\n      e.a = 444;\n      e.b = 500;\n      e.c = 444;\n      e.d = 500;\n      e.e = 444;\n      e.f = 333;\n      e.g = 500;\n      e.h = 500;\n      e.i = 278;\n      e.j = 278;\n      e.k = 500;\n      e.l = 278;\n      e.m = 778;\n      e.n = 500;\n      e.o = 500;\n      e.p = 500;\n      e.q = 500;\n      e.r = 333;\n      e.s = 389;\n      e.t = 278;\n      e.u = 500;\n      e.v = 500;\n      e.w = 722;\n      e.x = 500;\n      e.y = 500;\n      e.z = 444;\n      e.braceleft = 480;\n      e.bar = 200;\n      e.braceright = 480;\n      e.asciitilde = 541;\n      e.exclamdown = 333;\n      e.cent = 500;\n      e.sterling = 500;\n      e.fraction = 167;\n      e.yen = 500;\n      e.florin = 500;\n      e.section = 500;\n      e.currency = 500;\n      e.quotesingle = 180;\n      e.quotedblleft = 444;\n      e.guillemotleft = 500;\n      e.guilsinglleft = 333;\n      e.guilsinglright = 333;\n      e.fi = 556;\n      e.fl = 556;\n      e.endash = 500;\n      e.dagger = 500;\n      e.daggerdbl = 500;\n      e.periodcentered = 250;\n      e.paragraph = 453;\n      e.bullet = 350;\n      e.quotesinglbase = 333;\n      e.quotedblbase = 444;\n      e.quotedblright = 444;\n      e.guillemotright = 500;\n      e.ellipsis = 1e3;\n      e.perthousand = 1e3;\n      e.questiondown = 444;\n      e.grave = 333;\n      e.acute = 333;\n      e.circumflex = 333;\n      e.tilde = 333;\n      e.macron = 333;\n      e.breve = 333;\n      e.dotaccent = 333;\n      e.dieresis = 333;\n      e.ring = 333;\n      e.cedilla = 333;\n      e.hungarumlaut = 333;\n      e.ogonek = 333;\n      e.caron = 333;\n      e.emdash = 1e3;\n      e.AE = 889;\n      e.ordfeminine = 276;\n      e.Lslash = 611;\n      e.Oslash = 722;\n      e.OE = 889;\n      e.ordmasculine = 310;\n      e.ae = 667;\n      e.dotlessi = 278;\n      e.lslash = 278;\n      e.oslash = 500;\n      e.oe = 722;\n      e.germandbls = 500;\n      e.Idieresis = 333;\n      e.eacute = 444;\n      e.abreve = 444;\n      e.uhungarumlaut = 500;\n      e.ecaron = 444;\n      e.Ydieresis = 722;\n      e.divide = 564;\n      e.Yacute = 722;\n      e.Acircumflex = 722;\n      e.aacute = 444;\n      e.Ucircumflex = 722;\n      e.yacute = 500;\n      e.scommaaccent = 389;\n      e.ecircumflex = 444;\n      e.Uring = 722;\n      e.Udieresis = 722;\n      e.aogonek = 444;\n      e.Uacute = 722;\n      e.uogonek = 500;\n      e.Edieresis = 611;\n      e.Dcroat = 722;\n      e.commaaccent = 250;\n      e.copyright = 760;\n      e.Emacron = 611;\n      e.ccaron = 444;\n      e.aring = 444;\n      e.Ncommaaccent = 722;\n      e.lacute = 278;\n      e.agrave = 444;\n      e.Tcommaaccent = 611;\n      e.Cacute = 667;\n      e.atilde = 444;\n      e.Edotaccent = 611;\n      e.scaron = 389;\n      e.scedilla = 389;\n      e.iacute = 278;\n      e.lozenge = 471;\n      e.Rcaron = 667;\n      e.Gcommaaccent = 722;\n      e.ucircumflex = 500;\n      e.acircumflex = 444;\n      e.Amacron = 722;\n      e.rcaron = 333;\n      e.ccedilla = 444;\n      e.Zdotaccent = 611;\n      e.Thorn = 556;\n      e.Omacron = 722;\n      e.Racute = 667;\n      e.Sacute = 556;\n      e.dcaron = 588;\n      e.Umacron = 722;\n      e.uring = 500;\n      e.threesuperior = 300;\n      e.Ograve = 722;\n      e.Agrave = 722;\n      e.Abreve = 722;\n      e.multiply = 564;\n      e.uacute = 500;\n      e.Tcaron = 611;\n      e.partialdiff = 476;\n      e.ydieresis = 500;\n      e.Nacute = 722;\n      e.icircumflex = 278;\n      e.Ecircumflex = 611;\n      e.adieresis = 444;\n      e.edieresis = 444;\n      e.cacute = 444;\n      e.nacute = 500;\n      e.umacron = 500;\n      e.Ncaron = 722;\n      e.Iacute = 333;\n      e.plusminus = 564;\n      e.brokenbar = 200;\n      e.registered = 760;\n      e.Gbreve = 722;\n      e.Idotaccent = 333;\n      e.summation = 600;\n      e.Egrave = 611;\n      e.racute = 333;\n      e.omacron = 500;\n      e.Zacute = 611;\n      e.Zcaron = 611;\n      e.greaterequal = 549;\n      e.Eth = 722;\n      e.Ccedilla = 667;\n      e.lcommaaccent = 278;\n      e.tcaron = 326;\n      e.eogonek = 444;\n      e.Uogonek = 722;\n      e.Aacute = 722;\n      e.Adieresis = 722;\n      e.egrave = 444;\n      e.zacute = 444;\n      e.iogonek = 278;\n      e.Oacute = 722;\n      e.oacute = 500;\n      e.amacron = 444;\n      e.sacute = 389;\n      e.idieresis = 278;\n      e.Ocircumflex = 722;\n      e.Ugrave = 722;\n      e.Delta = 612;\n      e.thorn = 500;\n      e.twosuperior = 300;\n      e.Odieresis = 722;\n      e.mu = 500;\n      e.igrave = 278;\n      e.ohungarumlaut = 500;\n      e.Eogonek = 611;\n      e.dcroat = 500;\n      e.threequarters = 750;\n      e.Scedilla = 556;\n      e.lcaron = 344;\n      e.Kcommaaccent = 722;\n      e.Lacute = 611;\n      e.trademark = 980;\n      e.edotaccent = 444;\n      e.Igrave = 333;\n      e.Imacron = 333;\n      e.Lcaron = 611;\n      e.onehalf = 750;\n      e.lessequal = 549;\n      e.ocircumflex = 500;\n      e.ntilde = 500;\n      e.Uhungarumlaut = 722;\n      e.Eacute = 611;\n      e.emacron = 444;\n      e.gbreve = 500;\n      e.onequarter = 750;\n      e.Scaron = 556;\n      e.Scommaaccent = 556;\n      e.Ohungarumlaut = 722;\n      e.degree = 400;\n      e.ograve = 500;\n      e.Ccaron = 667;\n      e.ugrave = 500;\n      e.radical = 453;\n      e.Dcaron = 722;\n      e.rcommaaccent = 333;\n      e.Ntilde = 722;\n      e.otilde = 500;\n      e.Rcommaaccent = 667;\n      e.Lcommaaccent = 611;\n      e.Atilde = 722;\n      e.Aogonek = 722;\n      e.Aring = 722;\n      e.Otilde = 722;\n      e.zdotaccent = 444;\n      e.Ecaron = 611;\n      e.Iogonek = 333;\n      e.kcommaaccent = 500;\n      e.minus = 564;\n      e.Icircumflex = 333;\n      e.ncaron = 500;\n      e.tcommaaccent = 278;\n      e.logicalnot = 564;\n      e.odieresis = 500;\n      e.udieresis = 500;\n      e.notequal = 549;\n      e.gcommaaccent = 500;\n      e.eth = 500;\n      e.zcaron = 444;\n      e.ncommaaccent = 500;\n      e.onesuperior = 300;\n      e.imacron = 278;\n      e.Euro = 500;\n    });\n    e[\"Times-Bold\"] = getLookupTableFactory(function (e) {\n      e.space = 250;\n      e.exclam = 333;\n      e.quotedbl = 555;\n      e.numbersign = 500;\n      e.dollar = 500;\n      e.percent = 1e3;\n      e.ampersand = 833;\n      e.quoteright = 333;\n      e.parenleft = 333;\n      e.parenright = 333;\n      e.asterisk = 500;\n      e.plus = 570;\n      e.comma = 250;\n      e.hyphen = 333;\n      e.period = 250;\n      e.slash = 278;\n      e.zero = 500;\n      e.one = 500;\n      e.two = 500;\n      e.three = 500;\n      e.four = 500;\n      e.five = 500;\n      e.six = 500;\n      e.seven = 500;\n      e.eight = 500;\n      e.nine = 500;\n      e.colon = 333;\n      e.semicolon = 333;\n      e.less = 570;\n      e.equal = 570;\n      e.greater = 570;\n      e.question = 500;\n      e.at = 930;\n      e.A = 722;\n      e.B = 667;\n      e.C = 722;\n      e.D = 722;\n      e.E = 667;\n      e.F = 611;\n      e.G = 778;\n      e.H = 778;\n      e.I = 389;\n      e.J = 500;\n      e.K = 778;\n      e.L = 667;\n      e.M = 944;\n      e.N = 722;\n      e.O = 778;\n      e.P = 611;\n      e.Q = 778;\n      e.R = 722;\n      e.S = 556;\n      e.T = 667;\n      e.U = 722;\n      e.V = 722;\n      e.W = 1e3;\n      e.X = 722;\n      e.Y = 722;\n      e.Z = 667;\n      e.bracketleft = 333;\n      e.backslash = 278;\n      e.bracketright = 333;\n      e.asciicircum = 581;\n      e.underscore = 500;\n      e.quoteleft = 333;\n      e.a = 500;\n      e.b = 556;\n      e.c = 444;\n      e.d = 556;\n      e.e = 444;\n      e.f = 333;\n      e.g = 500;\n      e.h = 556;\n      e.i = 278;\n      e.j = 333;\n      e.k = 556;\n      e.l = 278;\n      e.m = 833;\n      e.n = 556;\n      e.o = 500;\n      e.p = 556;\n      e.q = 556;\n      e.r = 444;\n      e.s = 389;\n      e.t = 333;\n      e.u = 556;\n      e.v = 500;\n      e.w = 722;\n      e.x = 500;\n      e.y = 500;\n      e.z = 444;\n      e.braceleft = 394;\n      e.bar = 220;\n      e.braceright = 394;\n      e.asciitilde = 520;\n      e.exclamdown = 333;\n      e.cent = 500;\n      e.sterling = 500;\n      e.fraction = 167;\n      e.yen = 500;\n      e.florin = 500;\n      e.section = 500;\n      e.currency = 500;\n      e.quotesingle = 278;\n      e.quotedblleft = 500;\n      e.guillemotleft = 500;\n      e.guilsinglleft = 333;\n      e.guilsinglright = 333;\n      e.fi = 556;\n      e.fl = 556;\n      e.endash = 500;\n      e.dagger = 500;\n      e.daggerdbl = 500;\n      e.periodcentered = 250;\n      e.paragraph = 540;\n      e.bullet = 350;\n      e.quotesinglbase = 333;\n      e.quotedblbase = 500;\n      e.quotedblright = 500;\n      e.guillemotright = 500;\n      e.ellipsis = 1e3;\n      e.perthousand = 1e3;\n      e.questiondown = 500;\n      e.grave = 333;\n      e.acute = 333;\n      e.circumflex = 333;\n      e.tilde = 333;\n      e.macron = 333;\n      e.breve = 333;\n      e.dotaccent = 333;\n      e.dieresis = 333;\n      e.ring = 333;\n      e.cedilla = 333;\n      e.hungarumlaut = 333;\n      e.ogonek = 333;\n      e.caron = 333;\n      e.emdash = 1e3;\n      e.AE = 1e3;\n      e.ordfeminine = 300;\n      e.Lslash = 667;\n      e.Oslash = 778;\n      e.OE = 1e3;\n      e.ordmasculine = 330;\n      e.ae = 722;\n      e.dotlessi = 278;\n      e.lslash = 278;\n      e.oslash = 500;\n      e.oe = 722;\n      e.germandbls = 556;\n      e.Idieresis = 389;\n      e.eacute = 444;\n      e.abreve = 500;\n      e.uhungarumlaut = 556;\n      e.ecaron = 444;\n      e.Ydieresis = 722;\n      e.divide = 570;\n      e.Yacute = 722;\n      e.Acircumflex = 722;\n      e.aacute = 500;\n      e.Ucircumflex = 722;\n      e.yacute = 500;\n      e.scommaaccent = 389;\n      e.ecircumflex = 444;\n      e.Uring = 722;\n      e.Udieresis = 722;\n      e.aogonek = 500;\n      e.Uacute = 722;\n      e.uogonek = 556;\n      e.Edieresis = 667;\n      e.Dcroat = 722;\n      e.commaaccent = 250;\n      e.copyright = 747;\n      e.Emacron = 667;\n      e.ccaron = 444;\n      e.aring = 500;\n      e.Ncommaaccent = 722;\n      e.lacute = 278;\n      e.agrave = 500;\n      e.Tcommaaccent = 667;\n      e.Cacute = 722;\n      e.atilde = 500;\n      e.Edotaccent = 667;\n      e.scaron = 389;\n      e.scedilla = 389;\n      e.iacute = 278;\n      e.lozenge = 494;\n      e.Rcaron = 722;\n      e.Gcommaaccent = 778;\n      e.ucircumflex = 556;\n      e.acircumflex = 500;\n      e.Amacron = 722;\n      e.rcaron = 444;\n      e.ccedilla = 444;\n      e.Zdotaccent = 667;\n      e.Thorn = 611;\n      e.Omacron = 778;\n      e.Racute = 722;\n      e.Sacute = 556;\n      e.dcaron = 672;\n      e.Umacron = 722;\n      e.uring = 556;\n      e.threesuperior = 300;\n      e.Ograve = 778;\n      e.Agrave = 722;\n      e.Abreve = 722;\n      e.multiply = 570;\n      e.uacute = 556;\n      e.Tcaron = 667;\n      e.partialdiff = 494;\n      e.ydieresis = 500;\n      e.Nacute = 722;\n      e.icircumflex = 278;\n      e.Ecircumflex = 667;\n      e.adieresis = 500;\n      e.edieresis = 444;\n      e.cacute = 444;\n      e.nacute = 556;\n      e.umacron = 556;\n      e.Ncaron = 722;\n      e.Iacute = 389;\n      e.plusminus = 570;\n      e.brokenbar = 220;\n      e.registered = 747;\n      e.Gbreve = 778;\n      e.Idotaccent = 389;\n      e.summation = 600;\n      e.Egrave = 667;\n      e.racute = 444;\n      e.omacron = 500;\n      e.Zacute = 667;\n      e.Zcaron = 667;\n      e.greaterequal = 549;\n      e.Eth = 722;\n      e.Ccedilla = 722;\n      e.lcommaaccent = 278;\n      e.tcaron = 416;\n      e.eogonek = 444;\n      e.Uogonek = 722;\n      e.Aacute = 722;\n      e.Adieresis = 722;\n      e.egrave = 444;\n      e.zacute = 444;\n      e.iogonek = 278;\n      e.Oacute = 778;\n      e.oacute = 500;\n      e.amacron = 500;\n      e.sacute = 389;\n      e.idieresis = 278;\n      e.Ocircumflex = 778;\n      e.Ugrave = 722;\n      e.Delta = 612;\n      e.thorn = 556;\n      e.twosuperior = 300;\n      e.Odieresis = 778;\n      e.mu = 556;\n      e.igrave = 278;\n      e.ohungarumlaut = 500;\n      e.Eogonek = 667;\n      e.dcroat = 556;\n      e.threequarters = 750;\n      e.Scedilla = 556;\n      e.lcaron = 394;\n      e.Kcommaaccent = 778;\n      e.Lacute = 667;\n      e.trademark = 1e3;\n      e.edotaccent = 444;\n      e.Igrave = 389;\n      e.Imacron = 389;\n      e.Lcaron = 667;\n      e.onehalf = 750;\n      e.lessequal = 549;\n      e.ocircumflex = 500;\n      e.ntilde = 556;\n      e.Uhungarumlaut = 722;\n      e.Eacute = 667;\n      e.emacron = 444;\n      e.gbreve = 500;\n      e.onequarter = 750;\n      e.Scaron = 556;\n      e.Scommaaccent = 556;\n      e.Ohungarumlaut = 778;\n      e.degree = 400;\n      e.ograve = 500;\n      e.Ccaron = 722;\n      e.ugrave = 556;\n      e.radical = 549;\n      e.Dcaron = 722;\n      e.rcommaaccent = 444;\n      e.Ntilde = 722;\n      e.otilde = 500;\n      e.Rcommaaccent = 722;\n      e.Lcommaaccent = 667;\n      e.Atilde = 722;\n      e.Aogonek = 722;\n      e.Aring = 722;\n      e.Otilde = 778;\n      e.zdotaccent = 444;\n      e.Ecaron = 667;\n      e.Iogonek = 389;\n      e.kcommaaccent = 556;\n      e.minus = 570;\n      e.Icircumflex = 389;\n      e.ncaron = 556;\n      e.tcommaaccent = 333;\n      e.logicalnot = 570;\n      e.odieresis = 500;\n      e.udieresis = 556;\n      e.notequal = 549;\n      e.gcommaaccent = 500;\n      e.eth = 500;\n      e.zcaron = 444;\n      e.ncommaaccent = 556;\n      e.onesuperior = 300;\n      e.imacron = 278;\n      e.Euro = 500;\n    });\n    e[\"Times-BoldItalic\"] = getLookupTableFactory(function (e) {\n      e.space = 250;\n      e.exclam = 389;\n      e.quotedbl = 555;\n      e.numbersign = 500;\n      e.dollar = 500;\n      e.percent = 833;\n      e.ampersand = 778;\n      e.quoteright = 333;\n      e.parenleft = 333;\n      e.parenright = 333;\n      e.asterisk = 500;\n      e.plus = 570;\n      e.comma = 250;\n      e.hyphen = 333;\n      e.period = 250;\n      e.slash = 278;\n      e.zero = 500;\n      e.one = 500;\n      e.two = 500;\n      e.three = 500;\n      e.four = 500;\n      e.five = 500;\n      e.six = 500;\n      e.seven = 500;\n      e.eight = 500;\n      e.nine = 500;\n      e.colon = 333;\n      e.semicolon = 333;\n      e.less = 570;\n      e.equal = 570;\n      e.greater = 570;\n      e.question = 500;\n      e.at = 832;\n      e.A = 667;\n      e.B = 667;\n      e.C = 667;\n      e.D = 722;\n      e.E = 667;\n      e.F = 667;\n      e.G = 722;\n      e.H = 778;\n      e.I = 389;\n      e.J = 500;\n      e.K = 667;\n      e.L = 611;\n      e.M = 889;\n      e.N = 722;\n      e.O = 722;\n      e.P = 611;\n      e.Q = 722;\n      e.R = 667;\n      e.S = 556;\n      e.T = 611;\n      e.U = 722;\n      e.V = 667;\n      e.W = 889;\n      e.X = 667;\n      e.Y = 611;\n      e.Z = 611;\n      e.bracketleft = 333;\n      e.backslash = 278;\n      e.bracketright = 333;\n      e.asciicircum = 570;\n      e.underscore = 500;\n      e.quoteleft = 333;\n      e.a = 500;\n      e.b = 500;\n      e.c = 444;\n      e.d = 500;\n      e.e = 444;\n      e.f = 333;\n      e.g = 500;\n      e.h = 556;\n      e.i = 278;\n      e.j = 278;\n      e.k = 500;\n      e.l = 278;\n      e.m = 778;\n      e.n = 556;\n      e.o = 500;\n      e.p = 500;\n      e.q = 500;\n      e.r = 389;\n      e.s = 389;\n      e.t = 278;\n      e.u = 556;\n      e.v = 444;\n      e.w = 667;\n      e.x = 500;\n      e.y = 444;\n      e.z = 389;\n      e.braceleft = 348;\n      e.bar = 220;\n      e.braceright = 348;\n      e.asciitilde = 570;\n      e.exclamdown = 389;\n      e.cent = 500;\n      e.sterling = 500;\n      e.fraction = 167;\n      e.yen = 500;\n      e.florin = 500;\n      e.section = 500;\n      e.currency = 500;\n      e.quotesingle = 278;\n      e.quotedblleft = 500;\n      e.guillemotleft = 500;\n      e.guilsinglleft = 333;\n      e.guilsinglright = 333;\n      e.fi = 556;\n      e.fl = 556;\n      e.endash = 500;\n      e.dagger = 500;\n      e.daggerdbl = 500;\n      e.periodcentered = 250;\n      e.paragraph = 500;\n      e.bullet = 350;\n      e.quotesinglbase = 333;\n      e.quotedblbase = 500;\n      e.quotedblright = 500;\n      e.guillemotright = 500;\n      e.ellipsis = 1e3;\n      e.perthousand = 1e3;\n      e.questiondown = 500;\n      e.grave = 333;\n      e.acute = 333;\n      e.circumflex = 333;\n      e.tilde = 333;\n      e.macron = 333;\n      e.breve = 333;\n      e.dotaccent = 333;\n      e.dieresis = 333;\n      e.ring = 333;\n      e.cedilla = 333;\n      e.hungarumlaut = 333;\n      e.ogonek = 333;\n      e.caron = 333;\n      e.emdash = 1e3;\n      e.AE = 944;\n      e.ordfeminine = 266;\n      e.Lslash = 611;\n      e.Oslash = 722;\n      e.OE = 944;\n      e.ordmasculine = 300;\n      e.ae = 722;\n      e.dotlessi = 278;\n      e.lslash = 278;\n      e.oslash = 500;\n      e.oe = 722;\n      e.germandbls = 500;\n      e.Idieresis = 389;\n      e.eacute = 444;\n      e.abreve = 500;\n      e.uhungarumlaut = 556;\n      e.ecaron = 444;\n      e.Ydieresis = 611;\n      e.divide = 570;\n      e.Yacute = 611;\n      e.Acircumflex = 667;\n      e.aacute = 500;\n      e.Ucircumflex = 722;\n      e.yacute = 444;\n      e.scommaaccent = 389;\n      e.ecircumflex = 444;\n      e.Uring = 722;\n      e.Udieresis = 722;\n      e.aogonek = 500;\n      e.Uacute = 722;\n      e.uogonek = 556;\n      e.Edieresis = 667;\n      e.Dcroat = 722;\n      e.commaaccent = 250;\n      e.copyright = 747;\n      e.Emacron = 667;\n      e.ccaron = 444;\n      e.aring = 500;\n      e.Ncommaaccent = 722;\n      e.lacute = 278;\n      e.agrave = 500;\n      e.Tcommaaccent = 611;\n      e.Cacute = 667;\n      e.atilde = 500;\n      e.Edotaccent = 667;\n      e.scaron = 389;\n      e.scedilla = 389;\n      e.iacute = 278;\n      e.lozenge = 494;\n      e.Rcaron = 667;\n      e.Gcommaaccent = 722;\n      e.ucircumflex = 556;\n      e.acircumflex = 500;\n      e.Amacron = 667;\n      e.rcaron = 389;\n      e.ccedilla = 444;\n      e.Zdotaccent = 611;\n      e.Thorn = 611;\n      e.Omacron = 722;\n      e.Racute = 667;\n      e.Sacute = 556;\n      e.dcaron = 608;\n      e.Umacron = 722;\n      e.uring = 556;\n      e.threesuperior = 300;\n      e.Ograve = 722;\n      e.Agrave = 667;\n      e.Abreve = 667;\n      e.multiply = 570;\n      e.uacute = 556;\n      e.Tcaron = 611;\n      e.partialdiff = 494;\n      e.ydieresis = 444;\n      e.Nacute = 722;\n      e.icircumflex = 278;\n      e.Ecircumflex = 667;\n      e.adieresis = 500;\n      e.edieresis = 444;\n      e.cacute = 444;\n      e.nacute = 556;\n      e.umacron = 556;\n      e.Ncaron = 722;\n      e.Iacute = 389;\n      e.plusminus = 570;\n      e.brokenbar = 220;\n      e.registered = 747;\n      e.Gbreve = 722;\n      e.Idotaccent = 389;\n      e.summation = 600;\n      e.Egrave = 667;\n      e.racute = 389;\n      e.omacron = 500;\n      e.Zacute = 611;\n      e.Zcaron = 611;\n      e.greaterequal = 549;\n      e.Eth = 722;\n      e.Ccedilla = 667;\n      e.lcommaaccent = 278;\n      e.tcaron = 366;\n      e.eogonek = 444;\n      e.Uogonek = 722;\n      e.Aacute = 667;\n      e.Adieresis = 667;\n      e.egrave = 444;\n      e.zacute = 389;\n      e.iogonek = 278;\n      e.Oacute = 722;\n      e.oacute = 500;\n      e.amacron = 500;\n      e.sacute = 389;\n      e.idieresis = 278;\n      e.Ocircumflex = 722;\n      e.Ugrave = 722;\n      e.Delta = 612;\n      e.thorn = 500;\n      e.twosuperior = 300;\n      e.Odieresis = 722;\n      e.mu = 576;\n      e.igrave = 278;\n      e.ohungarumlaut = 500;\n      e.Eogonek = 667;\n      e.dcroat = 500;\n      e.threequarters = 750;\n      e.Scedilla = 556;\n      e.lcaron = 382;\n      e.Kcommaaccent = 667;\n      e.Lacute = 611;\n      e.trademark = 1e3;\n      e.edotaccent = 444;\n      e.Igrave = 389;\n      e.Imacron = 389;\n      e.Lcaron = 611;\n      e.onehalf = 750;\n      e.lessequal = 549;\n      e.ocircumflex = 500;\n      e.ntilde = 556;\n      e.Uhungarumlaut = 722;\n      e.Eacute = 667;\n      e.emacron = 444;\n      e.gbreve = 500;\n      e.onequarter = 750;\n      e.Scaron = 556;\n      e.Scommaaccent = 556;\n      e.Ohungarumlaut = 722;\n      e.degree = 400;\n      e.ograve = 500;\n      e.Ccaron = 667;\n      e.ugrave = 556;\n      e.radical = 549;\n      e.Dcaron = 722;\n      e.rcommaaccent = 389;\n      e.Ntilde = 722;\n      e.otilde = 500;\n      e.Rcommaaccent = 667;\n      e.Lcommaaccent = 611;\n      e.Atilde = 667;\n      e.Aogonek = 667;\n      e.Aring = 667;\n      e.Otilde = 722;\n      e.zdotaccent = 389;\n      e.Ecaron = 667;\n      e.Iogonek = 389;\n      e.kcommaaccent = 500;\n      e.minus = 606;\n      e.Icircumflex = 389;\n      e.ncaron = 556;\n      e.tcommaaccent = 278;\n      e.logicalnot = 606;\n      e.odieresis = 500;\n      e.udieresis = 556;\n      e.notequal = 549;\n      e.gcommaaccent = 500;\n      e.eth = 500;\n      e.zcaron = 389;\n      e.ncommaaccent = 556;\n      e.onesuperior = 300;\n      e.imacron = 278;\n      e.Euro = 500;\n    });\n    e[\"Times-Italic\"] = getLookupTableFactory(function (e) {\n      e.space = 250;\n      e.exclam = 333;\n      e.quotedbl = 420;\n      e.numbersign = 500;\n      e.dollar = 500;\n      e.percent = 833;\n      e.ampersand = 778;\n      e.quoteright = 333;\n      e.parenleft = 333;\n      e.parenright = 333;\n      e.asterisk = 500;\n      e.plus = 675;\n      e.comma = 250;\n      e.hyphen = 333;\n      e.period = 250;\n      e.slash = 278;\n      e.zero = 500;\n      e.one = 500;\n      e.two = 500;\n      e.three = 500;\n      e.four = 500;\n      e.five = 500;\n      e.six = 500;\n      e.seven = 500;\n      e.eight = 500;\n      e.nine = 500;\n      e.colon = 333;\n      e.semicolon = 333;\n      e.less = 675;\n      e.equal = 675;\n      e.greater = 675;\n      e.question = 500;\n      e.at = 920;\n      e.A = 611;\n      e.B = 611;\n      e.C = 667;\n      e.D = 722;\n      e.E = 611;\n      e.F = 611;\n      e.G = 722;\n      e.H = 722;\n      e.I = 333;\n      e.J = 444;\n      e.K = 667;\n      e.L = 556;\n      e.M = 833;\n      e.N = 667;\n      e.O = 722;\n      e.P = 611;\n      e.Q = 722;\n      e.R = 611;\n      e.S = 500;\n      e.T = 556;\n      e.U = 722;\n      e.V = 611;\n      e.W = 833;\n      e.X = 611;\n      e.Y = 556;\n      e.Z = 556;\n      e.bracketleft = 389;\n      e.backslash = 278;\n      e.bracketright = 389;\n      e.asciicircum = 422;\n      e.underscore = 500;\n      e.quoteleft = 333;\n      e.a = 500;\n      e.b = 500;\n      e.c = 444;\n      e.d = 500;\n      e.e = 444;\n      e.f = 278;\n      e.g = 500;\n      e.h = 500;\n      e.i = 278;\n      e.j = 278;\n      e.k = 444;\n      e.l = 278;\n      e.m = 722;\n      e.n = 500;\n      e.o = 500;\n      e.p = 500;\n      e.q = 500;\n      e.r = 389;\n      e.s = 389;\n      e.t = 278;\n      e.u = 500;\n      e.v = 444;\n      e.w = 667;\n      e.x = 444;\n      e.y = 444;\n      e.z = 389;\n      e.braceleft = 400;\n      e.bar = 275;\n      e.braceright = 400;\n      e.asciitilde = 541;\n      e.exclamdown = 389;\n      e.cent = 500;\n      e.sterling = 500;\n      e.fraction = 167;\n      e.yen = 500;\n      e.florin = 500;\n      e.section = 500;\n      e.currency = 500;\n      e.quotesingle = 214;\n      e.quotedblleft = 556;\n      e.guillemotleft = 500;\n      e.guilsinglleft = 333;\n      e.guilsinglright = 333;\n      e.fi = 500;\n      e.fl = 500;\n      e.endash = 500;\n      e.dagger = 500;\n      e.daggerdbl = 500;\n      e.periodcentered = 250;\n      e.paragraph = 523;\n      e.bullet = 350;\n      e.quotesinglbase = 333;\n      e.quotedblbase = 556;\n      e.quotedblright = 556;\n      e.guillemotright = 500;\n      e.ellipsis = 889;\n      e.perthousand = 1e3;\n      e.questiondown = 500;\n      e.grave = 333;\n      e.acute = 333;\n      e.circumflex = 333;\n      e.tilde = 333;\n      e.macron = 333;\n      e.breve = 333;\n      e.dotaccent = 333;\n      e.dieresis = 333;\n      e.ring = 333;\n      e.cedilla = 333;\n      e.hungarumlaut = 333;\n      e.ogonek = 333;\n      e.caron = 333;\n      e.emdash = 889;\n      e.AE = 889;\n      e.ordfeminine = 276;\n      e.Lslash = 556;\n      e.Oslash = 722;\n      e.OE = 944;\n      e.ordmasculine = 310;\n      e.ae = 667;\n      e.dotlessi = 278;\n      e.lslash = 278;\n      e.oslash = 500;\n      e.oe = 667;\n      e.germandbls = 500;\n      e.Idieresis = 333;\n      e.eacute = 444;\n      e.abreve = 500;\n      e.uhungarumlaut = 500;\n      e.ecaron = 444;\n      e.Ydieresis = 556;\n      e.divide = 675;\n      e.Yacute = 556;\n      e.Acircumflex = 611;\n      e.aacute = 500;\n      e.Ucircumflex = 722;\n      e.yacute = 444;\n      e.scommaaccent = 389;\n      e.ecircumflex = 444;\n      e.Uring = 722;\n      e.Udieresis = 722;\n      e.aogonek = 500;\n      e.Uacute = 722;\n      e.uogonek = 500;\n      e.Edieresis = 611;\n      e.Dcroat = 722;\n      e.commaaccent = 250;\n      e.copyright = 760;\n      e.Emacron = 611;\n      e.ccaron = 444;\n      e.aring = 500;\n      e.Ncommaaccent = 667;\n      e.lacute = 278;\n      e.agrave = 500;\n      e.Tcommaaccent = 556;\n      e.Cacute = 667;\n      e.atilde = 500;\n      e.Edotaccent = 611;\n      e.scaron = 389;\n      e.scedilla = 389;\n      e.iacute = 278;\n      e.lozenge = 471;\n      e.Rcaron = 611;\n      e.Gcommaaccent = 722;\n      e.ucircumflex = 500;\n      e.acircumflex = 500;\n      e.Amacron = 611;\n      e.rcaron = 389;\n      e.ccedilla = 444;\n      e.Zdotaccent = 556;\n      e.Thorn = 611;\n      e.Omacron = 722;\n      e.Racute = 611;\n      e.Sacute = 500;\n      e.dcaron = 544;\n      e.Umacron = 722;\n      e.uring = 500;\n      e.threesuperior = 300;\n      e.Ograve = 722;\n      e.Agrave = 611;\n      e.Abreve = 611;\n      e.multiply = 675;\n      e.uacute = 500;\n      e.Tcaron = 556;\n      e.partialdiff = 476;\n      e.ydieresis = 444;\n      e.Nacute = 667;\n      e.icircumflex = 278;\n      e.Ecircumflex = 611;\n      e.adieresis = 500;\n      e.edieresis = 444;\n      e.cacute = 444;\n      e.nacute = 500;\n      e.umacron = 500;\n      e.Ncaron = 667;\n      e.Iacute = 333;\n      e.plusminus = 675;\n      e.brokenbar = 275;\n      e.registered = 760;\n      e.Gbreve = 722;\n      e.Idotaccent = 333;\n      e.summation = 600;\n      e.Egrave = 611;\n      e.racute = 389;\n      e.omacron = 500;\n      e.Zacute = 556;\n      e.Zcaron = 556;\n      e.greaterequal = 549;\n      e.Eth = 722;\n      e.Ccedilla = 667;\n      e.lcommaaccent = 278;\n      e.tcaron = 300;\n      e.eogonek = 444;\n      e.Uogonek = 722;\n      e.Aacute = 611;\n      e.Adieresis = 611;\n      e.egrave = 444;\n      e.zacute = 389;\n      e.iogonek = 278;\n      e.Oacute = 722;\n      e.oacute = 500;\n      e.amacron = 500;\n      e.sacute = 389;\n      e.idieresis = 278;\n      e.Ocircumflex = 722;\n      e.Ugrave = 722;\n      e.Delta = 612;\n      e.thorn = 500;\n      e.twosuperior = 300;\n      e.Odieresis = 722;\n      e.mu = 500;\n      e.igrave = 278;\n      e.ohungarumlaut = 500;\n      e.Eogonek = 611;\n      e.dcroat = 500;\n      e.threequarters = 750;\n      e.Scedilla = 500;\n      e.lcaron = 300;\n      e.Kcommaaccent = 667;\n      e.Lacute = 556;\n      e.trademark = 980;\n      e.edotaccent = 444;\n      e.Igrave = 333;\n      e.Imacron = 333;\n      e.Lcaron = 611;\n      e.onehalf = 750;\n      e.lessequal = 549;\n      e.ocircumflex = 500;\n      e.ntilde = 500;\n      e.Uhungarumlaut = 722;\n      e.Eacute = 611;\n      e.emacron = 444;\n      e.gbreve = 500;\n      e.onequarter = 750;\n      e.Scaron = 500;\n      e.Scommaaccent = 500;\n      e.Ohungarumlaut = 722;\n      e.degree = 400;\n      e.ograve = 500;\n      e.Ccaron = 667;\n      e.ugrave = 500;\n      e.radical = 453;\n      e.Dcaron = 722;\n      e.rcommaaccent = 389;\n      e.Ntilde = 667;\n      e.otilde = 500;\n      e.Rcommaaccent = 611;\n      e.Lcommaaccent = 556;\n      e.Atilde = 611;\n      e.Aogonek = 611;\n      e.Aring = 611;\n      e.Otilde = 722;\n      e.zdotaccent = 389;\n      e.Ecaron = 611;\n      e.Iogonek = 333;\n      e.kcommaaccent = 444;\n      e.minus = 675;\n      e.Icircumflex = 333;\n      e.ncaron = 500;\n      e.tcommaaccent = 278;\n      e.logicalnot = 675;\n      e.odieresis = 500;\n      e.udieresis = 500;\n      e.notequal = 549;\n      e.gcommaaccent = 500;\n      e.eth = 500;\n      e.zcaron = 389;\n      e.ncommaaccent = 500;\n      e.onesuperior = 300;\n      e.imacron = 278;\n      e.Euro = 500;\n    });\n    e.ZapfDingbats = getLookupTableFactory(function (e) {\n      e.space = 278;\n      e.a1 = 974;\n      e.a2 = 961;\n      e.a202 = 974;\n      e.a3 = 980;\n      e.a4 = 719;\n      e.a5 = 789;\n      e.a119 = 790;\n      e.a118 = 791;\n      e.a117 = 690;\n      e.a11 = 960;\n      e.a12 = 939;\n      e.a13 = 549;\n      e.a14 = 855;\n      e.a15 = 911;\n      e.a16 = 933;\n      e.a105 = 911;\n      e.a17 = 945;\n      e.a18 = 974;\n      e.a19 = 755;\n      e.a20 = 846;\n      e.a21 = 762;\n      e.a22 = 761;\n      e.a23 = 571;\n      e.a24 = 677;\n      e.a25 = 763;\n      e.a26 = 760;\n      e.a27 = 759;\n      e.a28 = 754;\n      e.a6 = 494;\n      e.a7 = 552;\n      e.a8 = 537;\n      e.a9 = 577;\n      e.a10 = 692;\n      e.a29 = 786;\n      e.a30 = 788;\n      e.a31 = 788;\n      e.a32 = 790;\n      e.a33 = 793;\n      e.a34 = 794;\n      e.a35 = 816;\n      e.a36 = 823;\n      e.a37 = 789;\n      e.a38 = 841;\n      e.a39 = 823;\n      e.a40 = 833;\n      e.a41 = 816;\n      e.a42 = 831;\n      e.a43 = 923;\n      e.a44 = 744;\n      e.a45 = 723;\n      e.a46 = 749;\n      e.a47 = 790;\n      e.a48 = 792;\n      e.a49 = 695;\n      e.a50 = 776;\n      e.a51 = 768;\n      e.a52 = 792;\n      e.a53 = 759;\n      e.a54 = 707;\n      e.a55 = 708;\n      e.a56 = 682;\n      e.a57 = 701;\n      e.a58 = 826;\n      e.a59 = 815;\n      e.a60 = 789;\n      e.a61 = 789;\n      e.a62 = 707;\n      e.a63 = 687;\n      e.a64 = 696;\n      e.a65 = 689;\n      e.a66 = 786;\n      e.a67 = 787;\n      e.a68 = 713;\n      e.a69 = 791;\n      e.a70 = 785;\n      e.a71 = 791;\n      e.a72 = 873;\n      e.a73 = 761;\n      e.a74 = 762;\n      e.a203 = 762;\n      e.a75 = 759;\n      e.a204 = 759;\n      e.a76 = 892;\n      e.a77 = 892;\n      e.a78 = 788;\n      e.a79 = 784;\n      e.a81 = 438;\n      e.a82 = 138;\n      e.a83 = 277;\n      e.a84 = 415;\n      e.a97 = 392;\n      e.a98 = 392;\n      e.a99 = 668;\n      e.a100 = 668;\n      e.a89 = 390;\n      e.a90 = 390;\n      e.a93 = 317;\n      e.a94 = 317;\n      e.a91 = 276;\n      e.a92 = 276;\n      e.a205 = 509;\n      e.a85 = 509;\n      e.a206 = 410;\n      e.a86 = 410;\n      e.a87 = 234;\n      e.a88 = 234;\n      e.a95 = 334;\n      e.a96 = 334;\n      e.a101 = 732;\n      e.a102 = 544;\n      e.a103 = 544;\n      e.a104 = 910;\n      e.a106 = 667;\n      e.a107 = 760;\n      e.a108 = 760;\n      e.a112 = 776;\n      e.a111 = 595;\n      e.a110 = 694;\n      e.a109 = 626;\n      e.a120 = 788;\n      e.a121 = 788;\n      e.a122 = 788;\n      e.a123 = 788;\n      e.a124 = 788;\n      e.a125 = 788;\n      e.a126 = 788;\n      e.a127 = 788;\n      e.a128 = 788;\n      e.a129 = 788;\n      e.a130 = 788;\n      e.a131 = 788;\n      e.a132 = 788;\n      e.a133 = 788;\n      e.a134 = 788;\n      e.a135 = 788;\n      e.a136 = 788;\n      e.a137 = 788;\n      e.a138 = 788;\n      e.a139 = 788;\n      e.a140 = 788;\n      e.a141 = 788;\n      e.a142 = 788;\n      e.a143 = 788;\n      e.a144 = 788;\n      e.a145 = 788;\n      e.a146 = 788;\n      e.a147 = 788;\n      e.a148 = 788;\n      e.a149 = 788;\n      e.a150 = 788;\n      e.a151 = 788;\n      e.a152 = 788;\n      e.a153 = 788;\n      e.a154 = 788;\n      e.a155 = 788;\n      e.a156 = 788;\n      e.a157 = 788;\n      e.a158 = 788;\n      e.a159 = 788;\n      e.a160 = 894;\n      e.a161 = 838;\n      e.a163 = 1016;\n      e.a164 = 458;\n      e.a196 = 748;\n      e.a165 = 924;\n      e.a192 = 748;\n      e.a166 = 918;\n      e.a167 = 927;\n      e.a168 = 928;\n      e.a169 = 928;\n      e.a170 = 834;\n      e.a171 = 873;\n      e.a172 = 828;\n      e.a173 = 924;\n      e.a162 = 924;\n      e.a174 = 917;\n      e.a175 = 930;\n      e.a176 = 931;\n      e.a177 = 463;\n      e.a178 = 883;\n      e.a179 = 836;\n      e.a193 = 836;\n      e.a180 = 867;\n      e.a199 = 867;\n      e.a181 = 696;\n      e.a200 = 696;\n      e.a182 = 874;\n      e.a201 = 874;\n      e.a183 = 760;\n      e.a184 = 946;\n      e.a197 = 771;\n      e.a185 = 865;\n      e.a194 = 771;\n      e.a198 = 888;\n      e.a186 = 967;\n      e.a195 = 888;\n      e.a187 = 831;\n      e.a188 = 873;\n      e.a189 = 927;\n      e.a190 = 970;\n      e.a191 = 918;\n    });\n  }),\n  ea = getLookupTableFactory(function (e) {\n    e.Courier = {\n      ascent: 629,\n      descent: -157,\n      capHeight: 562,\n      xHeight: -426\n    };\n    e[\"Courier-Bold\"] = {\n      ascent: 629,\n      descent: -157,\n      capHeight: 562,\n      xHeight: 439\n    };\n    e[\"Courier-Oblique\"] = {\n      ascent: 629,\n      descent: -157,\n      capHeight: 562,\n      xHeight: 426\n    };\n    e[\"Courier-BoldOblique\"] = {\n      ascent: 629,\n      descent: -157,\n      capHeight: 562,\n      xHeight: 426\n    };\n    e.Helvetica = {\n      ascent: 718,\n      descent: -207,\n      capHeight: 718,\n      xHeight: 523\n    };\n    e[\"Helvetica-Bold\"] = {\n      ascent: 718,\n      descent: -207,\n      capHeight: 718,\n      xHeight: 532\n    };\n    e[\"Helvetica-Oblique\"] = {\n      ascent: 718,\n      descent: -207,\n      capHeight: 718,\n      xHeight: 523\n    };\n    e[\"Helvetica-BoldOblique\"] = {\n      ascent: 718,\n      descent: -207,\n      capHeight: 718,\n      xHeight: 532\n    };\n    e[\"Times-Roman\"] = {\n      ascent: 683,\n      descent: -217,\n      capHeight: 662,\n      xHeight: 450\n    };\n    e[\"Times-Bold\"] = {\n      ascent: 683,\n      descent: -217,\n      capHeight: 676,\n      xHeight: 461\n    };\n    e[\"Times-Italic\"] = {\n      ascent: 683,\n      descent: -217,\n      capHeight: 653,\n      xHeight: 441\n    };\n    e[\"Times-BoldItalic\"] = {\n      ascent: 683,\n      descent: -217,\n      capHeight: 669,\n      xHeight: 462\n    };\n    e.Symbol = {\n      ascent: Math.NaN,\n      descent: Math.NaN,\n      capHeight: Math.NaN,\n      xHeight: Math.NaN\n    };\n    e.ZapfDingbats = {\n      ascent: Math.NaN,\n      descent: Math.NaN,\n      capHeight: Math.NaN,\n      xHeight: Math.NaN\n    };\n  });\nclass GlyfTable {\n  constructor({\n    glyfTable: e,\n    isGlyphLocationsLong: t,\n    locaTable: i,\n    numGlyphs: a\n  }) {\n    this.glyphs = [];\n    const s = new DataView(i.buffer, i.byteOffset, i.byteLength),\n      r = new DataView(e.buffer, e.byteOffset, e.byteLength),\n      n = t ? 4 : 2;\n    let g = t ? s.getUint32(0) : 2 * s.getUint16(0),\n      o = 0;\n    for (let e = 0; e < a; e++) {\n      o += n;\n      const e = t ? s.getUint32(o) : 2 * s.getUint16(o);\n      if (e === g) {\n        this.glyphs.push(new Glyph({}));\n        continue;\n      }\n      const i = Glyph.parse(g, r);\n      this.glyphs.push(i);\n      g = e;\n    }\n  }\n  getSize() {\n    return this.glyphs.reduce((e, t) => e + (t.getSize() + 3 & -4), 0);\n  }\n  write() {\n    const e = this.getSize(),\n      t = new DataView(new ArrayBuffer(e)),\n      i = e > 131070,\n      a = i ? 4 : 2,\n      s = new DataView(new ArrayBuffer((this.glyphs.length + 1) * a));\n    i ? s.setUint32(0, 0) : s.setUint16(0, 0);\n    let r = 0,\n      n = 0;\n    for (const e of this.glyphs) {\n      r += e.write(r, t);\n      r = r + 3 & -4;\n      n += a;\n      i ? s.setUint32(n, r) : s.setUint16(n, r >> 1);\n    }\n    return {\n      isLocationLong: i,\n      loca: new Uint8Array(s.buffer),\n      glyf: new Uint8Array(t.buffer)\n    };\n  }\n  scale(e) {\n    for (let t = 0, i = this.glyphs.length; t < i; t++) this.glyphs[t].scale(e[t]);\n  }\n}\nclass Glyph {\n  constructor({\n    header: e = null,\n    simple: t = null,\n    composites: i = null\n  }) {\n    this.header = e;\n    this.simple = t;\n    this.composites = i;\n  }\n  static parse(e, t) {\n    const [i, a] = GlyphHeader.parse(e, t);\n    e += i;\n    if (a.numberOfContours < 0) {\n      const i = [];\n      for (;;) {\n        const [a, s] = CompositeGlyph.parse(e, t);\n        e += a;\n        i.push(s);\n        if (!(32 & s.flags)) break;\n      }\n      return new Glyph({\n        header: a,\n        composites: i\n      });\n    }\n    const s = SimpleGlyph.parse(e, t, a.numberOfContours);\n    return new Glyph({\n      header: a,\n      simple: s\n    });\n  }\n  getSize() {\n    if (!this.header) return 0;\n    const e = this.simple ? this.simple.getSize() : this.composites.reduce((e, t) => e + t.getSize(), 0);\n    return this.header.getSize() + e;\n  }\n  write(e, t) {\n    if (!this.header) return 0;\n    const i = e;\n    e += this.header.write(e, t);\n    if (this.simple) e += this.simple.write(e, t);else for (const i of this.composites) e += i.write(e, t);\n    return e - i;\n  }\n  scale(e) {\n    if (!this.header) return;\n    const t = (this.header.xMin + this.header.xMax) / 2;\n    this.header.scale(t, e);\n    if (this.simple) this.simple.scale(t, e);else for (const i of this.composites) i.scale(t, e);\n  }\n}\nclass GlyphHeader {\n  constructor({\n    numberOfContours: e,\n    xMin: t,\n    yMin: i,\n    xMax: a,\n    yMax: s\n  }) {\n    this.numberOfContours = e;\n    this.xMin = t;\n    this.yMin = i;\n    this.xMax = a;\n    this.yMax = s;\n  }\n  static parse(e, t) {\n    return [10, new GlyphHeader({\n      numberOfContours: t.getInt16(e),\n      xMin: t.getInt16(e + 2),\n      yMin: t.getInt16(e + 4),\n      xMax: t.getInt16(e + 6),\n      yMax: t.getInt16(e + 8)\n    })];\n  }\n  getSize() {\n    return 10;\n  }\n  write(e, t) {\n    t.setInt16(e, this.numberOfContours);\n    t.setInt16(e + 2, this.xMin);\n    t.setInt16(e + 4, this.yMin);\n    t.setInt16(e + 6, this.xMax);\n    t.setInt16(e + 8, this.yMax);\n    return 10;\n  }\n  scale(e, t) {\n    this.xMin = Math.round(e + (this.xMin - e) * t);\n    this.xMax = Math.round(e + (this.xMax - e) * t);\n  }\n}\nclass Contour {\n  constructor({\n    flags: e,\n    xCoordinates: t,\n    yCoordinates: i\n  }) {\n    this.xCoordinates = t;\n    this.yCoordinates = i;\n    this.flags = e;\n  }\n}\nclass SimpleGlyph {\n  constructor({\n    contours: e,\n    instructions: t\n  }) {\n    this.contours = e;\n    this.instructions = t;\n  }\n  static parse(e, t, i) {\n    const a = [];\n    for (let s = 0; s < i; s++) {\n      const i = t.getUint16(e);\n      e += 2;\n      a.push(i);\n    }\n    const s = a[i - 1] + 1,\n      r = t.getUint16(e);\n    e += 2;\n    const n = new Uint8Array(t).slice(e, e + r);\n    e += r;\n    const g = [];\n    for (let i = 0; i < s; e++, i++) {\n      let a = t.getUint8(e);\n      g.push(a);\n      if (8 & a) {\n        const s = t.getUint8(++e);\n        a ^= 8;\n        for (let e = 0; e < s; e++) g.push(a);\n        i += s;\n      }\n    }\n    const o = [];\n    let c = [],\n      C = [],\n      h = [];\n    const l = [];\n    let Q = 0,\n      E = 0;\n    for (let i = 0; i < s; i++) {\n      const s = g[i];\n      if (2 & s) {\n        const i = t.getUint8(e++);\n        E += 16 & s ? i : -i;\n        c.push(E);\n      } else if (16 & s) c.push(E);else {\n        E += t.getInt16(e);\n        e += 2;\n        c.push(E);\n      }\n      if (a[Q] === i) {\n        Q++;\n        o.push(c);\n        c = [];\n      }\n    }\n    E = 0;\n    Q = 0;\n    for (let i = 0; i < s; i++) {\n      const s = g[i];\n      if (4 & s) {\n        const i = t.getUint8(e++);\n        E += 32 & s ? i : -i;\n        C.push(E);\n      } else if (32 & s) C.push(E);else {\n        E += t.getInt16(e);\n        e += 2;\n        C.push(E);\n      }\n      h.push(1 & s | 64 & s);\n      if (a[Q] === i) {\n        c = o[Q];\n        Q++;\n        l.push(new Contour({\n          flags: h,\n          xCoordinates: c,\n          yCoordinates: C\n        }));\n        C = [];\n        h = [];\n      }\n    }\n    return new SimpleGlyph({\n      contours: l,\n      instructions: n\n    });\n  }\n  getSize() {\n    let e = 2 * this.contours.length + 2 + this.instructions.length,\n      t = 0,\n      i = 0;\n    for (const a of this.contours) {\n      e += a.flags.length;\n      for (let s = 0, r = a.xCoordinates.length; s < r; s++) {\n        const r = a.xCoordinates[s],\n          n = a.yCoordinates[s];\n        let g = Math.abs(r - t);\n        g > 255 ? e += 2 : g > 0 && (e += 1);\n        t = r;\n        g = Math.abs(n - i);\n        g > 255 ? e += 2 : g > 0 && (e += 1);\n        i = n;\n      }\n    }\n    return e;\n  }\n  write(e, t) {\n    const i = e,\n      a = [],\n      s = [],\n      r = [];\n    let n = 0,\n      g = 0;\n    for (const i of this.contours) {\n      for (let e = 0, t = i.xCoordinates.length; e < t; e++) {\n        let t = i.flags[e];\n        const o = i.xCoordinates[e];\n        let c = o - n;\n        if (0 === c) {\n          t |= 16;\n          a.push(0);\n        } else {\n          const e = Math.abs(c);\n          if (e <= 255) {\n            t |= c >= 0 ? 18 : 2;\n            a.push(e);\n          } else a.push(c);\n        }\n        n = o;\n        const C = i.yCoordinates[e];\n        c = C - g;\n        if (0 === c) {\n          t |= 32;\n          s.push(0);\n        } else {\n          const e = Math.abs(c);\n          if (e <= 255) {\n            t |= c >= 0 ? 36 : 4;\n            s.push(e);\n          } else s.push(c);\n        }\n        g = C;\n        r.push(t);\n      }\n      t.setUint16(e, a.length - 1);\n      e += 2;\n    }\n    t.setUint16(e, this.instructions.length);\n    e += 2;\n    if (this.instructions.length) {\n      new Uint8Array(t.buffer, 0, t.buffer.byteLength).set(this.instructions, e);\n      e += this.instructions.length;\n    }\n    for (const i of r) t.setUint8(e++, i);\n    for (let i = 0, s = a.length; i < s; i++) {\n      const s = a[i],\n        n = r[i];\n      if (2 & n) t.setUint8(e++, s);else if (!(16 & n)) {\n        t.setInt16(e, s);\n        e += 2;\n      }\n    }\n    for (let i = 0, a = s.length; i < a; i++) {\n      const a = s[i],\n        n = r[i];\n      if (4 & n) t.setUint8(e++, a);else if (!(32 & n)) {\n        t.setInt16(e, a);\n        e += 2;\n      }\n    }\n    return e - i;\n  }\n  scale(e, t) {\n    for (const i of this.contours) if (0 !== i.xCoordinates.length) for (let a = 0, s = i.xCoordinates.length; a < s; a++) i.xCoordinates[a] = Math.round(e + (i.xCoordinates[a] - e) * t);\n  }\n}\nclass CompositeGlyph {\n  constructor({\n    flags: e,\n    glyphIndex: t,\n    argument1: i,\n    argument2: a,\n    transf: s,\n    instructions: r\n  }) {\n    this.flags = e;\n    this.glyphIndex = t;\n    this.argument1 = i;\n    this.argument2 = a;\n    this.transf = s;\n    this.instructions = r;\n  }\n  static parse(e, t) {\n    const i = e,\n      a = [];\n    let s = t.getUint16(e);\n    const r = t.getUint16(e + 2);\n    e += 4;\n    let n, g;\n    if (1 & s) {\n      if (2 & s) {\n        n = t.getInt16(e);\n        g = t.getInt16(e + 2);\n      } else {\n        n = t.getUint16(e);\n        g = t.getUint16(e + 2);\n      }\n      e += 4;\n      s ^= 1;\n    } else {\n      if (2 & s) {\n        n = t.getInt8(e);\n        g = t.getInt8(e + 1);\n      } else {\n        n = t.getUint8(e);\n        g = t.getUint8(e + 1);\n      }\n      e += 2;\n    }\n    if (8 & s) {\n      a.push(t.getUint16(e));\n      e += 2;\n    } else if (64 & s) {\n      a.push(t.getUint16(e), t.getUint16(e + 2));\n      e += 4;\n    } else if (128 & s) {\n      a.push(t.getUint16(e), t.getUint16(e + 2), t.getUint16(e + 4), t.getUint16(e + 6));\n      e += 8;\n    }\n    let o = null;\n    if (256 & s) {\n      const i = t.getUint16(e);\n      e += 2;\n      o = new Uint8Array(t).slice(e, e + i);\n      e += i;\n    }\n    return [e - i, new CompositeGlyph({\n      flags: s,\n      glyphIndex: r,\n      argument1: n,\n      argument2: g,\n      transf: a,\n      instructions: o\n    })];\n  }\n  getSize() {\n    let e = 4 + 2 * this.transf.length;\n    256 & this.flags && (e += 2 + this.instructions.length);\n    e += 2;\n    2 & this.flags ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (e += 2) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (e += 2);\n    return e;\n  }\n  write(e, t) {\n    const i = e;\n    2 & this.flags ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (this.flags |= 1) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (this.flags |= 1);\n    t.setUint16(e, this.flags);\n    t.setUint16(e + 2, this.glyphIndex);\n    e += 4;\n    if (1 & this.flags) {\n      if (2 & this.flags) {\n        t.setInt16(e, this.argument1);\n        t.setInt16(e + 2, this.argument2);\n      } else {\n        t.setUint16(e, this.argument1);\n        t.setUint16(e + 2, this.argument2);\n      }\n      e += 4;\n    } else {\n      t.setUint8(e, this.argument1);\n      t.setUint8(e + 1, this.argument2);\n      e += 2;\n    }\n    if (256 & this.flags) {\n      t.setUint16(e, this.instructions.length);\n      e += 2;\n      if (this.instructions.length) {\n        new Uint8Array(t.buffer, 0, t.buffer.byteLength).set(this.instructions, e);\n        e += this.instructions.length;\n      }\n    }\n    return e - i;\n  }\n  scale(e, t) {}\n}\nfunction writeInt16(e, t, i) {\n  e[t] = i >> 8 & 255;\n  e[t + 1] = 255 & i;\n}\nfunction writeInt32(e, t, i) {\n  e[t] = i >> 24 & 255;\n  e[t + 1] = i >> 16 & 255;\n  e[t + 2] = i >> 8 & 255;\n  e[t + 3] = 255 & i;\n}\nfunction writeData(e, t, i) {\n  if (i instanceof Uint8Array) e.set(i, t);else if (\"string\" == typeof i) for (let a = 0, s = i.length; a < s; a++) e[t++] = 255 & i.charCodeAt(a);else for (const a of i) e[t++] = 255 & a;\n}\nclass OpenTypeFileBuilder {\n  constructor(e) {\n    this.sfnt = e;\n    this.tables = Object.create(null);\n  }\n  static getSearchParams(e, t) {\n    let i = 1,\n      a = 0;\n    for (; (i ^ e) > i;) {\n      i <<= 1;\n      a++;\n    }\n    const s = i * t;\n    return {\n      range: s,\n      entry: a,\n      rangeShift: t * e - s\n    };\n  }\n  toArray() {\n    let e = this.sfnt;\n    const t = this.tables,\n      i = Object.keys(t);\n    i.sort();\n    const a = i.length;\n    let s,\n      r,\n      n,\n      g,\n      o,\n      c = 12 + 16 * a;\n    const C = [c];\n    for (s = 0; s < a; s++) {\n      g = t[i[s]];\n      c += (g.length + 3 & -4) >>> 0;\n      C.push(c);\n    }\n    const h = new Uint8Array(c);\n    for (s = 0; s < a; s++) {\n      g = t[i[s]];\n      writeData(h, C[s], g);\n    }\n    \"true\" === e && (e = string32(65536));\n    h[0] = 255 & e.charCodeAt(0);\n    h[1] = 255 & e.charCodeAt(1);\n    h[2] = 255 & e.charCodeAt(2);\n    h[3] = 255 & e.charCodeAt(3);\n    writeInt16(h, 4, a);\n    const l = OpenTypeFileBuilder.getSearchParams(a, 16);\n    writeInt16(h, 6, l.range);\n    writeInt16(h, 8, l.entry);\n    writeInt16(h, 10, l.rangeShift);\n    c = 12;\n    for (s = 0; s < a; s++) {\n      o = i[s];\n      h[c] = 255 & o.charCodeAt(0);\n      h[c + 1] = 255 & o.charCodeAt(1);\n      h[c + 2] = 255 & o.charCodeAt(2);\n      h[c + 3] = 255 & o.charCodeAt(3);\n      let e = 0;\n      for (r = C[s], n = C[s + 1]; r < n; r += 4) {\n        e = e + readUint32(h, r) >>> 0;\n      }\n      writeInt32(h, c + 4, e);\n      writeInt32(h, c + 8, C[s]);\n      writeInt32(h, c + 12, t[o].length);\n      c += 16;\n    }\n    return h;\n  }\n  addTable(e, t) {\n    if (e in this.tables) throw new Error(\"Table \" + e + \" already exists\");\n    this.tables[e] = t;\n  }\n}\nconst ta = [4],\n  ia = [5],\n  aa = [6],\n  sa = [7],\n  ra = [8],\n  na = [12, 35],\n  ga = [14],\n  oa = [21],\n  Ia = [22],\n  ca = [30],\n  Ca = [31];\nclass Type1CharString {\n  constructor() {\n    this.width = 0;\n    this.lsb = 0;\n    this.flexing = !1;\n    this.output = [];\n    this.stack = [];\n  }\n  convert(e, t, i) {\n    const a = e.length;\n    let s,\n      r,\n      n,\n      g = !1;\n    for (let o = 0; o < a; o++) {\n      let a = e[o];\n      if (a < 32) {\n        12 === a && (a = (a << 8) + e[++o]);\n        switch (a) {\n          case 1:\n          case 3:\n          case 9:\n          case 3072:\n          case 3073:\n          case 3074:\n          case 3105:\n            this.stack = [];\n            break;\n          case 4:\n            if (this.flexing) {\n              if (this.stack.length < 1) {\n                g = !0;\n                break;\n              }\n              const e = this.stack.pop();\n              this.stack.push(0, e);\n              break;\n            }\n            g = this.executeCommand(1, ta);\n            break;\n          case 5:\n            g = this.executeCommand(2, ia);\n            break;\n          case 6:\n            g = this.executeCommand(1, aa);\n            break;\n          case 7:\n            g = this.executeCommand(1, sa);\n            break;\n          case 8:\n            g = this.executeCommand(6, ra);\n            break;\n          case 10:\n            if (this.stack.length < 1) {\n              g = !0;\n              break;\n            }\n            n = this.stack.pop();\n            if (!t[n]) {\n              g = !0;\n              break;\n            }\n            g = this.convert(t[n], t, i);\n            break;\n          case 11:\n            return g;\n          case 13:\n            if (this.stack.length < 2) {\n              g = !0;\n              break;\n            }\n            s = this.stack.pop();\n            r = this.stack.pop();\n            this.lsb = r;\n            this.width = s;\n            this.stack.push(s, r);\n            g = this.executeCommand(2, Ia);\n            break;\n          case 14:\n            this.output.push(ga[0]);\n            break;\n          case 21:\n            if (this.flexing) break;\n            g = this.executeCommand(2, oa);\n            break;\n          case 22:\n            if (this.flexing) {\n              this.stack.push(0);\n              break;\n            }\n            g = this.executeCommand(1, Ia);\n            break;\n          case 30:\n            g = this.executeCommand(4, ca);\n            break;\n          case 31:\n            g = this.executeCommand(4, Ca);\n            break;\n          case 3078:\n            if (i) {\n              const e = this.stack.at(-5);\n              this.seac = this.stack.splice(-4, 4);\n              this.seac[0] += this.lsb - e;\n              g = this.executeCommand(0, ga);\n            } else g = this.executeCommand(4, ga);\n            break;\n          case 3079:\n            if (this.stack.length < 4) {\n              g = !0;\n              break;\n            }\n            this.stack.pop();\n            s = this.stack.pop();\n            const e = this.stack.pop();\n            r = this.stack.pop();\n            this.lsb = r;\n            this.width = s;\n            this.stack.push(s, r, e);\n            g = this.executeCommand(3, oa);\n            break;\n          case 3084:\n            if (this.stack.length < 2) {\n              g = !0;\n              break;\n            }\n            const o = this.stack.pop(),\n              c = this.stack.pop();\n            this.stack.push(c / o);\n            break;\n          case 3088:\n            if (this.stack.length < 2) {\n              g = !0;\n              break;\n            }\n            n = this.stack.pop();\n            const C = this.stack.pop();\n            if (0 === n && 3 === C) {\n              const e = this.stack.splice(-17, 17);\n              this.stack.push(e[2] + e[0], e[3] + e[1], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14]);\n              g = this.executeCommand(13, na, !0);\n              this.flexing = !1;\n              this.stack.push(e[15], e[16]);\n            } else 1 === n && 0 === C && (this.flexing = !0);\n            break;\n          case 3089:\n            break;\n          default:\n            warn('Unknown type 1 charstring command of \"' + a + '\"');\n        }\n        if (g) break;\n      } else {\n        a <= 246 ? a -= 139 : a = a <= 250 ? 256 * (a - 247) + e[++o] + 108 : a <= 254 ? -256 * (a - 251) - e[++o] - 108 : (255 & e[++o]) << 24 | (255 & e[++o]) << 16 | (255 & e[++o]) << 8 | (255 & e[++o]) << 0;\n        this.stack.push(a);\n      }\n    }\n    return g;\n  }\n  executeCommand(e, t, i) {\n    const a = this.stack.length;\n    if (e > a) return !0;\n    const s = a - e;\n    for (let e = s; e < a; e++) {\n      let t = this.stack[e];\n      if (Number.isInteger(t)) this.output.push(28, t >> 8 & 255, 255 & t);else {\n        t = 65536 * t | 0;\n        this.output.push(255, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t);\n      }\n    }\n    this.output.push(...t);\n    i ? this.stack.splice(s, e) : this.stack.length = 0;\n    return !1;\n  }\n}\nfunction isHexDigit(e) {\n  return e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102;\n}\nfunction decrypt(e, t, i) {\n  if (i >= e.length) return new Uint8Array(0);\n  let a,\n    s,\n    r = 0 | t;\n  for (a = 0; a < i; a++) r = 52845 * (e[a] + r) + 22719 & 65535;\n  const n = e.length - i,\n    g = new Uint8Array(n);\n  for (a = i, s = 0; s < n; a++, s++) {\n    const t = e[a];\n    g[s] = t ^ r >> 8;\n    r = 52845 * (t + r) + 22719 & 65535;\n  }\n  return g;\n}\nfunction isSpecial(e) {\n  return 47 === e || 91 === e || 93 === e || 123 === e || 125 === e || 40 === e || 41 === e;\n}\nclass Type1Parser {\n  constructor(e, t, i) {\n    if (t) {\n      const t = e.getBytes(),\n        i = !((isHexDigit(t[0]) || isWhiteSpace(t[0])) && isHexDigit(t[1]) && isHexDigit(t[2]) && isHexDigit(t[3]) && isHexDigit(t[4]) && isHexDigit(t[5]) && isHexDigit(t[6]) && isHexDigit(t[7]));\n      e = new Stream(i ? decrypt(t, 55665, 4) : function decryptAscii(e, t, i) {\n        let a = 0 | t;\n        const s = e.length,\n          r = new Uint8Array(s >>> 1);\n        let n, g;\n        for (n = 0, g = 0; n < s; n++) {\n          const t = e[n];\n          if (!isHexDigit(t)) continue;\n          n++;\n          let i;\n          for (; n < s && !isHexDigit(i = e[n]);) n++;\n          if (n < s) {\n            const e = parseInt(String.fromCharCode(t, i), 16);\n            r[g++] = e ^ a >> 8;\n            a = 52845 * (e + a) + 22719 & 65535;\n          }\n        }\n        return r.slice(i, g);\n      }(t, 55665, 4));\n    }\n    this.seacAnalysisEnabled = !!i;\n    this.stream = e;\n    this.nextChar();\n  }\n  readNumberArray() {\n    this.getToken();\n    const e = [];\n    for (;;) {\n      const t = this.getToken();\n      if (null === t || \"]\" === t || \"}\" === t) break;\n      e.push(parseFloat(t || 0));\n    }\n    return e;\n  }\n  readNumber() {\n    const e = this.getToken();\n    return parseFloat(e || 0);\n  }\n  readInt() {\n    const e = this.getToken();\n    return 0 | parseInt(e || 0, 10);\n  }\n  readBoolean() {\n    return \"true\" === this.getToken() ? 1 : 0;\n  }\n  nextChar() {\n    return this.currentChar = this.stream.getByte();\n  }\n  prevChar() {\n    this.stream.skip(-2);\n    return this.currentChar = this.stream.getByte();\n  }\n  getToken() {\n    let e = !1,\n      t = this.currentChar;\n    for (;;) {\n      if (-1 === t) return null;\n      if (e) 10 !== t && 13 !== t || (e = !1);else if (37 === t) e = !0;else if (!isWhiteSpace(t)) break;\n      t = this.nextChar();\n    }\n    if (isSpecial(t)) {\n      this.nextChar();\n      return String.fromCharCode(t);\n    }\n    let i = \"\";\n    do {\n      i += String.fromCharCode(t);\n      t = this.nextChar();\n    } while (t >= 0 && !isWhiteSpace(t) && !isSpecial(t));\n    return i;\n  }\n  readCharStrings(e, t) {\n    return -1 === t ? e : decrypt(e, 4330, t);\n  }\n  extractFontProgram(e) {\n    const t = this.stream,\n      i = [],\n      a = [],\n      s = Object.create(null);\n    s.lenIV = 4;\n    const r = {\n      subrs: [],\n      charstrings: [],\n      properties: {\n        privateData: s\n      }\n    };\n    let n, g, o, c;\n    for (; null !== (n = this.getToken());) if (\"/\" === n) {\n      n = this.getToken();\n      switch (n) {\n        case \"CharStrings\":\n          this.getToken();\n          this.getToken();\n          this.getToken();\n          this.getToken();\n          for (;;) {\n            n = this.getToken();\n            if (null === n || \"end\" === n) break;\n            if (\"/\" !== n) continue;\n            const e = this.getToken();\n            g = this.readInt();\n            this.getToken();\n            o = g > 0 ? t.getBytes(g) : new Uint8Array(0);\n            c = r.properties.privateData.lenIV;\n            const i = this.readCharStrings(o, c);\n            this.nextChar();\n            n = this.getToken();\n            \"noaccess\" === n ? this.getToken() : \"/\" === n && this.prevChar();\n            a.push({\n              glyph: e,\n              encoded: i\n            });\n          }\n          break;\n        case \"Subrs\":\n          this.readInt();\n          this.getToken();\n          for (; \"dup\" === this.getToken();) {\n            const e = this.readInt();\n            g = this.readInt();\n            this.getToken();\n            o = g > 0 ? t.getBytes(g) : new Uint8Array(0);\n            c = r.properties.privateData.lenIV;\n            const a = this.readCharStrings(o, c);\n            this.nextChar();\n            n = this.getToken();\n            \"noaccess\" === n && this.getToken();\n            i[e] = a;\n          }\n          break;\n        case \"BlueValues\":\n        case \"OtherBlues\":\n        case \"FamilyBlues\":\n        case \"FamilyOtherBlues\":\n          const e = this.readNumberArray();\n          e.length > 0 && e.length, 0;\n          break;\n        case \"StemSnapH\":\n        case \"StemSnapV\":\n          r.properties.privateData[n] = this.readNumberArray();\n          break;\n        case \"StdHW\":\n        case \"StdVW\":\n          r.properties.privateData[n] = this.readNumberArray()[0];\n          break;\n        case \"BlueShift\":\n        case \"lenIV\":\n        case \"BlueFuzz\":\n        case \"BlueScale\":\n        case \"LanguageGroup\":\n          r.properties.privateData[n] = this.readNumber();\n          break;\n        case \"ExpansionFactor\":\n          r.properties.privateData[n] = this.readNumber() || .06;\n          break;\n        case \"ForceBold\":\n          r.properties.privateData[n] = this.readBoolean();\n      }\n    }\n    for (const {\n      encoded: t,\n      glyph: s\n    } of a) {\n      const a = new Type1CharString(),\n        n = a.convert(t, i, this.seacAnalysisEnabled);\n      let g = a.output;\n      n && (g = [14]);\n      const o = {\n        glyphName: s,\n        charstring: g,\n        width: a.width,\n        lsb: a.lsb,\n        seac: a.seac\n      };\n      \".notdef\" === s ? r.charstrings.unshift(o) : r.charstrings.push(o);\n      if (e.builtInEncoding) {\n        const t = e.builtInEncoding.indexOf(s);\n        t > -1 && void 0 === e.widths[t] && t >= e.firstChar && t <= e.lastChar && (e.widths[t] = a.width);\n      }\n    }\n    return r;\n  }\n  extractFontHeader(e) {\n    let t;\n    for (; null !== (t = this.getToken());) if (\"/\" === t) {\n      t = this.getToken();\n      switch (t) {\n        case \"FontMatrix\":\n          const i = this.readNumberArray();\n          e.fontMatrix = i;\n          break;\n        case \"Encoding\":\n          const a = this.getToken();\n          let s;\n          if (/^\\d+$/.test(a)) {\n            s = [];\n            const e = 0 | parseInt(a, 10);\n            this.getToken();\n            for (let i = 0; i < e; i++) {\n              t = this.getToken();\n              for (; \"dup\" !== t && \"def\" !== t;) {\n                t = this.getToken();\n                if (null === t) return;\n              }\n              if (\"def\" === t) break;\n              const e = this.readInt();\n              this.getToken();\n              const i = this.getToken();\n              s[e] = i;\n              this.getToken();\n            }\n          } else s = getEncoding(a);\n          e.builtInEncoding = s;\n          break;\n        case \"FontBBox\":\n          const r = this.readNumberArray();\n          e.ascent = Math.max(r[3], r[1]);\n          e.descent = Math.min(r[1], r[3]);\n          e.ascentScaled = !0;\n      }\n    }\n  }\n}\nfunction findBlock(e, t, i) {\n  const a = e.length,\n    s = t.length,\n    r = a - s;\n  let n = i,\n    g = !1;\n  for (; n < r;) {\n    let i = 0;\n    for (; i < s && e[n + i] === t[i];) i++;\n    if (i >= s) {\n      n += i;\n      for (; n < a && isWhiteSpace(e[n]);) n++;\n      g = !0;\n      break;\n    }\n    n++;\n  }\n  return {\n    found: g,\n    length: n\n  };\n}\nclass Type1Font {\n  constructor(e, t, i) {\n    let a = i.length1,\n      s = i.length2,\n      r = t.peekBytes(6);\n    const n = 128 === r[0] && 1 === r[1];\n    if (n) {\n      t.skip(6);\n      a = r[5] << 24 | r[4] << 16 | r[3] << 8 | r[2];\n    }\n    const g = function getHeaderBlock(e, t) {\n      const i = [101, 101, 120, 101, 99],\n        a = e.pos;\n      let s, r, n, g;\n      try {\n        s = e.getBytes(t);\n        r = s.length;\n      } catch {}\n      if (r === t) {\n        n = findBlock(s, i, t - 2 * i.length);\n        if (n.found && n.length === t) return {\n          stream: new Stream(s),\n          length: t\n        };\n      }\n      warn('Invalid \"Length1\" property in Type1 font -- trying to recover.');\n      e.pos = a;\n      for (;;) {\n        n = findBlock(e.peekBytes(2048), i, 0);\n        if (0 === n.length) break;\n        e.pos += n.length;\n        if (n.found) {\n          g = e.pos - a;\n          break;\n        }\n      }\n      e.pos = a;\n      if (g) return {\n        stream: new Stream(e.getBytes(g)),\n        length: g\n      };\n      warn('Unable to recover \"Length1\" property in Type1 font -- using as is.');\n      return {\n        stream: new Stream(e.getBytes(t)),\n        length: t\n      };\n    }(t, a);\n    new Type1Parser(g.stream, !1, Yi).extractFontHeader(i);\n    if (n) {\n      r = t.getBytes(6);\n      s = r[5] << 24 | r[4] << 16 | r[3] << 8 | r[2];\n    }\n    const o = function getEexecBlock(e, t) {\n        const i = e.getBytes();\n        if (0 === i.length) throw new FormatError(\"getEexecBlock - no font program found.\");\n        return {\n          stream: new Stream(i),\n          length: i.length\n        };\n      }(t),\n      c = new Type1Parser(o.stream, !0, Yi).extractFontProgram(i);\n    for (const e in c.properties) i[e] = c.properties[e];\n    const C = c.charstrings,\n      h = this.getType2Charstrings(C),\n      l = this.getType2Subrs(c.subrs);\n    this.charstrings = C;\n    this.data = this.wrap(e, h, this.charstrings, l, i);\n    this.seacs = this.getSeacs(c.charstrings);\n  }\n  get numGlyphs() {\n    return this.charstrings.length + 1;\n  }\n  getCharset() {\n    const e = [\".notdef\"];\n    for (const {\n      glyphName: t\n    } of this.charstrings) e.push(t);\n    return e;\n  }\n  getGlyphMapping(e) {\n    const t = this.charstrings;\n    if (e.composite) {\n      const i = Object.create(null);\n      for (let a = 0, s = t.length; a < s; a++) {\n        i[e.cMap.charCodeOf(a)] = a + 1;\n      }\n      return i;\n    }\n    const i = [\".notdef\"];\n    let a, s;\n    for (s = 0; s < t.length; s++) i.push(t[s].glyphName);\n    const r = e.builtInEncoding;\n    if (r) {\n      a = Object.create(null);\n      for (const e in r) {\n        s = i.indexOf(r[e]);\n        s >= 0 && (a[e] = s);\n      }\n    }\n    return type1FontGlyphMapping(e, a, i);\n  }\n  hasGlyphId(e) {\n    if (e < 0 || e >= this.numGlyphs) return !1;\n    if (0 === e) return !0;\n    return this.charstrings[e - 1].charstring.length > 0;\n  }\n  getSeacs(e) {\n    const t = [];\n    for (let i = 0, a = e.length; i < a; i++) {\n      const a = e[i];\n      a.seac && (t[i + 1] = a.seac);\n    }\n    return t;\n  }\n  getType2Charstrings(e) {\n    const t = [];\n    for (const i of e) t.push(i.charstring);\n    return t;\n  }\n  getType2Subrs(e) {\n    let t = 0;\n    const i = e.length;\n    t = i < 1133 ? 107 : i < 33769 ? 1131 : 32768;\n    const a = [];\n    let s;\n    for (s = 0; s < t; s++) a.push([11]);\n    for (s = 0; s < i; s++) a.push(e[s]);\n    return a;\n  }\n  wrap(e, t, i, a, s) {\n    const r = new CFF();\n    r.header = new CFFHeader(1, 0, 4, 4);\n    r.names = [e];\n    const n = new CFFTopDict();\n    n.setByName(\"version\", 391);\n    n.setByName(\"Notice\", 392);\n    n.setByName(\"FullName\", 393);\n    n.setByName(\"FamilyName\", 394);\n    n.setByName(\"Weight\", 395);\n    n.setByName(\"Encoding\", null);\n    n.setByName(\"FontMatrix\", s.fontMatrix);\n    n.setByName(\"FontBBox\", s.bbox);\n    n.setByName(\"charset\", null);\n    n.setByName(\"CharStrings\", null);\n    n.setByName(\"Private\", null);\n    r.topDict = n;\n    const g = new CFFStrings();\n    g.add(\"Version 0.11\");\n    g.add(\"See original notice\");\n    g.add(e);\n    g.add(e);\n    g.add(\"Medium\");\n    r.strings = g;\n    r.globalSubrIndex = new CFFIndex();\n    const o = t.length,\n      c = [\".notdef\"];\n    let C, h;\n    for (C = 0; C < o; C++) {\n      const e = i[C].glyphName;\n      -1 === wi.indexOf(e) && g.add(e);\n      c.push(e);\n    }\n    r.charset = new CFFCharset(!1, 0, c);\n    const l = new CFFIndex();\n    l.add([139, 14]);\n    for (C = 0; C < o; C++) l.add(t[C]);\n    r.charStrings = l;\n    const Q = new CFFPrivateDict();\n    Q.setByName(\"Subrs\", null);\n    const E = [\"BlueValues\", \"OtherBlues\", \"FamilyBlues\", \"FamilyOtherBlues\", \"StemSnapH\", \"StemSnapV\", \"BlueShift\", \"BlueFuzz\", \"BlueScale\", \"LanguageGroup\", \"ExpansionFactor\", \"ForceBold\", \"StdHW\", \"StdVW\"];\n    for (C = 0, h = E.length; C < h; C++) {\n      const e = E[C];\n      if (!(e in s.privateData)) continue;\n      const t = s.privateData[e];\n      if (Array.isArray(t)) for (let e = t.length - 1; e > 0; e--) t[e] -= t[e - 1];\n      Q.setByName(e, t);\n    }\n    r.topDict.privateDict = Q;\n    const u = new CFFIndex();\n    for (C = 0, h = a.length; C < h; C++) u.add(a[C]);\n    Q.subrsIndex = u;\n    return new CFFCompiler(r).compile();\n  }\n}\nconst ha = [[57344, 63743], [1048576, 1114109]],\n  Ba = 1e3,\n  la = [\"ascent\", \"bbox\", \"black\", \"bold\", \"charProcOperatorList\", \"composite\", \"cssFontInfo\", \"data\", \"defaultVMetrics\", \"defaultWidth\", \"descent\", \"fallbackName\", \"fontMatrix\", \"isInvalidPDFjsFont\", \"isType3Font\", \"italic\", \"loadedName\", \"mimetype\", \"missingFile\", \"name\", \"remeasure\", \"subtype\", \"systemFontInfo\", \"type\", \"vertical\"],\n  Qa = [\"cMap\", \"defaultEncoding\", \"differences\", \"isMonospace\", \"isSerifFont\", \"isSymbolicFont\", \"seacMap\", \"toFontChar\", \"toUnicode\", \"vmetrics\", \"widths\"];\nfunction adjustWidths(e) {\n  if (!e.fontMatrix) return;\n  if (e.fontMatrix[0] === a[0]) return;\n  const t = .001 / e.fontMatrix[0],\n    i = e.widths;\n  for (const e in i) i[e] *= t;\n  e.defaultWidth *= t;\n}\nfunction amendFallbackToUnicode(e) {\n  if (!e.fallbackToUnicode) return;\n  if (e.toUnicode instanceof IdentityToUnicodeMap) return;\n  const t = [];\n  for (const i in e.fallbackToUnicode) e.toUnicode.has(i) || (t[i] = e.fallbackToUnicode[i]);\n  t.length > 0 && e.toUnicode.amend(t);\n}\nclass fonts_Glyph {\n  constructor(e, t, i, a, s, r, n, g, o) {\n    this.originalCharCode = e;\n    this.fontChar = t;\n    this.unicode = i;\n    this.accent = a;\n    this.width = s;\n    this.vmetric = r;\n    this.operatorListId = n;\n    this.isSpace = g;\n    this.isInFont = o;\n  }\n  get category() {\n    return shadow(this, \"category\", function getCharUnicodeCategory(e) {\n      const t = Ji.get(e);\n      if (t) return t;\n      const i = e.match(Hi),\n        a = {\n          isWhitespace: !!i?.[1],\n          isZeroWidthDiacritic: !!i?.[2],\n          isInvisibleFormatMark: !!i?.[3]\n        };\n      Ji.set(e, a);\n      return a;\n    }(this.unicode), !0);\n  }\n}\nfunction int16(e, t) {\n  return (e << 8) + t;\n}\nfunction writeSignedInt16(e, t, i) {\n  e[t + 1] = i;\n  e[t] = i >>> 8;\n}\nfunction signedInt16(e, t) {\n  const i = (e << 8) + t;\n  return 32768 & i ? i - 65536 : i;\n}\nfunction string16(e) {\n  return String.fromCharCode(e >> 8 & 255, 255 & e);\n}\nfunction safeString16(e) {\n  e > 32767 ? e = 32767 : e < -32768 && (e = -32768);\n  return String.fromCharCode(e >> 8 & 255, 255 & e);\n}\nfunction isTrueTypeCollectionFile(e) {\n  return \"ttcf\" === bytesToString(e.peekBytes(4));\n}\nfunction getFontFileType(e, {\n  type: t,\n  subtype: i,\n  composite: a\n}) {\n  let s, r;\n  if (function isTrueTypeFile(e) {\n    const t = e.peekBytes(4);\n    return 65536 === readUint32(t, 0) || \"true\" === bytesToString(t);\n  }(e) || isTrueTypeCollectionFile(e)) s = a ? \"CIDFontType2\" : \"TrueType\";else if (function isOpenTypeFile(e) {\n    return \"OTTO\" === bytesToString(e.peekBytes(4));\n  }(e)) s = a ? \"CIDFontType2\" : \"OpenType\";else if (function isType1File(e) {\n    const t = e.peekBytes(2);\n    return 37 === t[0] && 33 === t[1] || 128 === t[0] && 1 === t[1];\n  }(e)) s = a ? \"CIDFontType0\" : \"MMType1\" === t ? \"MMType1\" : \"Type1\";else if (function isCFFFile(e) {\n    const t = e.peekBytes(4);\n    return t[0] >= 1 && t[3] >= 1 && t[3] <= 4;\n  }(e)) {\n    if (a) {\n      s = \"CIDFontType0\";\n      r = \"CIDFontType0C\";\n    } else {\n      s = \"MMType1\" === t ? \"MMType1\" : \"Type1\";\n      r = \"Type1C\";\n    }\n  } else {\n    warn(\"getFontFileType: Unable to detect correct font file Type/Subtype.\");\n    s = t;\n    r = i;\n  }\n  return [s, r];\n}\nfunction applyStandardFontGlyphMap(e, t) {\n  for (const i in t) e[+i] = t[i];\n}\nfunction buildToFontChar(e, t, i) {\n  const a = [];\n  let s;\n  for (let i = 0, r = e.length; i < r; i++) {\n    s = getUnicodeForGlyph(e[i], t);\n    -1 !== s && (a[i] = s);\n  }\n  for (const e in i) {\n    s = getUnicodeForGlyph(i[e], t);\n    -1 !== s && (a[+e] = s);\n  }\n  return a;\n}\nfunction isMacNameRecord(e) {\n  return 1 === e.platform && 0 === e.encoding && 0 === e.language;\n}\nfunction isWinNameRecord(e) {\n  return 3 === e.platform && 1 === e.encoding && 1033 === e.language;\n}\nfunction convertCidString(e, t, i = !1) {\n  switch (t.length) {\n    case 1:\n      return t.charCodeAt(0);\n    case 2:\n      return t.charCodeAt(0) << 8 | t.charCodeAt(1);\n  }\n  const a = `Unsupported CID string (charCode ${e}): \"${t}\".`;\n  if (i) throw new FormatError(a);\n  warn(a);\n  return t;\n}\nfunction adjustMapping(e, t, i, a) {\n  const s = Object.create(null),\n    r = new Map(),\n    n = [],\n    g = new Set();\n  let o = 0;\n  let c = ha[o][0],\n    C = ha[o][1];\n  for (const l in e) {\n    let Q = e[l];\n    if (!t(Q)) continue;\n    if (c > C) {\n      o++;\n      if (o >= ha.length) {\n        warn(\"Ran out of space in font private use area.\");\n        break;\n      }\n      c = ha[o][0];\n      C = ha[o][1];\n    }\n    const E = c++;\n    0 === Q && (Q = i);\n    let u = a.get(l);\n    \"string\" == typeof u && (u = u.codePointAt(0));\n    if (u && !(h = u, ha[0][0] <= h && h <= ha[0][1] || ha[1][0] <= h && h <= ha[1][1]) && !g.has(Q)) {\n      r.set(u, Q);\n      g.add(Q);\n    }\n    s[E] = Q;\n    n[l] = E;\n  }\n  var h;\n  return {\n    toFontChar: n,\n    charCodeToGlyphId: s,\n    toUnicodeExtraMap: r,\n    nextAvailableFontCharCode: c\n  };\n}\nfunction createCmapTable(e, t, i) {\n  const a = function getRanges(e, t, i) {\n      const a = [];\n      for (const t in e) e[t] >= i || a.push({\n        fontCharCode: 0 | t,\n        glyphId: e[t]\n      });\n      if (t) for (const [e, s] of t) s >= i || a.push({\n        fontCharCode: e,\n        glyphId: s\n      });\n      0 === a.length && a.push({\n        fontCharCode: 0,\n        glyphId: 0\n      });\n      a.sort(function fontGetRangesSort(e, t) {\n        return e.fontCharCode - t.fontCharCode;\n      });\n      const s = [],\n        r = a.length;\n      for (let e = 0; e < r;) {\n        const t = a[e].fontCharCode,\n          i = [a[e].glyphId];\n        ++e;\n        let n = t;\n        for (; e < r && n + 1 === a[e].fontCharCode;) {\n          i.push(a[e].glyphId);\n          ++n;\n          ++e;\n          if (65535 === n) break;\n        }\n        s.push([t, n, i]);\n      }\n      return s;\n    }(e, t, i),\n    s = a.at(-1)[1] > 65535 ? 2 : 1;\n  let r,\n    n,\n    g,\n    o,\n    c = \"\\0\\0\" + string16(s) + \"\\0\u0003\\0\u0001\" + string32(4 + 8 * s);\n  for (r = a.length - 1; r >= 0 && !(a[r][0] <= 65535); --r);\n  const C = r + 1;\n  a[r][0] < 65535 && 65535 === a[r][1] && (a[r][1] = 65534);\n  const h = a[r][1] < 65535 ? 1 : 0,\n    l = C + h,\n    Q = OpenTypeFileBuilder.getSearchParams(l, 2);\n  let E,\n    u,\n    d,\n    f,\n    p = \"\",\n    m = \"\",\n    y = \"\",\n    w = \"\",\n    D = \"\",\n    b = 0;\n  for (r = 0, n = C; r < n; r++) {\n    E = a[r];\n    u = E[0];\n    d = E[1];\n    p += string16(u);\n    m += string16(d);\n    f = E[2];\n    let e = !0;\n    for (g = 1, o = f.length; g < o; ++g) if (f[g] !== f[g - 1] + 1) {\n      e = !1;\n      break;\n    }\n    if (e) {\n      y += string16(f[0] - u & 65535);\n      w += string16(0);\n    } else {\n      const e = 2 * (l - r) + 2 * b;\n      b += d - u + 1;\n      y += string16(0);\n      w += string16(e);\n      for (g = 0, o = f.length; g < o; ++g) D += string16(f[g]);\n    }\n  }\n  if (h > 0) {\n    m += \"ÿÿ\";\n    p += \"ÿÿ\";\n    y += \"\\0\u0001\";\n    w += \"\\0\\0\";\n  }\n  const F = \"\\0\\0\" + string16(2 * l) + string16(Q.range) + string16(Q.entry) + string16(Q.rangeShift) + m + \"\\0\\0\" + p + y + w + D;\n  let S = \"\",\n    k = \"\";\n  if (s > 1) {\n    c += \"\\0\u0003\\0\\n\" + string32(4 + 8 * s + 4 + F.length);\n    S = \"\";\n    for (r = 0, n = a.length; r < n; r++) {\n      E = a[r];\n      u = E[0];\n      f = E[2];\n      let e = f[0];\n      for (g = 1, o = f.length; g < o; ++g) if (f[g] !== f[g - 1] + 1) {\n        d = E[0] + g - 1;\n        S += string32(u) + string32(d) + string32(e);\n        u = d + 1;\n        e = f[g];\n      }\n      S += string32(u) + string32(E[1]) + string32(e);\n    }\n    k = \"\\0\\f\\0\\0\" + string32(S.length + 16) + \"\\0\\0\\0\\0\" + string32(S.length / 12);\n  }\n  return c + \"\\0\u0004\" + string16(F.length + 4) + F + k + S;\n}\nfunction createOS2Table(e, t, i) {\n  i ||= {\n    unitsPerEm: 0,\n    yMax: 0,\n    yMin: 0,\n    ascent: 0,\n    descent: 0\n  };\n  let a = 0,\n    s = 0,\n    r = 0,\n    n = 0,\n    g = null,\n    o = 0,\n    c = -1;\n  if (t) {\n    for (let e in t) {\n      e |= 0;\n      (g > e || !g) && (g = e);\n      o < e && (o = e);\n      c = getUnicodeRangeFor(e, c);\n      if (c < 32) a |= 1 << c;else if (c < 64) s |= 1 << c - 32;else if (c < 96) r |= 1 << c - 64;else {\n        if (!(c < 123)) throw new FormatError(\"Unicode ranges Bits > 123 are reserved for internal usage\");\n        n |= 1 << c - 96;\n      }\n    }\n    o > 65535 && (o = 65535);\n  } else {\n    g = 0;\n    o = 255;\n  }\n  const C = e.bbox || [0, 0, 0, 0],\n    h = i.unitsPerEm || (e.fontMatrix ? 1 / Math.max(...e.fontMatrix.slice(0, 4).map(Math.abs)) : 1e3),\n    l = e.ascentScaled ? 1 : h / Ba,\n    Q = i.ascent || Math.round(l * (e.ascent || C[3]));\n  let E = i.descent || Math.round(l * (e.descent || C[1]));\n  E > 0 && e.descent > 0 && C[1] < 0 && (E = -E);\n  const u = i.yMax || Q,\n    d = -i.yMin || -E;\n  return \"\\0\u0003\u0002$\u0001ô\\0\u0005\\0\\0\u0002\u0002»\\0\\0\\0\u0002\u0002»\\0\\0\u0001ß\\x001\u0001\u0002\\0\\0\\0\\0\u0006\" + String.fromCharCode(e.fixedPitch ? 9 : 0) + \"\\0\\0\\0\\0\\0\\0\" + string32(a) + string32(s) + string32(r) + string32(n) + \"*21*\" + string16(e.italicAngle ? 1 : 0) + string16(g || e.firstChar) + string16(o || e.lastChar) + string16(Q) + string16(E) + \"\\0d\" + string16(u) + string16(d) + \"\\0\\0\\0\\0\\0\\0\\0\\0\" + string16(e.xHeight) + string16(e.capHeight) + string16(0) + string16(g || e.firstChar) + \"\\0\u0003\";\n}\nfunction createPostTable(e) {\n  return \"\\0\u0003\\0\\0\" + string32(Math.floor(65536 * e.italicAngle)) + \"\\0\\0\\0\\0\" + string32(e.fixedPitch ? 1 : 0) + \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n}\nfunction createPostscriptName(e) {\n  return e.replaceAll(/[^\\x21-\\x7E]|[[\\](){}<>/%]/g, \"\").slice(0, 63);\n}\nfunction createNameTable(e, t) {\n  t || (t = [[], []]);\n  const i = [t[0][0] || \"Original licence\", t[0][1] || e, t[0][2] || \"Unknown\", t[0][3] || \"uniqueID\", t[0][4] || e, t[0][5] || \"Version 0.11\", t[0][6] || createPostscriptName(e), t[0][7] || \"Unknown\", t[0][8] || \"Unknown\", t[0][9] || \"Unknown\"],\n    a = [];\n  let s, r, n, g, o;\n  for (s = 0, r = i.length; s < r; s++) {\n    o = t[1][s] || i[s];\n    const e = [];\n    for (n = 0, g = o.length; n < g; n++) e.push(string16(o.charCodeAt(n)));\n    a.push(e.join(\"\"));\n  }\n  const c = [i, a],\n    C = [\"\\0\u0001\", \"\\0\u0003\"],\n    h = [\"\\0\\0\", \"\\0\u0001\"],\n    l = [\"\\0\\0\", \"\u0004\\t\"],\n    Q = i.length * C.length;\n  let E = \"\\0\\0\" + string16(Q) + string16(12 * Q + 6),\n    u = 0;\n  for (s = 0, r = C.length; s < r; s++) {\n    const e = c[s];\n    for (n = 0, g = e.length; n < g; n++) {\n      o = e[n];\n      E += C[s] + h[s] + l[s] + string16(n) + string16(o.length) + string16(u);\n      u += o.length;\n    }\n  }\n  E += i.join(\"\") + a.join(\"\");\n  return E;\n}\nclass Font {\n  constructor(e, t, i) {\n    this.name = e;\n    this.psName = null;\n    this.mimetype = null;\n    this.disableFontFace = !1;\n    this.loadedName = i.loadedName;\n    this.isType3Font = i.isType3Font;\n    this.missingFile = !1;\n    this.cssFontInfo = i.cssFontInfo;\n    this._charsCache = Object.create(null);\n    this._glyphCache = Object.create(null);\n    let a = !!(i.flags & Ki);\n    if (!a && !i.isSimulatedFlags) {\n      const t = e.replaceAll(/[,_]/g, \"-\").split(\"-\", 1)[0],\n        i = Xi();\n      for (const e of t.split(\"+\")) if (i[e]) {\n        a = !0;\n        break;\n      }\n    }\n    this.isSerifFont = a;\n    this.isSymbolicFont = !!(i.flags & Ti);\n    this.isMonospace = !!(i.flags & vi);\n    let {\n      type: s,\n      subtype: r\n    } = i;\n    this.type = s;\n    this.subtype = r;\n    this.systemFontInfo = i.systemFontInfo;\n    const n = e.match(/^InvalidPDFjsFont_(.*)_\\d+$/);\n    this.isInvalidPDFjsFont = !!n;\n    this.isInvalidPDFjsFont ? this.fallbackName = n[1] : this.isMonospace ? this.fallbackName = \"monospace\" : this.isSerifFont ? this.fallbackName = \"serif\" : this.fallbackName = \"sans-serif\";\n    if (this.systemFontInfo?.guessFallback) {\n      this.systemFontInfo.guessFallback = !1;\n      this.systemFontInfo.css += `,${this.fallbackName}`;\n    }\n    this.differences = i.differences;\n    this.widths = i.widths;\n    this.defaultWidth = i.defaultWidth;\n    this.composite = i.composite;\n    this.cMap = i.cMap;\n    this.capHeight = i.capHeight / Ba;\n    this.ascent = i.ascent / Ba;\n    this.descent = i.descent / Ba;\n    this.lineHeight = this.ascent - this.descent;\n    this.fontMatrix = i.fontMatrix;\n    this.bbox = i.bbox;\n    this.defaultEncoding = i.defaultEncoding;\n    this.toUnicode = i.toUnicode;\n    this.toFontChar = [];\n    if (\"Type3\" === i.type) {\n      for (let e = 0; e < 256; e++) this.toFontChar[e] = this.differences[e] || i.defaultEncoding[e];\n      return;\n    }\n    this.cidEncoding = i.cidEncoding || \"\";\n    this.vertical = !!i.vertical;\n    if (this.vertical) {\n      this.vmetrics = i.vmetrics;\n      this.defaultVMetrics = i.defaultVMetrics;\n    }\n    if (!t || t.isEmpty) {\n      t && warn('Font file is empty in \"' + e + '\" (' + this.loadedName + \")\");\n      this.fallbackToSystemFont(i);\n      return;\n    }\n    [s, r] = getFontFileType(t, i);\n    s === this.type && r === this.subtype || info(`Inconsistent font file Type/SubType, expected: ${this.type}/${this.subtype} but found: ${s}/${r}.`);\n    let g;\n    try {\n      switch (s) {\n        case \"MMType1\":\n          info(\"MMType1 font (\" + e + \"), falling back to Type1.\");\n        case \"Type1\":\n        case \"CIDFontType0\":\n          this.mimetype = \"font/opentype\";\n          const a = \"Type1C\" === r || \"CIDFontType0C\" === r ? new CFFFont(t, i) : new Type1Font(e, t, i);\n          adjustWidths(i);\n          g = this.convert(e, a, i);\n          break;\n        case \"OpenType\":\n        case \"TrueType\":\n        case \"CIDFontType2\":\n          this.mimetype = \"font/opentype\";\n          g = this.checkAndRepair(e, t, i);\n          if (this.isOpenType) {\n            adjustWidths(i);\n            s = \"OpenType\";\n          }\n          break;\n        default:\n          throw new FormatError(`Font ${s} is not supported`);\n      }\n    } catch (e) {\n      warn(e);\n      this.fallbackToSystemFont(i);\n      return;\n    }\n    amendFallbackToUnicode(i);\n    this.data = g;\n    this.type = s;\n    this.subtype = r;\n    this.fontMatrix = i.fontMatrix;\n    this.widths = i.widths;\n    this.defaultWidth = i.defaultWidth;\n    this.toUnicode = i.toUnicode;\n    this.seacMap = i.seacMap;\n  }\n  get renderer() {\n    return shadow(this, \"renderer\", FontRendererFactory.create(this, Yi));\n  }\n  exportData(e = !1) {\n    const t = e ? [...la, ...Qa] : la,\n      i = Object.create(null);\n    let a, s;\n    for (a of t) {\n      s = this[a];\n      void 0 !== s && (i[a] = s);\n    }\n    return i;\n  }\n  fallbackToSystemFont(e) {\n    this.missingFile = !0;\n    const {\n      name: t,\n      type: i\n    } = this;\n    let a = normalizeFontName(t);\n    const s = Pi(),\n      r = ji(),\n      n = !!s[a],\n      g = !(!r[a] || !s[r[a]]);\n    a = s[a] || r[a] || a;\n    const o = ea()[a];\n    if (o) {\n      isNaN(this.ascent) && (this.ascent = o.ascent / Ba);\n      isNaN(this.descent) && (this.descent = o.descent / Ba);\n      isNaN(this.capHeight) && (this.capHeight = o.capHeight / Ba);\n    }\n    this.bold = /bold/gi.test(a);\n    this.italic = /oblique|italic/gi.test(a);\n    this.black = /Black/g.test(t);\n    const c = /Narrow/g.test(t);\n    this.remeasure = (!n || c) && Object.keys(this.widths).length > 0;\n    if ((n || g) && \"CIDFontType2\" === i && this.cidEncoding.startsWith(\"Identity-\")) {\n      const i = e.cidToGidMap,\n        a = [];\n      applyStandardFontGlyphMap(a, Vi());\n      /Arial-?Black/i.test(t) ? applyStandardFontGlyphMap(a, zi()) : /Calibri/i.test(t) && applyStandardFontGlyphMap(a, _i());\n      if (i) {\n        for (const e in a) {\n          const t = a[e];\n          void 0 !== i[t] && (a[+e] = i[t]);\n        }\n        i.length !== this.toUnicode.length && e.hasIncludedToUnicodeMap && this.toUnicode instanceof IdentityToUnicodeMap && this.toUnicode.forEach(function (e, t) {\n          const s = a[e];\n          void 0 === i[s] && (a[+e] = t);\n        });\n      }\n      this.toUnicode instanceof IdentityToUnicodeMap || this.toUnicode.forEach(function (e, t) {\n        a[+e] = t;\n      });\n      this.toFontChar = a;\n      this.toUnicode = new ToUnicodeMap(a);\n    } else if (/Symbol/i.test(a)) this.toFontChar = buildToFontChar(mi, Ni(), this.differences);else if (/Dingbats/i.test(a)) this.toFontChar = buildToFontChar(yi, Gi(), this.differences);else if (n) {\n      const e = buildToFontChar(this.defaultEncoding, Ni(), this.differences);\n      \"CIDFontType2\" !== i || this.cidEncoding.startsWith(\"Identity-\") || this.toUnicode instanceof IdentityToUnicodeMap || this.toUnicode.forEach(function (t, i) {\n        e[+t] = i;\n      });\n      this.toFontChar = e;\n    } else {\n      const e = Ni(),\n        i = [];\n      this.toUnicode.forEach((t, a) => {\n        if (!this.composite) {\n          const i = getUnicodeForGlyph(this.differences[t] || this.defaultEncoding[t], e);\n          -1 !== i && (a = i);\n        }\n        i[+t] = a;\n      });\n      this.composite && this.toUnicode instanceof IdentityToUnicodeMap && /Tahoma|Verdana/i.test(t) && applyStandardFontGlyphMap(i, Vi());\n      this.toFontChar = i;\n    }\n    amendFallbackToUnicode(e);\n    this.loadedName = a.split(\"-\", 1)[0];\n  }\n  checkAndRepair(e, t, i) {\n    const a = [\"OS/2\", \"cmap\", \"head\", \"hhea\", \"hmtx\", \"maxp\", \"name\", \"post\", \"loca\", \"glyf\", \"fpgm\", \"prep\", \"cvt \", \"CFF \"];\n    function readTables(e, t) {\n      const i = Object.create(null);\n      i[\"OS/2\"] = null;\n      i.cmap = null;\n      i.head = null;\n      i.hhea = null;\n      i.hmtx = null;\n      i.maxp = null;\n      i.name = null;\n      i.post = null;\n      for (let s = 0; s < t; s++) {\n        const t = readTableEntry(e);\n        a.includes(t.tag) && 0 !== t.length && (i[t.tag] = t);\n      }\n      return i;\n    }\n    function readTableEntry(e) {\n      const t = e.getString(4),\n        i = e.getInt32() >>> 0,\n        a = e.getInt32() >>> 0,\n        s = e.getInt32() >>> 0,\n        r = e.pos;\n      e.pos = e.start || 0;\n      e.skip(a);\n      const n = e.getBytes(s);\n      e.pos = r;\n      if (\"head\" === t) {\n        n[8] = n[9] = n[10] = n[11] = 0;\n        n[17] |= 32;\n      }\n      return {\n        tag: t,\n        checksum: i,\n        length: s,\n        offset: a,\n        data: n\n      };\n    }\n    function readOpenTypeHeader(e) {\n      return {\n        version: e.getString(4),\n        numTables: e.getUint16(),\n        searchRange: e.getUint16(),\n        entrySelector: e.getUint16(),\n        rangeShift: e.getUint16()\n      };\n    }\n    function sanitizeGlyph(e, t, i, a, s, r) {\n      const n = {\n        length: 0,\n        sizeOfInstructions: 0\n      };\n      if (t < 0 || t >= e.length || i > e.length || i - t <= 12) return n;\n      const g = e.subarray(t, i),\n        o = signedInt16(g[2], g[3]),\n        c = signedInt16(g[4], g[5]),\n        C = signedInt16(g[6], g[7]),\n        h = signedInt16(g[8], g[9]);\n      if (o > C) {\n        writeSignedInt16(g, 2, C);\n        writeSignedInt16(g, 6, o);\n      }\n      if (c > h) {\n        writeSignedInt16(g, 4, h);\n        writeSignedInt16(g, 8, c);\n      }\n      const l = signedInt16(g[0], g[1]);\n      if (l < 0) {\n        if (l < -1) return n;\n        a.set(g, s);\n        n.length = g.length;\n        return n;\n      }\n      let Q,\n        E = 10,\n        u = 0;\n      for (Q = 0; Q < l; Q++) {\n        u = (g[E] << 8 | g[E + 1]) + 1;\n        E += 2;\n      }\n      const d = E,\n        f = g[E] << 8 | g[E + 1];\n      n.sizeOfInstructions = f;\n      E += 2 + f;\n      const p = E;\n      let m = 0;\n      for (Q = 0; Q < u; Q++) {\n        const e = g[E++];\n        192 & e && (g[E - 1] = 63 & e);\n        let t = 2;\n        2 & e ? t = 1 : 16 & e && (t = 0);\n        let i = 2;\n        4 & e ? i = 1 : 32 & e && (i = 0);\n        const a = t + i;\n        m += a;\n        if (8 & e) {\n          const e = g[E++];\n          0 === e && (g[E - 1] ^= 8);\n          Q += e;\n          m += e * a;\n        }\n      }\n      if (0 === m) return n;\n      let y = E + m;\n      if (y > g.length) return n;\n      if (!r && f > 0) {\n        a.set(g.subarray(0, d), s);\n        a.set([0, 0], s + d);\n        a.set(g.subarray(p, y), s + d + 2);\n        y -= f;\n        g.length - y > 3 && (y = y + 3 & -4);\n        n.length = y;\n        return n;\n      }\n      if (g.length - y > 3) {\n        y = y + 3 & -4;\n        a.set(g.subarray(0, y), s);\n        n.length = y;\n        return n;\n      }\n      a.set(g, s);\n      n.length = g.length;\n      return n;\n    }\n    function readNameTable(e) {\n      const i = (t.start || 0) + e.offset;\n      t.pos = i;\n      const a = [[], []],\n        s = [],\n        r = e.length,\n        n = i + r;\n      if (0 !== t.getUint16() || r < 6) return [a, s];\n      const g = t.getUint16(),\n        o = t.getUint16();\n      let c, C;\n      for (c = 0; c < g && t.pos + 12 <= n; c++) {\n        const e = {\n          platform: t.getUint16(),\n          encoding: t.getUint16(),\n          language: t.getUint16(),\n          name: t.getUint16(),\n          length: t.getUint16(),\n          offset: t.getUint16()\n        };\n        (isMacNameRecord(e) || isWinNameRecord(e)) && s.push(e);\n      }\n      for (c = 0, C = s.length; c < C; c++) {\n        const e = s[c];\n        if (e.length <= 0) continue;\n        const r = i + o + e.offset;\n        if (r + e.length > n) continue;\n        t.pos = r;\n        const g = e.name;\n        if (e.encoding) {\n          let i = \"\";\n          for (let a = 0, s = e.length; a < s; a += 2) i += String.fromCharCode(t.getUint16());\n          a[1][g] = i;\n        } else a[0][g] = t.getString(e.length);\n      }\n      return [a, s];\n    }\n    const s = [0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1, 0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2, 0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1, -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];\n    function sanitizeTTProgram(e, t) {\n      let i,\n        a,\n        r,\n        n,\n        g,\n        o = e.data,\n        c = 0,\n        C = 0,\n        h = 0;\n      const l = [],\n        Q = [],\n        E = [];\n      let u = t.tooComplexToFollowFunctions,\n        d = !1,\n        f = 0,\n        p = 0;\n      for (let e = o.length; c < e;) {\n        const e = o[c++];\n        if (64 === e) {\n          a = o[c++];\n          if (d || p) c += a;else for (i = 0; i < a; i++) l.push(o[c++]);\n        } else if (65 === e) {\n          a = o[c++];\n          if (d || p) c += 2 * a;else for (i = 0; i < a; i++) {\n            r = o[c++];\n            l.push(r << 8 | o[c++]);\n          }\n        } else if (176 == (248 & e)) {\n          a = e - 176 + 1;\n          if (d || p) c += a;else for (i = 0; i < a; i++) l.push(o[c++]);\n        } else if (184 == (248 & e)) {\n          a = e - 184 + 1;\n          if (d || p) c += 2 * a;else for (i = 0; i < a; i++) {\n            r = o[c++];\n            l.push(r << 8 | o[c++]);\n          }\n        } else if (43 !== e || u) {\n          if (44 !== e || u) {\n            if (45 === e) {\n              if (d) {\n                d = !1;\n                C = c;\n              } else {\n                g = Q.pop();\n                if (!g) {\n                  warn(\"TT: ENDF bad stack\");\n                  t.hintsValid = !1;\n                  return;\n                }\n                n = E.pop();\n                o = g.data;\n                c = g.i;\n                t.functionsStackDeltas[n] = l.length - g.stackTop;\n              }\n            } else if (137 === e) {\n              if (d || p) {\n                warn(\"TT: nested IDEFs not allowed\");\n                u = !0;\n              }\n              d = !0;\n              h = c;\n            } else if (88 === e) ++f;else if (27 === e) p = f;else if (89 === e) {\n              p === f && (p = 0);\n              --f;\n            } else if (28 === e && !d && !p) {\n              const e = l.at(-1);\n              e > 0 && (c += e - 1);\n            }\n          } else {\n            if (d || p) {\n              warn(\"TT: nested FDEFs not allowed\");\n              u = !0;\n            }\n            d = !0;\n            h = c;\n            n = l.pop();\n            t.functionsDefined[n] = {\n              data: o,\n              i: c\n            };\n          }\n        } else if (!d && !p) {\n          n = l.at(-1);\n          if (isNaN(n)) info(\"TT: CALL empty stack (or invalid entry).\");else {\n            t.functionsUsed[n] = !0;\n            if (n in t.functionsStackDeltas) {\n              const e = l.length + t.functionsStackDeltas[n];\n              if (e < 0) {\n                warn(\"TT: CALL invalid functions stack delta.\");\n                t.hintsValid = !1;\n                return;\n              }\n              l.length = e;\n            } else if (n in t.functionsDefined && !E.includes(n)) {\n              Q.push({\n                data: o,\n                i: c,\n                stackTop: l.length - 1\n              });\n              E.push(n);\n              g = t.functionsDefined[n];\n              if (!g) {\n                warn(\"TT: CALL non-existent function\");\n                t.hintsValid = !1;\n                return;\n              }\n              o = g.data;\n              c = g.i;\n            }\n          }\n        }\n        if (!d && !p) {\n          let t = 0;\n          e <= 142 ? t = s[e] : e >= 192 && e <= 223 ? t = -1 : e >= 224 && (t = -2);\n          if (e >= 113 && e <= 117) {\n            a = l.pop();\n            isNaN(a) || (t = 2 * -a);\n          }\n          for (; t < 0 && l.length > 0;) {\n            l.pop();\n            t++;\n          }\n          for (; t > 0;) {\n            l.push(NaN);\n            t--;\n          }\n        }\n      }\n      t.tooComplexToFollowFunctions = u;\n      const m = [o];\n      c > o.length && m.push(new Uint8Array(c - o.length));\n      if (h > C) {\n        warn(\"TT: complementing a missing function tail\");\n        m.push(new Uint8Array([34, 45]));\n      }\n      !function foldTTTable(e, t) {\n        if (t.length > 1) {\n          let i,\n            a,\n            s = 0;\n          for (i = 0, a = t.length; i < a; i++) s += t[i].length;\n          s = s + 3 & -4;\n          const r = new Uint8Array(s);\n          let n = 0;\n          for (i = 0, a = t.length; i < a; i++) {\n            r.set(t[i], n);\n            n += t[i].length;\n          }\n          e.data = r;\n          e.length = s;\n        }\n      }(e, m);\n    }\n    let r, n, g, o;\n    if (isTrueTypeCollectionFile(t = new Stream(new Uint8Array(t.getBytes())))) {\n      const e = function readTrueTypeCollectionData(e, t) {\n        const {\n            numFonts: i,\n            offsetTable: a\n          } = function readTrueTypeCollectionHeader(e) {\n            const t = e.getString(4);\n            assert(\"ttcf\" === t, \"Must be a TrueType Collection font.\");\n            const i = e.getUint16(),\n              a = e.getUint16(),\n              s = e.getInt32() >>> 0,\n              r = [];\n            for (let t = 0; t < s; t++) r.push(e.getInt32() >>> 0);\n            const n = {\n              ttcTag: t,\n              majorVersion: i,\n              minorVersion: a,\n              numFonts: s,\n              offsetTable: r\n            };\n            switch (i) {\n              case 1:\n                return n;\n              case 2:\n                n.dsigTag = e.getInt32() >>> 0;\n                n.dsigLength = e.getInt32() >>> 0;\n                n.dsigOffset = e.getInt32() >>> 0;\n                return n;\n            }\n            throw new FormatError(`Invalid TrueType Collection majorVersion: ${i}.`);\n          }(e),\n          s = t.split(\"+\");\n        let r;\n        for (let n = 0; n < i; n++) {\n          e.pos = (e.start || 0) + a[n];\n          const i = readOpenTypeHeader(e),\n            g = readTables(e, i.numTables);\n          if (!g.name) throw new FormatError('TrueType Collection font must contain a \"name\" table.');\n          const [o] = readNameTable(g.name);\n          for (let e = 0, a = o.length; e < a; e++) for (let a = 0, n = o[e].length; a < n; a++) {\n            const n = o[e][a]?.replaceAll(/\\s/g, \"\");\n            if (n) {\n              if (n === t) return {\n                header: i,\n                tables: g\n              };\n              if (!(s.length < 2)) for (const e of s) n === e && (r = {\n                name: e,\n                header: i,\n                tables: g\n              });\n            }\n          }\n        }\n        if (r) {\n          warn(`TrueType Collection does not contain \"${t}\" font, falling back to \"${r.name}\" font instead.`);\n          return {\n            header: r.header,\n            tables: r.tables\n          };\n        }\n        throw new FormatError(`TrueType Collection does not contain \"${t}\" font.`);\n      }(t, this.name);\n      r = e.header;\n      n = e.tables;\n    } else {\n      r = readOpenTypeHeader(t);\n      n = readTables(t, r.numTables);\n    }\n    const c = !n[\"CFF \"];\n    if (c) {\n      if (!n.loca) throw new FormatError('Required \"loca\" table is not found');\n      if (!n.glyf) {\n        warn('Required \"glyf\" table is not found -- trying to recover.');\n        n.glyf = {\n          tag: \"glyf\",\n          data: new Uint8Array(0)\n        };\n      }\n      this.isOpenType = !1;\n    } else {\n      const t = i.composite && (i.cidToGidMap?.length > 0 || !(i.cMap instanceof IdentityCMap));\n      if (\"OTTO\" === r.version && !t || !n.head || !n.hhea || !n.maxp || !n.post) {\n        o = new Stream(n[\"CFF \"].data);\n        g = new CFFFont(o, i);\n        adjustWidths(i);\n        return this.convert(e, g, i);\n      }\n      delete n.glyf;\n      delete n.loca;\n      delete n.fpgm;\n      delete n.prep;\n      delete n[\"cvt \"];\n      this.isOpenType = !0;\n    }\n    if (!n.maxp) throw new FormatError('Required \"maxp\" table is not found');\n    t.pos = (t.start || 0) + n.maxp.offset;\n    let C = t.getInt32();\n    const h = t.getUint16();\n    if (65536 !== C && 20480 !== C) {\n      if (6 === n.maxp.length) C = 20480;else {\n        if (!(n.maxp.length >= 32)) throw new FormatError('\"maxp\" table has a wrong version number');\n        C = 65536;\n      }\n      !function writeUint32(e, t, i) {\n        e[t + 3] = 255 & i;\n        e[t + 2] = i >>> 8;\n        e[t + 1] = i >>> 16;\n        e[t] = i >>> 24;\n      }(n.maxp.data, 0, C);\n    }\n    if (i.scaleFactors?.length === h && c) {\n      const {\n          scaleFactors: e\n        } = i,\n        t = int16(n.head.data[50], n.head.data[51]),\n        a = new GlyfTable({\n          glyfTable: n.glyf.data,\n          isGlyphLocationsLong: t,\n          locaTable: n.loca.data,\n          numGlyphs: h\n        });\n      a.scale(e);\n      const {\n        glyf: s,\n        loca: r,\n        isLocationLong: g\n      } = a.write();\n      n.glyf.data = s;\n      n.loca.data = r;\n      if (g !== !!t) {\n        n.head.data[50] = 0;\n        n.head.data[51] = g ? 1 : 0;\n      }\n      const o = n.hmtx.data;\n      for (let t = 0; t < h; t++) {\n        const i = 4 * t,\n          a = Math.round(e[t] * int16(o[i], o[i + 1]));\n        o[i] = a >> 8 & 255;\n        o[i + 1] = 255 & a;\n        writeSignedInt16(o, i + 2, Math.round(e[t] * signedInt16(o[i + 2], o[i + 3])));\n      }\n    }\n    let l = h + 1,\n      Q = !0;\n    if (l > 65535) {\n      Q = !1;\n      l = h;\n      warn(\"Not enough space in glyfs to duplicate first glyph.\");\n    }\n    let E = 0,\n      u = 0;\n    if (C >= 65536 && n.maxp.length >= 32) {\n      t.pos += 8;\n      if (t.getUint16() > 2) {\n        n.maxp.data[14] = 0;\n        n.maxp.data[15] = 2;\n      }\n      t.pos += 4;\n      E = t.getUint16();\n      t.pos += 4;\n      u = t.getUint16();\n    }\n    n.maxp.data[4] = l >> 8;\n    n.maxp.data[5] = 255 & l;\n    const d = function sanitizeTTPrograms(e, t, i, a) {\n      const s = {\n        functionsDefined: [],\n        functionsUsed: [],\n        functionsStackDeltas: [],\n        tooComplexToFollowFunctions: !1,\n        hintsValid: !0\n      };\n      e && sanitizeTTProgram(e, s);\n      t && sanitizeTTProgram(t, s);\n      e && function checkInvalidFunctions(e, t) {\n        if (!e.tooComplexToFollowFunctions) if (e.functionsDefined.length > t) {\n          warn(\"TT: more functions defined than expected\");\n          e.hintsValid = !1;\n        } else for (let i = 0, a = e.functionsUsed.length; i < a; i++) {\n          if (i > t) {\n            warn(\"TT: invalid function id: \" + i);\n            e.hintsValid = !1;\n            return;\n          }\n          if (e.functionsUsed[i] && !e.functionsDefined[i]) {\n            warn(\"TT: undefined function: \" + i);\n            e.hintsValid = !1;\n            return;\n          }\n        }\n      }(s, a);\n      if (i && 1 & i.length) {\n        const e = new Uint8Array(i.length + 1);\n        e.set(i.data);\n        i.data = e;\n      }\n      return s.hintsValid;\n    }(n.fpgm, n.prep, n[\"cvt \"], E);\n    if (!d) {\n      delete n.fpgm;\n      delete n.prep;\n      delete n[\"cvt \"];\n    }\n    !function sanitizeMetrics(e, t, i, a, s, r) {\n      if (!t) {\n        i && (i.data = null);\n        return;\n      }\n      e.pos = (e.start || 0) + t.offset;\n      e.pos += 4;\n      e.pos += 2;\n      e.pos += 2;\n      e.pos += 2;\n      e.pos += 2;\n      e.pos += 2;\n      e.pos += 2;\n      e.pos += 2;\n      e.pos += 2;\n      e.pos += 2;\n      const n = e.getUint16();\n      e.pos += 8;\n      e.pos += 2;\n      let g = e.getUint16();\n      if (0 !== n) {\n        if (!(2 & int16(a.data[44], a.data[45]))) {\n          t.data[22] = 0;\n          t.data[23] = 0;\n        }\n      }\n      if (g > s) {\n        info(`The numOfMetrics (${g}) should not be greater than the numGlyphs (${s}).`);\n        g = s;\n        t.data[34] = (65280 & g) >> 8;\n        t.data[35] = 255 & g;\n      }\n      const o = s - g - (i.length - 4 * g >> 1);\n      if (o > 0) {\n        const e = new Uint8Array(i.length + 2 * o);\n        e.set(i.data);\n        if (r) {\n          e[i.length] = i.data[2];\n          e[i.length + 1] = i.data[3];\n        }\n        i.data = e;\n      }\n    }(t, n.hhea, n.hmtx, n.head, l, Q);\n    if (!n.head) throw new FormatError('Required \"head\" table is not found');\n    !function sanitizeHead(e, t, i) {\n      const a = e.data,\n        s = function int32(e, t, i, a) {\n          return (e << 24) + (t << 16) + (i << 8) + a;\n        }(a[0], a[1], a[2], a[3]);\n      if (s >> 16 != 1) {\n        info(\"Attempting to fix invalid version in head table: \" + s);\n        a[0] = 0;\n        a[1] = 1;\n        a[2] = 0;\n        a[3] = 0;\n      }\n      const r = int16(a[50], a[51]);\n      if (r < 0 || r > 1) {\n        info(\"Attempting to fix invalid indexToLocFormat in head table: \" + r);\n        const e = t + 1;\n        if (i === e << 1) {\n          a[50] = 0;\n          a[51] = 0;\n        } else {\n          if (i !== e << 2) throw new FormatError(\"Could not fix indexToLocFormat: \" + r);\n          a[50] = 0;\n          a[51] = 1;\n        }\n      }\n    }(n.head, h, c ? n.loca.length : 0);\n    let f = Object.create(null);\n    if (c) {\n      const e = int16(n.head.data[50], n.head.data[51]),\n        t = function sanitizeGlyphLocations(e, t, i, a, s, r, n) {\n          let g, o, c;\n          if (a) {\n            g = 4;\n            o = function fontItemDecodeLong(e, t) {\n              return e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3];\n            };\n            c = function fontItemEncodeLong(e, t, i) {\n              e[t] = i >>> 24 & 255;\n              e[t + 1] = i >> 16 & 255;\n              e[t + 2] = i >> 8 & 255;\n              e[t + 3] = 255 & i;\n            };\n          } else {\n            g = 2;\n            o = function fontItemDecode(e, t) {\n              return e[t] << 9 | e[t + 1] << 1;\n            };\n            c = function fontItemEncode(e, t, i) {\n              e[t] = i >> 9 & 255;\n              e[t + 1] = i >> 1 & 255;\n            };\n          }\n          const C = r ? i + 1 : i,\n            h = g * (1 + C),\n            l = new Uint8Array(h);\n          l.set(e.data.subarray(0, h));\n          e.data = l;\n          const Q = t.data,\n            E = Q.length,\n            u = new Uint8Array(E);\n          let d, f;\n          const p = [];\n          for (d = 0, f = 0; d < i + 1; d++, f += g) {\n            let e = o(l, f);\n            e > E && (e = E);\n            p.push({\n              index: d,\n              offset: e,\n              endOffset: 0\n            });\n          }\n          p.sort((e, t) => e.offset - t.offset);\n          for (d = 0; d < i; d++) p[d].endOffset = p[d + 1].offset;\n          p.sort((e, t) => e.index - t.index);\n          for (d = 0; d < i; d++) {\n            const {\n              offset: e,\n              endOffset: t\n            } = p[d];\n            if (0 !== e || 0 !== t) break;\n            const i = p[d + 1].offset;\n            if (0 !== i) {\n              p[d].endOffset = i;\n              break;\n            }\n          }\n          const m = p.at(-2);\n          0 !== m.offset && 0 === m.endOffset && (m.endOffset = E);\n          const y = Object.create(null);\n          let w = 0;\n          c(l, 0, w);\n          for (d = 0, f = g; d < i; d++, f += g) {\n            const e = sanitizeGlyph(Q, p[d].offset, p[d].endOffset, u, w, s),\n              t = e.length;\n            0 === t && (y[d] = !0);\n            e.sizeOfInstructions > n && (n = e.sizeOfInstructions);\n            w += t;\n            c(l, f, w);\n          }\n          if (0 === w) {\n            const e = new Uint8Array([0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0]);\n            for (d = 0, f = g; d < C; d++, f += g) c(l, f, e.length);\n            t.data = e;\n          } else if (r) {\n            const i = o(l, g);\n            if (u.length > i + w) t.data = u.subarray(0, i + w);else {\n              t.data = new Uint8Array(i + w);\n              t.data.set(u.subarray(0, w));\n            }\n            t.data.set(u.subarray(0, i), w);\n            c(e.data, l.length - g, w + i);\n          } else t.data = u.subarray(0, w);\n          return {\n            missingGlyphs: y,\n            maxSizeOfInstructions: n\n          };\n        }(n.loca, n.glyf, h, e, d, Q, u);\n      f = t.missingGlyphs;\n      if (C >= 65536 && n.maxp.length >= 32) {\n        n.maxp.data[26] = t.maxSizeOfInstructions >> 8;\n        n.maxp.data[27] = 255 & t.maxSizeOfInstructions;\n      }\n    }\n    if (!n.hhea) throw new FormatError('Required \"hhea\" table is not found');\n    if (0 === n.hhea.data[10] && 0 === n.hhea.data[11]) {\n      n.hhea.data[10] = 255;\n      n.hhea.data[11] = 255;\n    }\n    const p = {\n      unitsPerEm: int16(n.head.data[18], n.head.data[19]),\n      yMax: signedInt16(n.head.data[42], n.head.data[43]),\n      yMin: signedInt16(n.head.data[38], n.head.data[39]),\n      ascent: signedInt16(n.hhea.data[4], n.hhea.data[5]),\n      descent: signedInt16(n.hhea.data[6], n.hhea.data[7]),\n      lineGap: signedInt16(n.hhea.data[8], n.hhea.data[9])\n    };\n    this.ascent = p.ascent / p.unitsPerEm;\n    this.descent = p.descent / p.unitsPerEm;\n    this.lineGap = p.lineGap / p.unitsPerEm;\n    if (this.cssFontInfo?.lineHeight) {\n      this.lineHeight = this.cssFontInfo.metrics.lineHeight;\n      this.lineGap = this.cssFontInfo.metrics.lineGap;\n    } else this.lineHeight = this.ascent - this.descent + this.lineGap;\n    n.post && function readPostScriptTable(e, i, a) {\n      const s = (t.start || 0) + e.offset;\n      t.pos = s;\n      const r = s + e.length,\n        n = t.getInt32();\n      t.skip(28);\n      let g,\n        o,\n        c = !0;\n      switch (n) {\n        case 65536:\n          g = Oi;\n          break;\n        case 131072:\n          const e = t.getUint16();\n          if (e !== a) {\n            c = !1;\n            break;\n          }\n          const s = [];\n          for (o = 0; o < e; ++o) {\n            const e = t.getUint16();\n            if (e >= 32768) {\n              c = !1;\n              break;\n            }\n            s.push(e);\n          }\n          if (!c) break;\n          const C = [],\n            h = [];\n          for (; t.pos < r;) {\n            const e = t.getByte();\n            h.length = e;\n            for (o = 0; o < e; ++o) h[o] = String.fromCharCode(t.getByte());\n            C.push(h.join(\"\"));\n          }\n          g = [];\n          for (o = 0; o < e; ++o) {\n            const e = s[o];\n            e < 258 ? g.push(Oi[e]) : g.push(C[e - 258]);\n          }\n          break;\n        case 196608:\n          break;\n        default:\n          warn(\"Unknown/unsupported post table version \" + n);\n          c = !1;\n          i.defaultEncoding && (g = i.defaultEncoding);\n      }\n      i.glyphNames = g;\n      return c;\n    }(n.post, i, h);\n    n.post = {\n      tag: \"post\",\n      data: createPostTable(i)\n    };\n    const m = Object.create(null);\n    function hasGlyph(e) {\n      return !f[e];\n    }\n    if (i.composite) {\n      const e = i.cidToGidMap || [],\n        t = 0 === e.length;\n      i.cMap.forEach(function (i, a) {\n        \"string\" == typeof a && (a = convertCidString(i, a, !0));\n        if (a > 65535) throw new FormatError(\"Max size of CID is 65,535\");\n        let s = -1;\n        t ? s = a : void 0 !== e[a] && (s = e[a]);\n        s >= 0 && s < h && hasGlyph(s) && (m[i] = s);\n      });\n    } else {\n      const e = function readCmapTable(e, t, i, a) {\n          if (!e) {\n            warn(\"No cmap table available.\");\n            return {\n              platformId: -1,\n              encodingId: -1,\n              mappings: [],\n              hasShortCmap: !1\n            };\n          }\n          let s,\n            r = (t.start || 0) + e.offset;\n          t.pos = r;\n          t.skip(2);\n          const n = t.getUint16();\n          let g,\n            o = !1;\n          for (let e = 0; e < n; e++) {\n            const s = t.getUint16(),\n              r = t.getUint16(),\n              c = t.getInt32() >>> 0;\n            let C = !1;\n            if (g?.platformId !== s || g?.encodingId !== r) {\n              if (0 !== s || 0 !== r && 1 !== r && 3 !== r) {\n                if (1 === s && 0 === r) C = !0;else if (3 !== s || 1 !== r || !a && g) {\n                  if (i && 3 === s && 0 === r) {\n                    C = !0;\n                    let i = !0;\n                    if (e < n - 1) {\n                      const e = t.peekBytes(2);\n                      int16(e[0], e[1]) < s && (i = !1);\n                    }\n                    i && (o = !0);\n                  }\n                } else {\n                  C = !0;\n                  i || (o = !0);\n                }\n              } else C = !0;\n              C && (g = {\n                platformId: s,\n                encodingId: r,\n                offset: c\n              });\n              if (o) break;\n            }\n          }\n          g && (t.pos = r + g.offset);\n          if (!g || -1 === t.peekByte()) {\n            warn(\"Could not find a preferred cmap table.\");\n            return {\n              platformId: -1,\n              encodingId: -1,\n              mappings: [],\n              hasShortCmap: !1\n            };\n          }\n          const c = t.getUint16();\n          let C = !1;\n          const h = [];\n          let l, Q;\n          if (0 === c) {\n            t.skip(4);\n            for (l = 0; l < 256; l++) {\n              const e = t.getByte();\n              e && h.push({\n                charCode: l,\n                glyphId: e\n              });\n            }\n            C = !0;\n          } else if (2 === c) {\n            t.skip(4);\n            const e = [];\n            let i = 0;\n            for (let a = 0; a < 256; a++) {\n              const a = t.getUint16() >> 3;\n              e.push(a);\n              i = Math.max(a, i);\n            }\n            const a = [];\n            for (let e = 0; e <= i; e++) a.push({\n              firstCode: t.getUint16(),\n              entryCount: t.getUint16(),\n              idDelta: signedInt16(t.getByte(), t.getByte()),\n              idRangePos: t.pos + t.getUint16()\n            });\n            for (let i = 0; i < 256; i++) if (0 === e[i]) {\n              t.pos = a[0].idRangePos + 2 * i;\n              Q = t.getUint16();\n              h.push({\n                charCode: i,\n                glyphId: Q\n              });\n            } else {\n              const s = a[e[i]];\n              for (l = 0; l < s.entryCount; l++) {\n                const e = (i << 8) + l + s.firstCode;\n                t.pos = s.idRangePos + 2 * l;\n                Q = t.getUint16();\n                0 !== Q && (Q = (Q + s.idDelta) % 65536);\n                h.push({\n                  charCode: e,\n                  glyphId: Q\n                });\n              }\n            }\n          } else if (4 === c) {\n            t.skip(4);\n            const e = t.getUint16() >> 1;\n            t.skip(6);\n            const i = [];\n            let a;\n            for (a = 0; a < e; a++) i.push({\n              end: t.getUint16()\n            });\n            t.skip(2);\n            for (a = 0; a < e; a++) i[a].start = t.getUint16();\n            for (a = 0; a < e; a++) i[a].delta = t.getUint16();\n            let n,\n              g = 0;\n            for (a = 0; a < e; a++) {\n              s = i[a];\n              const r = t.getUint16();\n              if (r) {\n                n = (r >> 1) - (e - a);\n                s.offsetIndex = n;\n                g = Math.max(g, n + s.end - s.start + 1);\n              } else s.offsetIndex = -1;\n            }\n            const o = [];\n            for (l = 0; l < g; l++) o.push(t.getUint16());\n            for (a = 0; a < e; a++) {\n              s = i[a];\n              r = s.start;\n              const e = s.end,\n                t = s.delta;\n              n = s.offsetIndex;\n              for (l = r; l <= e; l++) if (65535 !== l) {\n                Q = n < 0 ? l : o[n + l - r];\n                Q = Q + t & 65535;\n                h.push({\n                  charCode: l,\n                  glyphId: Q\n                });\n              }\n            }\n          } else if (6 === c) {\n            t.skip(4);\n            const e = t.getUint16(),\n              i = t.getUint16();\n            for (l = 0; l < i; l++) {\n              Q = t.getUint16();\n              const i = e + l;\n              h.push({\n                charCode: i,\n                glyphId: Q\n              });\n            }\n          } else {\n            if (12 !== c) {\n              warn(\"cmap table has unsupported format: \" + c);\n              return {\n                platformId: -1,\n                encodingId: -1,\n                mappings: [],\n                hasShortCmap: !1\n              };\n            }\n            {\n              t.skip(10);\n              const e = t.getInt32() >>> 0;\n              for (l = 0; l < e; l++) {\n                const e = t.getInt32() >>> 0,\n                  i = t.getInt32() >>> 0;\n                let a = t.getInt32() >>> 0;\n                for (let t = e; t <= i; t++) h.push({\n                  charCode: t,\n                  glyphId: a++\n                });\n              }\n            }\n          }\n          h.sort(function (e, t) {\n            return e.charCode - t.charCode;\n          });\n          for (let e = 1; e < h.length; e++) if (h[e - 1].charCode === h[e].charCode) {\n            h.splice(e, 1);\n            e--;\n          }\n          return {\n            platformId: g.platformId,\n            encodingId: g.encodingId,\n            mappings: h,\n            hasShortCmap: C\n          };\n        }(n.cmap, t, this.isSymbolicFont, i.hasEncoding),\n        a = e.platformId,\n        s = e.encodingId,\n        r = e.mappings;\n      let g = [],\n        o = !1;\n      !i.hasEncoding || \"MacRomanEncoding\" !== i.baseEncodingName && \"WinAnsiEncoding\" !== i.baseEncodingName || (g = getEncoding(i.baseEncodingName));\n      if (i.hasEncoding && !this.isSymbolicFont && (3 === a && 1 === s || 1 === a && 0 === s)) {\n        const e = Ni();\n        for (let t = 0; t < 256; t++) {\n          let n;\n          n = void 0 !== this.differences[t] ? this.differences[t] : g.length && \"\" !== g[t] ? g[t] : fi[t];\n          if (!n) continue;\n          const o = recoverGlyphName(n, e);\n          let c;\n          3 === a && 1 === s ? c = e[o] : 1 === a && 0 === s && (c = di.indexOf(o));\n          if (void 0 === c) {\n            if (!i.glyphNames && i.hasIncludedToUnicodeMap && !(this.toUnicode instanceof IdentityToUnicodeMap)) {\n              const e = this.toUnicode.get(t);\n              e && (c = e.codePointAt(0));\n            }\n            if (void 0 === c) continue;\n          }\n          for (const e of r) if (e.charCode === c) {\n            m[t] = e.glyphId;\n            break;\n          }\n        }\n      } else if (0 === a) {\n        for (const e of r) m[e.charCode] = e.glyphId;\n        o = !0;\n      } else if (3 === a && 0 === s) for (const e of r) {\n        let t = e.charCode;\n        t >= 61440 && t <= 61695 && (t &= 255);\n        m[t] = e.glyphId;\n      } else for (const e of r) m[e.charCode] = e.glyphId;\n      if (i.glyphNames && (g.length || this.differences.length)) for (let e = 0; e < 256; ++e) {\n        if (!o && void 0 !== m[e]) continue;\n        const t = this.differences[e] || g[e];\n        if (!t) continue;\n        const a = i.glyphNames.indexOf(t);\n        a > 0 && hasGlyph(a) && (m[e] = a);\n      }\n    }\n    0 === m.length && (m[0] = 0);\n    let y = l - 1;\n    Q || (y = 0);\n    if (!i.cssFontInfo) {\n      const e = adjustMapping(m, hasGlyph, y, this.toUnicode);\n      this.toFontChar = e.toFontChar;\n      n.cmap = {\n        tag: \"cmap\",\n        data: createCmapTable(e.charCodeToGlyphId, e.toUnicodeExtraMap, l)\n      };\n      n[\"OS/2\"] && function validateOS2Table(e, t) {\n        t.pos = (t.start || 0) + e.offset;\n        const i = t.getUint16();\n        t.skip(60);\n        const a = t.getUint16();\n        if (i < 4 && 768 & a) return !1;\n        if (t.getUint16() > t.getUint16()) return !1;\n        t.skip(6);\n        if (0 === t.getUint16()) return !1;\n        e.data[8] = e.data[9] = 0;\n        return !0;\n      }(n[\"OS/2\"], t) || (n[\"OS/2\"] = {\n        tag: \"OS/2\",\n        data: createOS2Table(i, e.charCodeToGlyphId, p)\n      });\n    }\n    if (!c) try {\n      o = new Stream(n[\"CFF \"].data);\n      g = new CFFParser(o, i, Yi).parse();\n      g.duplicateFirstGlyph();\n      const e = new CFFCompiler(g);\n      n[\"CFF \"].data = e.compile();\n    } catch {\n      warn(\"Failed to compile font \" + i.loadedName);\n    }\n    if (n.name) {\n      const [t, a] = readNameTable(n.name);\n      n.name.data = createNameTable(e, t);\n      this.psName = t[0][6] || null;\n      i.composite || function adjustTrueTypeToUnicode(e, t, i) {\n        if (e.isInternalFont) return;\n        if (e.hasIncludedToUnicodeMap) return;\n        if (e.hasEncoding) return;\n        if (e.toUnicode instanceof IdentityToUnicodeMap) return;\n        if (!t) return;\n        if (0 === i.length) return;\n        if (e.defaultEncoding === pi) return;\n        for (const e of i) if (!isWinNameRecord(e)) return;\n        const a = pi,\n          s = [],\n          r = Ni();\n        for (const e in a) {\n          const t = a[e];\n          if (\"\" === t) continue;\n          const i = r[t];\n          void 0 !== i && (s[e] = String.fromCharCode(i));\n        }\n        s.length > 0 && e.toUnicode.amend(s);\n      }(i, this.isSymbolicFont, a);\n    } else n.name = {\n      tag: \"name\",\n      data: createNameTable(this.name)\n    };\n    const w = new OpenTypeFileBuilder(r.version);\n    for (const e in n) w.addTable(e, n[e].data);\n    return w.toArray();\n  }\n  convert(e, t, i) {\n    i.fixedPitch = !1;\n    i.builtInEncoding && function adjustType1ToUnicode(e, t) {\n      if (e.isInternalFont) return;\n      if (e.hasIncludedToUnicodeMap) return;\n      if (t === e.defaultEncoding) return;\n      if (e.toUnicode instanceof IdentityToUnicodeMap) return;\n      const i = [],\n        a = Ni();\n      for (const s in t) {\n        if (e.hasEncoding && (e.baseEncodingName || void 0 !== e.differences[s])) continue;\n        const r = getUnicodeForGlyph(t[s], a);\n        -1 !== r && (i[s] = String.fromCharCode(r));\n      }\n      i.length > 0 && e.toUnicode.amend(i);\n    }(i, i.builtInEncoding);\n    let s = 1;\n    t instanceof CFFFont && (s = t.numGlyphs - 1);\n    const r = t.getGlyphMapping(i);\n    let n = null,\n      g = r,\n      o = null;\n    if (!i.cssFontInfo) {\n      n = adjustMapping(r, t.hasGlyphId.bind(t), s, this.toUnicode);\n      this.toFontChar = n.toFontChar;\n      g = n.charCodeToGlyphId;\n      o = n.toUnicodeExtraMap;\n    }\n    const c = t.numGlyphs;\n    function getCharCodes(e, t) {\n      let i = null;\n      for (const a in e) t === e[a] && (i ||= []).push(0 | a);\n      return i;\n    }\n    function createCharCode(e, t) {\n      for (const i in e) if (t === e[i]) return 0 | i;\n      n.charCodeToGlyphId[n.nextAvailableFontCharCode] = t;\n      return n.nextAvailableFontCharCode++;\n    }\n    const C = t.seacs;\n    if (n && C?.length) {\n      const e = i.fontMatrix || a,\n        s = t.getCharset(),\n        g = Object.create(null);\n      for (let t in C) {\n        t |= 0;\n        const i = C[t],\n          a = fi[i[2]],\n          o = fi[i[3]],\n          c = s.indexOf(a),\n          h = s.indexOf(o);\n        if (c < 0 || h < 0) continue;\n        const l = {\n            x: i[0] * e[0] + i[1] * e[2] + e[4],\n            y: i[0] * e[1] + i[1] * e[3] + e[5]\n          },\n          Q = getCharCodes(r, t);\n        if (Q) for (const e of Q) {\n          const t = n.charCodeToGlyphId,\n            i = createCharCode(t, c),\n            a = createCharCode(t, h);\n          g[e] = {\n            baseFontCharCode: i,\n            accentFontCharCode: a,\n            accentOffset: l\n          };\n        }\n      }\n      i.seacMap = g;\n    }\n    const h = i.fontMatrix ? 1 / Math.max(...i.fontMatrix.slice(0, 4).map(Math.abs)) : 1e3,\n      l = new OpenTypeFileBuilder(\"OTTO\");\n    l.addTable(\"CFF \", t.data);\n    l.addTable(\"OS/2\", createOS2Table(i, g));\n    l.addTable(\"cmap\", createCmapTable(g, o, c));\n    l.addTable(\"head\", \"\\0\u0001\\0\\0\\0\\0\u0010\\0\\0\\0\\0\\0_\u000f<õ\\0\\0\" + safeString16(h) + \"\\0\\0\\0\\0\\v~'\\0\\0\\0\\0\\v~'\\0\\0\" + safeString16(i.descent) + \"\u000fÿ\" + safeString16(i.ascent) + string16(i.italicAngle ? 2 : 0) + \"\\0\u0011\\0\\0\\0\\0\\0\\0\");\n    l.addTable(\"hhea\", \"\\0\u0001\\0\\0\" + safeString16(i.ascent) + safeString16(i.descent) + \"\\0\\0ÿÿ\\0\\0\\0\\0\\0\\0\" + safeString16(i.capHeight) + safeString16(Math.tan(i.italicAngle) * i.xHeight) + \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" + string16(c));\n    l.addTable(\"hmtx\", function fontFieldsHmtx() {\n      const e = t.charstrings,\n        i = t.cff ? t.cff.widths : null;\n      let a = \"\\0\\0\\0\\0\";\n      for (let t = 1, s = c; t < s; t++) {\n        let s = 0;\n        if (e) {\n          const i = e[t - 1];\n          s = \"width\" in i ? i.width : 0;\n        } else i && (s = Math.ceil(i[t] || 0));\n        a += string16(s) + string16(0);\n      }\n      return a;\n    }());\n    l.addTable(\"maxp\", \"\\0\\0P\\0\" + string16(c));\n    l.addTable(\"name\", createNameTable(e));\n    l.addTable(\"post\", createPostTable(i));\n    return l.toArray();\n  }\n  _charToGlyph(e, t = !1) {\n    let i,\n      a,\n      s,\n      r = this._glyphCache[e];\n    if (r?.isSpace === t) return r;\n    let n = e;\n    if (this.cMap?.contains(e)) {\n      n = this.cMap.lookup(e);\n      \"string\" == typeof n && (n = convertCidString(e, n));\n    }\n    a = this.widths[n];\n    \"number\" != typeof a && (a = this.defaultWidth);\n    const g = this.vmetrics?.[n];\n    let o = this.toUnicode.get(e) || e;\n    \"number\" == typeof o && (o = String.fromCharCode(o));\n    let c = void 0 !== this.toFontChar[e];\n    i = this.toFontChar[e] || e;\n    if (this.missingFile) {\n      const t = this.differences[e] || this.defaultEncoding[e];\n      \".notdef\" !== t && \"\" !== t || \"Type1\" !== this.type || (i = 32);\n      i = function mapSpecialUnicodeValues(e) {\n        return e >= 65520 && e <= 65535 ? 0 : e >= 62976 && e <= 63743 ? xi()[e] || e : 173 === e ? 45 : e;\n      }(i);\n    }\n    this.isType3Font && (s = i);\n    let C = null;\n    if (this.seacMap?.[e]) {\n      c = !0;\n      const t = this.seacMap[e];\n      i = t.baseFontCharCode;\n      C = {\n        fontChar: String.fromCodePoint(t.accentFontCharCode),\n        offset: t.accentOffset\n      };\n    }\n    let h = \"\";\n    \"number\" == typeof i && (i <= 1114111 ? h = String.fromCodePoint(i) : warn(`charToGlyph - invalid fontCharCode: ${i}`));\n    r = new fonts_Glyph(e, h, o, C, a, g, s, t, c);\n    return this._glyphCache[e] = r;\n  }\n  charsToGlyphs(e) {\n    let t = this._charsCache[e];\n    if (t) return t;\n    t = [];\n    if (this.cMap) {\n      const i = Object.create(null),\n        a = e.length;\n      let s = 0;\n      for (; s < a;) {\n        this.cMap.readCharCode(e, s, i);\n        const {\n          charcode: a,\n          length: r\n        } = i;\n        s += r;\n        const n = this._charToGlyph(a, 1 === r && 32 === e.charCodeAt(s - 1));\n        t.push(n);\n      }\n    } else for (let i = 0, a = e.length; i < a; ++i) {\n      const a = e.charCodeAt(i),\n        s = this._charToGlyph(a, 32 === a);\n      t.push(s);\n    }\n    return this._charsCache[e] = t;\n  }\n  getCharPositions(e) {\n    const t = [];\n    if (this.cMap) {\n      const i = Object.create(null);\n      let a = 0;\n      for (; a < e.length;) {\n        this.cMap.readCharCode(e, a, i);\n        const s = i.length;\n        t.push([a, a + s]);\n        a += s;\n      }\n    } else for (let i = 0, a = e.length; i < a; ++i) t.push([i, i + 1]);\n    return t;\n  }\n  get glyphCacheValues() {\n    return Object.values(this._glyphCache);\n  }\n  encodeString(e) {\n    const t = [],\n      i = [],\n      hasCurrentBufErrors = () => t.length % 2 == 1,\n      a = this.toUnicode instanceof IdentityToUnicodeMap ? e => this.toUnicode.charCodeOf(e) : e => this.toUnicode.charCodeOf(String.fromCodePoint(e));\n    for (let s = 0, r = e.length; s < r; s++) {\n      const r = e.codePointAt(s);\n      r > 55295 && (r < 57344 || r > 65533) && s++;\n      if (this.toUnicode) {\n        const e = a(r);\n        if (-1 !== e) {\n          if (hasCurrentBufErrors()) {\n            t.push(i.join(\"\"));\n            i.length = 0;\n          }\n          for (let t = (this.cMap ? this.cMap.getCharCodeLength(e) : 1) - 1; t >= 0; t--) i.push(String.fromCharCode(e >> 8 * t & 255));\n          continue;\n        }\n      }\n      if (!hasCurrentBufErrors()) {\n        t.push(i.join(\"\"));\n        i.length = 0;\n      }\n      i.push(String.fromCodePoint(r));\n    }\n    t.push(i.join(\"\"));\n    return t;\n  }\n}\nclass ErrorFont {\n  constructor(e) {\n    this.error = e;\n    this.loadedName = \"g_font_error\";\n    this.missingFile = !0;\n  }\n  charsToGlyphs() {\n    return [];\n  }\n  encodeString(e) {\n    return [e];\n  }\n  exportData(e = !1) {\n    return {\n      error: this.error\n    };\n  }\n}\nconst Ea = 2,\n  ua = 3,\n  da = 4,\n  fa = 5,\n  pa = 6,\n  ma = 7;\nclass Pattern {\n  constructor() {\n    unreachable(\"Cannot initialize Pattern.\");\n  }\n  static parseShading(e, t, i, a, s) {\n    const r = e instanceof BaseStream ? e.dict : e,\n      n = r.get(\"ShadingType\");\n    try {\n      switch (n) {\n        case Ea:\n        case ua:\n          return new RadialAxialShading(r, t, i, a, s);\n        case da:\n        case fa:\n        case pa:\n        case ma:\n          return new MeshShading(e, t, i, a, s);\n        default:\n          throw new FormatError(\"Unsupported ShadingType: \" + n);\n      }\n    } catch (e) {\n      if (e instanceof MissingDataException) throw e;\n      warn(e);\n      return new DummyShading();\n    }\n  }\n}\nclass BaseShading {\n  static SMALL_NUMBER = 1e-6;\n  constructor() {\n    this.constructor === BaseShading && unreachable(\"Cannot initialize BaseShading.\");\n  }\n  getIR() {\n    unreachable(\"Abstract method `getIR` called.\");\n  }\n}\nclass RadialAxialShading extends BaseShading {\n  constructor(e, t, i, a, s) {\n    super();\n    this.shadingType = e.get(\"ShadingType\");\n    let r = 0;\n    this.shadingType === Ea ? r = 4 : this.shadingType === ua && (r = 6);\n    this.coordsArr = e.getArray(\"Coords\");\n    if (!isNumberArray(this.coordsArr, r)) throw new FormatError(\"RadialAxialShading: Invalid /Coords array.\");\n    const n = ColorSpace.parse({\n      cs: e.getRaw(\"CS\") || e.getRaw(\"ColorSpace\"),\n      xref: t,\n      resources: i,\n      pdfFunctionFactory: a,\n      localColorSpaceCache: s\n    });\n    this.bbox = lookupNormalRect(e.getArray(\"BBox\"), null);\n    let g = 0,\n      o = 1;\n    const c = e.getArray(\"Domain\");\n    isNumberArray(c, 2) && ([g, o] = c);\n    let C = !1,\n      h = !1;\n    const l = e.getArray(\"Extend\");\n    (function isBooleanArray(e, t) {\n      return Array.isArray(e) && (null === t || e.length === t) && e.every(e => \"boolean\" == typeof e);\n    })(l, 2) && ([C, h] = l);\n    if (!(this.shadingType !== ua || C && h)) {\n      const [e, t, i, a, s, r] = this.coordsArr,\n        n = Math.hypot(e - a, t - s);\n      i <= r + n && r <= i + n && warn(\"Unsupported radial gradient.\");\n    }\n    this.extendStart = C;\n    this.extendEnd = h;\n    const Q = e.getRaw(\"Function\"),\n      E = a.createFromArray(Q),\n      u = (o - g) / 840,\n      d = this.colorStops = [];\n    if (g >= o || u <= 0) {\n      info(\"Bad shading domain.\");\n      return;\n    }\n    const f = new Float32Array(n.numComps),\n      p = new Float32Array(1);\n    let m,\n      y = 0;\n    p[0] = g;\n    E(p, 0, f, 0);\n    let w = n.getRgb(f, 0);\n    const D = Util.makeHexColor(w[0], w[1], w[2]);\n    d.push([0, D]);\n    let b = 1;\n    p[0] = g + u;\n    E(p, 0, f, 0);\n    let F = n.getRgb(f, 0),\n      S = F[0] - w[0] + 1,\n      k = F[1] - w[1] + 1,\n      R = F[2] - w[2] + 1,\n      N = F[0] - w[0] - 1,\n      G = F[1] - w[1] - 1,\n      x = F[2] - w[2] - 1;\n    for (let e = 2; e < 840; e++) {\n      p[0] = g + e * u;\n      E(p, 0, f, 0);\n      m = n.getRgb(f, 0);\n      const t = e - y;\n      S = Math.min(S, (m[0] - w[0] + 1) / t);\n      k = Math.min(k, (m[1] - w[1] + 1) / t);\n      R = Math.min(R, (m[2] - w[2] + 1) / t);\n      N = Math.max(N, (m[0] - w[0] - 1) / t);\n      G = Math.max(G, (m[1] - w[1] - 1) / t);\n      x = Math.max(x, (m[2] - w[2] - 1) / t);\n      if (!(N <= S && G <= k && x <= R)) {\n        const e = Util.makeHexColor(F[0], F[1], F[2]);\n        d.push([b / 840, e]);\n        S = m[0] - F[0] + 1;\n        k = m[1] - F[1] + 1;\n        R = m[2] - F[2] + 1;\n        N = m[0] - F[0] - 1;\n        G = m[1] - F[1] - 1;\n        x = m[2] - F[2] - 1;\n        y = b;\n        w = F;\n      }\n      b = e;\n      F = m;\n    }\n    const U = Util.makeHexColor(F[0], F[1], F[2]);\n    d.push([1, U]);\n    let M = \"transparent\";\n    if (e.has(\"Background\")) {\n      m = n.getRgb(e.get(\"Background\"), 0);\n      M = Util.makeHexColor(m[0], m[1], m[2]);\n    }\n    if (!C) {\n      d.unshift([0, M]);\n      d[1][0] += BaseShading.SMALL_NUMBER;\n    }\n    if (!h) {\n      d.at(-1)[0] -= BaseShading.SMALL_NUMBER;\n      d.push([1, M]);\n    }\n    this.colorStops = d;\n  }\n  getIR() {\n    const {\n      coordsArr: e,\n      shadingType: t\n    } = this;\n    let i, a, s, r, n;\n    if (t === Ea) {\n      a = [e[0], e[1]];\n      s = [e[2], e[3]];\n      r = null;\n      n = null;\n      i = \"axial\";\n    } else if (t === ua) {\n      a = [e[0], e[1]];\n      s = [e[3], e[4]];\n      r = e[2];\n      n = e[5];\n      i = \"radial\";\n    } else unreachable(`getPattern type unknown: ${t}`);\n    return [\"RadialAxial\", i, this.bbox, this.colorStops, a, s, r, n];\n  }\n}\nclass MeshStreamReader {\n  constructor(e, t) {\n    this.stream = e;\n    this.context = t;\n    this.buffer = 0;\n    this.bufferLength = 0;\n    const i = t.numComps;\n    this.tmpCompsBuf = new Float32Array(i);\n    const a = t.colorSpace.numComps;\n    this.tmpCsCompsBuf = t.colorFn ? new Float32Array(a) : this.tmpCompsBuf;\n  }\n  get hasData() {\n    if (this.stream.end) return this.stream.pos < this.stream.end;\n    if (this.bufferLength > 0) return !0;\n    const e = this.stream.getByte();\n    if (e < 0) return !1;\n    this.buffer = e;\n    this.bufferLength = 8;\n    return !0;\n  }\n  readBits(e) {\n    let t = this.buffer,\n      i = this.bufferLength;\n    if (32 === e) {\n      if (0 === i) return (this.stream.getByte() << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte()) >>> 0;\n      t = t << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte();\n      const e = this.stream.getByte();\n      this.buffer = e & (1 << i) - 1;\n      return (t << 8 - i | (255 & e) >> i) >>> 0;\n    }\n    if (8 === e && 0 === i) return this.stream.getByte();\n    for (; i < e;) {\n      t = t << 8 | this.stream.getByte();\n      i += 8;\n    }\n    i -= e;\n    this.bufferLength = i;\n    this.buffer = t & (1 << i) - 1;\n    return t >> i;\n  }\n  align() {\n    this.buffer = 0;\n    this.bufferLength = 0;\n  }\n  readFlag() {\n    return this.readBits(this.context.bitsPerFlag);\n  }\n  readCoordinate() {\n    const e = this.context.bitsPerCoordinate,\n      t = this.readBits(e),\n      i = this.readBits(e),\n      a = this.context.decode,\n      s = e < 32 ? 1 / ((1 << e) - 1) : 2.3283064365386963e-10;\n    return [t * s * (a[1] - a[0]) + a[0], i * s * (a[3] - a[2]) + a[2]];\n  }\n  readComponents() {\n    const e = this.context.numComps,\n      t = this.context.bitsPerComponent,\n      i = t < 32 ? 1 / ((1 << t) - 1) : 2.3283064365386963e-10,\n      a = this.context.decode,\n      s = this.tmpCompsBuf;\n    for (let r = 0, n = 4; r < e; r++, n += 2) {\n      const e = this.readBits(t);\n      s[r] = e * i * (a[n + 1] - a[n]) + a[n];\n    }\n    const r = this.tmpCsCompsBuf;\n    this.context.colorFn && this.context.colorFn(s, 0, r, 0);\n    return this.context.colorSpace.getRgb(r, 0);\n  }\n}\nlet ya = Object.create(null);\nfunction getB(e) {\n  return ya[e] ||= function buildB(e) {\n    const t = [];\n    for (let i = 0; i <= e; i++) {\n      const a = i / e,\n        s = 1 - a;\n      t.push(new Float32Array([s ** 3, 3 * a * s ** 2, 3 * a ** 2 * s, a ** 3]));\n    }\n    return t;\n  }(e);\n}\nclass MeshShading extends BaseShading {\n  static MIN_SPLIT_PATCH_CHUNKS_AMOUNT = 3;\n  static MAX_SPLIT_PATCH_CHUNKS_AMOUNT = 20;\n  static TRIANGLE_DENSITY = 20;\n  constructor(e, t, i, a, s) {\n    super();\n    if (!(e instanceof BaseStream)) throw new FormatError(\"Mesh data is not a stream\");\n    const r = e.dict;\n    this.shadingType = r.get(\"ShadingType\");\n    this.bbox = lookupNormalRect(r.getArray(\"BBox\"), null);\n    const n = ColorSpace.parse({\n      cs: r.getRaw(\"CS\") || r.getRaw(\"ColorSpace\"),\n      xref: t,\n      resources: i,\n      pdfFunctionFactory: a,\n      localColorSpaceCache: s\n    });\n    this.background = r.has(\"Background\") ? n.getRgb(r.get(\"Background\"), 0) : null;\n    const g = r.getRaw(\"Function\"),\n      o = g ? a.createFromArray(g) : null;\n    this.coords = [];\n    this.colors = [];\n    this.figures = [];\n    const c = {\n        bitsPerCoordinate: r.get(\"BitsPerCoordinate\"),\n        bitsPerComponent: r.get(\"BitsPerComponent\"),\n        bitsPerFlag: r.get(\"BitsPerFlag\"),\n        decode: r.getArray(\"Decode\"),\n        colorFn: o,\n        colorSpace: n,\n        numComps: o ? 1 : n.numComps\n      },\n      C = new MeshStreamReader(e, c);\n    let h = !1;\n    switch (this.shadingType) {\n      case da:\n        this._decodeType4Shading(C);\n        break;\n      case fa:\n        const e = 0 | r.get(\"VerticesPerRow\");\n        if (e < 2) throw new FormatError(\"Invalid VerticesPerRow\");\n        this._decodeType5Shading(C, e);\n        break;\n      case pa:\n        this._decodeType6Shading(C);\n        h = !0;\n        break;\n      case ma:\n        this._decodeType7Shading(C);\n        h = !0;\n        break;\n      default:\n        unreachable(\"Unsupported mesh type.\");\n    }\n    if (h) {\n      this._updateBounds();\n      for (let e = 0, t = this.figures.length; e < t; e++) this._buildFigureFromPatch(e);\n    }\n    this._updateBounds();\n    this._packData();\n  }\n  _decodeType4Shading(e) {\n    const t = this.coords,\n      i = this.colors,\n      a = [],\n      s = [];\n    let r = 0;\n    for (; e.hasData;) {\n      const n = e.readFlag(),\n        g = e.readCoordinate(),\n        o = e.readComponents();\n      if (0 === r) {\n        if (!(0 <= n && n <= 2)) throw new FormatError(\"Unknown type4 flag\");\n        switch (n) {\n          case 0:\n            r = 3;\n            break;\n          case 1:\n            s.push(s.at(-2), s.at(-1));\n            r = 1;\n            break;\n          case 2:\n            s.push(s.at(-3), s.at(-1));\n            r = 1;\n        }\n        a.push(n);\n      }\n      s.push(t.length);\n      t.push(g);\n      i.push(o);\n      r--;\n      e.align();\n    }\n    this.figures.push({\n      type: \"triangles\",\n      coords: new Int32Array(s),\n      colors: new Int32Array(s)\n    });\n  }\n  _decodeType5Shading(e, t) {\n    const i = this.coords,\n      a = this.colors,\n      s = [];\n    for (; e.hasData;) {\n      const t = e.readCoordinate(),\n        r = e.readComponents();\n      s.push(i.length);\n      i.push(t);\n      a.push(r);\n    }\n    this.figures.push({\n      type: \"lattice\",\n      coords: new Int32Array(s),\n      colors: new Int32Array(s),\n      verticesPerRow: t\n    });\n  }\n  _decodeType6Shading(e) {\n    const t = this.coords,\n      i = this.colors,\n      a = new Int32Array(16),\n      s = new Int32Array(4);\n    for (; e.hasData;) {\n      const r = e.readFlag();\n      if (!(0 <= r && r <= 3)) throw new FormatError(\"Unknown type6 flag\");\n      const n = t.length;\n      for (let i = 0, a = 0 !== r ? 8 : 12; i < a; i++) t.push(e.readCoordinate());\n      const g = i.length;\n      for (let t = 0, a = 0 !== r ? 2 : 4; t < a; t++) i.push(e.readComponents());\n      let o, c, C, h;\n      switch (r) {\n        case 0:\n          a[12] = n + 3;\n          a[13] = n + 4;\n          a[14] = n + 5;\n          a[15] = n + 6;\n          a[8] = n + 2;\n          a[11] = n + 7;\n          a[4] = n + 1;\n          a[7] = n + 8;\n          a[0] = n;\n          a[1] = n + 11;\n          a[2] = n + 10;\n          a[3] = n + 9;\n          s[2] = g + 1;\n          s[3] = g + 2;\n          s[0] = g;\n          s[1] = g + 3;\n          break;\n        case 1:\n          o = a[12];\n          c = a[13];\n          C = a[14];\n          h = a[15];\n          a[12] = h;\n          a[13] = n + 0;\n          a[14] = n + 1;\n          a[15] = n + 2;\n          a[8] = C;\n          a[11] = n + 3;\n          a[4] = c;\n          a[7] = n + 4;\n          a[0] = o;\n          a[1] = n + 7;\n          a[2] = n + 6;\n          a[3] = n + 5;\n          o = s[2];\n          c = s[3];\n          s[2] = c;\n          s[3] = g;\n          s[0] = o;\n          s[1] = g + 1;\n          break;\n        case 2:\n          o = a[15];\n          c = a[11];\n          a[12] = a[3];\n          a[13] = n + 0;\n          a[14] = n + 1;\n          a[15] = n + 2;\n          a[8] = a[7];\n          a[11] = n + 3;\n          a[4] = c;\n          a[7] = n + 4;\n          a[0] = o;\n          a[1] = n + 7;\n          a[2] = n + 6;\n          a[3] = n + 5;\n          o = s[3];\n          s[2] = s[1];\n          s[3] = g;\n          s[0] = o;\n          s[1] = g + 1;\n          break;\n        case 3:\n          a[12] = a[0];\n          a[13] = n + 0;\n          a[14] = n + 1;\n          a[15] = n + 2;\n          a[8] = a[1];\n          a[11] = n + 3;\n          a[4] = a[2];\n          a[7] = n + 4;\n          a[0] = a[3];\n          a[1] = n + 7;\n          a[2] = n + 6;\n          a[3] = n + 5;\n          s[2] = s[0];\n          s[3] = g;\n          s[0] = s[1];\n          s[1] = g + 1;\n      }\n      a[5] = t.length;\n      t.push([(-4 * t[a[0]][0] - t[a[15]][0] + 6 * (t[a[4]][0] + t[a[1]][0]) - 2 * (t[a[12]][0] + t[a[3]][0]) + 3 * (t[a[13]][0] + t[a[7]][0])) / 9, (-4 * t[a[0]][1] - t[a[15]][1] + 6 * (t[a[4]][1] + t[a[1]][1]) - 2 * (t[a[12]][1] + t[a[3]][1]) + 3 * (t[a[13]][1] + t[a[7]][1])) / 9]);\n      a[6] = t.length;\n      t.push([(-4 * t[a[3]][0] - t[a[12]][0] + 6 * (t[a[2]][0] + t[a[7]][0]) - 2 * (t[a[0]][0] + t[a[15]][0]) + 3 * (t[a[4]][0] + t[a[14]][0])) / 9, (-4 * t[a[3]][1] - t[a[12]][1] + 6 * (t[a[2]][1] + t[a[7]][1]) - 2 * (t[a[0]][1] + t[a[15]][1]) + 3 * (t[a[4]][1] + t[a[14]][1])) / 9]);\n      a[9] = t.length;\n      t.push([(-4 * t[a[12]][0] - t[a[3]][0] + 6 * (t[a[8]][0] + t[a[13]][0]) - 2 * (t[a[0]][0] + t[a[15]][0]) + 3 * (t[a[11]][0] + t[a[1]][0])) / 9, (-4 * t[a[12]][1] - t[a[3]][1] + 6 * (t[a[8]][1] + t[a[13]][1]) - 2 * (t[a[0]][1] + t[a[15]][1]) + 3 * (t[a[11]][1] + t[a[1]][1])) / 9]);\n      a[10] = t.length;\n      t.push([(-4 * t[a[15]][0] - t[a[0]][0] + 6 * (t[a[11]][0] + t[a[14]][0]) - 2 * (t[a[12]][0] + t[a[3]][0]) + 3 * (t[a[2]][0] + t[a[8]][0])) / 9, (-4 * t[a[15]][1] - t[a[0]][1] + 6 * (t[a[11]][1] + t[a[14]][1]) - 2 * (t[a[12]][1] + t[a[3]][1]) + 3 * (t[a[2]][1] + t[a[8]][1])) / 9]);\n      this.figures.push({\n        type: \"patch\",\n        coords: new Int32Array(a),\n        colors: new Int32Array(s)\n      });\n    }\n  }\n  _decodeType7Shading(e) {\n    const t = this.coords,\n      i = this.colors,\n      a = new Int32Array(16),\n      s = new Int32Array(4);\n    for (; e.hasData;) {\n      const r = e.readFlag();\n      if (!(0 <= r && r <= 3)) throw new FormatError(\"Unknown type7 flag\");\n      const n = t.length;\n      for (let i = 0, a = 0 !== r ? 12 : 16; i < a; i++) t.push(e.readCoordinate());\n      const g = i.length;\n      for (let t = 0, a = 0 !== r ? 2 : 4; t < a; t++) i.push(e.readComponents());\n      let o, c, C, h;\n      switch (r) {\n        case 0:\n          a[12] = n + 3;\n          a[13] = n + 4;\n          a[14] = n + 5;\n          a[15] = n + 6;\n          a[8] = n + 2;\n          a[9] = n + 13;\n          a[10] = n + 14;\n          a[11] = n + 7;\n          a[4] = n + 1;\n          a[5] = n + 12;\n          a[6] = n + 15;\n          a[7] = n + 8;\n          a[0] = n;\n          a[1] = n + 11;\n          a[2] = n + 10;\n          a[3] = n + 9;\n          s[2] = g + 1;\n          s[3] = g + 2;\n          s[0] = g;\n          s[1] = g + 3;\n          break;\n        case 1:\n          o = a[12];\n          c = a[13];\n          C = a[14];\n          h = a[15];\n          a[12] = h;\n          a[13] = n + 0;\n          a[14] = n + 1;\n          a[15] = n + 2;\n          a[8] = C;\n          a[9] = n + 9;\n          a[10] = n + 10;\n          a[11] = n + 3;\n          a[4] = c;\n          a[5] = n + 8;\n          a[6] = n + 11;\n          a[7] = n + 4;\n          a[0] = o;\n          a[1] = n + 7;\n          a[2] = n + 6;\n          a[3] = n + 5;\n          o = s[2];\n          c = s[3];\n          s[2] = c;\n          s[3] = g;\n          s[0] = o;\n          s[1] = g + 1;\n          break;\n        case 2:\n          o = a[15];\n          c = a[11];\n          a[12] = a[3];\n          a[13] = n + 0;\n          a[14] = n + 1;\n          a[15] = n + 2;\n          a[8] = a[7];\n          a[9] = n + 9;\n          a[10] = n + 10;\n          a[11] = n + 3;\n          a[4] = c;\n          a[5] = n + 8;\n          a[6] = n + 11;\n          a[7] = n + 4;\n          a[0] = o;\n          a[1] = n + 7;\n          a[2] = n + 6;\n          a[3] = n + 5;\n          o = s[3];\n          s[2] = s[1];\n          s[3] = g;\n          s[0] = o;\n          s[1] = g + 1;\n          break;\n        case 3:\n          a[12] = a[0];\n          a[13] = n + 0;\n          a[14] = n + 1;\n          a[15] = n + 2;\n          a[8] = a[1];\n          a[9] = n + 9;\n          a[10] = n + 10;\n          a[11] = n + 3;\n          a[4] = a[2];\n          a[5] = n + 8;\n          a[6] = n + 11;\n          a[7] = n + 4;\n          a[0] = a[3];\n          a[1] = n + 7;\n          a[2] = n + 6;\n          a[3] = n + 5;\n          s[2] = s[0];\n          s[3] = g;\n          s[0] = s[1];\n          s[1] = g + 1;\n      }\n      this.figures.push({\n        type: \"patch\",\n        coords: new Int32Array(a),\n        colors: new Int32Array(s)\n      });\n    }\n  }\n  _buildFigureFromPatch(e) {\n    const t = this.figures[e];\n    assert(\"patch\" === t.type, \"Unexpected patch mesh figure\");\n    const i = this.coords,\n      a = this.colors,\n      s = t.coords,\n      r = t.colors,\n      n = Math.min(i[s[0]][0], i[s[3]][0], i[s[12]][0], i[s[15]][0]),\n      g = Math.min(i[s[0]][1], i[s[3]][1], i[s[12]][1], i[s[15]][1]),\n      o = Math.max(i[s[0]][0], i[s[3]][0], i[s[12]][0], i[s[15]][0]),\n      c = Math.max(i[s[0]][1], i[s[3]][1], i[s[12]][1], i[s[15]][1]);\n    let C = Math.ceil((o - n) * MeshShading.TRIANGLE_DENSITY / (this.bounds[2] - this.bounds[0]));\n    C = Math.max(MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, C));\n    let h = Math.ceil((c - g) * MeshShading.TRIANGLE_DENSITY / (this.bounds[3] - this.bounds[1]));\n    h = Math.max(MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, h));\n    const l = C + 1,\n      Q = new Int32Array((h + 1) * l),\n      E = new Int32Array((h + 1) * l);\n    let u = 0;\n    const d = new Uint8Array(3),\n      f = new Uint8Array(3),\n      p = a[r[0]],\n      m = a[r[1]],\n      y = a[r[2]],\n      w = a[r[3]],\n      D = getB(h),\n      b = getB(C);\n    for (let e = 0; e <= h; e++) {\n      d[0] = (p[0] * (h - e) + y[0] * e) / h | 0;\n      d[1] = (p[1] * (h - e) + y[1] * e) / h | 0;\n      d[2] = (p[2] * (h - e) + y[2] * e) / h | 0;\n      f[0] = (m[0] * (h - e) + w[0] * e) / h | 0;\n      f[1] = (m[1] * (h - e) + w[1] * e) / h | 0;\n      f[2] = (m[2] * (h - e) + w[2] * e) / h | 0;\n      for (let t = 0; t <= C; t++, u++) {\n        if (!(0 !== e && e !== h || 0 !== t && t !== C)) continue;\n        let r = 0,\n          n = 0,\n          g = 0;\n        for (let a = 0; a <= 3; a++) for (let o = 0; o <= 3; o++, g++) {\n          const c = D[e][a] * b[t][o];\n          r += i[s[g]][0] * c;\n          n += i[s[g]][1] * c;\n        }\n        Q[u] = i.length;\n        i.push([r, n]);\n        E[u] = a.length;\n        const o = new Uint8Array(3);\n        o[0] = (d[0] * (C - t) + f[0] * t) / C | 0;\n        o[1] = (d[1] * (C - t) + f[1] * t) / C | 0;\n        o[2] = (d[2] * (C - t) + f[2] * t) / C | 0;\n        a.push(o);\n      }\n    }\n    Q[0] = s[0];\n    E[0] = r[0];\n    Q[C] = s[3];\n    E[C] = r[1];\n    Q[l * h] = s[12];\n    E[l * h] = r[2];\n    Q[l * h + C] = s[15];\n    E[l * h + C] = r[3];\n    this.figures[e] = {\n      type: \"lattice\",\n      coords: Q,\n      colors: E,\n      verticesPerRow: l\n    };\n  }\n  _updateBounds() {\n    let e = this.coords[0][0],\n      t = this.coords[0][1],\n      i = e,\n      a = t;\n    for (let s = 1, r = this.coords.length; s < r; s++) {\n      const r = this.coords[s][0],\n        n = this.coords[s][1];\n      e = e > r ? r : e;\n      t = t > n ? n : t;\n      i = i < r ? r : i;\n      a = a < n ? n : a;\n    }\n    this.bounds = [e, t, i, a];\n  }\n  _packData() {\n    let e, t, i, a;\n    const s = this.coords,\n      r = new Float32Array(2 * s.length);\n    for (e = 0, i = 0, t = s.length; e < t; e++) {\n      const t = s[e];\n      r[i++] = t[0];\n      r[i++] = t[1];\n    }\n    this.coords = r;\n    const n = this.colors,\n      g = new Uint8Array(3 * n.length);\n    for (e = 0, i = 0, t = n.length; e < t; e++) {\n      const t = n[e];\n      g[i++] = t[0];\n      g[i++] = t[1];\n      g[i++] = t[2];\n    }\n    this.colors = g;\n    const o = this.figures;\n    for (e = 0, t = o.length; e < t; e++) {\n      const t = o[e],\n        s = t.coords,\n        r = t.colors;\n      for (i = 0, a = s.length; i < a; i++) {\n        s[i] *= 2;\n        r[i] *= 3;\n      }\n    }\n  }\n  getIR() {\n    const {\n      bounds: e\n    } = this;\n    if (e[2] - e[0] == 0 || e[3] - e[1] == 0) throw new FormatError(`Invalid MeshShading bounds: [${e}].`);\n    return [\"Mesh\", this.shadingType, this.coords, this.colors, this.figures, e, this.bbox, this.background];\n  }\n}\nclass DummyShading extends BaseShading {\n  getIR() {\n    return [\"Dummy\"];\n  }\n}\nfunction getTilingPatternIR(e, t, a) {\n  const s = lookupMatrix(t.getArray(\"Matrix\"), i),\n    r = lookupNormalRect(t.getArray(\"BBox\"), null);\n  if (!r || r[2] - r[0] == 0 || r[3] - r[1] == 0) throw new FormatError(\"Invalid getTilingPatternIR /BBox array.\");\n  const n = t.get(\"XStep\");\n  if (\"number\" != typeof n) throw new FormatError(\"Invalid getTilingPatternIR /XStep value.\");\n  const g = t.get(\"YStep\");\n  if (\"number\" != typeof g) throw new FormatError(\"Invalid getTilingPatternIR /YStep value.\");\n  const o = t.get(\"PaintType\");\n  if (!Number.isInteger(o)) throw new FormatError(\"Invalid getTilingPatternIR /PaintType value.\");\n  const c = t.get(\"TilingType\");\n  if (!Number.isInteger(c)) throw new FormatError(\"Invalid getTilingPatternIR /TilingType value.\");\n  return [\"TilingPattern\", a, e, s, r, n, g, o, c];\n}\nconst wa = [1.3877, 1, 1, 1, .97801, .92482, .89552, .91133, .81988, .97566, .98152, .93548, .93548, 1.2798, .85284, .92794, 1, .96134, 1.54657, .91133, .91133, .91133, .91133, .91133, .91133, .91133, .91133, .91133, .91133, .82845, .82845, .85284, .85284, .85284, .75859, .92138, .83908, .7762, .73293, .87289, .73133, .7514, .81921, .87356, .95958, .59526, .75727, .69225, 1.04924, .9121, .86943, .79795, .88198, .77958, .70864, .81055, .90399, .88653, .96017, .82577, .77892, .78257, .97507, 1.54657, .97507, .85284, .89552, .90176, .88762, .8785, .75241, .8785, .90518, .95015, .77618, .8785, .88401, .91916, .86304, .88401, .91488, .8785, .8801, .8785, .8785, .91343, .7173, 1.04106, .8785, .85075, .95794, .82616, .85162, .79492, .88331, 1.69808, .88331, .85284, .97801, .89552, .91133, .89552, .91133, 1.7801, .89552, 1.24487, 1.13254, 1.12401, .96839, .85284, .68787, .70645, .85592, .90747, 1.01466, 1.0088, .90323, 1, 1.07463, 1, .91056, .75806, 1.19118, .96839, .78864, .82845, .84133, .75859, .83908, .83908, .83908, .83908, .83908, .83908, .77539, .73293, .73133, .73133, .73133, .73133, .95958, .95958, .95958, .95958, .88506, .9121, .86943, .86943, .86943, .86943, .86943, .85284, .87508, .90399, .90399, .90399, .90399, .77892, .79795, .90807, .88762, .88762, .88762, .88762, .88762, .88762, .8715, .75241, .90518, .90518, .90518, .90518, .88401, .88401, .88401, .88401, .8785, .8785, .8801, .8801, .8801, .8801, .8801, .90747, .89049, .8785, .8785, .8785, .8785, .85162, .8785, .85162, .83908, .88762, .83908, .88762, .83908, .88762, .73293, .75241, .73293, .75241, .73293, .75241, .73293, .75241, .87289, .83016, .88506, .93125, .73133, .90518, .73133, .90518, .73133, .90518, .73133, .90518, .73133, .90518, .81921, .77618, .81921, .77618, .81921, .77618, 1, 1, .87356, .8785, .91075, .89608, .95958, .88401, .95958, .88401, .95958, .88401, .95958, .88401, .95958, .88401, .76229, .90167, .59526, .91916, 1, 1, .86304, .69225, .88401, 1, 1, .70424, .79468, .91926, .88175, .70823, .94903, .9121, .8785, 1, 1, .9121, .8785, .87802, .88656, .8785, .86943, .8801, .86943, .8801, .86943, .8801, .87402, .89291, .77958, .91343, 1, 1, .77958, .91343, .70864, .7173, .70864, .7173, .70864, .7173, .70864, .7173, 1, 1, .81055, .75841, .81055, 1.06452, .90399, .8785, .90399, .8785, .90399, .8785, .90399, .8785, .90399, .8785, .90399, .8785, .96017, .95794, .77892, .85162, .77892, .78257, .79492, .78257, .79492, .78257, .79492, .9297, .56892, .83908, .88762, .77539, .8715, .87508, .89049, 1, 1, .81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, .70674, .98387, .94721, 1.33431, 1.45894, .95161, 1.06303, .83908, .80352, .57184, .6965, .56289, .82001, .56029, .81235, 1.02988, .83908, .7762, .68156, .80367, .73133, .78257, .87356, .86943, .95958, .75727, .89019, 1.04924, .9121, .7648, .86943, .87356, .79795, .78275, .81055, .77892, .9762, .82577, .99819, .84896, .95958, .77892, .96108, 1.01407, .89049, 1.02988, .94211, .96108, .8936, .84021, .87842, .96399, .79109, .89049, 1.00813, 1.02988, .86077, .87445, .92099, .84723, .86513, .8801, .75638, .85714, .78216, .79586, .87965, .94211, .97747, .78287, .97926, .84971, 1.02988, .94211, .8801, .94211, .84971, .73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .90264, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .90518, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .90548, 1, 1, 1, 1, 1, 1, .96017, .95794, .96017, .95794, .96017, .95794, .77892, .85162, 1, 1, .89552, .90527, 1, .90363, .92794, .92794, .92794, .92794, .87012, .87012, .87012, .89552, .89552, 1.42259, .71143, 1.06152, 1, 1, 1.03372, 1.03372, .97171, 1.4956, 2.2807, .93835, .83406, .91133, .84107, .91133, 1, 1, 1, .72021, 1, 1.23108, .83489, .88525, .88525, .81499, .90527, 1.81055, .90527, 1.81055, 1.31006, 1.53711, .94434, 1.08696, 1, .95018, .77192, .85284, .90747, 1.17534, .69825, .9716, 1.37077, .90747, .90747, .85356, .90747, .90747, 1.44947, .85284, .8941, .8941, .70572, .8, .70572, .70572, .70572, .70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .99862, .99862, 1, 1, 1, 1, 1, 1.08004, .91027, 1, 1, 1, .99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .90727, .90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  Da = {\n    lineHeight: 1.2207,\n    lineGap: .2207\n  },\n  ba = [1.3877, 1, 1, 1, .97801, .92482, .89552, .91133, .81988, .97566, .98152, .93548, .93548, 1.2798, .85284, .92794, 1, .96134, 1.56239, .91133, .91133, .91133, .91133, .91133, .91133, .91133, .91133, .91133, .91133, .82845, .82845, .85284, .85284, .85284, .75859, .92138, .83908, .7762, .71805, .87289, .73133, .7514, .81921, .87356, .95958, .59526, .75727, .69225, 1.04924, .90872, .85938, .79795, .87068, .77958, .69766, .81055, .90399, .88653, .96068, .82577, .77892, .78257, .97507, 1.529, .97507, .85284, .89552, .90176, .94908, .86411, .74012, .86411, .88323, .95015, .86411, .86331, .88401, .91916, .86304, .88401, .9039, .86331, .86331, .86411, .86411, .90464, .70852, 1.04106, .86331, .84372, .95794, .82616, .84548, .79492, .88331, 1.69808, .88331, .85284, .97801, .89552, .91133, .89552, .91133, 1.7801, .89552, 1.24487, 1.13254, 1.19129, .96839, .85284, .68787, .70645, .85592, .90747, 1.01466, 1.0088, .90323, 1, 1.07463, 1, .91056, .75806, 1.19118, .96839, .78864, .82845, .84133, .75859, .83908, .83908, .83908, .83908, .83908, .83908, .77539, .71805, .73133, .73133, .73133, .73133, .95958, .95958, .95958, .95958, .88506, .90872, .85938, .85938, .85938, .85938, .85938, .85284, .87068, .90399, .90399, .90399, .90399, .77892, .79795, .90807, .94908, .94908, .94908, .94908, .94908, .94908, .85887, .74012, .88323, .88323, .88323, .88323, .88401, .88401, .88401, .88401, .8785, .86331, .86331, .86331, .86331, .86331, .86331, .90747, .89049, .86331, .86331, .86331, .86331, .84548, .86411, .84548, .83908, .94908, .83908, .94908, .83908, .94908, .71805, .74012, .71805, .74012, .71805, .74012, .71805, .74012, .87289, .79538, .88506, .92726, .73133, .88323, .73133, .88323, .73133, .88323, .73133, .88323, .73133, .88323, .81921, .86411, .81921, .86411, .81921, .86411, 1, 1, .87356, .86331, .91075, .8777, .95958, .88401, .95958, .88401, .95958, .88401, .95958, .88401, .95958, .88401, .76467, .90167, .59526, .91916, 1, 1, .86304, .69225, .88401, 1, 1, .70424, .77312, .91926, .88175, .70823, .94903, .90872, .86331, 1, 1, .90872, .86331, .86906, .88116, .86331, .85938, .86331, .85938, .86331, .85938, .86331, .87402, .86549, .77958, .90464, 1, 1, .77958, .90464, .69766, .70852, .69766, .70852, .69766, .70852, .69766, .70852, 1, 1, .81055, .75841, .81055, 1.06452, .90399, .86331, .90399, .86331, .90399, .86331, .90399, .86331, .90399, .86331, .90399, .86331, .96068, .95794, .77892, .84548, .77892, .78257, .79492, .78257, .79492, .78257, .79492, .9297, .56892, .83908, .94908, .77539, .85887, .87068, .89049, 1, 1, .81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, .70088, .98387, .94721, 1.33431, 1.45894, .95161, 1.48387, .83908, .80352, .57118, .6965, .56347, .79179, .55853, .80346, 1.02988, .83908, .7762, .67174, .86036, .73133, .78257, .87356, .86441, .95958, .75727, .89019, 1.04924, .90872, .74889, .85938, .87891, .79795, .7957, .81055, .77892, .97447, .82577, .97466, .87179, .95958, .77892, .94252, .95612, .8753, 1.02988, .92733, .94252, .87411, .84021, .8728, .95612, .74081, .8753, 1.02189, 1.02988, .84814, .87445, .91822, .84723, .85668, .86331, .81344, .87581, .76422, .82046, .96057, .92733, .99375, .78022, .95452, .86015, 1.02988, .92733, .86331, .92733, .86015, .73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .90631, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .88323, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .85174, 1, 1, 1, 1, 1, 1, .96068, .95794, .96068, .95794, .96068, .95794, .77892, .84548, 1, 1, .89552, .90527, 1, .90363, .92794, .92794, .92794, .89807, .87012, .87012, .87012, .89552, .89552, 1.42259, .71094, 1.06152, 1, 1, 1.03372, 1.03372, .97171, 1.4956, 2.2807, .92972, .83406, .91133, .83326, .91133, 1, 1, 1, .72021, 1, 1.23108, .83489, .88525, .88525, .81499, .90616, 1.81055, .90527, 1.81055, 1.3107, 1.53711, .94434, 1.08696, 1, .95018, .77192, .85284, .90747, 1.17534, .69825, .9716, 1.37077, .90747, .90747, .85356, .90747, .90747, 1.44947, .85284, .8941, .8941, .70572, .8, .70572, .70572, .70572, .70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .99862, .99862, 1, 1, 1, 1, 1, 1.08004, .91027, 1, 1, 1, .99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .90727, .90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  Fa = {\n    lineHeight: 1.2207,\n    lineGap: .2207\n  },\n  Sa = [1.3877, 1, 1, 1, 1.17223, 1.1293, .89552, .91133, .80395, 1.02269, 1.15601, .91056, .91056, 1.2798, .85284, .89807, 1, .90861, 1.39543, .91133, .91133, .91133, .91133, .91133, .91133, .91133, .91133, .91133, .91133, .96309, .96309, .85284, .85284, .85284, .83319, .88071, .8675, .81552, .72346, .85193, .73206, .7522, .81105, .86275, .90685, .6377, .77892, .75593, 1.02638, .89249, .84118, .77452, .85374, .75186, .67789, .79776, .88844, .85066, .94309, .77818, .7306, .76659, 1.10369, 1.38313, 1.10369, 1.06139, .89552, .8739, .9245, .9245, .83203, .9245, .85865, 1.09842, .9245, .9245, 1.03297, 1.07692, .90918, 1.03297, .94959, .9245, .92274, .9245, .9245, 1.02933, .77832, 1.20562, .9245, .8916, .98986, .86621, .89453, .79004, .94152, 1.77256, .94152, .85284, .97801, .89552, .91133, .89552, .91133, 1.91729, .89552, 1.17889, 1.13254, 1.16359, .92098, .85284, .68787, .71353, .84737, .90747, 1.0088, 1.0044, .87683, 1, 1.09091, 1, .92229, .739, 1.15642, .92098, .76288, .80504, .80972, .75859, .8675, .8675, .8675, .8675, .8675, .8675, .76318, .72346, .73206, .73206, .73206, .73206, .90685, .90685, .90685, .90685, .86477, .89249, .84118, .84118, .84118, .84118, .84118, .85284, .84557, .88844, .88844, .88844, .88844, .7306, .77452, .86331, .9245, .9245, .9245, .9245, .9245, .9245, .84843, .83203, .85865, .85865, .85865, .85865, .82601, .82601, .82601, .82601, .94469, .9245, .92274, .92274, .92274, .92274, .92274, .90747, .86651, .9245, .9245, .9245, .9245, .89453, .9245, .89453, .8675, .9245, .8675, .9245, .8675, .9245, .72346, .83203, .72346, .83203, .72346, .83203, .72346, .83203, .85193, .8875, .86477, .99034, .73206, .85865, .73206, .85865, .73206, .85865, .73206, .85865, .73206, .85865, .81105, .9245, .81105, .9245, .81105, .9245, 1, 1, .86275, .9245, .90872, .93591, .90685, .82601, .90685, .82601, .90685, .82601, .90685, 1.03297, .90685, .82601, .77896, 1.05611, .6377, 1.07692, 1, 1, .90918, .75593, 1.03297, 1, 1, .76032, .9375, .98156, .93407, .77261, 1.11429, .89249, .9245, 1, 1, .89249, .9245, .92534, .86698, .9245, .84118, .92274, .84118, .92274, .84118, .92274, .8667, .86291, .75186, 1.02933, 1, 1, .75186, 1.02933, .67789, .77832, .67789, .77832, .67789, .77832, .67789, .77832, 1, 1, .79776, .97655, .79776, 1.23023, .88844, .9245, .88844, .9245, .88844, .9245, .88844, .9245, .88844, .9245, .88844, .9245, .94309, .98986, .7306, .89453, .7306, .76659, .79004, .76659, .79004, .76659, .79004, 1.09231, .54873, .8675, .9245, .76318, .84843, .84557, .86651, 1, 1, .79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, .67009, .96334, .93695, 1.35191, 1.40909, .95161, 1.48387, .8675, .90861, .6192, .7363, .64824, .82411, .56321, .85696, 1.23516, .8675, .81552, .7286, .84134, .73206, .76659, .86275, .84369, .90685, .77892, .85871, 1.02638, .89249, .75828, .84118, .85984, .77452, .76466, .79776, .7306, .90782, .77818, .903, .87291, .90685, .7306, .99058, 1.03667, .94635, 1.23516, .9849, .99058, .92393, .8916, .942, 1.03667, .75026, .94635, 1.0297, 1.23516, .90918, .94048, .98217, .89746, .84153, .92274, .82507, .88832, .84438, .88178, 1.03525, .9849, 1.00225, .78086, .97248, .89404, 1.23516, .9849, .92274, .9849, .89404, .73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .89693, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .85865, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .90933, 1, 1, 1, 1, 1, 1, .94309, .98986, .94309, .98986, .94309, .98986, .7306, .89453, 1, 1, .89552, .90527, 1, .90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, .89552, .89552, 1.42259, .68994, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, .97858, .82616, .91133, .83437, .91133, 1, 1, 1, .70508, 1, 1.23108, .79801, .84426, .84426, .774, .90572, 1.81055, .90749, 1.81055, 1.28809, 1.55469, .94434, 1.07806, 1, .97094, .7589, .85284, .90747, 1.19658, .69825, .97622, 1.33512, .90747, .90747, .85284, .90747, .90747, 1.44947, .85284, .8941, .8941, .70572, .8, .70572, .70572, .70572, .70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .99862, .99862, 1, 1, 1, 1, 1, 1.0336, .91027, 1, 1, 1, .99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  ka = {\n    lineHeight: 1.2207,\n    lineGap: .2207\n  },\n  Ra = [1.3877, 1, 1, 1, 1.17223, 1.1293, .89552, .91133, .80395, 1.02269, 1.15601, .91056, .91056, 1.2798, .85284, .89807, 1, .90861, 1.39016, .91133, .91133, .91133, .91133, .91133, .91133, .91133, .91133, .91133, .91133, .96309, .96309, .85284, .85284, .85284, .83319, .88071, .8675, .81552, .73834, .85193, .73206, .7522, .81105, .86275, .90685, .6377, .77892, .75593, 1.02638, .89385, .85122, .77452, .86503, .75186, .68887, .79776, .88844, .85066, .94258, .77818, .7306, .76659, 1.10369, 1.39016, 1.10369, 1.06139, .89552, .8739, .86128, .94469, .8457, .94469, .89464, 1.09842, .84636, .94469, 1.03297, 1.07692, .90918, 1.03297, .95897, .94469, .9482, .94469, .94469, 1.04692, .78223, 1.20562, .94469, .90332, .98986, .86621, .90527, .79004, .94152, 1.77256, .94152, .85284, .97801, .89552, .91133, .89552, .91133, 1.91729, .89552, 1.17889, 1.13254, 1.08707, .92098, .85284, .68787, .71353, .84737, .90747, 1.0088, 1.0044, .87683, 1, 1.09091, 1, .92229, .739, 1.15642, .92098, .76288, .80504, .80972, .75859, .8675, .8675, .8675, .8675, .8675, .8675, .76318, .73834, .73206, .73206, .73206, .73206, .90685, .90685, .90685, .90685, .86477, .89385, .85122, .85122, .85122, .85122, .85122, .85284, .85311, .88844, .88844, .88844, .88844, .7306, .77452, .86331, .86128, .86128, .86128, .86128, .86128, .86128, .8693, .8457, .89464, .89464, .89464, .89464, .82601, .82601, .82601, .82601, .94469, .94469, .9482, .9482, .9482, .9482, .9482, .90747, .86651, .94469, .94469, .94469, .94469, .90527, .94469, .90527, .8675, .86128, .8675, .86128, .8675, .86128, .73834, .8457, .73834, .8457, .73834, .8457, .73834, .8457, .85193, .92454, .86477, .9921, .73206, .89464, .73206, .89464, .73206, .89464, .73206, .89464, .73206, .89464, .81105, .84636, .81105, .84636, .81105, .84636, 1, 1, .86275, .94469, .90872, .95786, .90685, .82601, .90685, .82601, .90685, .82601, .90685, 1.03297, .90685, .82601, .77741, 1.05611, .6377, 1.07692, 1, 1, .90918, .75593, 1.03297, 1, 1, .76032, .90452, .98156, 1.11842, .77261, 1.11429, .89385, .94469, 1, 1, .89385, .94469, .95877, .86901, .94469, .85122, .9482, .85122, .9482, .85122, .9482, .8667, .90016, .75186, 1.04692, 1, 1, .75186, 1.04692, .68887, .78223, .68887, .78223, .68887, .78223, .68887, .78223, 1, 1, .79776, .92188, .79776, 1.23023, .88844, .94469, .88844, .94469, .88844, .94469, .88844, .94469, .88844, .94469, .88844, .94469, .94258, .98986, .7306, .90527, .7306, .76659, .79004, .76659, .79004, .76659, .79004, 1.09231, .54873, .8675, .86128, .76318, .8693, .85311, .86651, 1, 1, .79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, .67742, .96334, .93695, 1.35191, 1.40909, .95161, 1.48387, .86686, .90861, .62267, .74359, .65649, .85498, .56963, .88254, 1.23516, .8675, .81552, .75443, .84503, .73206, .76659, .86275, .85122, .90685, .77892, .85746, 1.02638, .89385, .75657, .85122, .86275, .77452, .74171, .79776, .7306, .95165, .77818, .89772, .88831, .90685, .7306, .98142, 1.02191, .96576, 1.23516, .99018, .98142, .9236, .89258, .94035, 1.02191, .78848, .96576, .9561, 1.23516, .90918, .92578, .95424, .89746, .83969, .9482, .80113, .89442, .85208, .86155, .98022, .99018, 1.00452, .81209, .99247, .89181, 1.23516, .99018, .9482, .99018, .89181, .73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .88844, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .89464, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .96766, 1, 1, 1, 1, 1, 1, .94258, .98986, .94258, .98986, .94258, .98986, .7306, .90527, 1, 1, .89552, .90527, 1, .90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, .89552, .89552, 1.42259, .69043, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, .99331, .82616, .91133, .84286, .91133, 1, 1, 1, .70508, 1, 1.23108, .79801, .84426, .84426, .774, .90527, 1.81055, .90527, 1.81055, 1.28809, 1.55469, .94434, 1.07806, 1, .97094, .7589, .85284, .90747, 1.19658, .69825, .97622, 1.33512, .90747, .90747, .85356, .90747, .90747, 1.44947, .85284, .8941, .8941, .70572, .8, .70572, .70572, .70572, .70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .99862, .99862, 1, 1, 1, 1, 1, 1.0336, .91027, 1, 1, 1, .99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1.07185, .99413, .96334, 1.08065, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  Na = {\n    lineHeight: 1.2207,\n    lineGap: .2207\n  },\n  Ga = [.76116, 1, 1, 1.0006, .99998, .99974, .99973, .99973, .99982, .99977, 1.00087, .99998, .99998, .99959, 1.00003, 1.0006, .99998, 1.0006, 1.0006, .99973, .99973, .99973, .99973, .99973, .99973, .99973, .99973, .99973, .99973, .99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, .9999, .99977, .99977, .99977, .99977, 1.00001, 1.00026, 1.00022, .99977, 1.0006, .99973, .99977, 1.00026, .99999, .99977, 1.00022, 1.00001, 1.00022, .99977, 1.00001, 1.00026, .99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, .99998, 1.0006, .99998, 1.00003, .99973, .99998, .99973, 1.00026, .99973, 1.00026, .99973, .99998, 1.00026, 1.00026, 1.0006, 1.0006, .99973, 1.0006, .99982, 1.00026, 1.00026, 1.00026, 1.00026, .99959, .99973, .99998, 1.00026, .99973, 1.00022, .99973, .99973, 1, .99959, 1.00077, .99959, 1.00003, .99998, .99973, .99973, .99973, .99973, 1.00077, .99973, .99998, 1.00025, .99968, .99973, 1.00003, 1.00025, .60299, 1.00024, 1.06409, 1, 1, .99998, 1, .99973, 1.0006, .99998, 1, .99936, .99973, 1.00002, 1.00002, 1.00002, 1.00026, .99977, .99977, .99977, .99977, .99977, .99977, 1, .99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, .99977, .99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, .99977, .99977, .99977, .99977, 1.00001, 1.00001, 1.00026, .99973, .99973, .99973, .99973, .99973, .99973, .99982, .99973, .99973, .99973, .99973, .99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, .99973, 1.00026, .99973, .99977, .99973, .99977, .99973, .99977, .99973, .99977, .99973, .99977, .99973, .99977, .99973, .99977, .99973, .99977, 1.03374, .99977, 1.00026, 1.00001, .99973, 1.00001, .99973, 1.00001, .99973, 1.00001, .99973, 1.00001, .99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, .99977, 1.00026, .99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.00042, .99973, .99973, 1.0006, .99977, .99973, .99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.03828, 1.00026, .99999, 1.00026, 1.0006, .99977, 1.00026, .99977, 1.00026, .99977, 1.00026, .9993, .9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, .99977, .99959, .99977, .99959, .99977, .99959, 1.00001, .99973, 1.00001, .99973, 1.00001, .99973, 1.00001, .99973, 1.00026, .99998, 1.00026, .8121, 1.00026, .99998, .99977, 1.00026, .99977, 1.00026, .99977, 1.00026, .99977, 1.00026, .99977, 1.00026, .99977, 1.00026, 1.00016, 1.00022, 1.00001, .99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, .99973, .99977, .99973, 1, .99982, 1.00022, 1.00026, 1.00001, .99973, 1.00026, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99998, 1.00034, .99977, 1, .99997, 1.00026, 1.00078, 1.00036, .99973, 1.00013, 1.0006, .99977, .99977, .99988, .85148, 1.00001, 1.00026, .99977, 1.00022, 1.0006, .99977, 1.00001, .99999, .99977, 1.00069, 1.00022, .99977, 1.00001, .99984, 1.00026, 1.00001, 1.00024, 1.00001, .9999, 1, 1.0006, 1.00001, 1.00041, .99962, 1.00026, 1.0006, .99995, 1.00041, .99942, .99973, .99927, 1.00082, .99902, 1.00026, 1.00087, 1.0006, 1.00069, .99973, .99867, .99973, .9993, 1.00026, 1.00049, 1.00056, 1, .99988, .99935, .99995, .99954, 1.00055, .99945, 1.00032, 1.0006, .99995, 1.00026, .99995, 1.00032, 1.00001, 1.00008, .99971, 1.00019, .9994, 1.00001, 1.0006, 1.00044, .99973, 1.00023, 1.00047, 1, .99942, .99561, .99989, 1.00035, .99977, 1.00035, .99977, 1.00019, .99944, 1.00001, 1.00021, .99926, 1.00035, 1.00035, .99942, 1.00048, .99999, .99977, 1.00022, 1.00035, 1.00001, .99977, 1.00026, .99989, 1.00057, 1.00001, .99936, 1.00052, 1.00012, .99996, 1.00043, 1, 1.00035, .9994, .99976, 1.00035, .99973, 1.00052, 1.00041, 1.00119, 1.00037, .99973, 1.00002, .99986, 1.00041, 1.00041, .99902, .9996, 1.00034, .99999, 1.00026, .99999, 1.00026, .99973, 1.00052, .99973, 1, .99973, 1.00041, 1.00075, .9994, 1.0003, .99999, 1, 1.00041, .99955, 1, .99915, .99973, .99973, 1.00026, 1.00119, .99955, .99973, 1.0006, .99911, 1.0006, 1.00026, .99972, 1.00026, .99902, 1.00041, .99973, .99999, 1, 1, 1.00038, 1.0005, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, .99973, 1, 1, .99973, 1, 1, .99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, .99973, .99973, .99972, 1, 1, 1.00106, .99999, .99998, .99998, .99999, .99998, 1.66475, 1, .99973, .99973, 1.00023, .99973, .99971, 1.00047, 1.00023, 1, .99991, .99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, .99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, .99561, 1.00027, 1.00031, 1.00031, .99915, 1.00031, 1.00031, .99999, 1.00003, .99999, .99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, .99999, 1, .99861, .99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, .99972, .99999, .99999, .99999, .99999, 1.40483, 1, .99977, 1.00054, 1, 1, .99953, .99962, 1.00042, .9995, 1, 1, 1, 1, 1, 1, 1, 1, .99998, .99998, .99998, .99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  xa = {\n    lineHeight: 1.2,\n    lineGap: .2\n  },\n  Ua = [.76116, 1, 1, 1.0006, .99998, .99974, .99973, .99973, .99982, .99977, 1.00087, .99998, .99998, .99959, 1.00003, 1.0006, .99998, 1.0006, 1.0006, .99973, .99973, .99973, .99973, .99973, .99973, .99973, .99973, .99973, .99973, .99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, .9999, .99977, .99977, .99977, .99977, 1.00001, 1.00026, 1.00022, .99977, 1.0006, .99973, .99977, 1.00026, .99999, .99977, 1.00022, 1.00001, 1.00022, .99977, 1.00001, 1.00026, .99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, .99998, 1.0006, .99998, 1.00003, .99973, .99998, .99973, 1.00026, .99973, 1.00026, .99973, .99998, 1.00026, 1.00026, 1.0006, 1.0006, .99973, 1.0006, .99982, 1.00026, 1.00026, 1.00026, 1.00026, .99959, .99973, .99998, 1.00026, .99973, 1.00022, .99973, .99973, 1, .99959, 1.00077, .99959, 1.00003, .99998, .99973, .99973, .99973, .99973, 1.00077, .99973, .99998, 1.00025, .99968, .99973, 1.00003, 1.00025, .60299, 1.00024, 1.06409, 1, 1, .99998, 1, .99973, 1.0006, .99998, 1, .99936, .99973, 1.00002, 1.00002, 1.00002, 1.00026, .99977, .99977, .99977, .99977, .99977, .99977, 1, .99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, .99977, .99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, .99977, .99977, .99977, .99977, 1.00001, 1.00001, 1.00026, .99973, .99973, .99973, .99973, .99973, .99973, .99982, .99973, .99973, .99973, .99973, .99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, .99973, 1.00026, .99973, .99977, .99973, .99977, .99973, .99977, .99973, .99977, .99973, .99977, .99973, .99977, .99973, .99977, .99973, .99977, 1.0044, .99977, 1.00026, 1.00001, .99973, 1.00001, .99973, 1.00001, .99973, 1.00001, .99973, 1.00001, .99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, .99977, 1.00026, .99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, .99971, .99973, .99973, 1.0006, .99977, .99973, .99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.01011, 1.00026, .99999, 1.00026, 1.0006, .99977, 1.00026, .99977, 1.00026, .99977, 1.00026, .9993, .9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, .99977, .99959, .99977, .99959, .99977, .99959, 1.00001, .99973, 1.00001, .99973, 1.00001, .99973, 1.00001, .99973, 1.00026, .99998, 1.00026, .8121, 1.00026, .99998, .99977, 1.00026, .99977, 1.00026, .99977, 1.00026, .99977, 1.00026, .99977, 1.00026, .99977, 1.00026, 1.00016, 1.00022, 1.00001, .99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, .99973, .99977, .99973, 1, .99982, 1.00022, 1.00026, 1.00001, .99973, 1.00026, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99977, 1, 1, 1.00026, .99969, .99972, .99981, .9998, 1.0006, .99977, .99977, 1.00022, .91155, 1.00001, 1.00026, .99977, 1.00022, 1.0006, .99977, 1.00001, .99999, .99977, .99966, 1.00022, 1.00032, 1.00001, .99944, 1.00026, 1.00001, .99968, 1.00001, 1.00047, 1, 1.0006, 1.00001, .99981, 1.00101, 1.00026, 1.0006, .99948, .99981, 1.00064, .99973, .99942, 1.00101, 1.00061, 1.00026, 1.00069, 1.0006, 1.00014, .99973, 1.01322, .99973, 1.00065, 1.00026, 1.00012, .99923, 1, 1.00064, 1.00076, .99948, 1.00055, 1.00063, 1.00007, .99943, 1.0006, .99948, 1.00026, .99948, .99943, 1.00001, 1.00001, 1.00029, 1.00038, 1.00035, 1.00001, 1.0006, 1.0006, .99973, .99978, 1.00001, 1.00057, .99989, .99967, .99964, .99967, .99977, .99999, .99977, 1.00038, .99977, 1.00001, .99973, 1.00066, .99967, .99967, 1.00041, .99998, .99999, .99977, 1.00022, .99967, 1.00001, .99977, 1.00026, .99964, 1.00031, 1.00001, .99999, .99999, 1, 1.00023, 1, 1, .99999, 1.00035, 1.00001, .99999, .99973, .99977, .99999, 1.00058, .99973, .99973, .99955, .9995, 1.00026, 1.00026, 1.00032, .99989, 1.00034, .99999, 1.00026, 1.00026, 1.00026, .99973, .45998, .99973, 1.00026, .99973, 1.00001, .99999, .99982, .99994, .99996, 1, 1.00042, 1.00044, 1.00029, 1.00023, .99973, .99973, 1.00026, .99949, 1.00002, .99973, 1.0006, 1.0006, 1.0006, .99975, 1.00026, 1.00026, 1.00032, .98685, .99973, 1.00026, 1, 1, .99966, 1.00044, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, .99973, 1, 1, .99973, 1, 1, .99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, .99973, .99973, .99972, 1, 1, 1.00106, .99999, .99998, .99998, .99999, .99998, 1.66475, 1, .99973, .99973, 1, .99973, .99971, .99978, 1, 1, .99991, .99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00098, 1, 1, 1, 1.00049, 1, 1, .99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, .99561, 1.00027, 1.00031, 1.00031, .99915, 1.00031, 1.00031, .99999, 1.00003, .99999, .99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, .99999, 1, .99861, .99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, .99972, .99999, .99999, .99999, .99999, 1.40483, 1, .99977, 1.00054, 1, 1, .99953, .99962, 1.00042, .9995, 1, 1, 1, 1, 1, 1, 1, 1, .99998, .99998, .99998, .99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  Ma = {\n    lineHeight: 1.35,\n    lineGap: .2\n  },\n  La = [.76116, 1, 1, 1.0006, 1.0006, 1.00006, .99973, .99973, .99982, 1.00001, 1.00043, .99998, .99998, .99959, 1.00003, 1.0006, .99998, 1.0006, 1.0006, .99973, .99973, .99973, .99973, .99973, .99973, .99973, .99973, .99973, .99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, .99973, .99987, 1.00001, 1.00001, .99977, .99977, 1.00001, 1.00026, 1.00022, .99977, 1.0006, 1, 1.00001, .99973, .99999, .99977, 1.00022, 1.00001, 1.00022, .99977, 1.00001, 1.00026, .99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, .99949, .99973, .99998, .99973, .99973, 1, .99973, .99973, 1.0006, .99973, .99973, .99924, .99924, 1, .99924, .99999, .99973, .99973, .99973, .99973, .99998, 1, 1.0006, .99973, 1, .99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, .99998, .99973, .99973, .99973, .99973, 1.0009, .99973, .99998, 1.00025, .99968, .99973, 1.00003, 1.00025, .60299, 1.00024, 1.06409, 1, 1, .99998, 1, .9998, 1.0006, .99998, 1, .99936, .99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, .99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, .99977, .99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, .99977, .99977, .99977, .99977, 1.00001, 1.00001, 1.00026, .99973, .99973, .99973, .99973, .99973, .99973, .99982, 1, .99973, .99973, .99973, .99973, 1.0006, 1.0006, 1.0006, 1.0006, .99973, .99973, .99973, .99973, .99973, .99973, .99973, 1.06409, 1.00026, .99973, .99973, .99973, .99973, 1, .99973, 1, 1.00001, .99973, 1.00001, .99973, 1.00001, .99973, .99977, 1, .99977, 1, .99977, 1, .99977, 1, .99977, 1.0288, .99977, .99973, 1.00001, .99973, 1.00001, .99973, 1.00001, .99973, 1.00001, .99973, 1.00001, .99973, 1.00022, .99973, 1.00022, .99973, 1.00022, .99973, 1.00022, .99973, .99977, .99973, .99977, .99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, .99924, 1.0006, 1.0006, .99946, 1.00034, 1, .99924, 1.00001, 1, 1, .99973, .99924, .99973, .99924, .99973, 1.06311, .99973, 1.00024, .99973, .99924, .99977, .99973, .99977, .99973, .99977, .99973, 1.00041, .9998, .99973, 1.00022, .99973, 1.00022, .99973, 1.00022, .99973, 1, 1.00016, .99977, .99998, .99977, .99998, .99977, .99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, .89547, 1.00026, 1.0006, .99977, .99973, .99977, .99973, .99977, .99973, .99977, .99973, .99977, .99973, .99977, .99973, 1.00016, .99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, .99924, .99973, 1.00001, .99973, 1, .99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99998, 1.00001, 1, 1.00054, .99977, 1.00084, 1.00007, .99973, 1.00013, .99924, 1.00001, 1.00001, .99945, .91221, 1.00001, 1.00026, .99977, 1.00022, 1.0006, 1.00001, 1.00001, .99999, .99977, .99933, 1.00022, 1.00054, 1.00001, 1.00065, 1.00026, 1.00001, 1.0001, 1.00001, 1.00052, 1, 1.0006, 1.00001, .99945, .99897, .99968, .99924, 1.00036, .99945, .99949, 1, 1.0006, .99897, .99918, .99968, .99911, .99924, 1, .99962, 1.01487, 1, 1.0005, .99973, 1.00012, 1.00043, 1, .99995, .99994, 1.00036, .99947, 1.00019, 1.00063, 1.00025, .99924, 1.00036, .99973, 1.00036, 1.00025, 1.00001, 1.00001, 1.00027, 1.0001, 1.00068, 1.00001, 1.0006, 1.0006, 1, 1.00008, .99957, .99972, .9994, .99954, .99975, 1.00051, 1.00001, 1.00019, 1.00001, 1.0001, .99986, 1.00001, 1.00001, 1.00038, .99954, .99954, .9994, 1.00066, .99999, .99977, 1.00022, 1.00054, 1.00001, .99977, 1.00026, .99975, 1.0001, 1.00001, .99993, .9995, .99955, 1.00016, .99978, .99974, 1.00019, 1.00022, .99955, 1.00053, .99973, 1.00089, 1.00005, .99967, 1.00048, .99973, 1.00002, 1.00034, .99973, .99973, .99964, 1.00006, 1.00066, .99947, .99973, .98894, .99973, 1, .44898, 1, .99946, 1, 1.00039, 1.00082, .99991, .99991, .99985, 1.00022, 1.00023, 1.00061, 1.00006, .99966, .99973, .99973, .99973, 1.00019, 1.0008, 1, .99924, .99924, .99924, .99983, 1.00044, .99973, .99964, .98332, 1, .99973, 1, 1, .99962, .99895, 1.00016, .99977, 1.00016, .99977, 1.00016, .99977, 1.00001, 1, 1, 1, .99973, 1, 1, .99955, .99924, .99924, .99924, .99924, .99998, .99998, .99998, .99973, .99973, .99972, 1, 1, 1.00267, .99999, .99998, .99998, 1, .99998, 1.66475, 1, .99973, .99973, 1.00023, .99973, 1.00423, .99925, .99999, 1, .99991, .99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00049, 1, 1.00245, 1, 1, 1, 1, .96329, 1, 1.20985, 1.39713, 1.00003, .8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 1.00003, 1.00031, 1.00031, .99999, 1.00003, .99999, .99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, .99999, 1, .99861, .99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, .95317, .99999, .99999, .99999, .99999, 1.40483, 1, .99977, 1.00054, 1, 1, .99953, .99962, 1.00042, .9995, 1, 1, 1, 1, 1, 1, 1, 1, .99998, .99998, .99998, .99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  Ha = {\n    lineHeight: 1.35,\n    lineGap: .2\n  },\n  Ja = [.76116, 1, 1, 1.0006, 1.0006, 1.00006, .99973, .99973, .99982, 1.00001, 1.00043, .99998, .99998, .99959, 1.00003, 1.0006, .99998, 1.0006, 1.0006, .99973, .99973, .99973, .99973, .99973, .99973, .99973, .99973, .99973, .99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, .99973, .99987, 1.00001, 1.00001, .99977, .99977, 1.00001, 1.00026, 1.00022, .99977, 1.0006, 1, 1.00001, .99973, .99999, .99977, 1.00022, 1.00001, 1.00022, .99977, 1.00001, 1.00026, .99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, .99949, .99973, .99998, .99973, .99973, 1, .99973, .99973, 1.0006, .99973, .99973, .99924, .99924, 1, .99924, .99999, .99973, .99973, .99973, .99973, .99998, 1, 1.0006, .99973, 1, .99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, .99998, .99973, .99973, .99973, .99973, 1.0009, .99973, .99998, 1.00025, .99968, .99973, 1.00003, 1.00025, .60299, 1.00024, 1.06409, 1, 1, .99998, 1, .9998, 1.0006, .99998, 1, .99936, .99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, .99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, .99977, .99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, .99977, .99977, .99977, .99977, 1.00001, 1.00001, 1.00026, .99973, .99973, .99973, .99973, .99973, .99973, .99982, 1, .99973, .99973, .99973, .99973, 1.0006, 1.0006, 1.0006, 1.0006, .99973, .99973, .99973, .99973, .99973, .99973, .99973, 1.06409, 1.00026, .99973, .99973, .99973, .99973, 1, .99973, 1, 1.00001, .99973, 1.00001, .99973, 1.00001, .99973, .99977, 1, .99977, 1, .99977, 1, .99977, 1, .99977, 1.04596, .99977, .99973, 1.00001, .99973, 1.00001, .99973, 1.00001, .99973, 1.00001, .99973, 1.00001, .99973, 1.00022, .99973, 1.00022, .99973, 1.00022, .99973, 1.00022, .99973, .99977, .99973, .99977, .99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, .99924, 1.0006, 1.0006, 1.00019, 1.00034, 1, .99924, 1.00001, 1, 1, .99973, .99924, .99973, .99924, .99973, 1.02572, .99973, 1.00005, .99973, .99924, .99977, .99973, .99977, .99973, .99977, .99973, .99999, .9998, .99973, 1.00022, .99973, 1.00022, .99973, 1.00022, .99973, 1, 1.00016, .99977, .99998, .99977, .99998, .99977, .99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, .84533, 1.00026, 1.0006, .99977, .99973, .99977, .99973, .99977, .99973, .99977, .99973, .99977, .99973, .99977, .99973, 1.00016, .99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, .99924, .99973, 1.00001, .99973, 1, .99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99998, .99928, 1, .99977, 1.00013, 1.00055, .99947, .99945, .99941, .99924, 1.00001, 1.00001, 1.0004, .91621, 1.00001, 1.00026, .99977, 1.00022, 1.0006, 1.00001, 1.00005, .99999, .99977, 1.00015, 1.00022, .99977, 1.00001, .99973, 1.00026, 1.00001, 1.00019, 1.00001, .99946, 1, 1.0006, 1.00001, .99978, 1.00045, .99973, .99924, 1.00023, .99978, .99966, 1, 1.00065, 1.00045, 1.00019, .99973, .99973, .99924, 1, 1, .96499, 1, 1.00055, .99973, 1.00008, 1.00027, 1, .9997, .99995, 1.00023, .99933, 1.00019, 1.00015, 1.00031, .99924, 1.00023, .99973, 1.00023, 1.00031, 1.00001, .99928, 1.00029, 1.00092, 1.00035, 1.00001, 1.0006, 1.0006, 1, .99988, .99975, 1, 1.00082, .99561, .9996, 1.00035, 1.00001, .99962, 1.00001, 1.00092, .99964, 1.00001, .99963, .99999, 1.00035, 1.00035, 1.00082, .99962, .99999, .99977, 1.00022, 1.00035, 1.00001, .99977, 1.00026, .9996, .99967, 1.00001, 1.00034, 1.00074, 1.00054, 1.00053, 1.00063, .99971, .99962, 1.00035, .99975, .99977, .99973, 1.00043, .99953, 1.0007, .99915, .99973, 1.00008, .99892, 1.00073, 1.00073, 1.00114, .99915, 1.00073, .99955, .99973, 1.00092, .99973, 1, .99998, 1, 1.0003, 1, 1.00043, 1.00001, .99969, 1.0003, 1, 1.00035, 1.00001, .9995, 1, 1.00092, .99973, .99973, .99973, 1.0007, .9995, 1, .99924, 1.0006, .99924, .99972, 1.00062, .99973, 1.00114, 1.00073, 1, .99955, 1, 1, 1.00047, .99968, 1.00016, .99977, 1.00016, .99977, 1.00016, .99977, 1.00001, 1, 1, 1, .99973, 1, 1, .99955, .99924, .99924, .99924, .99924, .99998, .99998, .99998, .99973, .99973, .99972, 1, 1, 1.00267, .99999, .99998, .99998, 1, .99998, 1.66475, 1, .99973, .99973, 1.00023, .99973, .99971, .99925, 1.00023, 1, .99991, .99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, .96329, 1, 1.20985, 1.39713, 1.00003, .8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, .99915, 1.00031, 1.00031, .99999, 1.00003, .99999, .99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, .99999, 1, .99861, .99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, .95317, .99999, .99999, .99999, .99999, 1.40483, 1, .99977, 1.00054, 1, 1, .99953, .99962, 1.00042, .9995, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  Ya = {\n    lineHeight: 1.2,\n    lineGap: .2\n  },\n  va = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 719, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 785, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 385, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 465, 722, 333, 853, 906, 474, 825, 927, 838, 278, 722, 722, 601, 719, 667, 611, 722, 778, 278, 722, 667, 833, 722, 644, 778, 722, 667, 600, 611, 667, 821, 667, 809, 802, 278, 667, 615, 451, 611, 278, 582, 615, 610, 556, 606, 475, 460, 611, 541, 278, 558, 556, 612, 556, 445, 611, 766, 619, 520, 684, 446, 582, 715, 576, 753, 845, 278, 582, 611, 582, 845, 667, 669, 885, 567, 711, 667, 278, 276, 556, 1094, 1062, 875, 610, 722, 622, 719, 722, 719, 722, 567, 712, 667, 904, 626, 719, 719, 610, 702, 833, 722, 778, 719, 667, 722, 611, 622, 854, 667, 730, 703, 1005, 1019, 870, 979, 719, 711, 1031, 719, 556, 618, 615, 417, 635, 556, 709, 497, 615, 615, 500, 635, 740, 604, 611, 604, 611, 556, 490, 556, 875, 556, 615, 581, 833, 844, 729, 854, 615, 552, 854, 583, 556, 556, 611, 417, 552, 556, 278, 281, 278, 969, 906, 611, 500, 615, 556, 604, 778, 611, 487, 447, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1094, 556, 885, 489, 1115, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333],\n  Ka = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\n  Ta = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 740, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 782, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 396, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 722, 333, 854, 906, 473, 844, 930, 847, 278, 722, 722, 610, 671, 667, 611, 722, 778, 278, 722, 667, 833, 722, 657, 778, 718, 667, 590, 611, 667, 822, 667, 829, 781, 278, 667, 620, 479, 611, 278, 591, 620, 621, 556, 610, 479, 492, 611, 558, 278, 566, 556, 603, 556, 450, 611, 712, 605, 532, 664, 409, 591, 704, 578, 773, 834, 278, 591, 611, 591, 834, 667, 667, 886, 614, 719, 667, 278, 278, 556, 1094, 1042, 854, 622, 719, 677, 719, 722, 708, 722, 614, 722, 667, 927, 643, 719, 719, 615, 687, 833, 722, 778, 719, 667, 722, 611, 677, 781, 667, 729, 708, 979, 989, 854, 1e3, 708, 719, 1042, 729, 556, 619, 604, 534, 618, 556, 736, 510, 611, 611, 507, 622, 740, 604, 611, 611, 611, 556, 889, 556, 885, 556, 646, 583, 889, 935, 707, 854, 594, 552, 865, 589, 556, 556, 611, 469, 563, 556, 278, 278, 278, 969, 906, 611, 507, 619, 556, 611, 778, 611, 575, 467, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1104, 556, 885, 516, 1146, 1e3, 768, 600, 834, 834, 834, 834, 999, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333],\n  qa = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\n  Oa = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 625, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 733, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 281, 556, 400, 556, 222, 722, 556, 722, 556, 722, 556, 615, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 354, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 789, 846, 389, 794, 865, 775, 222, 667, 667, 570, 671, 667, 611, 722, 778, 278, 667, 667, 833, 722, 648, 778, 725, 667, 600, 611, 667, 837, 667, 831, 761, 278, 667, 570, 439, 555, 222, 550, 570, 571, 500, 556, 439, 463, 555, 542, 222, 500, 492, 548, 500, 447, 556, 670, 573, 486, 603, 374, 550, 652, 546, 728, 779, 222, 550, 556, 550, 779, 667, 667, 843, 544, 708, 667, 278, 278, 500, 1066, 982, 844, 589, 715, 639, 724, 667, 651, 667, 544, 704, 667, 917, 614, 715, 715, 589, 686, 833, 722, 778, 725, 667, 722, 611, 639, 795, 667, 727, 673, 920, 923, 805, 886, 651, 694, 1022, 682, 556, 562, 522, 493, 553, 556, 688, 465, 556, 556, 472, 564, 686, 550, 556, 556, 556, 500, 833, 500, 835, 500, 572, 518, 830, 851, 621, 736, 526, 492, 752, 534, 556, 556, 556, 378, 496, 500, 222, 222, 222, 910, 828, 556, 472, 565, 500, 556, 778, 556, 492, 339, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1083, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 998, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 584, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285],\n  Pa = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\n  Wa = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 615, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 735, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 292, 556, 334, 556, 222, 722, 556, 722, 556, 722, 556, 604, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 375, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 784, 838, 384, 774, 855, 752, 222, 667, 667, 551, 668, 667, 611, 722, 778, 278, 667, 668, 833, 722, 650, 778, 722, 667, 618, 611, 667, 798, 667, 835, 748, 278, 667, 578, 446, 556, 222, 547, 578, 575, 500, 557, 446, 441, 556, 556, 222, 500, 500, 576, 500, 448, 556, 690, 569, 482, 617, 395, 547, 648, 525, 713, 781, 222, 547, 556, 547, 781, 667, 667, 865, 542, 719, 667, 278, 278, 500, 1057, 1010, 854, 583, 722, 635, 719, 667, 656, 667, 542, 677, 667, 923, 604, 719, 719, 583, 656, 833, 722, 778, 719, 667, 722, 611, 635, 760, 667, 740, 667, 917, 938, 792, 885, 656, 719, 1010, 722, 556, 573, 531, 365, 583, 556, 669, 458, 559, 559, 438, 583, 688, 552, 556, 542, 556, 500, 458, 500, 823, 500, 573, 521, 802, 823, 625, 719, 521, 510, 750, 542, 556, 556, 556, 365, 510, 500, 222, 278, 222, 906, 812, 556, 438, 559, 500, 552, 778, 556, 489, 411, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1073, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285],\n  ja = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\n  Xa = [1.36898, 1, 1, .72706, .80479, .83734, .98894, .99793, .9897, .93884, .86209, .94292, .94292, 1.16661, 1.02058, .93582, .96694, .93582, 1.19137, .99793, .99793, .99793, .99793, .99793, .99793, .99793, .99793, .99793, .99793, .78076, .78076, 1.02058, 1.02058, 1.02058, .72851, .78966, .90838, .83637, .82391, .96376, .80061, .86275, .8768, .95407, 1.0258, .73901, .85022, .83655, 1.0156, .95546, .92179, .87107, .92179, .82114, .8096, .89713, .94438, .95353, .94083, .91905, .90406, .9446, .94292, 1.18777, .94292, 1.02058, .89903, .90088, .94938, .97898, .81093, .97571, .94938, 1.024, .9577, .95933, .98621, 1.0474, .97455, .98981, .9672, .95933, .9446, .97898, .97407, .97646, .78036, 1.10208, .95442, .95298, .97579, .9332, .94039, .938, .80687, 1.01149, .80687, 1.02058, .80479, .99793, .99793, .99793, .99793, 1.01149, 1.00872, .90088, .91882, 1.0213, .8361, 1.02058, .62295, .54324, .89022, 1.08595, 1, 1, .90088, 1, .97455, .93582, .90088, 1, 1.05686, .8361, .99642, .99642, .99642, .72851, .90838, .90838, .90838, .90838, .90838, .90838, .868, .82391, .80061, .80061, .80061, .80061, 1.0258, 1.0258, 1.0258, 1.0258, .97484, .95546, .92179, .92179, .92179, .92179, .92179, 1.02058, .92179, .94438, .94438, .94438, .94438, .90406, .86958, .98225, .94938, .94938, .94938, .94938, .94938, .94938, .9031, .81093, .94938, .94938, .94938, .94938, .98621, .98621, .98621, .98621, .93969, .95933, .9446, .9446, .9446, .9446, .9446, 1.08595, .9446, .95442, .95442, .95442, .95442, .94039, .97898, .94039, .90838, .94938, .90838, .94938, .90838, .94938, .82391, .81093, .82391, .81093, .82391, .81093, .82391, .81093, .96376, .84313, .97484, .97571, .80061, .94938, .80061, .94938, .80061, .94938, .80061, .94938, .80061, .94938, .8768, .9577, .8768, .9577, .8768, .9577, 1, 1, .95407, .95933, .97069, .95933, 1.0258, .98621, 1.0258, .98621, 1.0258, .98621, 1.0258, .98621, 1.0258, .98621, .887, 1.01591, .73901, 1.0474, 1, 1, .97455, .83655, .98981, 1, 1, .83655, .73977, .83655, .73903, .84638, 1.033, .95546, .95933, 1, 1, .95546, .95933, .8271, .95417, .95933, .92179, .9446, .92179, .9446, .92179, .9446, .936, .91964, .82114, .97646, 1, 1, .82114, .97646, .8096, .78036, .8096, .78036, 1, 1, .8096, .78036, 1, 1, .89713, .77452, .89713, 1.10208, .94438, .95442, .94438, .95442, .94438, .95442, .94438, .95442, .94438, .95442, .94438, .95442, .94083, .97579, .90406, .94039, .90406, .9446, .938, .9446, .938, .9446, .938, 1, .99793, .90838, .94938, .868, .9031, .92179, .9446, 1, 1, .89713, 1.10208, .90088, .90088, .90088, .90088, .90088, .90088, .90088, .90088, .90088, .90989, .9358, .91945, .83181, .75261, .87992, .82976, .96034, .83689, .97268, 1.0078, .90838, .83637, .8019, .90157, .80061, .9446, .95407, .92436, 1.0258, .85022, .97153, 1.0156, .95546, .89192, .92179, .92361, .87107, .96318, .89713, .93704, .95638, .91905, .91709, .92796, 1.0258, .93704, .94836, 1.0373, .95933, 1.0078, .95871, .94836, .96174, .92601, .9498, .98607, .95776, .95933, 1.05453, 1.0078, .98275, .9314, .95617, .91701, 1.05993, .9446, .78367, .9553, 1, .86832, 1.0128, .95871, .99394, .87548, .96361, .86774, 1.0078, .95871, .9446, .95871, .86774, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .94083, .97579, .94083, .97579, .94083, .97579, .90406, .94039, .96694, 1, .89903, 1, 1, 1, .93582, .93582, .93582, 1, .908, .908, .918, .94219, .94219, .96544, 1, 1.285, 1, 1, .81079, .81079, 1, 1, .74854, 1, 1, 1, 1, .99793, 1, 1, 1, .65, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.17173, 1, .80535, .76169, 1.02058, 1.0732, 1.05486, 1, 1, 1.30692, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.16161, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  Za = {\n    lineHeight: 1.2,\n    lineGap: .2\n  },\n  Va = [1.36898, 1, 1, .66227, .80779, .81625, .97276, .97276, .97733, .92222, .83266, .94292, .94292, 1.16148, 1.02058, .93582, .96694, .93582, 1.17337, .97276, .97276, .97276, .97276, .97276, .97276, .97276, .97276, .97276, .97276, .78076, .78076, 1.02058, 1.02058, 1.02058, .71541, .76813, .85576, .80591, .80729, .94299, .77512, .83655, .86523, .92222, .98621, .71743, .81698, .79726, .98558, .92222, .90637, .83809, .90637, .80729, .76463, .86275, .90699, .91605, .9154, .85308, .85458, .90531, .94292, 1.21296, .94292, 1.02058, .89903, 1.18616, .99613, .91677, .78216, .91677, .90083, .98796, .9135, .92168, .95381, .98981, .95298, .95381, .93459, .92168, .91513, .92004, .91677, .95077, .748, 1.04502, .91677, .92061, .94236, .89544, .89364, .9, .80687, .8578, .80687, 1.02058, .80779, .97276, .97276, .97276, .97276, .8578, .99973, 1.18616, .91339, 1.08074, .82891, 1.02058, .55509, .71526, .89022, 1.08595, 1, 1, 1.18616, 1, .96736, .93582, 1.18616, 1, 1.04864, .82711, .99043, .99043, .99043, .71541, .85576, .85576, .85576, .85576, .85576, .85576, .845, .80729, .77512, .77512, .77512, .77512, .98621, .98621, .98621, .98621, .95961, .92222, .90637, .90637, .90637, .90637, .90637, 1.02058, .90251, .90699, .90699, .90699, .90699, .85458, .83659, .94951, .99613, .99613, .99613, .99613, .99613, .99613, .85811, .78216, .90083, .90083, .90083, .90083, .95381, .95381, .95381, .95381, .9135, .92168, .91513, .91513, .91513, .91513, .91513, 1.08595, .91677, .91677, .91677, .91677, .91677, .89364, .92332, .89364, .85576, .99613, .85576, .99613, .85576, .99613, .80729, .78216, .80729, .78216, .80729, .78216, .80729, .78216, .94299, .76783, .95961, .91677, .77512, .90083, .77512, .90083, .77512, .90083, .77512, .90083, .77512, .90083, .86523, .9135, .86523, .9135, .86523, .9135, 1, 1, .92222, .92168, .92222, .92168, .98621, .95381, .98621, .95381, .98621, .95381, .98621, .95381, .98621, .95381, .86036, .97096, .71743, .98981, 1, 1, .95298, .79726, .95381, 1, 1, .79726, .6894, .79726, .74321, .81691, 1.0006, .92222, .92168, 1, 1, .92222, .92168, .79464, .92098, .92168, .90637, .91513, .90637, .91513, .90637, .91513, .909, .87514, .80729, .95077, 1, 1, .80729, .95077, .76463, .748, .76463, .748, 1, 1, .76463, .748, 1, 1, .86275, .72651, .86275, 1.04502, .90699, .91677, .90699, .91677, .90699, .91677, .90699, .91677, .90699, .91677, .90699, .91677, .9154, .94236, .85458, .89364, .85458, .90531, .9, .90531, .9, .90531, .9, 1, .97276, .85576, .99613, .845, .85811, .90251, .91677, 1, 1, .86275, 1.04502, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.00899, 1.30628, .85576, .80178, .66862, .7927, .69323, .88127, .72459, .89711, .95381, .85576, .80591, .7805, .94729, .77512, .90531, .92222, .90637, .98621, .81698, .92655, .98558, .92222, .85359, .90637, .90976, .83809, .94523, .86275, .83509, .93157, .85308, .83392, .92346, .98621, .83509, .92886, .91324, .92168, .95381, .90646, .92886, .90557, .86847, .90276, .91324, .86842, .92168, .99531, .95381, .9224, .85408, .92699, .86847, 1.0051, .91513, .80487, .93481, 1, .88159, 1.05214, .90646, .97355, .81539, .89398, .85923, .95381, .90646, .91513, .90646, .85923, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .9154, .94236, .9154, .94236, .9154, .94236, .85458, .89364, .96694, 1, .89903, 1, 1, 1, .91782, .91782, .91782, 1, .896, .896, .896, .9332, .9332, .95973, 1, 1.26, 1, 1, .80479, .80178, 1, 1, .85633, 1, 1, 1, 1, .97276, 1, 1, 1, .698, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.14542, 1, .79199, .78694, 1.02058, 1.03493, 1.05486, 1, 1, 1.23026, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.20006, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  za = {\n    lineHeight: 1.2,\n    lineGap: .2\n  },\n  _a = [1.36898, 1, 1, .65507, .84943, .85639, .88465, .88465, .86936, .88307, .86948, .85283, .85283, 1.06383, 1.02058, .75945, .9219, .75945, 1.17337, .88465, .88465, .88465, .88465, .88465, .88465, .88465, .88465, .88465, .88465, .75945, .75945, 1.02058, 1.02058, 1.02058, .69046, .70926, .85158, .77812, .76852, .89591, .70466, .76125, .80094, .86822, .83864, .728, .77212, .79475, .93637, .87514, .8588, .76013, .8588, .72421, .69866, .77598, .85991, .80811, .87832, .78112, .77512, .8562, 1.0222, 1.18417, 1.0222, 1.27014, .89903, 1.15012, .93859, .94399, .846, .94399, .81453, 1.0186, .94219, .96017, 1.03075, 1.02175, .912, 1.03075, .96998, .96017, .93859, .94399, .94399, .95493, .746, 1.12658, .94578, .91, .979, .882, .882, .83, .85034, .83537, .85034, 1.02058, .70869, .88465, .88465, .88465, .88465, .83537, .90083, 1.15012, .9161, .94565, .73541, 1.02058, .53609, .69353, .79519, 1.08595, 1, 1, 1.15012, 1, .91974, .75945, 1.15012, 1, .9446, .73361, .9005, .9005, .9005, .62864, .85158, .85158, .85158, .85158, .85158, .85158, .773, .76852, .70466, .70466, .70466, .70466, .83864, .83864, .83864, .83864, .90561, .87514, .8588, .8588, .8588, .8588, .8588, 1.02058, .85751, .85991, .85991, .85991, .85991, .77512, .76013, .88075, .93859, .93859, .93859, .93859, .93859, .93859, .8075, .846, .81453, .81453, .81453, .81453, .82424, .82424, .82424, .82424, .9278, .96017, .93859, .93859, .93859, .93859, .93859, 1.08595, .8562, .94578, .94578, .94578, .94578, .882, .94578, .882, .85158, .93859, .85158, .93859, .85158, .93859, .76852, .846, .76852, .846, .76852, .846, .76852, .846, .89591, .8544, .90561, .94399, .70466, .81453, .70466, .81453, .70466, .81453, .70466, .81453, .70466, .81453, .80094, .94219, .80094, .94219, .80094, .94219, 1, 1, .86822, .96017, .86822, .96017, .83864, .82424, .83864, .82424, .83864, .82424, .83864, 1.03075, .83864, .82424, .81402, 1.02738, .728, 1.02175, 1, 1, .912, .79475, 1.03075, 1, 1, .79475, .83911, .79475, .66266, .80553, 1.06676, .87514, .96017, 1, 1, .87514, .96017, .86865, .87396, .96017, .8588, .93859, .8588, .93859, .8588, .93859, .867, .84759, .72421, .95493, 1, 1, .72421, .95493, .69866, .746, .69866, .746, 1, 1, .69866, .746, 1, 1, .77598, .88417, .77598, 1.12658, .85991, .94578, .85991, .94578, .85991, .94578, .85991, .94578, .85991, .94578, .85991, .94578, .87832, .979, .77512, .882, .77512, .8562, .83, .8562, .83, .8562, .83, 1, .88465, .85158, .93859, .773, .8075, .85751, .8562, 1, 1, .77598, 1.12658, 1.15012, 1.15012, 1.15012, 1.15012, 1.15012, 1.15313, 1.15012, 1.15012, 1.15012, 1.08106, 1.03901, .85158, .77025, .62264, .7646, .65351, .86026, .69461, .89947, 1.03075, .85158, .77812, .76449, .88836, .70466, .8562, .86822, .8588, .83864, .77212, .85308, .93637, .87514, .82352, .8588, .85701, .76013, .89058, .77598, .8156, .82565, .78112, .77899, .89386, .83864, .8156, .9486, .92388, .96186, 1.03075, .91123, .9486, .93298, .878, .93942, .92388, .84596, .96186, .95119, 1.03075, .922, .88787, .95829, .88, .93559, .93859, .78815, .93758, 1, .89217, 1.03737, .91123, .93969, .77487, .85769, .86799, 1.03075, .91123, .93859, .91123, .86799, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .87832, .979, .87832, .979, .87832, .979, .77512, .882, .9219, 1, .89903, 1, 1, 1, .87321, .87321, .87321, 1, 1.027, 1.027, 1.027, .86847, .86847, .79121, 1, 1.124, 1, 1, .73572, .73572, 1, 1, .85034, 1, 1, 1, 1, .88465, 1, 1, 1, .669, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04828, 1, .74948, .75187, 1.02058, .98391, 1.02119, 1, 1, 1.06233, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05233, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  $a = {\n    lineHeight: 1.2,\n    lineGap: .2\n  },\n  As = [1.36898, 1, 1, .76305, .82784, .94935, .89364, .92241, .89073, .90706, .98472, .85283, .85283, 1.0664, 1.02058, .74505, .9219, .74505, 1.23456, .92241, .92241, .92241, .92241, .92241, .92241, .92241, .92241, .92241, .92241, .74505, .74505, 1.02058, 1.02058, 1.02058, .73002, .72601, .91755, .8126, .80314, .92222, .73764, .79726, .83051, .90284, .86023, .74, .8126, .84869, .96518, .91115, .8858, .79761, .8858, .74498, .73914, .81363, .89591, .83659, .89633, .85608, .8111, .90531, 1.0222, 1.22736, 1.0222, 1.27014, .89903, .90088, .86667, 1.0231, .896, 1.01411, .90083, 1.05099, 1.00512, .99793, 1.05326, 1.09377, .938, 1.06226, 1.00119, .99793, .98714, 1.0231, 1.01231, .98196, .792, 1.19137, .99074, .962, 1.01915, .926, .942, .856, .85034, .92006, .85034, 1.02058, .69067, .92241, .92241, .92241, .92241, .92006, .9332, .90088, .91882, .93484, .75339, 1.02058, .56866, .54324, .79519, 1.08595, 1, 1, .90088, 1, .95325, .74505, .90088, 1, .97198, .75339, .91009, .91009, .91009, .66466, .91755, .91755, .91755, .91755, .91755, .91755, .788, .80314, .73764, .73764, .73764, .73764, .86023, .86023, .86023, .86023, .92915, .91115, .8858, .8858, .8858, .8858, .8858, 1.02058, .8858, .89591, .89591, .89591, .89591, .8111, .79611, .89713, .86667, .86667, .86667, .86667, .86667, .86667, .86936, .896, .90083, .90083, .90083, .90083, .84224, .84224, .84224, .84224, .97276, .99793, .98714, .98714, .98714, .98714, .98714, 1.08595, .89876, .99074, .99074, .99074, .99074, .942, 1.0231, .942, .91755, .86667, .91755, .86667, .91755, .86667, .80314, .896, .80314, .896, .80314, .896, .80314, .896, .92222, .93372, .92915, 1.01411, .73764, .90083, .73764, .90083, .73764, .90083, .73764, .90083, .73764, .90083, .83051, 1.00512, .83051, 1.00512, .83051, 1.00512, 1, 1, .90284, .99793, .90976, .99793, .86023, .84224, .86023, .84224, .86023, .84224, .86023, 1.05326, .86023, .84224, .82873, 1.07469, .74, 1.09377, 1, 1, .938, .84869, 1.06226, 1, 1, .84869, .83704, .84869, .81441, .85588, 1.08927, .91115, .99793, 1, 1, .91115, .99793, .91887, .90991, .99793, .8858, .98714, .8858, .98714, .8858, .98714, .894, .91434, .74498, .98196, 1, 1, .74498, .98196, .73914, .792, .73914, .792, 1, 1, .73914, .792, 1, 1, .81363, .904, .81363, 1.19137, .89591, .99074, .89591, .99074, .89591, .99074, .89591, .99074, .89591, .99074, .89591, .99074, .89633, 1.01915, .8111, .942, .8111, .90531, .856, .90531, .856, .90531, .856, 1, .92241, .91755, .86667, .788, .86936, .8858, .89876, 1, 1, .81363, 1.19137, .90088, .90088, .90088, .90088, .90088, .90088, .90088, .90088, .90088, .90388, 1.03901, .92138, .78105, .7154, .86169, .80513, .94007, .82528, .98612, 1.06226, .91755, .8126, .81884, .92819, .73764, .90531, .90284, .8858, .86023, .8126, .91172, .96518, .91115, .83089, .8858, .87791, .79761, .89297, .81363, .88157, .89992, .85608, .81992, .94307, .86023, .88157, .95308, .98699, .99793, 1.06226, .95817, .95308, .97358, .928, .98088, .98699, .92761, .99793, .96017, 1.06226, .986, .944, .95978, .938, .96705, .98714, .80442, .98972, 1, .89762, 1.04552, .95817, .99007, .87064, .91879, .88888, 1.06226, .95817, .98714, .95817, .88888, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .89633, 1.01915, .89633, 1.01915, .89633, 1.01915, .8111, .942, .9219, 1, .89903, 1, 1, 1, .93173, .93173, .93173, 1, 1.06304, 1.06304, 1.06904, .89903, .89903, .80549, 1, 1.156, 1, 1, .76575, .76575, 1, 1, .72458, 1, 1, 1, 1, .92241, 1, 1, 1, .619, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.07257, 1, .74705, .71119, 1.02058, 1.024, 1.02119, 1, 1, 1.1536, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05638, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  es = {\n    lineHeight: 1.2,\n    lineGap: .2\n  },\n  ts = [1.76738, 1, 1, .99297, .9824, 1.04016, 1.06497, 1.03424, .97529, 1.17647, 1.23203, 1.1085, 1.1085, 1.16939, 1.2107, .9754, 1.21408, .9754, 1.59578, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, .81378, .81378, 1.2107, 1.2107, 1.2107, .71703, .97847, .97363, .88776, .8641, 1.02096, .79795, .85132, .914, 1.06085, 1.1406, .8007, .89858, .83693, 1.14889, 1.09398, .97489, .92094, .97489, .90399, .84041, .95923, 1.00135, 1, 1.06467, .98243, .90996, .99361, 1.1085, 1.56942, 1.1085, 1.2107, .74627, .94282, .96752, 1.01519, .86304, 1.01359, .97278, 1.15103, 1.01359, .98561, 1.02285, 1.02285, 1.00527, 1.02285, 1.0302, .99041, 1.0008, 1.01519, 1.01359, 1.02258, .79104, 1.16862, .99041, .97454, 1.02511, .99298, .96752, .95801, .94856, 1.16579, .94856, 1.2107, .9824, 1.03424, 1.03424, 1, 1.03424, 1.16579, .8727, 1.3871, 1.18622, 1.10818, 1.04478, 1.2107, 1.18622, .75155, .94994, 1.28826, 1.21408, 1.21408, .91056, 1, .91572, .9754, .64663, 1.18328, 1.24866, 1.04478, 1.14169, 1.15749, 1.17389, .71703, .97363, .97363, .97363, .97363, .97363, .97363, .93506, .8641, .79795, .79795, .79795, .79795, 1.1406, 1.1406, 1.1406, 1.1406, 1.02096, 1.09398, .97426, .97426, .97426, .97426, .97426, 1.2107, .97489, 1.00135, 1.00135, 1.00135, 1.00135, .90996, .92094, 1.02798, .96752, .96752, .96752, .96752, .96752, .96752, .93136, .86304, .97278, .97278, .97278, .97278, 1.02285, 1.02285, 1.02285, 1.02285, .97122, .99041, 1, 1, 1, 1, 1, 1.28826, 1.0008, .99041, .99041, .99041, .99041, .96752, 1.01519, .96752, .97363, .96752, .97363, .96752, .97363, .96752, .8641, .86304, .8641, .86304, .8641, .86304, .8641, .86304, 1.02096, 1.03057, 1.02096, 1.03517, .79795, .97278, .79795, .97278, .79795, .97278, .79795, .97278, .79795, .97278, .914, 1.01359, .914, 1.01359, .914, 1.01359, 1, 1, 1.06085, .98561, 1.06085, 1.00879, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, .97138, 1.08692, .8007, 1.02285, 1, 1, 1.00527, .83693, 1.02285, 1, 1, .83693, .9455, .83693, .90418, .83693, 1.13005, 1.09398, .99041, 1, 1, 1.09398, .99041, .96692, 1.09251, .99041, .97489, 1.0008, .97489, 1.0008, .97489, 1.0008, .93994, .97931, .90399, 1.02258, 1, 1, .90399, 1.02258, .84041, .79104, .84041, .79104, .84041, .79104, .84041, .79104, 1, 1, .95923, 1.07034, .95923, 1.16862, 1.00135, .99041, 1.00135, .99041, 1.00135, .99041, 1.00135, .99041, 1.00135, .99041, 1.00135, .99041, 1.06467, 1.02511, .90996, .96752, .90996, .99361, .95801, .99361, .95801, .99361, .95801, 1.07733, 1.03424, .97363, .96752, .93506, .93136, .97489, 1.0008, 1, 1, .95923, 1.16862, 1.15103, 1.15103, 1.01173, 1.03959, .75953, .81378, .79912, 1.15103, 1.21994, .95161, .87815, 1.01149, .81525, .7676, .98167, 1.01134, 1.02546, .84097, 1.03089, 1.18102, .97363, .88776, .85134, .97826, .79795, .99361, 1.06085, .97489, 1.1406, .89858, 1.0388, 1.14889, 1.09398, .86039, .97489, 1.0595, .92094, .94793, .95923, .90996, .99346, .98243, 1.02112, .95493, 1.1406, .90996, 1.03574, 1.02597, 1.0008, 1.18102, 1.06628, 1.03574, 1.0192, 1.01932, 1.00886, .97531, 1.0106, 1.0008, 1.13189, 1.18102, 1.02277, .98683, 1.0016, .99561, 1.07237, 1.0008, .90434, .99921, .93803, .8965, 1.23085, 1.06628, 1.04983, .96268, 1.0499, .98439, 1.18102, 1.06628, 1.0008, 1.06628, .98439, .79795, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09466, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .97278, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.02065, 1, 1, 1, 1, 1, 1, 1.06467, 1.02511, 1.06467, 1.02511, 1.06467, 1.02511, .90996, .96752, 1, 1.21408, .89903, 1, 1, .75155, 1.04394, 1.04394, 1.04394, 1.04394, .98633, .98633, .98633, .73047, .73047, 1.20642, .91211, 1.25635, 1.222, 1.02956, 1.03372, 1.03372, .96039, 1.24633, 1, 1.12454, .93503, 1.03424, 1.19687, 1.03424, 1, 1, 1, .771, 1, 1, 1.15749, 1.15749, 1.15749, 1.10948, .86279, .94434, .86279, .94434, .86182, 1, 1, 1.16897, 1, .96085, .90137, 1.2107, 1.18416, 1.13973, .69825, .9716, 2.10339, 1.29004, 1.29004, 1.21172, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, .99862, .99862, 1, .87025, .87025, .87025, .87025, 1.18874, 1.42603, 1, 1.42603, 1.42603, .99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.09193, 1.09193, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  is = {\n    lineHeight: 1.33008,\n    lineGap: 0\n  },\n  as = [1.76738, 1, 1, .98946, 1.03959, 1.04016, 1.02809, 1.036, .97639, 1.10953, 1.23203, 1.11144, 1.11144, 1.16939, 1.21237, .9754, 1.21261, .9754, 1.59754, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, .81378, .81378, 1.21237, 1.21237, 1.21237, .73541, .97847, .97363, .89723, .87897, 1.0426, .79429, .85292, .91149, 1.05815, 1.1406, .79631, .90128, .83853, 1.04396, 1.10615, .97552, .94436, .97552, .88641, .80527, .96083, 1.00135, 1, 1.06777, .9817, .91142, .99361, 1.11144, 1.57293, 1.11144, 1.21237, .74627, 1.31818, 1.06585, .97042, .83055, .97042, .93503, 1.1261, .97042, .97922, 1.14236, .94552, 1.01054, 1.14236, 1.02471, .97922, .94165, .97042, .97042, 1.0276, .78929, 1.1261, .97922, .95874, 1.02197, .98507, .96752, .97168, .95107, 1.16579, .95107, 1.21237, 1.03959, 1.036, 1.036, 1, 1.036, 1.16579, .87357, 1.31818, 1.18754, 1.26781, 1.05356, 1.21237, 1.18622, .79487, .94994, 1.29004, 1.24047, 1.24047, 1.31818, 1, .91484, .9754, 1.31818, 1.1349, 1.24866, 1.05356, 1.13934, 1.15574, 1.17389, .73541, .97363, .97363, .97363, .97363, .97363, .97363, .94385, .87897, .79429, .79429, .79429, .79429, 1.1406, 1.1406, 1.1406, 1.1406, 1.0426, 1.10615, .97552, .97552, .97552, .97552, .97552, 1.21237, .97552, 1.00135, 1.00135, 1.00135, 1.00135, .91142, .94436, .98721, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, .96705, .83055, .93503, .93503, .93503, .93503, 1.14236, 1.14236, 1.14236, 1.14236, .93125, .97922, .94165, .94165, .94165, .94165, .94165, 1.29004, .94165, .97922, .97922, .97922, .97922, .96752, .97042, .96752, .97363, 1.06585, .97363, 1.06585, .97363, 1.06585, .87897, .83055, .87897, .83055, .87897, .83055, .87897, .83055, 1.0426, 1.0033, 1.0426, .97042, .79429, .93503, .79429, .93503, .79429, .93503, .79429, .93503, .79429, .93503, .91149, .97042, .91149, .97042, .91149, .97042, 1, 1, 1.05815, .97922, 1.05815, .97922, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, .97441, 1.04302, .79631, 1.01582, 1, 1, 1.01054, .83853, 1.14236, 1, 1, .83853, 1.09125, .83853, .90418, .83853, 1.19508, 1.10615, .97922, 1, 1, 1.10615, .97922, 1.01034, 1.10466, .97922, .97552, .94165, .97552, .94165, .97552, .94165, .91602, .91981, .88641, 1.0276, 1, 1, .88641, 1.0276, .80527, .78929, .80527, .78929, .80527, .78929, .80527, .78929, 1, 1, .96083, 1.05403, .95923, 1.16862, 1.00135, .97922, 1.00135, .97922, 1.00135, .97922, 1.00135, .97922, 1.00135, .97922, 1.00135, .97922, 1.06777, 1.02197, .91142, .96752, .91142, .99361, .97168, .99361, .97168, .99361, .97168, 1.23199, 1.036, .97363, 1.06585, .94385, .96705, .97552, .94165, 1, 1, .96083, 1.1261, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, .95161, 1.27126, 1.00811, .83284, .77702, .99137, .95253, 1.0347, .86142, 1.07205, 1.14236, .97363, .89723, .86869, 1.09818, .79429, .99361, 1.05815, .97552, 1.1406, .90128, 1.06662, 1.04396, 1.10615, .84918, .97552, 1.04694, .94436, .98015, .96083, .91142, 1.00356, .9817, 1.01945, .98999, 1.1406, .91142, 1.04961, .9898, 1.00639, 1.14236, 1.07514, 1.04961, .99607, 1.02897, 1.008, .9898, .95134, 1.00639, 1.11121, 1.14236, 1.00518, .97981, 1.02186, 1, 1.08578, .94165, .99314, .98387, .93028, .93377, 1.35125, 1.07514, 1.10687, .93491, 1.04232, 1.00351, 1.14236, 1.07514, .94165, 1.07514, 1.00351, .79429, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09097, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .93503, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .96609, 1, 1, 1, 1, 1, 1, 1.06777, 1.02197, 1.06777, 1.02197, 1.06777, 1.02197, .91142, .96752, 1, 1.21261, .89903, 1, 1, .75155, 1.04745, 1.04745, 1.04745, 1.04394, .98633, .98633, .98633, .72959, .72959, 1.20502, .91406, 1.26514, 1.222, 1.02956, 1.03372, 1.03372, .96039, 1.24633, 1, 1.09125, .93327, 1.03336, 1.16541, 1.036, 1, 1, 1, .771, 1, 1, 1.15574, 1.15574, 1.15574, 1.15574, .86364, .94434, .86279, .94434, .86224, 1, 1, 1.16798, 1, .96085, .90068, 1.21237, 1.18416, 1.13904, .69825, .9716, 2.10339, 1.29004, 1.29004, 1.21339, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, .99862, .99862, 1, .87025, .87025, .87025, .87025, 1.18775, 1.42603, 1, 1.42603, 1.42603, .99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.13269, 1.13269, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  ss = {\n    lineHeight: 1.33008,\n    lineGap: 0\n  },\n  rs = [1.76738, 1, 1, .98946, 1.14763, 1.05365, 1.06234, .96927, .92586, 1.15373, 1.18414, .91349, .91349, 1.07403, 1.17308, .78383, 1.20088, .78383, 1.42531, .96927, .96927, .96927, .96927, .96927, .96927, .96927, .96927, .96927, .96927, .78383, .78383, 1.17308, 1.17308, 1.17308, .77349, .94565, .94729, .85944, .88506, .9858, .74817, .80016, .88449, .98039, .95782, .69238, .89898, .83231, .98183, 1.03989, .96924, .86237, .96924, .80595, .74524, .86091, .95402, .94143, .98448, .8858, .83089, .93285, 1.0949, 1.39016, 1.0949, 1.45994, .74627, 1.04839, .97454, .97454, .87207, .97454, .87533, 1.06151, .97454, 1.00176, 1.16484, 1.08132, .98047, 1.16484, 1.02989, 1.01054, .96225, .97454, .97454, 1.06598, .79004, 1.16344, 1.00351, .94629, .9973, .91016, .96777, .9043, .91082, .92481, .91082, 1.17308, .95748, .96927, .96927, 1, .96927, .92481, .80597, 1.04839, 1.23393, 1.1781, .9245, 1.17308, 1.20808, .63218, .94261, 1.24822, 1.09971, 1.09971, 1.04839, 1, .85273, .78032, 1.04839, 1.09971, 1.22326, .9245, 1.09836, 1.13525, 1.15222, .70424, .94729, .94729, .94729, .94729, .94729, .94729, .85498, .88506, .74817, .74817, .74817, .74817, .95782, .95782, .95782, .95782, .9858, 1.03989, .96924, .96924, .96924, .96924, .96924, 1.17308, .96924, .95402, .95402, .95402, .95402, .83089, .86237, .88409, .97454, .97454, .97454, .97454, .97454, .97454, .92916, .87207, .87533, .87533, .87533, .87533, .93146, .93146, .93146, .93146, .93854, 1.01054, .96225, .96225, .96225, .96225, .96225, 1.24822, .8761, 1.00351, 1.00351, 1.00351, 1.00351, .96777, .97454, .96777, .94729, .97454, .94729, .97454, .94729, .97454, .88506, .87207, .88506, .87207, .88506, .87207, .88506, .87207, .9858, .95391, .9858, .97454, .74817, .87533, .74817, .87533, .74817, .87533, .74817, .87533, .74817, .87533, .88449, .97454, .88449, .97454, .88449, .97454, 1, 1, .98039, 1.00176, .98039, 1.00176, .95782, .93146, .95782, .93146, .95782, .93146, .95782, 1.16484, .95782, .93146, .84421, 1.12761, .69238, 1.08132, 1, 1, .98047, .83231, 1.16484, 1, 1, .84723, 1.04861, .84723, .78755, .83231, 1.23736, 1.03989, 1.01054, 1, 1, 1.03989, 1.01054, .9857, 1.03849, 1.01054, .96924, .96225, .96924, .96225, .96924, .96225, .92383, .90171, .80595, 1.06598, 1, 1, .80595, 1.06598, .74524, .79004, .74524, .79004, .74524, .79004, .74524, .79004, 1, 1, .86091, 1.02759, .85771, 1.16344, .95402, 1.00351, .95402, 1.00351, .95402, 1.00351, .95402, 1.00351, .95402, 1.00351, .95402, 1.00351, .98448, .9973, .83089, .96777, .83089, .93285, .9043, .93285, .9043, .93285, .9043, 1.31868, .96927, .94729, .97454, .85498, .92916, .96924, .8761, 1, 1, .86091, 1.16344, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, .81965, .81965, .94729, .78032, .71022, .90883, .84171, .99877, .77596, 1.05734, 1.2, .94729, .85944, .82791, .9607, .74817, .93285, .98039, .96924, .95782, .89898, .98316, .98183, 1.03989, .78614, .96924, .97642, .86237, .86075, .86091, .83089, .90082, .8858, .97296, 1.01284, .95782, .83089, 1.0976, 1.04, 1.03342, 1.2, 1.0675, 1.0976, .98205, 1.03809, 1.05097, 1.04, .95364, 1.03342, 1.05401, 1.2, 1.02148, 1.0119, 1.04724, 1.0127, 1.02732, .96225, .8965, .97783, .93574, .94818, 1.30679, 1.0675, 1.11826, .99821, 1.0557, 1.0326, 1.2, 1.0675, .96225, 1.0675, 1.0326, .74817, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03754, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .87533, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .98705, 1, 1, 1, 1, 1, 1, .98448, .9973, .98448, .9973, .98448, .9973, .83089, .96777, 1, 1.20088, .89903, 1, 1, .75155, .94945, .94945, .94945, .94945, 1.12317, 1.12317, 1.12317, .67603, .67603, 1.15621, .73584, 1.21191, 1.22135, 1.06483, .94868, .94868, .95996, 1.24633, 1, 1.07497, .87709, .96927, 1.01473, .96927, 1, 1, 1, .77295, 1, 1, 1.09836, 1.09836, 1.09836, 1.01522, .86321, .94434, .8649, .94434, .86182, 1, 1, 1.083, 1, .91578, .86438, 1.17308, 1.18416, 1.14589, .69825, .97622, 1.96791, 1.24822, 1.24822, 1.17308, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, .99862, .99862, 1, .87025, .87025, .87025, .87025, 1.17984, 1.42603, 1, 1.42603, 1.42603, .99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10742, 1.10742, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  ns = {\n    lineHeight: 1.33008,\n    lineGap: 0\n  },\n  gs = [1.76738, 1, 1, .98594, 1.02285, 1.10454, 1.06234, .96927, .92037, 1.19985, 1.2046, .90616, .90616, 1.07152, 1.1714, .78032, 1.20088, .78032, 1.40246, .96927, .96927, .96927, .96927, .96927, .96927, .96927, .96927, .96927, .96927, .78032, .78032, 1.1714, 1.1714, 1.1714, .80597, .94084, .96706, .85944, .85734, .97093, .75842, .79936, .88198, .9831, .95782, .71387, .86969, .84636, 1.07796, 1.03584, .96924, .83968, .96924, .82826, .79649, .85771, .95132, .93119, .98965, .88433, .8287, .93365, 1.08612, 1.3638, 1.08612, 1.45786, .74627, .80499, .91484, 1.05707, .92383, 1.05882, .9403, 1.12654, 1.05882, 1.01756, 1.09011, 1.09011, .99414, 1.09011, 1.034, 1.01756, 1.05356, 1.05707, 1.05882, 1.04399, .84863, 1.21968, 1.01756, .95801, 1.00068, .91797, .96777, .9043, .90351, .92105, .90351, 1.1714, .85337, .96927, .96927, .99912, .96927, .92105, .80597, 1.2434, 1.20808, 1.05937, .90957, 1.1714, 1.20808, .75155, .94261, 1.24644, 1.09971, 1.09971, .84751, 1, .85273, .78032, .61584, 1.05425, 1.17914, .90957, 1.08665, 1.11593, 1.14169, .73381, .96706, .96706, .96706, .96706, .96706, .96706, .86035, .85734, .75842, .75842, .75842, .75842, .95782, .95782, .95782, .95782, .97093, 1.03584, .96924, .96924, .96924, .96924, .96924, 1.1714, .96924, .95132, .95132, .95132, .95132, .8287, .83968, .89049, .91484, .91484, .91484, .91484, .91484, .91484, .93575, .92383, .9403, .9403, .9403, .9403, .8717, .8717, .8717, .8717, 1.00527, 1.01756, 1.05356, 1.05356, 1.05356, 1.05356, 1.05356, 1.24644, .95923, 1.01756, 1.01756, 1.01756, 1.01756, .96777, 1.05707, .96777, .96706, .91484, .96706, .91484, .96706, .91484, .85734, .92383, .85734, .92383, .85734, .92383, .85734, .92383, .97093, 1.0969, .97093, 1.05882, .75842, .9403, .75842, .9403, .75842, .9403, .75842, .9403, .75842, .9403, .88198, 1.05882, .88198, 1.05882, .88198, 1.05882, 1, 1, .9831, 1.01756, .9831, 1.01756, .95782, .8717, .95782, .8717, .95782, .8717, .95782, 1.09011, .95782, .8717, .84784, 1.11551, .71387, 1.09011, 1, 1, .99414, .84636, 1.09011, 1, 1, .84636, 1.0536, .84636, .94298, .84636, 1.23297, 1.03584, 1.01756, 1, 1, 1.03584, 1.01756, 1.00323, 1.03444, 1.01756, .96924, 1.05356, .96924, 1.05356, .96924, 1.05356, .93066, .98293, .82826, 1.04399, 1, 1, .82826, 1.04399, .79649, .84863, .79649, .84863, .79649, .84863, .79649, .84863, 1, 1, .85771, 1.17318, .85771, 1.21968, .95132, 1.01756, .95132, 1.01756, .95132, 1.01756, .95132, 1.01756, .95132, 1.01756, .95132, 1.01756, .98965, 1.00068, .8287, .96777, .8287, .93365, .9043, .93365, .9043, .93365, .9043, 1.08571, .96927, .96706, .91484, .86035, .93575, .96924, .95923, 1, 1, .85771, 1.21968, 1.11437, 1.11437, .93109, .91202, .60411, .84164, .55572, 1.01173, .97361, .81818, .81818, .96635, .78032, .72727, .92366, .98601, 1.03405, .77968, 1.09799, 1.2, .96706, .85944, .85638, .96491, .75842, .93365, .9831, .96924, .95782, .86969, .94152, 1.07796, 1.03584, .78437, .96924, .98715, .83968, .83491, .85771, .8287, .94492, .88433, .9287, 1.0098, .95782, .8287, 1.0625, .98248, 1.03424, 1.2, 1.01071, 1.0625, .95246, 1.03809, 1.04912, .98248, 1.00221, 1.03424, 1.05443, 1.2, 1.04785, .99609, 1.00169, 1.05176, .99346, 1.05356, .9087, 1.03004, .95542, .93117, 1.23362, 1.01071, 1.07831, 1.02512, 1.05205, 1.03502, 1.2, 1.01071, 1.05356, 1.01071, 1.03502, .75842, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03719, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .9403, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04021, 1, 1, 1, 1, 1, 1, .98965, 1.00068, .98965, 1.00068, .98965, 1.00068, .8287, .96777, 1, 1.20088, .89903, 1, 1, .75155, 1.03077, 1.03077, 1.03077, 1.03077, 1.13196, 1.13196, 1.13196, .67428, .67428, 1.16039, .73291, 1.20996, 1.22135, 1.06483, .94868, .94868, .95996, 1.24633, 1, 1.07497, .87796, .96927, 1.01518, .96927, 1, 1, 1, .77295, 1, 1, 1.10539, 1.10539, 1.11358, 1.06967, .86279, .94434, .86279, .94434, .86182, 1, 1, 1.083, 1, .91578, .86507, 1.1714, 1.18416, 1.14589, .69825, .97622, 1.9697, 1.24822, 1.24822, 1.17238, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, .99862, .99862, 1, .87025, .87025, .87025, .87025, 1.18083, 1.42603, 1, 1.42603, 1.42603, .99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10938, 1.10938, 1, 1, 1, 1.05425, 1.09971, 1.09971, 1.09971, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  os = {\n    lineHeight: 1.33008,\n    lineGap: 0\n  },\n  Is = getLookupTableFactory(function (e) {\n    e[\"MyriadPro-Regular\"] = e[\"PdfJS-Fallback-Regular\"] = {\n      name: \"LiberationSans-Regular\",\n      factors: As,\n      baseWidths: Wa,\n      baseMapping: ja,\n      metrics: es\n    };\n    e[\"MyriadPro-Bold\"] = e[\"PdfJS-Fallback-Bold\"] = {\n      name: \"LiberationSans-Bold\",\n      factors: Xa,\n      baseWidths: va,\n      baseMapping: Ka,\n      metrics: Za\n    };\n    e[\"MyriadPro-It\"] = e[\"MyriadPro-Italic\"] = e[\"PdfJS-Fallback-Italic\"] = {\n      name: \"LiberationSans-Italic\",\n      factors: _a,\n      baseWidths: Oa,\n      baseMapping: Pa,\n      metrics: $a\n    };\n    e[\"MyriadPro-BoldIt\"] = e[\"MyriadPro-BoldItalic\"] = e[\"PdfJS-Fallback-BoldItalic\"] = {\n      name: \"LiberationSans-BoldItalic\",\n      factors: Va,\n      baseWidths: Ta,\n      baseMapping: qa,\n      metrics: za\n    };\n    e.ArialMT = e.Arial = e[\"Arial-Regular\"] = {\n      name: \"LiberationSans-Regular\",\n      baseWidths: Wa,\n      baseMapping: ja\n    };\n    e[\"Arial-BoldMT\"] = e[\"Arial-Bold\"] = {\n      name: \"LiberationSans-Bold\",\n      baseWidths: va,\n      baseMapping: Ka\n    };\n    e[\"Arial-ItalicMT\"] = e[\"Arial-Italic\"] = {\n      name: \"LiberationSans-Italic\",\n      baseWidths: Oa,\n      baseMapping: Pa\n    };\n    e[\"Arial-BoldItalicMT\"] = e[\"Arial-BoldItalic\"] = {\n      name: \"LiberationSans-BoldItalic\",\n      baseWidths: Ta,\n      baseMapping: qa\n    };\n    e[\"Calibri-Regular\"] = {\n      name: \"LiberationSans-Regular\",\n      factors: Ra,\n      baseWidths: Wa,\n      baseMapping: ja,\n      metrics: Na\n    };\n    e[\"Calibri-Bold\"] = {\n      name: \"LiberationSans-Bold\",\n      factors: wa,\n      baseWidths: va,\n      baseMapping: Ka,\n      metrics: Da\n    };\n    e[\"Calibri-Italic\"] = {\n      name: \"LiberationSans-Italic\",\n      factors: Sa,\n      baseWidths: Oa,\n      baseMapping: Pa,\n      metrics: ka\n    };\n    e[\"Calibri-BoldItalic\"] = {\n      name: \"LiberationSans-BoldItalic\",\n      factors: ba,\n      baseWidths: Ta,\n      baseMapping: qa,\n      metrics: Fa\n    };\n    e[\"Segoeui-Regular\"] = {\n      name: \"LiberationSans-Regular\",\n      factors: gs,\n      baseWidths: Wa,\n      baseMapping: ja,\n      metrics: os\n    };\n    e[\"Segoeui-Bold\"] = {\n      name: \"LiberationSans-Bold\",\n      factors: ts,\n      baseWidths: va,\n      baseMapping: Ka,\n      metrics: is\n    };\n    e[\"Segoeui-Italic\"] = {\n      name: \"LiberationSans-Italic\",\n      factors: rs,\n      baseWidths: Oa,\n      baseMapping: Pa,\n      metrics: ns\n    };\n    e[\"Segoeui-BoldItalic\"] = {\n      name: \"LiberationSans-BoldItalic\",\n      factors: as,\n      baseWidths: Ta,\n      baseMapping: qa,\n      metrics: ss\n    };\n    e[\"Helvetica-Regular\"] = e.Helvetica = {\n      name: \"LiberationSans-Regular\",\n      factors: Ja,\n      baseWidths: Wa,\n      baseMapping: ja,\n      metrics: Ya\n    };\n    e[\"Helvetica-Bold\"] = {\n      name: \"LiberationSans-Bold\",\n      factors: Ga,\n      baseWidths: va,\n      baseMapping: Ka,\n      metrics: xa\n    };\n    e[\"Helvetica-Italic\"] = {\n      name: \"LiberationSans-Italic\",\n      factors: La,\n      baseWidths: Oa,\n      baseMapping: Pa,\n      metrics: Ha\n    };\n    e[\"Helvetica-BoldItalic\"] = {\n      name: \"LiberationSans-BoldItalic\",\n      factors: Ua,\n      baseWidths: Ta,\n      baseMapping: qa,\n      metrics: Ma\n    };\n  });\nfunction getXfaFontName(e) {\n  const t = normalizeFontName(e);\n  return Is()[t];\n}\nfunction getXfaFontDict(e) {\n  const t = function getXfaFontWidths(e) {\n      const t = getXfaFontName(e);\n      if (!t) return null;\n      const {\n          baseWidths: i,\n          baseMapping: a,\n          factors: s\n        } = t,\n        r = s ? i.map((e, t) => e * s[t]) : i;\n      let n,\n        g = -2;\n      const o = [];\n      for (const [e, t] of a.map((e, t) => [e, t]).sort(([e], [t]) => e - t)) if (-1 !== e) if (e === g + 1) {\n        n.push(r[t]);\n        g += 1;\n      } else {\n        g = e;\n        n = [r[t]];\n        o.push(e, n);\n      }\n      return o;\n    }(e),\n    i = new Dict(null);\n  i.set(\"BaseFont\", Name.get(e));\n  i.set(\"Type\", Name.get(\"Font\"));\n  i.set(\"Subtype\", Name.get(\"CIDFontType2\"));\n  i.set(\"Encoding\", Name.get(\"Identity-H\"));\n  i.set(\"CIDToGIDMap\", Name.get(\"Identity\"));\n  i.set(\"W\", t);\n  i.set(\"FirstChar\", t[0]);\n  i.set(\"LastChar\", t.at(-2) + t.at(-1).length - 1);\n  const a = new Dict(null);\n  i.set(\"FontDescriptor\", a);\n  const s = new Dict(null);\n  s.set(\"Ordering\", \"Identity\");\n  s.set(\"Registry\", \"Adobe\");\n  s.set(\"Supplement\", 0);\n  i.set(\"CIDSystemInfo\", s);\n  return i;\n}\nclass PostScriptParser {\n  constructor(e) {\n    this.lexer = e;\n    this.operators = [];\n    this.token = null;\n    this.prev = null;\n  }\n  nextToken() {\n    this.prev = this.token;\n    this.token = this.lexer.getToken();\n  }\n  accept(e) {\n    if (this.token.type === e) {\n      this.nextToken();\n      return !0;\n    }\n    return !1;\n  }\n  expect(e) {\n    if (this.accept(e)) return !0;\n    throw new FormatError(`Unexpected symbol: found ${this.token.type} expected ${e}.`);\n  }\n  parse() {\n    this.nextToken();\n    this.expect(cs.LBRACE);\n    this.parseBlock();\n    this.expect(cs.RBRACE);\n    return this.operators;\n  }\n  parseBlock() {\n    for (;;) if (this.accept(cs.NUMBER)) this.operators.push(this.prev.value);else if (this.accept(cs.OPERATOR)) this.operators.push(this.prev.value);else {\n      if (!this.accept(cs.LBRACE)) return;\n      this.parseCondition();\n    }\n  }\n  parseCondition() {\n    const e = this.operators.length;\n    this.operators.push(null, null);\n    this.parseBlock();\n    this.expect(cs.RBRACE);\n    if (this.accept(cs.IF)) {\n      this.operators[e] = this.operators.length;\n      this.operators[e + 1] = \"jz\";\n    } else {\n      if (!this.accept(cs.LBRACE)) throw new FormatError(\"PS Function: error parsing conditional.\");\n      {\n        const t = this.operators.length;\n        this.operators.push(null, null);\n        const i = this.operators.length;\n        this.parseBlock();\n        this.expect(cs.RBRACE);\n        this.expect(cs.IFELSE);\n        this.operators[t] = this.operators.length;\n        this.operators[t + 1] = \"j\";\n        this.operators[e] = i;\n        this.operators[e + 1] = \"jz\";\n      }\n    }\n  }\n}\nconst cs = {\n  LBRACE: 0,\n  RBRACE: 1,\n  NUMBER: 2,\n  OPERATOR: 3,\n  IF: 4,\n  IFELSE: 5\n};\nclass PostScriptToken {\n  static get opCache() {\n    return shadow(this, \"opCache\", Object.create(null));\n  }\n  constructor(e, t) {\n    this.type = e;\n    this.value = t;\n  }\n  static getOperator(e) {\n    return PostScriptToken.opCache[e] ||= new PostScriptToken(cs.OPERATOR, e);\n  }\n  static get LBRACE() {\n    return shadow(this, \"LBRACE\", new PostScriptToken(cs.LBRACE, \"{\"));\n  }\n  static get RBRACE() {\n    return shadow(this, \"RBRACE\", new PostScriptToken(cs.RBRACE, \"}\"));\n  }\n  static get IF() {\n    return shadow(this, \"IF\", new PostScriptToken(cs.IF, \"IF\"));\n  }\n  static get IFELSE() {\n    return shadow(this, \"IFELSE\", new PostScriptToken(cs.IFELSE, \"IFELSE\"));\n  }\n}\nclass PostScriptLexer {\n  constructor(e) {\n    this.stream = e;\n    this.nextChar();\n    this.strBuf = [];\n  }\n  nextChar() {\n    return this.currentChar = this.stream.getByte();\n  }\n  getToken() {\n    let e = !1,\n      t = this.currentChar;\n    for (;;) {\n      if (t < 0) return pt;\n      if (e) 10 !== t && 13 !== t || (e = !1);else if (37 === t) e = !0;else if (!isWhiteSpace(t)) break;\n      t = this.nextChar();\n    }\n    switch (0 | t) {\n      case 48:\n      case 49:\n      case 50:\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n      case 43:\n      case 45:\n      case 46:\n        return new PostScriptToken(cs.NUMBER, this.getNumber());\n      case 123:\n        this.nextChar();\n        return PostScriptToken.LBRACE;\n      case 125:\n        this.nextChar();\n        return PostScriptToken.RBRACE;\n    }\n    const i = this.strBuf;\n    i.length = 0;\n    i[0] = String.fromCharCode(t);\n    for (; (t = this.nextChar()) >= 0 && (t >= 65 && t <= 90 || t >= 97 && t <= 122);) i.push(String.fromCharCode(t));\n    const a = i.join(\"\");\n    switch (a.toLowerCase()) {\n      case \"if\":\n        return PostScriptToken.IF;\n      case \"ifelse\":\n        return PostScriptToken.IFELSE;\n      default:\n        return PostScriptToken.getOperator(a);\n    }\n  }\n  getNumber() {\n    let e = this.currentChar;\n    const t = this.strBuf;\n    t.length = 0;\n    t[0] = String.fromCharCode(e);\n    for (; (e = this.nextChar()) >= 0 && (e >= 48 && e <= 57 || 45 === e || 46 === e);) t.push(String.fromCharCode(e));\n    const i = parseFloat(t.join(\"\"));\n    if (isNaN(i)) throw new FormatError(`Invalid floating point number: ${i}`);\n    return i;\n  }\n}\nclass BaseLocalCache {\n  constructor(e) {\n    this.constructor === BaseLocalCache && unreachable(\"Cannot initialize BaseLocalCache.\");\n    this._onlyRefs = !0 === e?.onlyRefs;\n    if (!this._onlyRefs) {\n      this._nameRefMap = new Map();\n      this._imageMap = new Map();\n    }\n    this._imageCache = new RefSetCache();\n  }\n  getByName(e) {\n    this._onlyRefs && unreachable(\"Should not call `getByName` method.\");\n    const t = this._nameRefMap.get(e);\n    return t ? this.getByRef(t) : this._imageMap.get(e) || null;\n  }\n  getByRef(e) {\n    return this._imageCache.get(e) || null;\n  }\n  set(e, t, i) {\n    unreachable(\"Abstract method `set` called.\");\n  }\n}\nclass LocalImageCache extends BaseLocalCache {\n  set(e, t = null, i) {\n    if (\"string\" != typeof e) throw new Error('LocalImageCache.set - expected \"name\" argument.');\n    if (t) {\n      if (this._imageCache.has(t)) return;\n      this._nameRefMap.set(e, t);\n      this._imageCache.put(t, i);\n    } else this._imageMap.has(e) || this._imageMap.set(e, i);\n  }\n}\nclass LocalColorSpaceCache extends BaseLocalCache {\n  set(e = null, t = null, i) {\n    if (\"string\" != typeof e && !t) throw new Error('LocalColorSpaceCache.set - expected \"name\" and/or \"ref\" argument.');\n    if (t) {\n      if (this._imageCache.has(t)) return;\n      null !== e && this._nameRefMap.set(e, t);\n      this._imageCache.put(t, i);\n    } else this._imageMap.has(e) || this._imageMap.set(e, i);\n  }\n}\nclass LocalFunctionCache extends BaseLocalCache {\n  constructor(e) {\n    super({\n      onlyRefs: !0\n    });\n  }\n  set(e = null, t, i) {\n    if (!t) throw new Error('LocalFunctionCache.set - expected \"ref\" argument.');\n    this._imageCache.has(t) || this._imageCache.put(t, i);\n  }\n}\nclass LocalGStateCache extends BaseLocalCache {\n  set(e, t = null, i) {\n    if (\"string\" != typeof e) throw new Error('LocalGStateCache.set - expected \"name\" argument.');\n    if (t) {\n      if (this._imageCache.has(t)) return;\n      this._nameRefMap.set(e, t);\n      this._imageCache.put(t, i);\n    } else this._imageMap.has(e) || this._imageMap.set(e, i);\n  }\n}\nclass LocalTilingPatternCache extends BaseLocalCache {\n  constructor(e) {\n    super({\n      onlyRefs: !0\n    });\n  }\n  set(e = null, t, i) {\n    if (!t) throw new Error('LocalTilingPatternCache.set - expected \"ref\" argument.');\n    this._imageCache.has(t) || this._imageCache.put(t, i);\n  }\n}\nclass RegionalImageCache extends BaseLocalCache {\n  constructor(e) {\n    super({\n      onlyRefs: !0\n    });\n  }\n  set(e = null, t, i) {\n    if (!t) throw new Error('RegionalImageCache.set - expected \"ref\" argument.');\n    this._imageCache.has(t) || this._imageCache.put(t, i);\n  }\n}\nclass GlobalImageCache {\n  static NUM_PAGES_THRESHOLD = 2;\n  static MIN_IMAGES_TO_CACHE = 10;\n  static MAX_BYTE_SIZE = 5e7;\n  #D = new RefSet();\n  constructor() {\n    this._refCache = new RefSetCache();\n    this._imageCache = new RefSetCache();\n  }\n  get #b() {\n    let e = 0;\n    for (const t of this._imageCache) e += t.byteSize;\n    return e;\n  }\n  get #F() {\n    return !(this._imageCache.size < GlobalImageCache.MIN_IMAGES_TO_CACHE) && !(this.#b < GlobalImageCache.MAX_BYTE_SIZE);\n  }\n  shouldCache(e, t) {\n    let i = this._refCache.get(e);\n    if (!i) {\n      i = new Set();\n      this._refCache.put(e, i);\n    }\n    i.add(t);\n    return !(i.size < GlobalImageCache.NUM_PAGES_THRESHOLD) && !(!this._imageCache.has(e) && this.#F);\n  }\n  addDecodeFailed(e) {\n    this.#D.put(e);\n  }\n  hasDecodeFailed(e) {\n    return this.#D.has(e);\n  }\n  addByteSize(e, t) {\n    const i = this._imageCache.get(e);\n    i && (i.byteSize || (i.byteSize = t));\n  }\n  getData(e, t) {\n    const i = this._refCache.get(e);\n    if (!i) return null;\n    if (i.size < GlobalImageCache.NUM_PAGES_THRESHOLD) return null;\n    const a = this._imageCache.get(e);\n    if (!a) return null;\n    i.add(t);\n    return a;\n  }\n  setData(e, t) {\n    if (!this._refCache.has(e)) throw new Error('GlobalImageCache.setData - expected \"shouldCache\" to have been called.');\n    this._imageCache.has(e) || (this.#F ? warn(\"GlobalImageCache.setData - cache limit reached.\") : this._imageCache.put(e, t));\n  }\n  clear(e = !1) {\n    if (!e) {\n      this.#D.clear();\n      this._refCache.clear();\n    }\n    this._imageCache.clear();\n  }\n}\nclass PDFFunctionFactory {\n  constructor({\n    xref: e,\n    isEvalSupported: t = !0\n  }) {\n    this.xref = e;\n    this.isEvalSupported = !1 !== t;\n  }\n  create(e) {\n    const t = this.getCached(e);\n    if (t) return t;\n    const i = PDFFunction.parse({\n      xref: this.xref,\n      isEvalSupported: this.isEvalSupported,\n      fn: e instanceof Ref ? this.xref.fetch(e) : e\n    });\n    this._cache(e, i);\n    return i;\n  }\n  createFromArray(e) {\n    const t = this.getCached(e);\n    if (t) return t;\n    const i = PDFFunction.parseArray({\n      xref: this.xref,\n      isEvalSupported: this.isEvalSupported,\n      fnObj: e instanceof Ref ? this.xref.fetch(e) : e\n    });\n    this._cache(e, i);\n    return i;\n  }\n  getCached(e) {\n    let t;\n    e instanceof Ref ? t = e : e instanceof Dict ? t = e.objId : e instanceof BaseStream && (t = e.dict?.objId);\n    if (t) {\n      const e = this._localFunctionCache.getByRef(t);\n      if (e) return e;\n    }\n    return null;\n  }\n  _cache(e, t) {\n    if (!t) throw new Error('PDFFunctionFactory._cache - expected \"parsedFunction\" argument.');\n    let i;\n    e instanceof Ref ? i = e : e instanceof Dict ? i = e.objId : e instanceof BaseStream && (i = e.dict?.objId);\n    i && this._localFunctionCache.set(null, i, t);\n  }\n  get _localFunctionCache() {\n    return shadow(this, \"_localFunctionCache\", new LocalFunctionCache());\n  }\n}\nfunction toNumberArray(e) {\n  return Array.isArray(e) ? isNumberArray(e, null) ? e : e.map(e => +e) : null;\n}\nclass PDFFunction {\n  static getSampleArray(e, t, i, a) {\n    let s,\n      r,\n      n = 1;\n    for (s = 0, r = e.length; s < r; s++) n *= e[s];\n    n *= t;\n    const g = new Array(n);\n    let o = 0,\n      c = 0;\n    const C = 1 / (2 ** i - 1),\n      h = a.getBytes((n * i + 7) / 8);\n    let l = 0;\n    for (s = 0; s < n; s++) {\n      for (; o < i;) {\n        c <<= 8;\n        c |= h[l++];\n        o += 8;\n      }\n      o -= i;\n      g[s] = (c >> o) * C;\n      c &= (1 << o) - 1;\n    }\n    return g;\n  }\n  static parse({\n    xref: e,\n    isEvalSupported: t,\n    fn: i\n  }) {\n    const a = i.dict || i;\n    switch (a.get(\"FunctionType\")) {\n      case 0:\n        return this.constructSampled({\n          xref: e,\n          isEvalSupported: t,\n          fn: i,\n          dict: a\n        });\n      case 1:\n        break;\n      case 2:\n        return this.constructInterpolated({\n          xref: e,\n          isEvalSupported: t,\n          dict: a\n        });\n      case 3:\n        return this.constructStiched({\n          xref: e,\n          isEvalSupported: t,\n          dict: a\n        });\n      case 4:\n        return this.constructPostScript({\n          xref: e,\n          isEvalSupported: t,\n          fn: i,\n          dict: a\n        });\n    }\n    throw new FormatError(\"Unknown type of function\");\n  }\n  static parseArray({\n    xref: e,\n    isEvalSupported: t,\n    fnObj: i\n  }) {\n    if (!Array.isArray(i)) return this.parse({\n      xref: e,\n      isEvalSupported: t,\n      fn: i\n    });\n    const a = [];\n    for (const s of i) a.push(this.parse({\n      xref: e,\n      isEvalSupported: t,\n      fn: e.fetchIfRef(s)\n    }));\n    return function (e, t, i, s) {\n      for (let r = 0, n = a.length; r < n; r++) a[r](e, t, i, s + r);\n    };\n  }\n  static constructSampled({\n    xref: e,\n    isEvalSupported: t,\n    fn: i,\n    dict: a\n  }) {\n    function toMultiArray(e) {\n      const t = e.length,\n        i = [];\n      let a = 0;\n      for (let s = 0; s < t; s += 2) i[a++] = [e[s], e[s + 1]];\n      return i;\n    }\n    function interpolate(e, t, i, a, s) {\n      return a + (s - a) / (i - t) * (e - t);\n    }\n    let s = toNumberArray(a.getArray(\"Domain\")),\n      r = toNumberArray(a.getArray(\"Range\"));\n    if (!s || !r) throw new FormatError(\"No domain or range\");\n    const n = s.length / 2,\n      g = r.length / 2;\n    s = toMultiArray(s);\n    r = toMultiArray(r);\n    const o = toNumberArray(a.getArray(\"Size\")),\n      c = a.get(\"BitsPerSample\"),\n      C = a.get(\"Order\") || 1;\n    1 !== C && info(\"No support for cubic spline interpolation: \" + C);\n    let h = toNumberArray(a.getArray(\"Encode\"));\n    if (h) h = toMultiArray(h);else {\n      h = [];\n      for (let e = 0; e < n; ++e) h.push([0, o[e] - 1]);\n    }\n    let l = toNumberArray(a.getArray(\"Decode\"));\n    l = l ? toMultiArray(l) : r;\n    const Q = this.getSampleArray(o, g, c, i);\n    return function constructSampledFn(e, t, i, a) {\n      const c = 1 << n,\n        C = new Float64Array(c),\n        E = new Uint32Array(c);\n      let u, d;\n      for (d = 0; d < c; d++) C[d] = 1;\n      let f = g,\n        p = 1;\n      for (u = 0; u < n; ++u) {\n        const i = s[u][0],\n          a = s[u][1];\n        let r = interpolate(Math.min(Math.max(e[t + u], i), a), i, a, h[u][0], h[u][1]);\n        const n = o[u];\n        r = Math.min(Math.max(r, 0), n - 1);\n        const g = r < n - 1 ? Math.floor(r) : r - 1,\n          l = g + 1 - r,\n          Q = r - g,\n          m = g * f,\n          y = m + f;\n        for (d = 0; d < c; d++) if (d & p) {\n          C[d] *= Q;\n          E[d] += y;\n        } else {\n          C[d] *= l;\n          E[d] += m;\n        }\n        f *= n;\n        p <<= 1;\n      }\n      for (d = 0; d < g; ++d) {\n        let e = 0;\n        for (u = 0; u < c; u++) e += Q[E[u] + d] * C[u];\n        e = interpolate(e, 0, 1, l[d][0], l[d][1]);\n        i[a + d] = Math.min(Math.max(e, r[d][0]), r[d][1]);\n      }\n    };\n  }\n  static constructInterpolated({\n    xref: e,\n    isEvalSupported: t,\n    dict: i\n  }) {\n    const a = toNumberArray(i.getArray(\"C0\")) || [0],\n      s = toNumberArray(i.getArray(\"C1\")) || [1],\n      r = i.get(\"N\"),\n      n = [];\n    for (let e = 0, t = a.length; e < t; ++e) n.push(s[e] - a[e]);\n    const g = n.length;\n    return function constructInterpolatedFn(e, t, i, s) {\n      const o = 1 === r ? e[t] : e[t] ** r;\n      for (let e = 0; e < g; ++e) i[s + e] = a[e] + o * n[e];\n    };\n  }\n  static constructStiched({\n    xref: e,\n    isEvalSupported: t,\n    dict: i\n  }) {\n    const a = toNumberArray(i.getArray(\"Domain\"));\n    if (!a) throw new FormatError(\"No domain\");\n    if (1 !== a.length / 2) throw new FormatError(\"Bad domain for stiched function\");\n    const s = [];\n    for (const a of i.get(\"Functions\")) s.push(this.parse({\n      xref: e,\n      isEvalSupported: t,\n      fn: e.fetchIfRef(a)\n    }));\n    const r = toNumberArray(i.getArray(\"Bounds\")),\n      n = toNumberArray(i.getArray(\"Encode\")),\n      g = new Float32Array(1);\n    return function constructStichedFn(e, t, i, o) {\n      const c = function constructStichedFromIRClip(e, t, i) {\n          e > i ? e = i : e < t && (e = t);\n          return e;\n        }(e[t], a[0], a[1]),\n        C = r.length;\n      let h;\n      for (h = 0; h < C && !(c < r[h]); ++h);\n      let l = a[0];\n      h > 0 && (l = r[h - 1]);\n      let Q = a[1];\n      h < r.length && (Q = r[h]);\n      const E = n[2 * h],\n        u = n[2 * h + 1];\n      g[0] = l === Q ? E : E + (c - l) * (u - E) / (Q - l);\n      s[h](g, 0, i, o);\n    };\n  }\n  static constructPostScript({\n    xref: e,\n    isEvalSupported: t,\n    fn: i,\n    dict: a\n  }) {\n    const s = toNumberArray(a.getArray(\"Domain\")),\n      r = toNumberArray(a.getArray(\"Range\"));\n    if (!s) throw new FormatError(\"No domain.\");\n    if (!r) throw new FormatError(\"No range.\");\n    const n = new PostScriptLexer(i),\n      g = new PostScriptParser(n).parse();\n    if (t && FeatureTest.isEvalSupported) {\n      const e = new PostScriptCompiler().compile(g, s, r);\n      if (e) return new Function(\"src\", \"srcOffset\", \"dest\", \"destOffset\", e);\n    }\n    info(\"Unable to compile PS function\");\n    const o = r.length >> 1,\n      c = s.length >> 1,\n      C = new PostScriptEvaluator(g),\n      h = Object.create(null);\n    let l = 8192;\n    const Q = new Float32Array(c);\n    return function constructPostScriptFn(e, t, i, a) {\n      let s,\n        n,\n        g = \"\";\n      const E = Q;\n      for (s = 0; s < c; s++) {\n        n = e[t + s];\n        E[s] = n;\n        g += n + \"_\";\n      }\n      const u = h[g];\n      if (void 0 !== u) {\n        i.set(u, a);\n        return;\n      }\n      const d = new Float32Array(o),\n        f = C.execute(E),\n        p = f.length - o;\n      for (s = 0; s < o; s++) {\n        n = f[p + s];\n        let e = r[2 * s];\n        if (n < e) n = e;else {\n          e = r[2 * s + 1];\n          n > e && (n = e);\n        }\n        d[s] = n;\n      }\n      if (l > 0) {\n        l--;\n        h[g] = d;\n      }\n      i.set(d, a);\n    };\n  }\n}\nfunction isPDFFunction(e) {\n  let t;\n  if (e instanceof Dict) t = e;else {\n    if (!(e instanceof BaseStream)) return !1;\n    t = e.dict;\n  }\n  return t.has(\"FunctionType\");\n}\nclass PostScriptStack {\n  static MAX_STACK_SIZE = 100;\n  constructor(e) {\n    this.stack = e ? Array.from(e) : [];\n  }\n  push(e) {\n    if (this.stack.length >= PostScriptStack.MAX_STACK_SIZE) throw new Error(\"PostScript function stack overflow.\");\n    this.stack.push(e);\n  }\n  pop() {\n    if (this.stack.length <= 0) throw new Error(\"PostScript function stack underflow.\");\n    return this.stack.pop();\n  }\n  copy(e) {\n    if (this.stack.length + e >= PostScriptStack.MAX_STACK_SIZE) throw new Error(\"PostScript function stack overflow.\");\n    const t = this.stack;\n    for (let i = t.length - e, a = e - 1; a >= 0; a--, i++) t.push(t[i]);\n  }\n  index(e) {\n    this.push(this.stack[this.stack.length - e - 1]);\n  }\n  roll(e, t) {\n    const i = this.stack,\n      a = i.length - e,\n      s = i.length - 1,\n      r = a + (t - Math.floor(t / e) * e);\n    for (let e = a, t = s; e < t; e++, t--) {\n      const a = i[e];\n      i[e] = i[t];\n      i[t] = a;\n    }\n    for (let e = a, t = r - 1; e < t; e++, t--) {\n      const a = i[e];\n      i[e] = i[t];\n      i[t] = a;\n    }\n    for (let e = r, t = s; e < t; e++, t--) {\n      const a = i[e];\n      i[e] = i[t];\n      i[t] = a;\n    }\n  }\n}\nclass PostScriptEvaluator {\n  constructor(e) {\n    this.operators = e;\n  }\n  execute(e) {\n    const t = new PostScriptStack(e);\n    let i = 0;\n    const a = this.operators,\n      s = a.length;\n    let r, n, g;\n    for (; i < s;) {\n      r = a[i++];\n      if (\"number\" != typeof r) switch (r) {\n        case \"jz\":\n          g = t.pop();\n          n = t.pop();\n          n || (i = g);\n          break;\n        case \"j\":\n          n = t.pop();\n          i = n;\n          break;\n        case \"abs\":\n          n = t.pop();\n          t.push(Math.abs(n));\n          break;\n        case \"add\":\n          g = t.pop();\n          n = t.pop();\n          t.push(n + g);\n          break;\n        case \"and\":\n          g = t.pop();\n          n = t.pop();\n          \"boolean\" == typeof n && \"boolean\" == typeof g ? t.push(n && g) : t.push(n & g);\n          break;\n        case \"atan\":\n          g = t.pop();\n          n = t.pop();\n          n = Math.atan2(n, g) / Math.PI * 180;\n          n < 0 && (n += 360);\n          t.push(n);\n          break;\n        case \"bitshift\":\n          g = t.pop();\n          n = t.pop();\n          n > 0 ? t.push(n << g) : t.push(n >> g);\n          break;\n        case \"ceiling\":\n          n = t.pop();\n          t.push(Math.ceil(n));\n          break;\n        case \"copy\":\n          n = t.pop();\n          t.copy(n);\n          break;\n        case \"cos\":\n          n = t.pop();\n          t.push(Math.cos(n % 360 / 180 * Math.PI));\n          break;\n        case \"cvi\":\n          n = 0 | t.pop();\n          t.push(n);\n          break;\n        case \"cvr\":\n          break;\n        case \"div\":\n          g = t.pop();\n          n = t.pop();\n          t.push(n / g);\n          break;\n        case \"dup\":\n          t.copy(1);\n          break;\n        case \"eq\":\n          g = t.pop();\n          n = t.pop();\n          t.push(n === g);\n          break;\n        case \"exch\":\n          t.roll(2, 1);\n          break;\n        case \"exp\":\n          g = t.pop();\n          n = t.pop();\n          t.push(n ** g);\n          break;\n        case \"false\":\n          t.push(!1);\n          break;\n        case \"floor\":\n          n = t.pop();\n          t.push(Math.floor(n));\n          break;\n        case \"ge\":\n          g = t.pop();\n          n = t.pop();\n          t.push(n >= g);\n          break;\n        case \"gt\":\n          g = t.pop();\n          n = t.pop();\n          t.push(n > g);\n          break;\n        case \"idiv\":\n          g = t.pop();\n          n = t.pop();\n          t.push(n / g | 0);\n          break;\n        case \"index\":\n          n = t.pop();\n          t.index(n);\n          break;\n        case \"le\":\n          g = t.pop();\n          n = t.pop();\n          t.push(n <= g);\n          break;\n        case \"ln\":\n          n = t.pop();\n          t.push(Math.log(n));\n          break;\n        case \"log\":\n          n = t.pop();\n          t.push(Math.log10(n));\n          break;\n        case \"lt\":\n          g = t.pop();\n          n = t.pop();\n          t.push(n < g);\n          break;\n        case \"mod\":\n          g = t.pop();\n          n = t.pop();\n          t.push(n % g);\n          break;\n        case \"mul\":\n          g = t.pop();\n          n = t.pop();\n          t.push(n * g);\n          break;\n        case \"ne\":\n          g = t.pop();\n          n = t.pop();\n          t.push(n !== g);\n          break;\n        case \"neg\":\n          n = t.pop();\n          t.push(-n);\n          break;\n        case \"not\":\n          n = t.pop();\n          \"boolean\" == typeof n ? t.push(!n) : t.push(~n);\n          break;\n        case \"or\":\n          g = t.pop();\n          n = t.pop();\n          \"boolean\" == typeof n && \"boolean\" == typeof g ? t.push(n || g) : t.push(n | g);\n          break;\n        case \"pop\":\n          t.pop();\n          break;\n        case \"roll\":\n          g = t.pop();\n          n = t.pop();\n          t.roll(n, g);\n          break;\n        case \"round\":\n          n = t.pop();\n          t.push(Math.round(n));\n          break;\n        case \"sin\":\n          n = t.pop();\n          t.push(Math.sin(n % 360 / 180 * Math.PI));\n          break;\n        case \"sqrt\":\n          n = t.pop();\n          t.push(Math.sqrt(n));\n          break;\n        case \"sub\":\n          g = t.pop();\n          n = t.pop();\n          t.push(n - g);\n          break;\n        case \"true\":\n          t.push(!0);\n          break;\n        case \"truncate\":\n          n = t.pop();\n          n = n < 0 ? Math.ceil(n) : Math.floor(n);\n          t.push(n);\n          break;\n        case \"xor\":\n          g = t.pop();\n          n = t.pop();\n          \"boolean\" == typeof n && \"boolean\" == typeof g ? t.push(n !== g) : t.push(n ^ g);\n          break;\n        default:\n          throw new FormatError(`Unknown operator ${r}`);\n      } else t.push(r);\n    }\n    return t.stack;\n  }\n}\nclass AstNode {\n  constructor(e) {\n    this.type = e;\n  }\n  visit(e) {\n    unreachable(\"abstract method\");\n  }\n}\nclass AstArgument extends AstNode {\n  constructor(e, t, i) {\n    super(\"args\");\n    this.index = e;\n    this.min = t;\n    this.max = i;\n  }\n  visit(e) {\n    e.visitArgument(this);\n  }\n}\nclass AstLiteral extends AstNode {\n  constructor(e) {\n    super(\"literal\");\n    this.number = e;\n    this.min = e;\n    this.max = e;\n  }\n  visit(e) {\n    e.visitLiteral(this);\n  }\n}\nclass AstBinaryOperation extends AstNode {\n  constructor(e, t, i, a, s) {\n    super(\"binary\");\n    this.op = e;\n    this.arg1 = t;\n    this.arg2 = i;\n    this.min = a;\n    this.max = s;\n  }\n  visit(e) {\n    e.visitBinaryOperation(this);\n  }\n}\nclass AstMin extends AstNode {\n  constructor(e, t) {\n    super(\"max\");\n    this.arg = e;\n    this.min = e.min;\n    this.max = t;\n  }\n  visit(e) {\n    e.visitMin(this);\n  }\n}\nclass AstVariable extends AstNode {\n  constructor(e, t, i) {\n    super(\"var\");\n    this.index = e;\n    this.min = t;\n    this.max = i;\n  }\n  visit(e) {\n    e.visitVariable(this);\n  }\n}\nclass AstVariableDefinition extends AstNode {\n  constructor(e, t) {\n    super(\"definition\");\n    this.variable = e;\n    this.arg = t;\n  }\n  visit(e) {\n    e.visitVariableDefinition(this);\n  }\n}\nclass ExpressionBuilderVisitor {\n  constructor() {\n    this.parts = [];\n  }\n  visitArgument(e) {\n    this.parts.push(\"Math.max(\", e.min, \", Math.min(\", e.max, \", src[srcOffset + \", e.index, \"]))\");\n  }\n  visitVariable(e) {\n    this.parts.push(\"v\", e.index);\n  }\n  visitLiteral(e) {\n    this.parts.push(e.number);\n  }\n  visitBinaryOperation(e) {\n    this.parts.push(\"(\");\n    e.arg1.visit(this);\n    this.parts.push(\" \", e.op, \" \");\n    e.arg2.visit(this);\n    this.parts.push(\")\");\n  }\n  visitVariableDefinition(e) {\n    this.parts.push(\"var \");\n    e.variable.visit(this);\n    this.parts.push(\" = \");\n    e.arg.visit(this);\n    this.parts.push(\";\");\n  }\n  visitMin(e) {\n    this.parts.push(\"Math.min(\");\n    e.arg.visit(this);\n    this.parts.push(\", \", e.max, \")\");\n  }\n  toString() {\n    return this.parts.join(\"\");\n  }\n}\nfunction buildAddOperation(e, t) {\n  return \"literal\" === t.type && 0 === t.number ? e : \"literal\" === e.type && 0 === e.number ? t : \"literal\" === t.type && \"literal\" === e.type ? new AstLiteral(e.number + t.number) : new AstBinaryOperation(\"+\", e, t, e.min + t.min, e.max + t.max);\n}\nfunction buildMulOperation(e, t) {\n  if (\"literal\" === t.type) {\n    if (0 === t.number) return new AstLiteral(0);\n    if (1 === t.number) return e;\n    if (\"literal\" === e.type) return new AstLiteral(e.number * t.number);\n  }\n  if (\"literal\" === e.type) {\n    if (0 === e.number) return new AstLiteral(0);\n    if (1 === e.number) return t;\n  }\n  const i = Math.min(e.min * t.min, e.min * t.max, e.max * t.min, e.max * t.max),\n    a = Math.max(e.min * t.min, e.min * t.max, e.max * t.min, e.max * t.max);\n  return new AstBinaryOperation(\"*\", e, t, i, a);\n}\nfunction buildSubOperation(e, t) {\n  if (\"literal\" === t.type) {\n    if (0 === t.number) return e;\n    if (\"literal\" === e.type) return new AstLiteral(e.number - t.number);\n  }\n  return \"binary\" === t.type && \"-\" === t.op && \"literal\" === e.type && 1 === e.number && \"literal\" === t.arg1.type && 1 === t.arg1.number ? t.arg2 : new AstBinaryOperation(\"-\", e, t, e.min - t.max, e.max - t.min);\n}\nfunction buildMinOperation(e, t) {\n  return e.min >= t ? new AstLiteral(t) : e.max <= t ? e : new AstMin(e, t);\n}\nclass PostScriptCompiler {\n  compile(e, t, i) {\n    const a = [],\n      s = [],\n      r = t.length >> 1,\n      n = i.length >> 1;\n    let g,\n      o,\n      c,\n      C,\n      h,\n      l,\n      Q,\n      E,\n      u = 0;\n    for (let e = 0; e < r; e++) a.push(new AstArgument(e, t[2 * e], t[2 * e + 1]));\n    for (let t = 0, i = e.length; t < i; t++) {\n      E = e[t];\n      if (\"number\" != typeof E) switch (E) {\n        case \"add\":\n          if (a.length < 2) return null;\n          C = a.pop();\n          c = a.pop();\n          a.push(buildAddOperation(c, C));\n          break;\n        case \"cvr\":\n          if (a.length < 1) return null;\n          break;\n        case \"mul\":\n          if (a.length < 2) return null;\n          C = a.pop();\n          c = a.pop();\n          a.push(buildMulOperation(c, C));\n          break;\n        case \"sub\":\n          if (a.length < 2) return null;\n          C = a.pop();\n          c = a.pop();\n          a.push(buildSubOperation(c, C));\n          break;\n        case \"exch\":\n          if (a.length < 2) return null;\n          h = a.pop();\n          l = a.pop();\n          a.push(h, l);\n          break;\n        case \"pop\":\n          if (a.length < 1) return null;\n          a.pop();\n          break;\n        case \"index\":\n          if (a.length < 1) return null;\n          c = a.pop();\n          if (\"literal\" !== c.type) return null;\n          g = c.number;\n          if (g < 0 || !Number.isInteger(g) || a.length < g) return null;\n          h = a[a.length - g - 1];\n          if (\"literal\" === h.type || \"var\" === h.type) {\n            a.push(h);\n            break;\n          }\n          Q = new AstVariable(u++, h.min, h.max);\n          a[a.length - g - 1] = Q;\n          a.push(Q);\n          s.push(new AstVariableDefinition(Q, h));\n          break;\n        case \"dup\":\n          if (a.length < 1) return null;\n          if (\"number\" == typeof e[t + 1] && \"gt\" === e[t + 2] && e[t + 3] === t + 7 && \"jz\" === e[t + 4] && \"pop\" === e[t + 5] && e[t + 6] === e[t + 1]) {\n            c = a.pop();\n            a.push(buildMinOperation(c, e[t + 1]));\n            t += 6;\n            break;\n          }\n          h = a.at(-1);\n          if (\"literal\" === h.type || \"var\" === h.type) {\n            a.push(h);\n            break;\n          }\n          Q = new AstVariable(u++, h.min, h.max);\n          a[a.length - 1] = Q;\n          a.push(Q);\n          s.push(new AstVariableDefinition(Q, h));\n          break;\n        case \"roll\":\n          if (a.length < 2) return null;\n          C = a.pop();\n          c = a.pop();\n          if (\"literal\" !== C.type || \"literal\" !== c.type) return null;\n          o = C.number;\n          g = c.number;\n          if (g <= 0 || !Number.isInteger(g) || !Number.isInteger(o) || a.length < g) return null;\n          o = (o % g + g) % g;\n          if (0 === o) break;\n          a.push(...a.splice(a.length - g, g - o));\n          break;\n        default:\n          return null;\n      } else a.push(new AstLiteral(E));\n    }\n    if (a.length !== n) return null;\n    const d = [];\n    for (const e of s) {\n      const t = new ExpressionBuilderVisitor();\n      e.visit(t);\n      d.push(t.toString());\n    }\n    for (let e = 0, t = a.length; e < t; e++) {\n      const t = a[e],\n        s = new ExpressionBuilderVisitor();\n      t.visit(s);\n      const r = i[2 * e],\n        n = i[2 * e + 1],\n        g = [s.toString()];\n      if (r > t.min) {\n        g.unshift(\"Math.max(\", r, \", \");\n        g.push(\")\");\n      }\n      if (n < t.max) {\n        g.unshift(\"Math.min(\", n, \", \");\n        g.push(\")\");\n      }\n      g.unshift(\"dest[destOffset + \", e, \"] = \");\n      g.push(\";\");\n      d.push(g.join(\"\"));\n    }\n    return d.join(\"\\n\");\n  }\n}\nconst Cs = [\"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"S\", \"B\", \"S\", \"WS\", \"B\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"B\", \"B\", \"B\", \"S\", \"WS\", \"ON\", \"ON\", \"ET\", \"ET\", \"ET\", \"ON\", \"ON\", \"ON\", \"ON\", \"ON\", \"ES\", \"CS\", \"ES\", \"CS\", \"CS\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"CS\", \"ON\", \"ON\", \"ON\", \"ON\", \"ON\", \"ON\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"ON\", \"ON\", \"ON\", \"ON\", \"ON\", \"ON\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"ON\", \"ON\", \"ON\", \"ON\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"B\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"CS\", \"ON\", \"ET\", \"ET\", \"ET\", \"ET\", \"ON\", \"ON\", \"ON\", \"ON\", \"L\", \"ON\", \"ON\", \"BN\", \"ON\", \"ON\", \"ET\", \"ET\", \"EN\", \"EN\", \"ON\", \"L\", \"ON\", \"ON\", \"ON\", \"EN\", \"L\", \"ON\", \"ON\", \"ON\", \"ON\", \"ON\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"ON\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"ON\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\"],\n  hs = [\"AN\", \"AN\", \"AN\", \"AN\", \"AN\", \"AN\", \"ON\", \"ON\", \"AL\", \"ET\", \"ET\", \"AL\", \"CS\", \"AL\", \"ON\", \"ON\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"AL\", \"AL\", \"\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"AN\", \"AN\", \"AN\", \"AN\", \"AN\", \"AN\", \"AN\", \"AN\", \"AN\", \"AN\", \"ET\", \"AN\", \"AN\", \"AL\", \"AL\", \"AL\", \"NSM\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"AN\", \"ON\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"AL\", \"AL\", \"NSM\", \"NSM\", \"ON\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"AL\", \"AL\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\"];\nfunction isOdd(e) {\n  return 0 != (1 & e);\n}\nfunction isEven(e) {\n  return 0 == (1 & e);\n}\nfunction findUnequal(e, t, i) {\n  let a, s;\n  for (a = t, s = e.length; a < s; ++a) if (e[a] !== i) return a;\n  return a;\n}\nfunction setValues(e, t, i, a) {\n  for (let s = t; s < i; ++s) e[s] = a;\n}\nfunction reverseValues(e, t, i) {\n  for (let a = t, s = i - 1; a < s; ++a, --s) {\n    const t = e[a];\n    e[a] = e[s];\n    e[s] = t;\n  }\n}\nfunction createBidiText(e, t, i = !1) {\n  let a = \"ltr\";\n  i ? a = \"ttb\" : t || (a = \"rtl\");\n  return {\n    str: e,\n    dir: a\n  };\n}\nconst Bs = [],\n  ls = [];\nfunction bidi(e, t = -1, i = !1) {\n  let a = !0;\n  const s = e.length;\n  if (0 === s || i) return createBidiText(e, a, i);\n  Bs.length = s;\n  ls.length = s;\n  let r,\n    n,\n    g = 0;\n  for (r = 0; r < s; ++r) {\n    Bs[r] = e.charAt(r);\n    const t = e.charCodeAt(r);\n    let i = \"L\";\n    if (t <= 255) i = Cs[t];else if (1424 <= t && t <= 1524) i = \"R\";else if (1536 <= t && t <= 1791) {\n      i = hs[255 & t];\n      i || warn(\"Bidi: invalid Unicode character \" + t.toString(16));\n    } else (1792 <= t && t <= 2220 || 64336 <= t && t <= 65023 || 65136 <= t && t <= 65279) && (i = \"AL\");\n    \"R\" !== i && \"AL\" !== i && \"AN\" !== i || g++;\n    ls[r] = i;\n  }\n  if (0 === g) {\n    a = !0;\n    return createBidiText(e, a);\n  }\n  if (-1 === t) if (g / s < .3 && s > 4) {\n    a = !0;\n    t = 0;\n  } else {\n    a = !1;\n    t = 1;\n  }\n  const o = [];\n  for (r = 0; r < s; ++r) o[r] = t;\n  const c = isOdd(t) ? \"R\" : \"L\",\n    C = c,\n    h = C;\n  let l,\n    Q = C;\n  for (r = 0; r < s; ++r) \"NSM\" === ls[r] ? ls[r] = Q : Q = ls[r];\n  Q = C;\n  for (r = 0; r < s; ++r) {\n    l = ls[r];\n    \"EN\" === l ? ls[r] = \"AL\" === Q ? \"AN\" : \"EN\" : \"R\" !== l && \"L\" !== l && \"AL\" !== l || (Q = l);\n  }\n  for (r = 0; r < s; ++r) {\n    l = ls[r];\n    \"AL\" === l && (ls[r] = \"R\");\n  }\n  for (r = 1; r < s - 1; ++r) {\n    \"ES\" === ls[r] && \"EN\" === ls[r - 1] && \"EN\" === ls[r + 1] && (ls[r] = \"EN\");\n    \"CS\" !== ls[r] || \"EN\" !== ls[r - 1] && \"AN\" !== ls[r - 1] || ls[r + 1] !== ls[r - 1] || (ls[r] = ls[r - 1]);\n  }\n  for (r = 0; r < s; ++r) if (\"EN\" === ls[r]) {\n    for (let e = r - 1; e >= 0 && \"ET\" === ls[e]; --e) ls[e] = \"EN\";\n    for (let e = r + 1; e < s && \"ET\" === ls[e]; ++e) ls[e] = \"EN\";\n  }\n  for (r = 0; r < s; ++r) {\n    l = ls[r];\n    \"WS\" !== l && \"ES\" !== l && \"ET\" !== l && \"CS\" !== l || (ls[r] = \"ON\");\n  }\n  Q = C;\n  for (r = 0; r < s; ++r) {\n    l = ls[r];\n    \"EN\" === l ? ls[r] = \"L\" === Q ? \"L\" : \"EN\" : \"R\" !== l && \"L\" !== l || (Q = l);\n  }\n  for (r = 0; r < s; ++r) if (\"ON\" === ls[r]) {\n    const e = findUnequal(ls, r + 1, \"ON\");\n    let t = C;\n    r > 0 && (t = ls[r - 1]);\n    let i = h;\n    e + 1 < s && (i = ls[e + 1]);\n    \"L\" !== t && (t = \"R\");\n    \"L\" !== i && (i = \"R\");\n    t === i && setValues(ls, r, e, t);\n    r = e - 1;\n  }\n  for (r = 0; r < s; ++r) \"ON\" === ls[r] && (ls[r] = c);\n  for (r = 0; r < s; ++r) {\n    l = ls[r];\n    isEven(o[r]) ? \"R\" === l ? o[r] += 1 : \"AN\" !== l && \"EN\" !== l || (o[r] += 2) : \"L\" !== l && \"AN\" !== l && \"EN\" !== l || (o[r] += 1);\n  }\n  let E,\n    u = -1,\n    d = 99;\n  for (r = 0, n = o.length; r < n; ++r) {\n    E = o[r];\n    u < E && (u = E);\n    d > E && isOdd(E) && (d = E);\n  }\n  for (E = u; E >= d; --E) {\n    let e = -1;\n    for (r = 0, n = o.length; r < n; ++r) if (o[r] < E) {\n      if (e >= 0) {\n        reverseValues(Bs, e, r);\n        e = -1;\n      }\n    } else e < 0 && (e = r);\n    e >= 0 && reverseValues(Bs, e, o.length);\n  }\n  for (r = 0, n = Bs.length; r < n; ++r) {\n    const e = Bs[r];\n    \"<\" !== e && \">\" !== e || (Bs[r] = \"\");\n  }\n  return createBidiText(Bs.join(\"\"), a);\n}\nconst Qs = {\n    style: \"normal\",\n    weight: \"normal\"\n  },\n  Es = {\n    style: \"normal\",\n    weight: \"bold\"\n  },\n  us = {\n    style: \"italic\",\n    weight: \"normal\"\n  },\n  ds = {\n    style: \"italic\",\n    weight: \"bold\"\n  },\n  fs = new Map([[\"Times-Roman\", {\n    local: [\"Times New Roman\", \"Times-Roman\", \"Times\", \"Liberation Serif\", \"Nimbus Roman\", \"Nimbus Roman L\", \"Tinos\", \"Thorndale\", \"TeX Gyre Termes\", \"FreeSerif\", \"Linux Libertine O\", \"Libertinus Serif\", \"DejaVu Serif\", \"Bitstream Vera Serif\", \"Ubuntu\"],\n    style: Qs,\n    ultimate: \"serif\"\n  }], [\"Times-Bold\", {\n    alias: \"Times-Roman\",\n    style: Es,\n    ultimate: \"serif\"\n  }], [\"Times-Italic\", {\n    alias: \"Times-Roman\",\n    style: us,\n    ultimate: \"serif\"\n  }], [\"Times-BoldItalic\", {\n    alias: \"Times-Roman\",\n    style: ds,\n    ultimate: \"serif\"\n  }], [\"Helvetica\", {\n    local: [\"Helvetica\", \"Helvetica Neue\", \"Arial\", \"Arial Nova\", \"Liberation Sans\", \"Arimo\", \"Nimbus Sans\", \"Nimbus Sans L\", \"A030\", \"TeX Gyre Heros\", \"FreeSans\", \"DejaVu Sans\", \"Albany\", \"Bitstream Vera Sans\", \"Arial Unicode MS\", \"Microsoft Sans Serif\", \"Apple Symbols\", \"Cantarell\"],\n    path: \"LiberationSans-Regular.ttf\",\n    style: Qs,\n    ultimate: \"sans-serif\"\n  }], [\"Helvetica-Bold\", {\n    alias: \"Helvetica\",\n    path: \"LiberationSans-Bold.ttf\",\n    style: Es,\n    ultimate: \"sans-serif\"\n  }], [\"Helvetica-Oblique\", {\n    alias: \"Helvetica\",\n    path: \"LiberationSans-Italic.ttf\",\n    style: us,\n    ultimate: \"sans-serif\"\n  }], [\"Helvetica-BoldOblique\", {\n    alias: \"Helvetica\",\n    path: \"LiberationSans-BoldItalic.ttf\",\n    style: ds,\n    ultimate: \"sans-serif\"\n  }], [\"Courier\", {\n    local: [\"Courier\", \"Courier New\", \"Liberation Mono\", \"Nimbus Mono\", \"Nimbus Mono L\", \"Cousine\", \"Cumberland\", \"TeX Gyre Cursor\", \"FreeMono\", \"Linux Libertine Mono O\", \"Libertinus Mono\"],\n    style: Qs,\n    ultimate: \"monospace\"\n  }], [\"Courier-Bold\", {\n    alias: \"Courier\",\n    style: Es,\n    ultimate: \"monospace\"\n  }], [\"Courier-Oblique\", {\n    alias: \"Courier\",\n    style: us,\n    ultimate: \"monospace\"\n  }], [\"Courier-BoldOblique\", {\n    alias: \"Courier\",\n    style: ds,\n    ultimate: \"monospace\"\n  }], [\"ArialBlack\", {\n    local: [\"Arial Black\"],\n    style: {\n      style: \"normal\",\n      weight: \"900\"\n    },\n    fallback: \"Helvetica-Bold\"\n  }], [\"ArialBlack-Bold\", {\n    alias: \"ArialBlack\"\n  }], [\"ArialBlack-Italic\", {\n    alias: \"ArialBlack\",\n    style: {\n      style: \"italic\",\n      weight: \"900\"\n    },\n    fallback: \"Helvetica-BoldOblique\"\n  }], [\"ArialBlack-BoldItalic\", {\n    alias: \"ArialBlack-Italic\"\n  }], [\"ArialNarrow\", {\n    local: [\"Arial Narrow\", \"Liberation Sans Narrow\", \"Helvetica Condensed\", \"Nimbus Sans Narrow\", \"TeX Gyre Heros Cn\"],\n    style: Qs,\n    fallback: \"Helvetica\"\n  }], [\"ArialNarrow-Bold\", {\n    alias: \"ArialNarrow\",\n    style: Es,\n    fallback: \"Helvetica-Bold\"\n  }], [\"ArialNarrow-Italic\", {\n    alias: \"ArialNarrow\",\n    style: us,\n    fallback: \"Helvetica-Oblique\"\n  }], [\"ArialNarrow-BoldItalic\", {\n    alias: \"ArialNarrow\",\n    style: ds,\n    fallback: \"Helvetica-BoldOblique\"\n  }], [\"Calibri\", {\n    local: [\"Calibri\", \"Carlito\"],\n    style: Qs,\n    fallback: \"Helvetica\"\n  }], [\"Calibri-Bold\", {\n    alias: \"Calibri\",\n    style: Es,\n    fallback: \"Helvetica-Bold\"\n  }], [\"Calibri-Italic\", {\n    alias: \"Calibri\",\n    style: us,\n    fallback: \"Helvetica-Oblique\"\n  }], [\"Calibri-BoldItalic\", {\n    alias: \"Calibri\",\n    style: ds,\n    fallback: \"Helvetica-BoldOblique\"\n  }], [\"Wingdings\", {\n    local: [\"Wingdings\", \"URW Dingbats\"],\n    style: Qs\n  }], [\"Wingdings-Regular\", {\n    alias: \"Wingdings\"\n  }], [\"Wingdings-Bold\", {\n    alias: \"Wingdings\"\n  }]]),\n  ps = new Map([[\"Arial-Black\", \"ArialBlack\"]]);\nfunction getFamilyName(e) {\n  const t = new Set([\"thin\", \"extralight\", \"ultralight\", \"demilight\", \"semilight\", \"light\", \"book\", \"regular\", \"normal\", \"medium\", \"demibold\", \"semibold\", \"bold\", \"extrabold\", \"ultrabold\", \"black\", \"heavy\", \"extrablack\", \"ultrablack\", \"roman\", \"italic\", \"oblique\", \"ultracondensed\", \"extracondensed\", \"condensed\", \"semicondensed\", \"normal\", \"semiexpanded\", \"expanded\", \"extraexpanded\", \"ultraexpanded\", \"bolditalic\"]);\n  return e.split(/[- ,+]+/g).filter(e => !t.has(e.toLowerCase())).join(\" \");\n}\nfunction generateFont({\n  alias: e,\n  local: t,\n  path: i,\n  fallback: a,\n  style: s,\n  ultimate: r\n}, n, g, o = !0, c = !0, C = \"\") {\n  const h = {\n    style: null,\n    ultimate: null\n  };\n  if (t) {\n    const e = C ? ` ${C}` : \"\";\n    for (const i of t) n.push(`local(${i}${e})`);\n  }\n  if (e) {\n    const t = fs.get(e),\n      r = C || function getStyleToAppend(e) {\n        switch (e) {\n          case Es:\n            return \"Bold\";\n          case us:\n            return \"Italic\";\n          case ds:\n            return \"Bold Italic\";\n          default:\n            if (\"bold\" === e?.weight) return \"Bold\";\n            if (\"italic\" === e?.style) return \"Italic\";\n        }\n        return \"\";\n      }(s);\n    Object.assign(h, generateFont(t, n, g, o && !a, c && !i, r));\n  }\n  s && (h.style = s);\n  r && (h.ultimate = r);\n  if (o && a) {\n    const e = fs.get(a),\n      {\n        ultimate: t\n      } = generateFont(e, n, g, o, c && !i, C);\n    h.ultimate ||= t;\n  }\n  c && i && g && n.push(`url(${g}${i})`);\n  return h;\n}\nfunction getFontSubstitution(e, t, i, a, s, r) {\n  if (a.startsWith(\"InvalidPDFjsFont_\")) return null;\n  \"TrueType\" !== r && \"Type1\" !== r || !/^[A-Z]{6}\\+/.test(a) || (a = a.slice(7));\n  const n = a = normalizeFontName(a);\n  let g = e.get(n);\n  if (g) return g;\n  let o = fs.get(a);\n  if (!o) for (const [e, t] of ps) if (a.startsWith(e)) {\n    a = `${t}${a.substring(e.length)}`;\n    o = fs.get(a);\n    break;\n  }\n  let c = !1;\n  if (!o) {\n    o = fs.get(s);\n    c = !0;\n  }\n  const C = `${t.getDocId()}_s${t.createFontId()}`;\n  if (!o) {\n    if (!validateFontName(a)) {\n      warn(`Cannot substitute the font because of its name: ${a}`);\n      e.set(n, null);\n      return null;\n    }\n    const t = /bold/gi.test(a),\n      i = /oblique|italic/gi.test(a),\n      s = t && i && ds || t && Es || i && us || Qs;\n    g = {\n      css: `\"${getFamilyName(a)}\",${C}`,\n      guessFallback: !0,\n      loadedName: C,\n      baseFontName: a,\n      src: `local(${a})`,\n      style: s\n    };\n    e.set(n, g);\n    return g;\n  }\n  const h = [];\n  c && validateFontName(a) && h.push(`local(${a})`);\n  const {\n      style: l,\n      ultimate: Q\n    } = generateFont(o, h, i),\n    E = null === Q,\n    u = E ? \"\" : `,${Q}`;\n  g = {\n    css: `\"${getFamilyName(a)}\",${C}${u}`,\n    guessFallback: E,\n    loadedName: C,\n    baseFontName: a,\n    src: h.join(\",\"),\n    style: l\n  };\n  e.set(n, g);\n  return g;\n}\nclass ImageResizer {\n  constructor(e, t) {\n    this._imgData = e;\n    this._isMask = t;\n  }\n  static needsToBeResized(e, t) {\n    if (e <= this._goodSquareLength && t <= this._goodSquareLength) return !1;\n    const {\n      MAX_DIM: i\n    } = this;\n    if (e > i || t > i) return !0;\n    const a = e * t;\n    if (this._hasMaxArea) return a > this.MAX_AREA;\n    if (a < this._goodSquareLength ** 2) return !1;\n    if (this._areGoodDims(e, t)) {\n      this._goodSquareLength = Math.max(this._goodSquareLength, Math.floor(Math.sqrt(e * t)));\n      return !1;\n    }\n    this._goodSquareLength = this._guessMax(this._goodSquareLength, i, 128, 0);\n    return a > (this.MAX_AREA = this._goodSquareLength ** 2);\n  }\n  static get MAX_DIM() {\n    return shadow(this, \"MAX_DIM\", this._guessMax(2048, 65537, 0, 1));\n  }\n  static get MAX_AREA() {\n    this._hasMaxArea = !0;\n    return shadow(this, \"MAX_AREA\", this._guessMax(ImageResizer._goodSquareLength, this.MAX_DIM, 128, 0) ** 2);\n  }\n  static set MAX_AREA(e) {\n    if (e >= 0) {\n      this._hasMaxArea = !0;\n      shadow(this, \"MAX_AREA\", e);\n    }\n  }\n  static setMaxArea(e) {\n    this._hasMaxArea || (this.MAX_AREA = e >> 2);\n  }\n  static _areGoodDims(e, t) {\n    try {\n      const i = new OffscreenCanvas(e, t),\n        a = i.getContext(\"2d\");\n      a.fillRect(0, 0, 1, 1);\n      const s = a.getImageData(0, 0, 1, 1).data[3];\n      i.width = i.height = 1;\n      return 0 !== s;\n    } catch {\n      return !1;\n    }\n  }\n  static _guessMax(e, t, i, a) {\n    for (; e + i + 1 < t;) {\n      const i = Math.floor((e + t) / 2),\n        s = a || i;\n      this._areGoodDims(i, s) ? e = i : t = i;\n    }\n    return e;\n  }\n  static async createImage(e, t = !1) {\n    return new ImageResizer(e, t)._createImage();\n  }\n  async _createImage() {\n    const e = this._encodeBMP(),\n      t = new Blob([e.buffer], {\n        type: \"image/bmp\"\n      }),\n      i = createImageBitmap(t),\n      {\n        MAX_AREA: a,\n        MAX_DIM: s\n      } = ImageResizer,\n      {\n        _imgData: r\n      } = this,\n      {\n        width: n,\n        height: g\n      } = r,\n      o = Math.max(n / s, g / s, Math.sqrt(n * g / a)),\n      c = Math.max(o, 2),\n      C = Math.round(10 * (o + 1.25)) / 10 / c,\n      h = Math.floor(Math.log2(C)),\n      l = new Array(h + 2).fill(2);\n    l[0] = c;\n    l.splice(-1, 1, C / (1 << h));\n    let Q = n,\n      E = g,\n      u = await i;\n    for (const e of l) {\n      const t = Q,\n        i = E;\n      Q = Math.floor(Q / e) - 1;\n      E = Math.floor(E / e) - 1;\n      const a = new OffscreenCanvas(Q, E);\n      a.getContext(\"2d\").drawImage(u, 0, 0, t, i, 0, 0, Q, E);\n      u = a.transferToImageBitmap();\n    }\n    r.data = null;\n    r.bitmap = u;\n    r.width = Q;\n    r.height = E;\n    return r;\n  }\n  _encodeBMP() {\n    const {\n      width: e,\n      height: t,\n      kind: i\n    } = this._imgData;\n    let a,\n      s = this._imgData.data,\n      r = new Uint8Array(0),\n      n = r,\n      g = 0;\n    switch (i) {\n      case D:\n        {\n          a = 1;\n          r = new Uint8Array(this._isMask ? [255, 255, 255, 255, 0, 0, 0, 0] : [0, 0, 0, 0, 255, 255, 255, 255]);\n          const i = e + 7 >> 3,\n            n = i + 3 & -4;\n          if (i !== n) {\n            const e = new Uint8Array(n * t);\n            let a = 0;\n            for (let r = 0, g = t * i; r < g; r += i, a += n) e.set(s.subarray(r, r + i), a);\n            s = e;\n          }\n          break;\n        }\n      case b:\n        a = 24;\n        if (3 & e) {\n          const i = 3 * e,\n            a = i + 3 & -4,\n            r = a - i,\n            n = new Uint8Array(a * t);\n          let g = 0;\n          for (let e = 0, a = t * i; e < a; e += i) {\n            const t = s.subarray(e, e + i);\n            for (let e = 0; e < i; e += 3) {\n              n[g++] = t[e + 2];\n              n[g++] = t[e + 1];\n              n[g++] = t[e];\n            }\n            g += r;\n          }\n          s = n;\n        } else for (let e = 0, t = s.length; e < t; e += 3) {\n          const t = s[e];\n          s[e] = s[e + 2];\n          s[e + 2] = t;\n        }\n        break;\n      case F:\n        a = 32;\n        g = 3;\n        n = new Uint8Array(68);\n        const i = new DataView(n.buffer);\n        if (FeatureTest.isLittleEndian) {\n          i.setUint32(0, 255, !0);\n          i.setUint32(4, 65280, !0);\n          i.setUint32(8, 16711680, !0);\n          i.setUint32(12, 4278190080, !0);\n        } else {\n          i.setUint32(0, 4278190080, !0);\n          i.setUint32(4, 16711680, !0);\n          i.setUint32(8, 65280, !0);\n          i.setUint32(12, 255, !0);\n        }\n        break;\n      default:\n        throw new Error(\"invalid format\");\n    }\n    let o = 0;\n    const c = 40 + n.length,\n      C = 14 + c + r.length + s.length,\n      h = new Uint8Array(C),\n      l = new DataView(h.buffer);\n    l.setUint16(o, 19778, !0);\n    o += 2;\n    l.setUint32(o, C, !0);\n    o += 4;\n    l.setUint32(o, 0, !0);\n    o += 4;\n    l.setUint32(o, 14 + c + r.length, !0);\n    o += 4;\n    l.setUint32(o, c, !0);\n    o += 4;\n    l.setInt32(o, e, !0);\n    o += 4;\n    l.setInt32(o, -t, !0);\n    o += 4;\n    l.setUint16(o, 1, !0);\n    o += 2;\n    l.setUint16(o, a, !0);\n    o += 2;\n    l.setUint32(o, g, !0);\n    o += 4;\n    l.setUint32(o, 0, !0);\n    o += 4;\n    l.setInt32(o, 0, !0);\n    o += 4;\n    l.setInt32(o, 0, !0);\n    o += 4;\n    l.setUint32(o, r.length / 4, !0);\n    o += 4;\n    l.setUint32(o, 0, !0);\n    o += 4;\n    h.set(n, o);\n    o += n.length;\n    h.set(r, o);\n    o += r.length;\n    h.set(s, o);\n    return h;\n  }\n}\nImageResizer._goodSquareLength = 2048;\nconst ms = 3285377520,\n  ys = 4294901760,\n  ws = 65535;\nclass MurmurHash3_64 {\n  constructor(e) {\n    this.h1 = e ? 4294967295 & e : ms;\n    this.h2 = e ? 4294967295 & e : ms;\n  }\n  update(e) {\n    let t, i;\n    if (\"string\" == typeof e) {\n      t = new Uint8Array(2 * e.length);\n      i = 0;\n      for (let a = 0, s = e.length; a < s; a++) {\n        const s = e.charCodeAt(a);\n        if (s <= 255) t[i++] = s;else {\n          t[i++] = s >>> 8;\n          t[i++] = 255 & s;\n        }\n      }\n    } else {\n      if (!ArrayBuffer.isView(e)) throw new Error(\"Invalid data format, must be a string or TypedArray.\");\n      t = e.slice();\n      i = t.byteLength;\n    }\n    const a = i >> 2,\n      s = i - 4 * a,\n      r = new Uint32Array(t.buffer, 0, a);\n    let n = 0,\n      g = 0,\n      o = this.h1,\n      c = this.h2;\n    const C = 3432918353,\n      h = 461845907,\n      l = 11601,\n      Q = 13715;\n    for (let e = 0; e < a; e++) if (1 & e) {\n      n = r[e];\n      n = n * C & ys | n * l & ws;\n      n = n << 15 | n >>> 17;\n      n = n * h & ys | n * Q & ws;\n      o ^= n;\n      o = o << 13 | o >>> 19;\n      o = 5 * o + 3864292196;\n    } else {\n      g = r[e];\n      g = g * C & ys | g * l & ws;\n      g = g << 15 | g >>> 17;\n      g = g * h & ys | g * Q & ws;\n      c ^= g;\n      c = c << 13 | c >>> 19;\n      c = 5 * c + 3864292196;\n    }\n    n = 0;\n    switch (s) {\n      case 3:\n        n ^= t[4 * a + 2] << 16;\n      case 2:\n        n ^= t[4 * a + 1] << 8;\n      case 1:\n        n ^= t[4 * a];\n        n = n * C & ys | n * l & ws;\n        n = n << 15 | n >>> 17;\n        n = n * h & ys | n * Q & ws;\n        1 & a ? o ^= n : c ^= n;\n    }\n    this.h1 = o;\n    this.h2 = c;\n  }\n  hexdigest() {\n    let e = this.h1,\n      t = this.h2;\n    e ^= t >>> 1;\n    e = 3981806797 * e & ys | 36045 * e & ws;\n    t = 4283543511 * t & ys | (2950163797 * (t << 16 | e >>> 16) & ys) >>> 16;\n    e ^= t >>> 1;\n    e = 444984403 * e & ys | 60499 * e & ws;\n    t = 3301882366 * t & ys | (3120437893 * (t << 16 | e >>> 16) & ys) >>> 16;\n    e ^= t >>> 1;\n    return (e >>> 0).toString(16).padStart(8, \"0\") + (t >>> 0).toString(16).padStart(8, \"0\");\n  }\n}\nfunction addState(e, t, i, a, s) {\n  let r = e;\n  for (let e = 0, i = t.length - 1; e < i; e++) {\n    const i = t[e];\n    r = r[i] ||= [];\n  }\n  r[t.at(-1)] = {\n    checkFn: i,\n    iterateFn: a,\n    processFn: s\n  };\n}\nconst Ds = [];\naddState(Ds, [GA, UA, ze, xA], null, function iterateInlineImageGroup(e, t) {\n  const i = e.fnArray,\n    a = (t - (e.iCurr - 3)) % 4;\n  switch (a) {\n    case 0:\n      return i[t] === GA;\n    case 1:\n      return i[t] === UA;\n    case 2:\n      return i[t] === ze;\n    case 3:\n      return i[t] === xA;\n  }\n  throw new Error(`iterateInlineImageGroup - invalid pos: ${a}`);\n}, function foundInlineImageGroup(e, t) {\n  const i = e.fnArray,\n    a = e.argsArray,\n    s = e.iCurr,\n    r = s - 3,\n    n = s - 2,\n    g = s - 1,\n    o = Math.min(Math.floor((t - r) / 4), 200);\n  if (o < 10) return t - (t - r) % 4;\n  let c = 0;\n  const C = [];\n  let h = 0,\n    l = 1,\n    Q = 1;\n  for (let e = 0; e < o; e++) {\n    const t = a[n + (e << 2)],\n      i = a[g + (e << 2)][0];\n    if (l + i.width > 1e3) {\n      c = Math.max(c, l);\n      Q += h + 2;\n      l = 0;\n      h = 0;\n    }\n    C.push({\n      transform: t,\n      x: l,\n      y: Q,\n      w: i.width,\n      h: i.height\n    });\n    l += i.width + 2;\n    h = Math.max(h, i.height);\n  }\n  const E = Math.max(c, l) + 1,\n    u = Q + h + 1,\n    d = new Uint8Array(E * u * 4),\n    f = E << 2;\n  for (let e = 0; e < o; e++) {\n    const t = a[g + (e << 2)][0].data,\n      i = C[e].w << 2;\n    let s = 0,\n      r = C[e].x + C[e].y * E << 2;\n    d.set(t.subarray(0, i), r - f);\n    for (let a = 0, n = C[e].h; a < n; a++) {\n      d.set(t.subarray(s, s + i), r);\n      s += i;\n      r += f;\n    }\n    d.set(t.subarray(s - i, s), r);\n    for (; r >= 0;) {\n      t[r - 4] = t[r];\n      t[r - 3] = t[r + 1];\n      t[r - 2] = t[r + 2];\n      t[r - 1] = t[r + 3];\n      t[r + i] = t[r + i - 4];\n      t[r + i + 1] = t[r + i - 3];\n      t[r + i + 2] = t[r + i - 2];\n      t[r + i + 3] = t[r + i - 1];\n      r -= f;\n    }\n  }\n  const p = {\n    width: E,\n    height: u\n  };\n  if (e.isOffscreenCanvasSupported) {\n    const e = new OffscreenCanvas(E, u);\n    e.getContext(\"2d\").putImageData(new ImageData(new Uint8ClampedArray(d.buffer), E, u), 0, 0);\n    p.bitmap = e.transferToImageBitmap();\n    p.data = null;\n  } else {\n    p.kind = F;\n    p.data = d;\n  }\n  i.splice(r, 4 * o, _e);\n  a.splice(r, 4 * o, [p, C]);\n  return r + 1;\n});\naddState(Ds, [GA, UA, Xe, xA], null, function iterateImageMaskGroup(e, t) {\n  const i = e.fnArray,\n    a = (t - (e.iCurr - 3)) % 4;\n  switch (a) {\n    case 0:\n      return i[t] === GA;\n    case 1:\n      return i[t] === UA;\n    case 2:\n      return i[t] === Xe;\n    case 3:\n      return i[t] === xA;\n  }\n  throw new Error(`iterateImageMaskGroup - invalid pos: ${a}`);\n}, function foundImageMaskGroup(e, t) {\n  const i = e.fnArray,\n    a = e.argsArray,\n    s = e.iCurr,\n    r = s - 3,\n    n = s - 2,\n    g = s - 1;\n  let o = Math.floor((t - r) / 4);\n  if (o < 10) return t - (t - r) % 4;\n  let c,\n    C,\n    h = !1;\n  const l = a[g][0],\n    Q = a[n][0],\n    E = a[n][1],\n    u = a[n][2],\n    d = a[n][3];\n  if (E === u) {\n    h = !0;\n    c = n + 4;\n    let e = g + 4;\n    for (let t = 1; t < o; t++, c += 4, e += 4) {\n      C = a[c];\n      if (a[e][0] !== l || C[0] !== Q || C[1] !== E || C[2] !== u || C[3] !== d) {\n        t < 10 ? h = !1 : o = t;\n        break;\n      }\n    }\n  }\n  if (h) {\n    o = Math.min(o, 1e3);\n    const e = new Float32Array(2 * o);\n    c = n;\n    for (let t = 0; t < o; t++, c += 4) {\n      C = a[c];\n      e[t << 1] = C[4];\n      e[1 + (t << 1)] = C[5];\n    }\n    i.splice(r, 4 * o, At);\n    a.splice(r, 4 * o, [l, Q, E, u, d, e]);\n  } else {\n    o = Math.min(o, 100);\n    const e = [];\n    for (let t = 0; t < o; t++) {\n      C = a[n + (t << 2)];\n      const i = a[g + (t << 2)][0];\n      e.push({\n        data: i.data,\n        width: i.width,\n        height: i.height,\n        interpolate: i.interpolate,\n        count: i.count,\n        transform: C\n      });\n    }\n    i.splice(r, 4 * o, Ze);\n    a.splice(r, 4 * o, [e]);\n  }\n  return r + 1;\n});\naddState(Ds, [GA, UA, Ve, xA], function (e) {\n  const t = e.argsArray,\n    i = e.iCurr - 2;\n  return 0 === t[i][1] && 0 === t[i][2];\n}, function iterateImageGroup(e, t) {\n  const i = e.fnArray,\n    a = e.argsArray,\n    s = (t - (e.iCurr - 3)) % 4;\n  switch (s) {\n    case 0:\n      return i[t] === GA;\n    case 1:\n      if (i[t] !== UA) return !1;\n      const s = e.iCurr - 2,\n        r = a[s][0],\n        n = a[s][3];\n      return a[t][0] === r && 0 === a[t][1] && 0 === a[t][2] && a[t][3] === n;\n    case 2:\n      if (i[t] !== Ve) return !1;\n      const g = a[e.iCurr - 1][0];\n      return a[t][0] === g;\n    case 3:\n      return i[t] === xA;\n  }\n  throw new Error(`iterateImageGroup - invalid pos: ${s}`);\n}, function (e, t) {\n  const i = e.fnArray,\n    a = e.argsArray,\n    s = e.iCurr,\n    r = s - 3,\n    n = s - 2,\n    g = a[s - 1][0],\n    o = a[n][0],\n    c = a[n][3],\n    C = Math.min(Math.floor((t - r) / 4), 1e3);\n  if (C < 3) return t - (t - r) % 4;\n  const h = new Float32Array(2 * C);\n  let l = n;\n  for (let e = 0; e < C; e++, l += 4) {\n    const t = a[l];\n    h[e << 1] = t[4];\n    h[1 + (e << 1)] = t[5];\n  }\n  const Q = [g, o, c, h];\n  i.splice(r, 4 * C, $e);\n  a.splice(r, 4 * C, Q);\n  return r + 1;\n});\naddState(Ds, [$A, se, Ie, Ce, Ae], null, function iterateShowTextGroup(e, t) {\n  const i = e.fnArray,\n    a = e.argsArray,\n    s = (t - (e.iCurr - 4)) % 5;\n  switch (s) {\n    case 0:\n      return i[t] === $A;\n    case 1:\n      return i[t] === se;\n    case 2:\n      return i[t] === Ie;\n    case 3:\n      if (i[t] !== Ce) return !1;\n      const s = e.iCurr - 3,\n        r = a[s][0],\n        n = a[s][1];\n      return a[t][0] === r && a[t][1] === n;\n    case 4:\n      return i[t] === Ae;\n  }\n  throw new Error(`iterateShowTextGroup - invalid pos: ${s}`);\n}, function (e, t) {\n  const i = e.fnArray,\n    a = e.argsArray,\n    s = e.iCurr,\n    r = s - 4,\n    n = s - 3,\n    g = s - 2,\n    o = s - 1,\n    c = s,\n    C = a[n][0],\n    h = a[n][1];\n  let l = Math.min(Math.floor((t - r) / 5), 1e3);\n  if (l < 3) return t - (t - r) % 5;\n  let Q = r;\n  if (r >= 4 && i[r - 4] === i[n] && i[r - 3] === i[g] && i[r - 2] === i[o] && i[r - 1] === i[c] && a[r - 4][0] === C && a[r - 4][1] === h) {\n    l++;\n    Q -= 5;\n  }\n  let E = Q + 4;\n  for (let e = 1; e < l; e++) {\n    i.splice(E, 3);\n    a.splice(E, 3);\n    E += 2;\n  }\n  return E + 1;\n});\nclass NullOptimizer {\n  constructor(e) {\n    this.queue = e;\n  }\n  _optimize() {}\n  push(e, t) {\n    this.queue.fnArray.push(e);\n    this.queue.argsArray.push(t);\n    this._optimize();\n  }\n  flush() {}\n  reset() {}\n}\nclass QueueOptimizer extends NullOptimizer {\n  constructor(e) {\n    super(e);\n    this.state = null;\n    this.context = {\n      iCurr: 0,\n      fnArray: e.fnArray,\n      argsArray: e.argsArray,\n      isOffscreenCanvasSupported: !1\n    };\n    this.match = null;\n    this.lastProcessed = 0;\n  }\n  set isOffscreenCanvasSupported(e) {\n    this.context.isOffscreenCanvasSupported = e;\n  }\n  _optimize() {\n    const e = this.queue.fnArray;\n    let t = this.lastProcessed,\n      i = e.length,\n      a = this.state,\n      s = this.match;\n    if (!a && !s && t + 1 === i && !Ds[e[t]]) {\n      this.lastProcessed = i;\n      return;\n    }\n    const r = this.context;\n    for (; t < i;) {\n      if (s) {\n        if ((0, s.iterateFn)(r, t)) {\n          t++;\n          continue;\n        }\n        t = (0, s.processFn)(r, t + 1);\n        i = e.length;\n        s = null;\n        a = null;\n        if (t >= i) break;\n      }\n      a = (a || Ds)[e[t]];\n      if (a && !Array.isArray(a)) {\n        r.iCurr = t;\n        t++;\n        if (!a.checkFn || (0, a.checkFn)(r)) {\n          s = a;\n          a = null;\n        } else a = null;\n      } else t++;\n    }\n    this.state = a;\n    this.match = s;\n    this.lastProcessed = t;\n  }\n  flush() {\n    for (; this.match;) {\n      const e = this.queue.fnArray.length;\n      this.lastProcessed = (0, this.match.processFn)(this.context, e);\n      this.match = null;\n      this.state = null;\n      this._optimize();\n    }\n  }\n  reset() {\n    this.state = null;\n    this.match = null;\n    this.lastProcessed = 0;\n  }\n}\nclass OperatorList {\n  static CHUNK_SIZE = 1e3;\n  static CHUNK_SIZE_ABOUT = this.CHUNK_SIZE - 5;\n  constructor(e = 0, t) {\n    this._streamSink = t;\n    this.fnArray = [];\n    this.argsArray = [];\n    this.optimizer = !t || e & Q ? new NullOptimizer(this) : new QueueOptimizer(this);\n    this.dependencies = new Set();\n    this._totalLength = 0;\n    this.weight = 0;\n    this._resolved = t ? null : Promise.resolve();\n  }\n  set isOffscreenCanvasSupported(e) {\n    this.optimizer.isOffscreenCanvasSupported = e;\n  }\n  get length() {\n    return this.argsArray.length;\n  }\n  get ready() {\n    return this._resolved || this._streamSink.ready;\n  }\n  get totalLength() {\n    return this._totalLength + this.length;\n  }\n  addOp(e, t) {\n    this.optimizer.push(e, t);\n    this.weight++;\n    this._streamSink && (this.weight >= OperatorList.CHUNK_SIZE || this.weight >= OperatorList.CHUNK_SIZE_ABOUT && (e === xA || e === Ae)) && this.flush();\n  }\n  addImageOps(e, t, i) {\n    void 0 !== i && this.addOp(Je, [\"OC\", i]);\n    this.addOp(e, t);\n    void 0 !== i && this.addOp(Ye, []);\n  }\n  addDependency(e) {\n    if (!this.dependencies.has(e)) {\n      this.dependencies.add(e);\n      this.addOp(yA, [e]);\n    }\n  }\n  addDependencies(e) {\n    for (const t of e) this.addDependency(t);\n  }\n  addOpList(e) {\n    if (e instanceof OperatorList) {\n      for (const t of e.dependencies) this.dependencies.add(t);\n      for (let t = 0, i = e.length; t < i; t++) this.addOp(e.fnArray[t], e.argsArray[t]);\n    } else warn('addOpList - ignoring invalid \"opList\" parameter.');\n  }\n  getIR() {\n    return {\n      fnArray: this.fnArray,\n      argsArray: this.argsArray,\n      length: this.length\n    };\n  }\n  get _transfers() {\n    const e = [],\n      {\n        fnArray: t,\n        argsArray: i,\n        length: a\n      } = this;\n    for (let s = 0; s < a; s++) switch (t[s]) {\n      case ze:\n      case _e:\n      case Xe:\n        const t = i[s][0];\n        !t.cached && t.data?.buffer instanceof ArrayBuffer && e.push(t.data.buffer);\n    }\n    return e;\n  }\n  flush(e = !1, t = null) {\n    this.optimizer.flush();\n    const i = this.length;\n    this._totalLength += i;\n    this._streamSink.enqueue({\n      fnArray: this.fnArray,\n      argsArray: this.argsArray,\n      lastChunk: e,\n      separateAnnots: t,\n      length: i\n    }, 1, this._transfers);\n    this.dependencies.clear();\n    this.fnArray.length = 0;\n    this.argsArray.length = 0;\n    this.weight = 0;\n    this.optimizer.reset();\n  }\n}\nfunction decodeAndClamp(e, t, i, a) {\n  (e = t + e * i) < 0 ? e = 0 : e > a && (e = a);\n  return e;\n}\nfunction resizeImageMask(e, t, i, a, s, r) {\n  const n = s * r;\n  let g;\n  g = t <= 8 ? new Uint8Array(n) : t <= 16 ? new Uint16Array(n) : new Uint32Array(n);\n  const o = i / s,\n    c = a / r;\n  let C,\n    h,\n    l,\n    Q,\n    E = 0;\n  const u = new Uint16Array(s),\n    d = i;\n  for (C = 0; C < s; C++) u[C] = Math.floor(C * o);\n  for (C = 0; C < r; C++) {\n    l = Math.floor(C * c) * d;\n    for (h = 0; h < s; h++) {\n      Q = l + u[h];\n      g[E++] = e[Q];\n    }\n  }\n  return g;\n}\nclass PDFImage {\n  constructor({\n    xref: e,\n    res: t,\n    image: i,\n    isInline: a = !1,\n    smask: s = null,\n    mask: r = null,\n    isMask: n = !1,\n    pdfFunctionFactory: g,\n    localColorSpaceCache: o\n  }) {\n    this.image = i;\n    const c = i.dict,\n      C = c.get(\"F\", \"Filter\");\n    let h;\n    if (C instanceof Name) h = C.name;else if (Array.isArray(C)) {\n      const t = e.fetchIfRef(C[0]);\n      t instanceof Name && (h = t.name);\n    }\n    switch (h) {\n      case \"JPXDecode\":\n        ({\n          width: i.width,\n          height: i.height,\n          componentsCount: i.numComps,\n          bitsPerComponent: i.bitsPerComponent\n        } = JpxImage.parseImageProperties(i.stream));\n        i.stream.reset();\n        this.jpxDecoderOptions = {\n          numComponents: 0,\n          isIndexedColormap: !1,\n          smaskInData: c.has(\"SMaskInData\")\n        };\n        break;\n      case \"JBIG2Decode\":\n        i.bitsPerComponent = 1;\n        i.numComps = 1;\n    }\n    let l = c.get(\"W\", \"Width\"),\n      Q = c.get(\"H\", \"Height\");\n    if (Number.isInteger(i.width) && i.width > 0 && Number.isInteger(i.height) && i.height > 0 && (i.width !== l || i.height !== Q)) {\n      warn(\"PDFImage - using the Width/Height of the image data, rather than the image dictionary.\");\n      l = i.width;\n      Q = i.height;\n    }\n    if (l < 1 || Q < 1) throw new FormatError(`Invalid image width: ${l} or height: ${Q}`);\n    this.width = l;\n    this.height = Q;\n    this.interpolate = c.get(\"I\", \"Interpolate\");\n    this.imageMask = c.get(\"IM\", \"ImageMask\") || !1;\n    this.matte = c.get(\"Matte\") || !1;\n    let E = i.bitsPerComponent;\n    if (!E) {\n      E = c.get(\"BPC\", \"BitsPerComponent\");\n      if (!E) {\n        if (!this.imageMask) throw new FormatError(`Bits per component missing in image: ${this.imageMask}`);\n        E = 1;\n      }\n    }\n    this.bpc = E;\n    if (!this.imageMask) {\n      let s = c.getRaw(\"CS\") || c.getRaw(\"ColorSpace\");\n      const r = !!s;\n      if (r) this.jpxDecoderOptions?.smaskInData && (s = Name.get(\"DeviceRGBA\"));else if (this.jpxDecoderOptions) s = Name.get(\"DeviceRGBA\");else switch (i.numComps) {\n        case 1:\n          s = Name.get(\"DeviceGray\");\n          break;\n        case 3:\n          s = Name.get(\"DeviceRGB\");\n          break;\n        case 4:\n          s = Name.get(\"DeviceCMYK\");\n          break;\n        default:\n          throw new Error(`Images with ${i.numComps} color components not supported.`);\n      }\n      this.colorSpace = ColorSpace.parse({\n        cs: s,\n        xref: e,\n        resources: a ? t : null,\n        pdfFunctionFactory: g,\n        localColorSpaceCache: o\n      });\n      this.numComps = this.colorSpace.numComps;\n      if (this.jpxDecoderOptions) {\n        this.jpxDecoderOptions.numComponents = r ? this.numComp : 0;\n        this.jpxDecoderOptions.isIndexedColormap = \"Indexed\" === this.colorSpace.name;\n      }\n    }\n    this.decode = c.getArray(\"D\", \"Decode\");\n    this.needsDecode = !1;\n    if (this.decode && (this.colorSpace && !this.colorSpace.isDefaultDecode(this.decode, E) || n && !ColorSpace.isDefaultDecode(this.decode, 1))) {\n      this.needsDecode = !0;\n      const e = (1 << E) - 1;\n      this.decodeCoefficients = [];\n      this.decodeAddends = [];\n      const t = \"Indexed\" === this.colorSpace?.name;\n      for (let i = 0, a = 0; i < this.decode.length; i += 2, ++a) {\n        const s = this.decode[i],\n          r = this.decode[i + 1];\n        this.decodeCoefficients[a] = t ? (r - s) / e : r - s;\n        this.decodeAddends[a] = t ? s : e * s;\n      }\n    }\n    if (s) this.smask = new PDFImage({\n      xref: e,\n      res: t,\n      image: s,\n      isInline: a,\n      pdfFunctionFactory: g,\n      localColorSpaceCache: o\n    });else if (r) if (r instanceof BaseStream) {\n      r.dict.get(\"IM\", \"ImageMask\") ? this.mask = new PDFImage({\n        xref: e,\n        res: t,\n        image: r,\n        isInline: a,\n        isMask: !0,\n        pdfFunctionFactory: g,\n        localColorSpaceCache: o\n      }) : warn(\"Ignoring /Mask in image without /ImageMask.\");\n    } else this.mask = r;\n  }\n  static async buildImage({\n    xref: e,\n    res: t,\n    image: i,\n    isInline: a = !1,\n    pdfFunctionFactory: s,\n    localColorSpaceCache: r\n  }) {\n    const n = i;\n    let g = null,\n      o = null;\n    const c = i.dict.get(\"SMask\"),\n      C = i.dict.get(\"Mask\");\n    c ? c instanceof BaseStream ? g = c : warn(\"Unsupported /SMask format.\") : C && (C instanceof BaseStream || Array.isArray(C) ? o = C : warn(\"Unsupported /Mask format.\"));\n    return new PDFImage({\n      xref: e,\n      res: t,\n      image: n,\n      isInline: a,\n      smask: g,\n      mask: o,\n      pdfFunctionFactory: s,\n      localColorSpaceCache: r\n    });\n  }\n  static createRawMask({\n    imgArray: e,\n    width: t,\n    height: i,\n    imageIsFromDecodeStream: a,\n    inverseDecode: s,\n    interpolate: r\n  }) {\n    const n = (t + 7 >> 3) * i,\n      g = e.byteLength;\n    let o, c;\n    if (!a || s && !(n === g)) {\n      if (s) {\n        o = new Uint8Array(n);\n        o.set(e);\n        o.fill(255, g);\n      } else o = new Uint8Array(e);\n    } else o = e;\n    if (s) for (c = 0; c < g; c++) o[c] ^= 255;\n    return {\n      data: o,\n      width: t,\n      height: i,\n      interpolate: r\n    };\n  }\n  static async createMask({\n    imgArray: e,\n    width: t,\n    height: i,\n    imageIsFromDecodeStream: a,\n    inverseDecode: s,\n    interpolate: r,\n    isOffscreenCanvasSupported: n = !1\n  }) {\n    const g = 1 === t && 1 === i && s === (0 === e.length || !!(128 & e[0]));\n    if (g) return {\n      isSingleOpaquePixel: g\n    };\n    if (n) {\n      if (ImageResizer.needsToBeResized(t, i)) {\n        const a = new Uint8ClampedArray(t * i * 4);\n        convertBlackAndWhiteToRGBA({\n          src: e,\n          dest: a,\n          width: t,\n          height: i,\n          nonBlackColor: 0,\n          inverseDecode: s\n        });\n        return ImageResizer.createImage({\n          kind: F,\n          data: a,\n          width: t,\n          height: i,\n          interpolate: r\n        });\n      }\n      const a = new OffscreenCanvas(t, i),\n        n = a.getContext(\"2d\"),\n        g = n.createImageData(t, i);\n      convertBlackAndWhiteToRGBA({\n        src: e,\n        dest: g.data,\n        width: t,\n        height: i,\n        nonBlackColor: 0,\n        inverseDecode: s\n      });\n      n.putImageData(g, 0, 0);\n      return {\n        data: null,\n        width: t,\n        height: i,\n        interpolate: r,\n        bitmap: a.transferToImageBitmap()\n      };\n    }\n    return this.createRawMask({\n      imgArray: e,\n      width: t,\n      height: i,\n      inverseDecode: s,\n      imageIsFromDecodeStream: a,\n      interpolate: r\n    });\n  }\n  get drawWidth() {\n    return Math.max(this.width, this.smask?.width || 0, this.mask?.width || 0);\n  }\n  get drawHeight() {\n    return Math.max(this.height, this.smask?.height || 0, this.mask?.height || 0);\n  }\n  decodeBuffer(e) {\n    const t = this.bpc,\n      i = this.numComps,\n      a = this.decodeAddends,\n      s = this.decodeCoefficients,\n      r = (1 << t) - 1;\n    let n, g;\n    if (1 === t) {\n      for (n = 0, g = e.length; n < g; n++) e[n] = +!e[n];\n      return;\n    }\n    let o = 0;\n    for (n = 0, g = this.width * this.height; n < g; n++) for (let t = 0; t < i; t++) {\n      e[o] = decodeAndClamp(e[o], a[t], s[t], r);\n      o++;\n    }\n  }\n  getComponents(e) {\n    const t = this.bpc;\n    if (8 === t) return e;\n    const i = this.width,\n      a = this.height,\n      s = this.numComps,\n      r = i * a * s;\n    let n,\n      g = 0;\n    n = t <= 8 ? new Uint8Array(r) : t <= 16 ? new Uint16Array(r) : new Uint32Array(r);\n    const o = i * s,\n      c = (1 << t) - 1;\n    let C,\n      h,\n      l = 0;\n    if (1 === t) {\n      let t, i, s;\n      for (let r = 0; r < a; r++) {\n        i = l + (-8 & o);\n        s = l + o;\n        for (; l < i;) {\n          h = e[g++];\n          n[l] = h >> 7 & 1;\n          n[l + 1] = h >> 6 & 1;\n          n[l + 2] = h >> 5 & 1;\n          n[l + 3] = h >> 4 & 1;\n          n[l + 4] = h >> 3 & 1;\n          n[l + 5] = h >> 2 & 1;\n          n[l + 6] = h >> 1 & 1;\n          n[l + 7] = 1 & h;\n          l += 8;\n        }\n        if (l < s) {\n          h = e[g++];\n          t = 128;\n          for (; l < s;) {\n            n[l++] = +!!(h & t);\n            t >>= 1;\n          }\n        }\n      }\n    } else {\n      let i = 0;\n      h = 0;\n      for (l = 0, C = r; l < C; ++l) {\n        if (l % o == 0) {\n          h = 0;\n          i = 0;\n        }\n        for (; i < t;) {\n          h = h << 8 | e[g++];\n          i += 8;\n        }\n        const a = i - t;\n        let s = h >> a;\n        s < 0 ? s = 0 : s > c && (s = c);\n        n[l] = s;\n        h &= (1 << a) - 1;\n        i = a;\n      }\n    }\n    return n;\n  }\n  async fillOpacity(e, t, i, a, s) {\n    const r = this.smask,\n      n = this.mask;\n    let g, o, c, C, h, l;\n    if (r) {\n      o = r.width;\n      c = r.height;\n      g = new Uint8ClampedArray(o * c);\n      await r.fillGrayBuffer(g);\n      o === t && c === i || (g = resizeImageMask(g, r.bpc, o, c, t, i));\n    } else if (n) if (n instanceof PDFImage) {\n      o = n.width;\n      c = n.height;\n      g = new Uint8ClampedArray(o * c);\n      n.numComps = 1;\n      await n.fillGrayBuffer(g);\n      for (C = 0, h = o * c; C < h; ++C) g[C] = 255 - g[C];\n      o === t && c === i || (g = resizeImageMask(g, n.bpc, o, c, t, i));\n    } else {\n      if (!Array.isArray(n)) throw new FormatError(\"Unknown mask format.\");\n      {\n        g = new Uint8ClampedArray(t * i);\n        const e = this.numComps;\n        for (C = 0, h = t * i; C < h; ++C) {\n          let t = 0;\n          const i = C * e;\n          for (l = 0; l < e; ++l) {\n            const e = s[i + l],\n              a = 2 * l;\n            if (e < n[a] || e > n[a + 1]) {\n              t = 255;\n              break;\n            }\n          }\n          g[C] = t;\n        }\n      }\n    }\n    if (g) for (C = 0, l = 3, h = t * a; C < h; ++C, l += 4) e[l] = g[C];else for (C = 0, l = 3, h = t * a; C < h; ++C, l += 4) e[l] = 255;\n  }\n  undoPreblend(e, t, i) {\n    const a = this.smask?.matte;\n    if (!a) return;\n    const s = this.colorSpace.getRgb(a, 0),\n      r = s[0],\n      n = s[1],\n      g = s[2],\n      o = t * i * 4;\n    for (let t = 0; t < o; t += 4) {\n      const i = e[t + 3];\n      if (0 === i) {\n        e[t] = 255;\n        e[t + 1] = 255;\n        e[t + 2] = 255;\n        continue;\n      }\n      const a = 255 / i;\n      e[t] = (e[t] - r) * a + r;\n      e[t + 1] = (e[t + 1] - n) * a + n;\n      e[t + 2] = (e[t + 2] - g) * a + g;\n    }\n  }\n  async createImageData(e = !1, t = !1) {\n    const i = this.drawWidth,\n      a = this.drawHeight,\n      s = {\n        width: i,\n        height: a,\n        interpolate: this.interpolate,\n        kind: 0,\n        data: null\n      },\n      r = this.numComps,\n      n = this.width,\n      g = this.height,\n      o = this.bpc,\n      c = n * r * o + 7 >> 3,\n      C = t && ImageResizer.needsToBeResized(i, a);\n    if (\"DeviceRGBA\" === this.colorSpace.name) {\n      s.kind = F;\n      const e = s.data = await this.getImageBytes(g * n * 4, {});\n      return t ? C ? ImageResizer.createImage(s, !1) : this.createBitmap(F, i, a, e) : s;\n    }\n    if (!e) {\n      let e;\n      \"DeviceGray\" === this.colorSpace.name && 1 === o ? e = D : \"DeviceRGB\" !== this.colorSpace.name || 8 !== o || this.needsDecode || (e = b);\n      if (e && !this.smask && !this.mask && i === n && a === g) {\n        const r = await this.getImageBytes(g * c, {});\n        if (t) return C ? ImageResizer.createImage({\n          data: r,\n          kind: e,\n          width: i,\n          height: a,\n          interpolate: this.interpolate\n        }, this.needsDecode) : this.createBitmap(e, n, g, r);\n        s.kind = e;\n        s.data = r;\n        if (this.needsDecode) {\n          assert(e === D, \"PDFImage.createImageData: The image must be grayscale.\");\n          const t = s.data;\n          for (let e = 0, i = t.length; e < i; e++) t[e] ^= 255;\n        }\n        return s;\n      }\n      if (this.image instanceof JpegStream && !this.smask && !this.mask && !this.needsDecode) {\n        let e = g * c;\n        if (t && !C) {\n          let t = !1;\n          switch (this.colorSpace.name) {\n            case \"DeviceGray\":\n              e *= 4;\n              t = !0;\n              break;\n            case \"DeviceRGB\":\n              e = e / 3 * 4;\n              t = !0;\n              break;\n            case \"DeviceCMYK\":\n              t = !0;\n          }\n          if (t) {\n            const t = await this.getImageBytes(e, {\n              drawWidth: i,\n              drawHeight: a,\n              forceRGBA: !0\n            });\n            return this.createBitmap(F, i, a, t);\n          }\n        } else switch (this.colorSpace.name) {\n          case \"DeviceGray\":\n            e *= 3;\n          case \"DeviceRGB\":\n          case \"DeviceCMYK\":\n            s.kind = b;\n            s.data = await this.getImageBytes(e, {\n              drawWidth: i,\n              drawHeight: a,\n              forceRGB: !0\n            });\n            return C ? ImageResizer.createImage(s) : s;\n        }\n      }\n    }\n    const h = await this.getImageBytes(g * c, {\n        internal: !0\n      }),\n      l = 0 | h.length / c * a / g,\n      Q = this.getComponents(h);\n    let E, u, d, f, p, m;\n    if (t && !C) {\n      d = new OffscreenCanvas(i, a);\n      f = d.getContext(\"2d\");\n      p = f.createImageData(i, a);\n      m = p.data;\n    }\n    s.kind = F;\n    if (e || this.smask || this.mask) {\n      t && !C || (m = new Uint8ClampedArray(i * a * 4));\n      E = 1;\n      u = !0;\n      await this.fillOpacity(m, i, a, l, Q);\n    } else {\n      if (!t || C) {\n        s.kind = b;\n        m = new Uint8ClampedArray(i * a * 3);\n        E = 0;\n      } else {\n        new Uint32Array(m.buffer).fill(FeatureTest.isLittleEndian ? 4278190080 : 255);\n        E = 1;\n      }\n      u = !1;\n    }\n    this.needsDecode && this.decodeBuffer(Q);\n    this.colorSpace.fillRgb(m, n, g, i, a, l, o, Q, E);\n    u && this.undoPreblend(m, i, l);\n    if (t && !C) {\n      f.putImageData(p, 0, 0);\n      return {\n        data: null,\n        width: i,\n        height: a,\n        bitmap: d.transferToImageBitmap(),\n        interpolate: this.interpolate\n      };\n    }\n    s.data = m;\n    return C ? ImageResizer.createImage(s) : s;\n  }\n  async fillGrayBuffer(e) {\n    const t = this.numComps;\n    if (1 !== t) throw new FormatError(`Reading gray scale from a color image: ${t}`);\n    const i = this.width,\n      a = this.height,\n      s = this.bpc,\n      r = i * t * s + 7 >> 3,\n      n = await this.getImageBytes(a * r, {\n        internal: !0\n      }),\n      g = this.getComponents(n);\n    let o, c;\n    if (1 === s) {\n      c = i * a;\n      if (this.needsDecode) for (o = 0; o < c; ++o) e[o] = g[o] - 1 & 255;else for (o = 0; o < c; ++o) e[o] = 255 & -g[o];\n      return;\n    }\n    this.needsDecode && this.decodeBuffer(g);\n    c = i * a;\n    const C = 255 / ((1 << s) - 1);\n    for (o = 0; o < c; ++o) e[o] = C * g[o];\n  }\n  createBitmap(e, t, i, a) {\n    const s = new OffscreenCanvas(t, i),\n      r = s.getContext(\"2d\");\n    let n;\n    if (e === F) n = new ImageData(a, t, i);else {\n      n = r.createImageData(t, i);\n      convertToRGBA({\n        kind: e,\n        src: a,\n        dest: new Uint32Array(n.data.buffer),\n        width: t,\n        height: i,\n        inverseDecode: this.needsDecode\n      });\n    }\n    r.putImageData(n, 0, 0);\n    return {\n      data: null,\n      width: t,\n      height: i,\n      bitmap: s.transferToImageBitmap(),\n      interpolate: this.interpolate\n    };\n  }\n  async getImageBytes(e, {\n    drawWidth: t,\n    drawHeight: i,\n    forceRGBA: a = !1,\n    forceRGB: s = !1,\n    internal: r = !1\n  }) {\n    this.image.reset();\n    this.image.drawWidth = t || this.width;\n    this.image.drawHeight = i || this.height;\n    this.image.forceRGBA = !!a;\n    this.image.forceRGB = !!s;\n    const n = await this.image.getImageData(e, this.jpxDecoderOptions);\n    if (r || this.image instanceof DecodeStream) return n;\n    assert(n instanceof Uint8Array, 'PDFImage.getImageBytes: Unsupported \"imageBytes\" type.');\n    return new Uint8Array(n);\n  }\n}\nconst bs = Object.freeze({\n    maxImageSize: -1,\n    disableFontFace: !1,\n    ignoreErrors: !1,\n    isEvalSupported: !0,\n    isOffscreenCanvasSupported: !1,\n    canvasMaxAreaInBytes: -1,\n    fontExtraProperties: !1,\n    useSystemFonts: !0,\n    cMapUrl: null,\n    standardFontDataUrl: null\n  }),\n  Fs = 1,\n  Ss = 2,\n  ks = Promise.resolve();\nfunction normalizeBlendMode(e, t = !1) {\n  if (Array.isArray(e)) {\n    for (const t of e) {\n      const e = normalizeBlendMode(t, !0);\n      if (e) return e;\n    }\n    warn(`Unsupported blend mode Array: ${e}`);\n    return \"source-over\";\n  }\n  if (!(e instanceof Name)) return t ? null : \"source-over\";\n  switch (e.name) {\n    case \"Normal\":\n    case \"Compatible\":\n      return \"source-over\";\n    case \"Multiply\":\n      return \"multiply\";\n    case \"Screen\":\n      return \"screen\";\n    case \"Overlay\":\n      return \"overlay\";\n    case \"Darken\":\n      return \"darken\";\n    case \"Lighten\":\n      return \"lighten\";\n    case \"ColorDodge\":\n      return \"color-dodge\";\n    case \"ColorBurn\":\n      return \"color-burn\";\n    case \"HardLight\":\n      return \"hard-light\";\n    case \"SoftLight\":\n      return \"soft-light\";\n    case \"Difference\":\n      return \"difference\";\n    case \"Exclusion\":\n      return \"exclusion\";\n    case \"Hue\":\n      return \"hue\";\n    case \"Saturation\":\n      return \"saturation\";\n    case \"Color\":\n      return \"color\";\n    case \"Luminosity\":\n      return \"luminosity\";\n  }\n  if (t) return null;\n  warn(`Unsupported blend mode: ${e.name}`);\n  return \"source-over\";\n}\nfunction addLocallyCachedImageOps(e, t) {\n  t.objId && e.addDependency(t.objId);\n  e.addImageOps(t.fn, t.args, t.optionalContent);\n  t.fn === Xe && t.args[0]?.count > 0 && t.args[0].count++;\n}\nclass TimeSlotManager {\n  static TIME_SLOT_DURATION_MS = 20;\n  static CHECK_TIME_EVERY = 100;\n  constructor() {\n    this.reset();\n  }\n  check() {\n    if (++this.checked < TimeSlotManager.CHECK_TIME_EVERY) return !1;\n    this.checked = 0;\n    return this.endTime <= Date.now();\n  }\n  reset() {\n    this.endTime = Date.now() + TimeSlotManager.TIME_SLOT_DURATION_MS;\n    this.checked = 0;\n  }\n}\nclass PartialEvaluator {\n  constructor({\n    xref: e,\n    handler: t,\n    pageIndex: i,\n    idFactory: a,\n    fontCache: s,\n    builtInCMapCache: r,\n    standardFontDataCache: n,\n    globalImageCache: g,\n    systemFontCache: o,\n    options: c = null\n  }) {\n    this.xref = e;\n    this.handler = t;\n    this.pageIndex = i;\n    this.idFactory = a;\n    this.fontCache = s;\n    this.builtInCMapCache = r;\n    this.standardFontDataCache = n;\n    this.globalImageCache = g;\n    this.systemFontCache = o;\n    this.options = c || bs;\n    this.type3FontRefs = null;\n    this._regionalImageCache = new RegionalImageCache();\n    this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);\n    ImageResizer.setMaxArea(this.options.canvasMaxAreaInBytes);\n  }\n  get _pdfFunctionFactory() {\n    return shadow(this, \"_pdfFunctionFactory\", new PDFFunctionFactory({\n      xref: this.xref,\n      isEvalSupported: this.options.isEvalSupported\n    }));\n  }\n  get parsingType3Font() {\n    return !!this.type3FontRefs;\n  }\n  clone(e = null) {\n    const t = Object.create(this);\n    t.options = Object.assign(Object.create(null), this.options, e);\n    return t;\n  }\n  hasBlendModes(e, t) {\n    if (!(e instanceof Dict)) return !1;\n    if (e.objId && t.has(e.objId)) return !1;\n    const i = new RefSet(t);\n    e.objId && i.put(e.objId);\n    const a = [e],\n      s = this.xref;\n    for (; a.length;) {\n      const e = a.shift(),\n        t = e.get(\"ExtGState\");\n      if (t instanceof Dict) for (let e of t.getRawValues()) {\n        if (e instanceof Ref) {\n          if (i.has(e)) continue;\n          try {\n            e = s.fetch(e);\n          } catch (t) {\n            i.put(e);\n            info(`hasBlendModes - ignoring ExtGState: \"${t}\".`);\n            continue;\n          }\n        }\n        if (!(e instanceof Dict)) continue;\n        e.objId && i.put(e.objId);\n        const t = e.get(\"BM\");\n        if (t instanceof Name) {\n          if (\"Normal\" !== t.name) return !0;\n        } else if (void 0 !== t && Array.isArray(t)) for (const e of t) if (e instanceof Name && \"Normal\" !== e.name) return !0;\n      }\n      const r = e.get(\"XObject\");\n      if (r instanceof Dict) for (let e of r.getRawValues()) {\n        if (e instanceof Ref) {\n          if (i.has(e)) continue;\n          try {\n            e = s.fetch(e);\n          } catch (t) {\n            i.put(e);\n            info(`hasBlendModes - ignoring XObject: \"${t}\".`);\n            continue;\n          }\n        }\n        if (!(e instanceof BaseStream)) continue;\n        e.dict.objId && i.put(e.dict.objId);\n        const t = e.dict.get(\"Resources\");\n        if (t instanceof Dict && (!t.objId || !i.has(t.objId))) {\n          a.push(t);\n          t.objId && i.put(t.objId);\n        }\n      }\n    }\n    for (const e of i) t.put(e);\n    return !1;\n  }\n  async fetchBuiltInCMap(e) {\n    const t = this.builtInCMapCache.get(e);\n    if (t) return t;\n    let i;\n    if (null !== this.options.cMapUrl) {\n      const t = `${this.options.cMapUrl}${e}.bcmap`,\n        a = await fetch(t);\n      if (!a.ok) throw new Error(`fetchBuiltInCMap: failed to fetch file \"${t}\" with \"${a.statusText}\".`);\n      i = {\n        cMapData: new Uint8Array(await a.arrayBuffer()),\n        compressionType: mA.BINARY\n      };\n    } else i = await this.handler.sendWithPromise(\"FetchBuiltInCMap\", {\n      name: e\n    });\n    i.compressionType !== mA.NONE && this.builtInCMapCache.set(e, i);\n    return i;\n  }\n  async fetchStandardFontData(e) {\n    const t = this.standardFontDataCache.get(e);\n    if (t) return new Stream(t);\n    if (this.options.useSystemFonts && \"Symbol\" !== e && \"ZapfDingbats\" !== e) return null;\n    const i = Wi()[e];\n    let a;\n    if (null !== this.options.standardFontDataUrl) {\n      const e = `${this.options.standardFontDataUrl}${i}`,\n        t = await fetch(e);\n      t.ok ? a = new Uint8Array(await t.arrayBuffer()) : warn(`fetchStandardFontData: failed to fetch file \"${e}\" with \"${t.statusText}\".`);\n    } else try {\n      a = await this.handler.sendWithPromise(\"FetchStandardFontData\", {\n        filename: i\n      });\n    } catch (e) {\n      warn(`fetchStandardFontData: failed to fetch file \"${i}\" with \"${e}\".`);\n    }\n    if (!a) return null;\n    this.standardFontDataCache.set(e, a);\n    return new Stream(a);\n  }\n  async buildFormXObject(e, t, i, a, s, r, n) {\n    const g = t.dict,\n      o = lookupMatrix(g.getArray(\"Matrix\"), null),\n      c = lookupNormalRect(g.getArray(\"BBox\"), null);\n    let C, h;\n    g.has(\"OC\") && (C = await this.parseMarkedContentProps(g.get(\"OC\"), e));\n    void 0 !== C && a.addOp(Je, [\"OC\", C]);\n    const l = g.get(\"Group\");\n    if (l) {\n      h = {\n        matrix: o,\n        bbox: c,\n        smask: i,\n        isolated: !1,\n        knockout: !1\n      };\n      let t = null;\n      if (isName(l.get(\"S\"), \"Transparency\")) {\n        h.isolated = l.get(\"I\") || !1;\n        h.knockout = l.get(\"K\") || !1;\n        if (l.has(\"CS\")) {\n          const i = l.getRaw(\"CS\"),\n            a = ColorSpace.getCached(i, this.xref, n);\n          t = a || (await this.parseColorSpace({\n            cs: i,\n            resources: e,\n            localColorSpaceCache: n\n          }));\n        }\n      }\n      if (i?.backdrop) {\n        t ||= ColorSpace.singletons.rgb;\n        i.backdrop = t.getRgb(i.backdrop, 0);\n      }\n      a.addOp(Oe, [h]);\n    }\n    const Q = l ? [o, null] : [o, c];\n    a.addOp(Te, Q);\n    await this.getOperatorList({\n      stream: t,\n      task: s,\n      resources: g.get(\"Resources\") || e,\n      operatorList: a,\n      initialState: r\n    });\n    a.addOp(qe, []);\n    l && a.addOp(Pe, [h]);\n    void 0 !== C && a.addOp(Ye, []);\n  }\n  _sendImgData(e, t, i = !1) {\n    const a = t ? [t.bitmap || t.data.buffer] : null;\n    return this.parsingType3Font || i ? this.handler.send(\"commonobj\", [e, \"Image\", t], a) : this.handler.send(\"obj\", [e, this.pageIndex, \"Image\", t], a);\n  }\n  async buildPaintImageXObject({\n    resources: e,\n    image: t,\n    isInline: i = !1,\n    operatorList: a,\n    cacheKey: s,\n    localImageCache: r,\n    localColorSpaceCache: n\n  }) {\n    const g = t.dict,\n      o = g.objId,\n      c = g.get(\"W\", \"Width\"),\n      C = g.get(\"H\", \"Height\");\n    if (!c || \"number\" != typeof c || !C || \"number\" != typeof C) {\n      warn(\"Image dimensions are missing, or not numbers.\");\n      return;\n    }\n    const h = this.options.maxImageSize;\n    if (-1 !== h && c * C > h) {\n      const e = \"Image exceeded maximum allowed size and was removed.\";\n      if (this.options.ignoreErrors) {\n        warn(e);\n        return;\n      }\n      throw new Error(e);\n    }\n    let l;\n    g.has(\"OC\") && (l = await this.parseMarkedContentProps(g.get(\"OC\"), e));\n    let Q, E;\n    if (g.get(\"IM\", \"ImageMask\") || !1) {\n      const e = g.get(\"I\", \"Interpolate\"),\n        i = c + 7 >> 3,\n        n = t.getBytes(i * C),\n        h = g.getArray(\"D\", \"Decode\");\n      if (this.parsingType3Font) {\n        Q = PDFImage.createRawMask({\n          imgArray: n,\n          width: c,\n          height: C,\n          imageIsFromDecodeStream: t instanceof DecodeStream,\n          inverseDecode: h?.[0] > 0,\n          interpolate: e\n        });\n        Q.cached = !!s;\n        E = [Q];\n        a.addImageOps(Xe, E, l);\n        if (s) {\n          const e = {\n            fn: Xe,\n            args: E,\n            optionalContent: l\n          };\n          r.set(s, o, e);\n          o && this._regionalImageCache.set(null, o, e);\n        }\n        return;\n      }\n      Q = await PDFImage.createMask({\n        imgArray: n,\n        width: c,\n        height: C,\n        imageIsFromDecodeStream: t instanceof DecodeStream,\n        inverseDecode: h?.[0] > 0,\n        interpolate: e,\n        isOffscreenCanvasSupported: this.options.isOffscreenCanvasSupported\n      });\n      if (Q.isSingleOpaquePixel) {\n        a.addImageOps(et, [], l);\n        if (s) {\n          const e = {\n            fn: et,\n            args: [],\n            optionalContent: l\n          };\n          r.set(s, o, e);\n          o && this._regionalImageCache.set(null, o, e);\n        }\n        return;\n      }\n      const u = `mask_${this.idFactory.createObjId()}`;\n      a.addDependency(u);\n      Q.dataLen = Q.bitmap ? Q.width * Q.height * 4 : Q.data.length;\n      this._sendImgData(u, Q);\n      E = [{\n        data: u,\n        width: Q.width,\n        height: Q.height,\n        interpolate: Q.interpolate,\n        count: 1\n      }];\n      a.addImageOps(Xe, E, l);\n      if (s) {\n        const e = {\n          objId: u,\n          fn: Xe,\n          args: E,\n          optionalContent: l\n        };\n        r.set(s, o, e);\n        o && this._regionalImageCache.set(null, o, e);\n      }\n      return;\n    }\n    if (i && c + C < 200 && !g.has(\"SMask\") && !g.has(\"Mask\")) {\n      try {\n        const s = new PDFImage({\n          xref: this.xref,\n          res: e,\n          image: t,\n          isInline: i,\n          pdfFunctionFactory: this._pdfFunctionFactory,\n          localColorSpaceCache: n\n        });\n        Q = await s.createImageData(!0, !1);\n        a.isOffscreenCanvasSupported = this.options.isOffscreenCanvasSupported;\n        a.addImageOps(ze, [Q], l);\n      } catch (e) {\n        const t = `Unable to decode inline image: \"${e}\".`;\n        if (!this.options.ignoreErrors) throw new Error(t);\n        warn(t);\n      }\n      return;\n    }\n    let u = `img_${this.idFactory.createObjId()}`,\n      d = !1;\n    if (this.parsingType3Font) u = `${this.idFactory.getDocId()}_type3_${u}`;else if (s && o) {\n      d = this.globalImageCache.shouldCache(o, this.pageIndex);\n      if (d) {\n        assert(!i, \"Cannot cache an inline image globally.\");\n        u = `${this.idFactory.getDocId()}_${u}`;\n      }\n    }\n    a.addDependency(u);\n    E = [u, c, C];\n    a.addImageOps(Ve, E, l);\n    if (d) {\n      if (this.globalImageCache.hasDecodeFailed(o)) {\n        this.globalImageCache.setData(o, {\n          objId: u,\n          fn: Ve,\n          args: E,\n          optionalContent: l,\n          byteSize: 0\n        });\n        this._sendImgData(u, null, d);\n        return;\n      }\n      if (c * C > 25e4 || g.has(\"SMask\") || g.has(\"Mask\")) {\n        const e = await this.handler.sendWithPromise(\"commonobj\", [u, \"CopyLocalImage\", {\n          imageRef: o\n        }]);\n        if (e) {\n          this.globalImageCache.setData(o, {\n            objId: u,\n            fn: Ve,\n            args: E,\n            optionalContent: l,\n            byteSize: 0\n          });\n          this.globalImageCache.addByteSize(o, e);\n          return;\n        }\n      }\n    }\n    PDFImage.buildImage({\n      xref: this.xref,\n      res: e,\n      image: t,\n      isInline: i,\n      pdfFunctionFactory: this._pdfFunctionFactory,\n      localColorSpaceCache: n\n    }).then(async e => {\n      Q = await e.createImageData(!1, this.options.isOffscreenCanvasSupported);\n      Q.dataLen = Q.bitmap ? Q.width * Q.height * 4 : Q.data.length;\n      Q.ref = o;\n      d && this.globalImageCache.addByteSize(o, Q.dataLen);\n      return this._sendImgData(u, Q, d);\n    }).catch(e => {\n      warn(`Unable to decode image \"${u}\": \"${e}\".`);\n      o && this.globalImageCache.addDecodeFailed(o);\n      return this._sendImgData(u, null, d);\n    });\n    if (s) {\n      const e = {\n        objId: u,\n        fn: Ve,\n        args: E,\n        optionalContent: l\n      };\n      r.set(s, o, e);\n      if (o) {\n        this._regionalImageCache.set(null, o, e);\n        d && this.globalImageCache.setData(o, {\n          objId: u,\n          fn: Ve,\n          args: E,\n          optionalContent: l,\n          byteSize: 0\n        });\n      }\n    }\n  }\n  handleSMask(e, t, i, a, s, r) {\n    const n = e.get(\"G\"),\n      g = {\n        subtype: e.get(\"S\").name,\n        backdrop: e.get(\"BC\")\n      },\n      o = e.get(\"TR\");\n    if (isPDFFunction(o)) {\n      const e = this._pdfFunctionFactory.create(o),\n        t = new Uint8Array(256),\n        i = new Float32Array(1);\n      for (let a = 0; a < 256; a++) {\n        i[0] = a / 255;\n        e(i, 0, i, 0);\n        t[a] = 255 * i[0] | 0;\n      }\n      g.transferMap = t;\n    }\n    return this.buildFormXObject(t, n, g, i, a, s.state.clone(), r);\n  }\n  handleTransferFunction(e) {\n    let t;\n    if (Array.isArray(e)) t = e;else {\n      if (!isPDFFunction(e)) return null;\n      t = [e];\n    }\n    const i = [];\n    let a = 0,\n      s = 0;\n    for (const e of t) {\n      const t = this.xref.fetchIfRef(e);\n      a++;\n      if (isName(t, \"Identity\")) {\n        i.push(null);\n        continue;\n      }\n      if (!isPDFFunction(t)) return null;\n      const r = this._pdfFunctionFactory.create(t),\n        n = new Uint8Array(256),\n        g = new Float32Array(1);\n      for (let e = 0; e < 256; e++) {\n        g[0] = e / 255;\n        r(g, 0, g, 0);\n        n[e] = 255 * g[0] | 0;\n      }\n      i.push(n);\n      s++;\n    }\n    return 1 !== a && 4 !== a || 0 === s ? null : i;\n  }\n  handleTilingType(e, t, i, a, s, r, n, g) {\n    const o = new OperatorList(),\n      c = Dict.merge({\n        xref: this.xref,\n        dictArray: [s.get(\"Resources\"), i]\n      });\n    return this.getOperatorList({\n      stream: a,\n      task: n,\n      resources: c,\n      operatorList: o\n    }).then(function () {\n      const i = o.getIR(),\n        a = getTilingPatternIR(i, s, t);\n      r.addDependencies(o.dependencies);\n      r.addOp(e, a);\n      s.objId && g.set(null, s.objId, {\n        operatorListIR: i,\n        dict: s\n      });\n    }).catch(e => {\n      if (!(e instanceof AbortException)) {\n        if (!this.options.ignoreErrors) throw e;\n        warn(`handleTilingType - ignoring pattern: \"${e}\".`);\n      }\n    });\n  }\n  async handleSetFont(e, t, i, a, s, r, n = null, g = null) {\n    const o = t?.[0] instanceof Name ? t[0].name : null;\n    let c = await this.loadFont(o, i, e, n, g);\n    if (c.font.isType3Font) try {\n      await c.loadType3Data(this, e, s);\n      a.addDependencies(c.type3Dependencies);\n    } catch (e) {\n      c = new TranslatedFont({\n        loadedName: \"g_font_error\",\n        font: new ErrorFont(`Type3 font load error: ${e}`),\n        dict: c.font,\n        evaluatorOptions: this.options\n      });\n    }\n    r.font = c.font;\n    c.send(this.handler);\n    return c.loadedName;\n  }\n  handleText(e, t) {\n    const i = t.font,\n      a = i.charsToGlyphs(e);\n    if (i.data) {\n      (!!(t.textRenderingMode & w) || \"Pattern\" === t.fillColorSpace.name || i.disableFontFace || this.options.disableFontFace) && PartialEvaluator.buildFontPaths(i, a, this.handler, this.options);\n    }\n    return a;\n  }\n  ensureStateFont(e) {\n    if (e.font) return;\n    const t = new FormatError(\"Missing setFont (Tf) operator before text rendering operator.\");\n    if (!this.options.ignoreErrors) throw t;\n    warn(`ensureStateFont: \"${t}\".`);\n  }\n  async setGState({\n    resources: e,\n    gState: t,\n    operatorList: i,\n    cacheKey: a,\n    task: s,\n    stateManager: r,\n    localGStateCache: n,\n    localColorSpaceCache: g\n  }) {\n    const o = t.objId;\n    let c = !0;\n    const C = [];\n    let h = Promise.resolve();\n    for (const a of t.getKeys()) {\n      const n = t.get(a);\n      switch (a) {\n        case \"Type\":\n          break;\n        case \"LW\":\n        case \"LC\":\n        case \"LJ\":\n        case \"ML\":\n        case \"D\":\n        case \"RI\":\n        case \"FL\":\n        case \"CA\":\n        case \"ca\":\n          C.push([a, n]);\n          break;\n        case \"Font\":\n          c = !1;\n          h = h.then(() => this.handleSetFont(e, null, n[0], i, s, r.state).then(function (e) {\n            i.addDependency(e);\n            C.push([a, [e, n[1]]]);\n          }));\n          break;\n        case \"BM\":\n          C.push([a, normalizeBlendMode(n)]);\n          break;\n        case \"SMask\":\n          if (isName(n, \"None\")) {\n            C.push([a, !1]);\n            break;\n          }\n          if (n instanceof Dict) {\n            c = !1;\n            h = h.then(() => this.handleSMask(n, e, i, s, r, g));\n            C.push([a, !0]);\n          } else warn(\"Unsupported SMask type\");\n          break;\n        case \"TR\":\n          const t = this.handleTransferFunction(n);\n          C.push([a, t]);\n          break;\n        case \"OP\":\n        case \"op\":\n        case \"OPM\":\n        case \"BG\":\n        case \"BG2\":\n        case \"UCR\":\n        case \"UCR2\":\n        case \"TR2\":\n        case \"HT\":\n        case \"SM\":\n        case \"SA\":\n        case \"AIS\":\n        case \"TK\":\n          info(\"graphic state operator \" + a);\n          break;\n        default:\n          info(\"Unknown graphic state operator \" + a);\n      }\n    }\n    await h;\n    C.length > 0 && i.addOp(NA, [C]);\n    c && n.set(a, o, C);\n  }\n  loadFont(e, t, i, a = null, s = null) {\n    const errorFont = async () => new TranslatedFont({\n      loadedName: \"g_font_error\",\n      font: new ErrorFont(`Font \"${e}\" is not available.`),\n      dict: t,\n      evaluatorOptions: this.options\n    });\n    let r;\n    if (t) t instanceof Ref && (r = t);else {\n      const t = i.get(\"Font\");\n      t && (r = t.getRaw(e));\n    }\n    if (r) {\n      if (this.type3FontRefs?.has(r)) return errorFont();\n      if (this.fontCache.has(r)) return this.fontCache.get(r);\n      try {\n        t = this.xref.fetchIfRef(r);\n      } catch (e) {\n        warn(`loadFont - lookup failed: \"${e}\".`);\n      }\n    }\n    if (!(t instanceof Dict)) {\n      if (!this.options.ignoreErrors && !this.parsingType3Font) {\n        warn(`Font \"${e}\" is not available.`);\n        return errorFont();\n      }\n      warn(`Font \"${e}\" is not available -- attempting to fallback to a default font.`);\n      t = a || PartialEvaluator.fallbackFontDict;\n    }\n    if (t.cacheKey && this.fontCache.has(t.cacheKey)) return this.fontCache.get(t.cacheKey);\n    const {\n      promise: n,\n      resolve: g\n    } = Promise.withResolvers();\n    let o;\n    try {\n      o = this.preEvaluateFont(t);\n      o.cssFontInfo = s;\n    } catch (e) {\n      warn(`loadFont - preEvaluateFont failed: \"${e}\".`);\n      return errorFont();\n    }\n    const {\n        descriptor: c,\n        hash: C\n      } = o,\n      h = r instanceof Ref;\n    let l;\n    if (C && c instanceof Dict) {\n      const e = c.fontAliases ||= Object.create(null);\n      if (e[C]) {\n        const t = e[C].aliasRef;\n        if (h && t && this.fontCache.has(t)) {\n          this.fontCache.putAlias(r, t);\n          return this.fontCache.get(r);\n        }\n      } else e[C] = {\n        fontID: this.idFactory.createFontId()\n      };\n      h && (e[C].aliasRef = r);\n      l = e[C].fontID;\n    } else l = this.idFactory.createFontId();\n    assert(l?.startsWith(\"f\"), 'The \"fontID\" must be (correctly) defined.');\n    if (h) this.fontCache.put(r, n);else {\n      t.cacheKey = `cacheKey_${l}`;\n      this.fontCache.put(t.cacheKey, n);\n    }\n    t.loadedName = `${this.idFactory.getDocId()}_${l}`;\n    this.translateFont(o).then(e => {\n      g(new TranslatedFont({\n        loadedName: t.loadedName,\n        font: e,\n        dict: t,\n        evaluatorOptions: this.options\n      }));\n    }).catch(e => {\n      warn(`loadFont - translateFont failed: \"${e}\".`);\n      g(new TranslatedFont({\n        loadedName: t.loadedName,\n        font: new ErrorFont(e instanceof Error ? e.message : e),\n        dict: t,\n        evaluatorOptions: this.options\n      }));\n    });\n    return n;\n  }\n  buildPath(e, t, i, a = !1) {\n    const s = e.length - 1;\n    i || (i = []);\n    if (s < 0 || e.fnArray[s] !== tt) {\n      if (a) {\n        warn(`Encountered path operator \"${t}\" inside of a text object.`);\n        e.addOp(GA, null);\n      }\n      let s;\n      switch (t) {\n        case KA:\n          const e = i[0] + i[2],\n            t = i[1] + i[3];\n          s = [Math.min(i[0], e), Math.min(i[1], t), Math.max(i[0], e), Math.max(i[1], t)];\n          break;\n        case MA:\n        case LA:\n          s = [i[0], i[1], i[0], i[1]];\n          break;\n        default:\n          s = [1 / 0, 1 / 0, -1 / 0, -1 / 0];\n      }\n      e.addOp(tt, [[t], i, s]);\n      a && e.addOp(xA, null);\n    } else {\n      const a = e.argsArray[s];\n      a[0].push(t);\n      a[1].push(...i);\n      const r = a[2];\n      switch (t) {\n        case KA:\n          const e = i[0] + i[2],\n            t = i[1] + i[3];\n          r[0] = Math.min(r[0], i[0], e);\n          r[1] = Math.min(r[1], i[1], t);\n          r[2] = Math.max(r[2], i[0], e);\n          r[3] = Math.max(r[3], i[1], t);\n          break;\n        case MA:\n        case LA:\n          r[0] = Math.min(r[0], i[0]);\n          r[1] = Math.min(r[1], i[1]);\n          r[2] = Math.max(r[2], i[0]);\n          r[3] = Math.max(r[3], i[1]);\n      }\n    }\n  }\n  parseColorSpace({\n    cs: e,\n    resources: t,\n    localColorSpaceCache: i\n  }) {\n    return ColorSpace.parseAsync({\n      cs: e,\n      xref: this.xref,\n      resources: t,\n      pdfFunctionFactory: this._pdfFunctionFactory,\n      localColorSpaceCache: i\n    }).catch(e => {\n      if (e instanceof AbortException) return null;\n      if (this.options.ignoreErrors) {\n        warn(`parseColorSpace - ignoring ColorSpace: \"${e}\".`);\n        return null;\n      }\n      throw e;\n    });\n  }\n  parseShading({\n    shading: e,\n    resources: t,\n    localColorSpaceCache: i,\n    localShadingPatternCache: a\n  }) {\n    let s,\n      r = a.get(e);\n    if (r) return r;\n    try {\n      s = Pattern.parseShading(e, this.xref, t, this._pdfFunctionFactory, i).getIR();\n    } catch (t) {\n      if (t instanceof AbortException) return null;\n      if (this.options.ignoreErrors) {\n        warn(`parseShading - ignoring shading: \"${t}\".`);\n        a.set(e, null);\n        return null;\n      }\n      throw t;\n    }\n    r = `pattern_${this.idFactory.createObjId()}`;\n    this.parsingType3Font && (r = `${this.idFactory.getDocId()}_type3_${r}`);\n    a.set(e, r);\n    this.parsingType3Font ? this.handler.send(\"commonobj\", [r, \"Pattern\", s]) : this.handler.send(\"obj\", [r, this.pageIndex, \"Pattern\", s]);\n    return r;\n  }\n  handleColorN(e, t, i, a, s, r, n, g, o, c) {\n    const C = i.pop();\n    if (C instanceof Name) {\n      const h = s.getRaw(C.name),\n        l = h instanceof Ref && o.getByRef(h);\n      if (l) try {\n        const s = a.base ? a.base.getRgb(i, 0) : null,\n          r = getTilingPatternIR(l.operatorListIR, l.dict, s);\n        e.addOp(t, r);\n        return;\n      } catch {}\n      const Q = this.xref.fetchIfRef(h);\n      if (Q) {\n        const s = Q instanceof BaseStream ? Q.dict : Q,\n          C = s.get(\"PatternType\");\n        if (C === Fs) {\n          const g = a.base ? a.base.getRgb(i, 0) : null;\n          return this.handleTilingType(t, g, r, Q, s, e, n, o);\n        }\n        if (C === Ss) {\n          const i = s.get(\"Shading\"),\n            a = this.parseShading({\n              shading: i,\n              resources: r,\n              localColorSpaceCache: g,\n              localShadingPatternCache: c\n            });\n          if (a) {\n            const i = lookupMatrix(s.getArray(\"Matrix\"), null);\n            e.addOp(t, [\"Shading\", a, i]);\n          }\n          return;\n        }\n        throw new FormatError(`Unknown PatternType: ${C}`);\n      }\n    }\n    throw new FormatError(`Unknown PatternName: ${C}`);\n  }\n  _parseVisibilityExpression(e, t, i) {\n    if (++t > 10) {\n      warn(\"Visibility expression is too deeply nested\");\n      return;\n    }\n    const a = e.length,\n      s = this.xref.fetchIfRef(e[0]);\n    if (!(a < 2) && s instanceof Name) {\n      switch (s.name) {\n        case \"And\":\n        case \"Or\":\n        case \"Not\":\n          i.push(s.name);\n          break;\n        default:\n          warn(`Invalid operator ${s.name} in visibility expression`);\n          return;\n      }\n      for (let s = 1; s < a; s++) {\n        const a = e[s],\n          r = this.xref.fetchIfRef(a);\n        if (Array.isArray(r)) {\n          const e = [];\n          i.push(e);\n          this._parseVisibilityExpression(r, t, e);\n        } else a instanceof Ref && i.push(a.toString());\n      }\n    } else warn(\"Invalid visibility expression\");\n  }\n  async parseMarkedContentProps(e, t) {\n    let i;\n    if (e instanceof Name) {\n      i = t.get(\"Properties\").get(e.name);\n    } else {\n      if (!(e instanceof Dict)) throw new FormatError(\"Optional content properties malformed.\");\n      i = e;\n    }\n    const a = i.get(\"Type\")?.name;\n    if (\"OCG\" === a) return {\n      type: a,\n      id: i.objId\n    };\n    if (\"OCMD\" === a) {\n      const e = i.get(\"VE\");\n      if (Array.isArray(e)) {\n        const t = [];\n        this._parseVisibilityExpression(e, 0, t);\n        if (t.length > 0) return {\n          type: \"OCMD\",\n          expression: t\n        };\n      }\n      const t = i.get(\"OCGs\");\n      if (Array.isArray(t) || t instanceof Dict) {\n        const e = [];\n        if (Array.isArray(t)) for (const i of t) e.push(i.toString());else e.push(t.objId);\n        return {\n          type: a,\n          ids: e,\n          policy: i.get(\"P\") instanceof Name ? i.get(\"P\").name : null,\n          expression: null\n        };\n      }\n      if (t instanceof Ref) return {\n        type: a,\n        id: t.toString()\n      };\n    }\n    return null;\n  }\n  getOperatorList({\n    stream: e,\n    task: t,\n    resources: i,\n    operatorList: a,\n    initialState: s = null,\n    fallbackFontDict: r = null\n  }) {\n    i ||= Dict.empty;\n    s ||= new EvalState();\n    if (!a) throw new Error('getOperatorList: missing \"operatorList\" parameter');\n    const n = this,\n      g = this.xref;\n    let o = !1;\n    const c = new LocalImageCache(),\n      C = new LocalColorSpaceCache(),\n      h = new LocalGStateCache(),\n      l = new LocalTilingPatternCache(),\n      Q = new Map(),\n      E = i.get(\"XObject\") || Dict.empty,\n      u = i.get(\"Pattern\") || Dict.empty,\n      d = new StateManager(s),\n      f = new EvaluatorPreprocessor(e, g, d),\n      p = new TimeSlotManager();\n    function closePendingRestoreOPS(e) {\n      for (let e = 0, t = f.savedStatesDepth; e < t; e++) a.addOp(xA, []);\n    }\n    return new Promise(function promiseBody(e, s) {\n      const next = function (t) {\n        Promise.all([t, a.ready]).then(function () {\n          try {\n            promiseBody(e, s);\n          } catch (e) {\n            s(e);\n          }\n        }, s);\n      };\n      t.ensureNotTerminated();\n      p.reset();\n      const m = {};\n      let y, w, D, b, F, S;\n      for (; !(y = p.check());) {\n        m.args = null;\n        if (!f.read(m)) break;\n        let e = m.args,\n          s = m.fn;\n        switch (0 | s) {\n          case Ue:\n            S = e[0] instanceof Name;\n            F = e[0].name;\n            if (S) {\n              const t = c.getByName(F);\n              if (t) {\n                addLocallyCachedImageOps(a, t);\n                e = null;\n                continue;\n              }\n            }\n            next(new Promise(function (e, s) {\n              if (!S) throw new FormatError(\"XObject must be referred to by name.\");\n              let r = E.getRaw(F);\n              if (r instanceof Ref) {\n                const t = c.getByRef(r) || n._regionalImageCache.getByRef(r);\n                if (t) {\n                  addLocallyCachedImageOps(a, t);\n                  e();\n                  return;\n                }\n                const i = n.globalImageCache.getData(r, n.pageIndex);\n                if (i) {\n                  a.addDependency(i.objId);\n                  a.addImageOps(i.fn, i.args, i.optionalContent);\n                  e();\n                  return;\n                }\n                r = g.fetch(r);\n              }\n              if (!(r instanceof BaseStream)) throw new FormatError(\"XObject should be a stream\");\n              const o = r.dict.get(\"Subtype\");\n              if (!(o instanceof Name)) throw new FormatError(\"XObject should have a Name subtype\");\n              if (\"Form\" !== o.name) {\n                if (\"Image\" !== o.name) {\n                  if (\"PS\" !== o.name) throw new FormatError(`Unhandled XObject subtype ${o.name}`);\n                  info(\"Ignored XObject subtype PS\");\n                  e();\n                } else n.buildPaintImageXObject({\n                  resources: i,\n                  image: r,\n                  operatorList: a,\n                  cacheKey: F,\n                  localImageCache: c,\n                  localColorSpaceCache: C\n                }).then(e, s);\n              } else {\n                d.save();\n                n.buildFormXObject(i, r, null, a, t, d.state.clone(), C).then(function () {\n                  d.restore();\n                  e();\n                }, s);\n              }\n            }).catch(function (e) {\n              if (!(e instanceof AbortException)) {\n                if (!n.options.ignoreErrors) throw e;\n                warn(`getOperatorList - ignoring XObject: \"${e}\".`);\n              }\n            }));\n            return;\n          case se:\n            var k = e[1];\n            next(n.handleSetFont(i, e, null, a, t, d.state, r).then(function (e) {\n              a.addDependency(e);\n              a.addOp(se, [e, k]);\n            }));\n            return;\n          case $A:\n            o = !0;\n            break;\n          case Ae:\n            o = !1;\n            break;\n          case xe:\n            var R = e[0].cacheKey;\n            if (R) {\n              const t = c.getByName(R);\n              if (t) {\n                addLocallyCachedImageOps(a, t);\n                e = null;\n                continue;\n              }\n            }\n            next(n.buildPaintImageXObject({\n              resources: i,\n              image: e[0],\n              isInline: !0,\n              operatorList: a,\n              cacheKey: R,\n              localImageCache: c,\n              localColorSpaceCache: C\n            }));\n            return;\n          case Ce:\n            if (!d.state.font) {\n              n.ensureStateFont(d.state);\n              continue;\n            }\n            e[0] = n.handleText(e[0], d.state);\n            break;\n          case he:\n            if (!d.state.font) {\n              n.ensureStateFont(d.state);\n              continue;\n            }\n            var N = [],\n              G = d.state;\n            for (const t of e[0]) \"string\" == typeof t ? N.push(...n.handleText(t, G)) : \"number\" == typeof t && N.push(t);\n            e[0] = N;\n            s = Ce;\n            break;\n          case Be:\n            if (!d.state.font) {\n              n.ensureStateFont(d.state);\n              continue;\n            }\n            a.addOp(ce);\n            e[0] = n.handleText(e[0], d.state);\n            s = Ce;\n            break;\n          case le:\n            if (!d.state.font) {\n              n.ensureStateFont(d.state);\n              continue;\n            }\n            a.addOp(ce);\n            a.addOp(te, [e.shift()]);\n            a.addOp(ee, [e.shift()]);\n            e[0] = n.handleText(e[0], d.state);\n            s = Ce;\n            break;\n          case re:\n            d.state.textRenderingMode = e[0];\n            break;\n          case de:\n            {\n              const t = ColorSpace.getCached(e[0], g, C);\n              if (t) {\n                d.state.fillColorSpace = t;\n                continue;\n              }\n              next(n.parseColorSpace({\n                cs: e[0],\n                resources: i,\n                localColorSpaceCache: C\n              }).then(function (e) {\n                e && (d.state.fillColorSpace = e);\n              }));\n              return;\n            }\n          case ue:\n            {\n              const t = ColorSpace.getCached(e[0], g, C);\n              if (t) {\n                d.state.strokeColorSpace = t;\n                continue;\n              }\n              next(n.parseColorSpace({\n                cs: e[0],\n                resources: i,\n                localColorSpaceCache: C\n              }).then(function (e) {\n                e && (d.state.strokeColorSpace = e);\n              }));\n              return;\n            }\n          case me:\n            b = d.state.fillColorSpace;\n            e = b.getRgb(e, 0);\n            s = Fe;\n            break;\n          case fe:\n            b = d.state.strokeColorSpace;\n            e = b.getRgb(e, 0);\n            s = be;\n            break;\n          case De:\n            d.state.fillColorSpace = ColorSpace.singletons.gray;\n            e = ColorSpace.singletons.gray.getRgb(e, 0);\n            s = Fe;\n            break;\n          case we:\n            d.state.strokeColorSpace = ColorSpace.singletons.gray;\n            e = ColorSpace.singletons.gray.getRgb(e, 0);\n            s = be;\n            break;\n          case ke:\n            d.state.fillColorSpace = ColorSpace.singletons.cmyk;\n            e = ColorSpace.singletons.cmyk.getRgb(e, 0);\n            s = Fe;\n            break;\n          case Se:\n            d.state.strokeColorSpace = ColorSpace.singletons.cmyk;\n            e = ColorSpace.singletons.cmyk.getRgb(e, 0);\n            s = be;\n            break;\n          case Fe:\n            d.state.fillColorSpace = ColorSpace.singletons.rgb;\n            e = ColorSpace.singletons.rgb.getRgb(e, 0);\n            break;\n          case be:\n            d.state.strokeColorSpace = ColorSpace.singletons.rgb;\n            e = ColorSpace.singletons.rgb.getRgb(e, 0);\n            break;\n          case ye:\n            b = d.state.fillColorSpace;\n            if (\"Pattern\" === b.name) {\n              next(n.handleColorN(a, ye, e, b, u, i, t, C, l, Q));\n              return;\n            }\n            e = b.getRgb(e, 0);\n            s = Fe;\n            break;\n          case pe:\n            b = d.state.strokeColorSpace;\n            if (\"Pattern\" === b.name) {\n              next(n.handleColorN(a, pe, e, b, u, i, t, C, l, Q));\n              return;\n            }\n            e = b.getRgb(e, 0);\n            s = be;\n            break;\n          case Re:\n            var x = i.get(\"Shading\");\n            if (!x) throw new FormatError(\"No shading resource found\");\n            var U = x.get(e[0].name);\n            if (!U) throw new FormatError(\"No shading object found\");\n            const f = n.parseShading({\n              shading: U,\n              resources: i,\n              localColorSpaceCache: C,\n              localShadingPatternCache: Q\n            });\n            if (!f) continue;\n            e = [f];\n            s = Re;\n            break;\n          case NA:\n            S = e[0] instanceof Name;\n            F = e[0].name;\n            if (S) {\n              const t = h.getByName(F);\n              if (t) {\n                t.length > 0 && a.addOp(NA, [t]);\n                e = null;\n                continue;\n              }\n            }\n            next(new Promise(function (e, s) {\n              if (!S) throw new FormatError(\"GState must be referred to by name.\");\n              const r = i.get(\"ExtGState\");\n              if (!(r instanceof Dict)) throw new FormatError(\"ExtGState should be a dictionary.\");\n              const g = r.get(F);\n              if (!(g instanceof Dict)) throw new FormatError(\"GState should be a dictionary.\");\n              n.setGState({\n                resources: i,\n                gState: g,\n                operatorList: a,\n                cacheKey: F,\n                task: t,\n                stateManager: d,\n                localGStateCache: h,\n                localColorSpaceCache: C\n              }).then(e, s);\n            }).catch(function (e) {\n              if (!(e instanceof AbortException)) {\n                if (!n.options.ignoreErrors) throw e;\n                warn(`getOperatorList - ignoring ExtGState: \"${e}\".`);\n              }\n            }));\n            return;\n          case MA:\n          case LA:\n          case HA:\n          case JA:\n          case YA:\n          case vA:\n          case KA:\n            n.buildPath(a, s, e, o);\n            continue;\n          case Me:\n          case Le:\n          case ve:\n          case Ke:\n            continue;\n          case Je:\n            if (!(e[0] instanceof Name)) {\n              warn(`Expected name for beginMarkedContentProps arg0=${e[0]}`);\n              a.addOp(Je, [\"OC\", null]);\n              continue;\n            }\n            if (\"OC\" === e[0].name) {\n              next(n.parseMarkedContentProps(e[1], i).then(e => {\n                a.addOp(Je, [\"OC\", e]);\n              }).catch(e => {\n                if (!(e instanceof AbortException)) {\n                  if (!n.options.ignoreErrors) throw e;\n                  warn(`getOperatorList - ignoring beginMarkedContentProps: \"${e}\".`);\n                  a.addOp(Je, [\"OC\", null]);\n                }\n              }));\n              return;\n            }\n            e = [e[0].name, e[1] instanceof Dict ? e[1].get(\"MCID\") : null];\n            break;\n          default:\n            if (null !== e) {\n              for (w = 0, D = e.length; w < D && !(e[w] instanceof Dict); w++);\n              if (w < D) {\n                warn(\"getOperatorList - ignoring operator: \" + s);\n                continue;\n              }\n            }\n        }\n        a.addOp(s, e);\n      }\n      if (y) next(ks);else {\n        closePendingRestoreOPS();\n        e();\n      }\n    }).catch(e => {\n      if (!(e instanceof AbortException)) {\n        if (!this.options.ignoreErrors) throw e;\n        warn(`getOperatorList - ignoring errors during \"${t.name}\" task: \"${e}\".`);\n        closePendingRestoreOPS();\n      }\n    });\n  }\n  getTextContent({\n    stream: e,\n    task: t,\n    resources: s,\n    stateManager: r = null,\n    includeMarkedContent: n = !1,\n    sink: g,\n    seenStyles: o = new Set(),\n    viewBox: c,\n    lang: C = null,\n    markedContentData: h = null,\n    disableNormalization: l = !1,\n    keepWhiteSpace: Q = !1\n  }) {\n    s ||= Dict.empty;\n    r ||= new StateManager(new TextState());\n    n && (h ||= {\n      level: 0\n    });\n    const E = {\n        items: [],\n        styles: Object.create(null),\n        lang: C\n      },\n      u = {\n        initialized: !1,\n        str: [],\n        totalWidth: 0,\n        totalHeight: 0,\n        width: 0,\n        height: 0,\n        vertical: !1,\n        prevTransform: null,\n        textAdvanceScale: 0,\n        spaceInFlowMin: 0,\n        spaceInFlowMax: 0,\n        trackingSpaceMin: 1 / 0,\n        negativeSpaceMax: -1 / 0,\n        notASpace: -1 / 0,\n        transform: null,\n        fontName: null,\n        hasEOL: !1\n      },\n      d = [\" \", \" \"];\n    let f = 0;\n    function saveLastChar(e) {\n      const t = (f + 1) % 2,\n        i = \" \" !== d[f] && \" \" === d[t];\n      d[f] = e;\n      f = t;\n      return !Q && i;\n    }\n    function shouldAddWhitepsace() {\n      return !Q && \" \" !== d[f] && \" \" === d[(f + 1) % 2];\n    }\n    function resetLastChars() {\n      d[0] = d[1] = \" \";\n      f = 0;\n    }\n    const p = this,\n      m = this.xref,\n      y = [];\n    let w = null;\n    const D = new LocalImageCache(),\n      b = new LocalGStateCache(),\n      F = new EvaluatorPreprocessor(e, m, r);\n    let S;\n    function pushWhitespace({\n      width: e = 0,\n      height: t = 0,\n      transform: i = u.prevTransform,\n      fontName: a = u.fontName\n    }) {\n      E.items.push({\n        str: \" \",\n        dir: \"ltr\",\n        width: e,\n        height: t,\n        transform: i,\n        fontName: a,\n        hasEOL: !1\n      });\n    }\n    function getCurrentTextTransform() {\n      const e = S.font,\n        t = [S.fontSize * S.textHScale, 0, 0, S.fontSize, 0, S.textRise];\n      if (e.isType3Font && (S.fontSize <= 1 || e.isCharBBox) && !isArrayEqual(S.fontMatrix, a)) {\n        const i = e.bbox[3] - e.bbox[1];\n        i > 0 && (t[3] *= i * S.fontMatrix[3]);\n      }\n      return Util.transform(S.ctm, Util.transform(S.textMatrix, t));\n    }\n    function ensureTextContentItem() {\n      if (u.initialized) return u;\n      const {\n        font: e,\n        loadedName: t\n      } = S;\n      if (!o.has(t)) {\n        o.add(t);\n        E.styles[t] = {\n          fontFamily: e.fallbackName,\n          ascent: e.ascent,\n          descent: e.descent,\n          vertical: e.vertical\n        };\n        if (p.options.fontExtraProperties && e.systemFontInfo) {\n          const i = E.styles[t];\n          i.fontSubstitution = e.systemFontInfo.css;\n          i.fontSubstitutionLoadedName = e.systemFontInfo.loadedName;\n        }\n      }\n      u.fontName = t;\n      const i = u.transform = getCurrentTextTransform();\n      if (e.vertical) {\n        u.width = u.totalWidth = Math.hypot(i[0], i[1]);\n        u.height = u.totalHeight = 0;\n        u.vertical = !0;\n      } else {\n        u.width = u.totalWidth = 0;\n        u.height = u.totalHeight = Math.hypot(i[2], i[3]);\n        u.vertical = !1;\n      }\n      const a = Math.hypot(S.textLineMatrix[0], S.textLineMatrix[1]),\n        s = Math.hypot(S.ctm[0], S.ctm[1]);\n      u.textAdvanceScale = s * a;\n      const {\n        fontSize: r\n      } = S;\n      u.trackingSpaceMin = .102 * r;\n      u.notASpace = .03 * r;\n      u.negativeSpaceMax = -.2 * r;\n      u.spaceInFlowMin = .102 * r;\n      u.spaceInFlowMax = .6 * r;\n      u.hasEOL = !1;\n      u.initialized = !0;\n      return u;\n    }\n    function updateAdvanceScale() {\n      if (!u.initialized) return;\n      const e = Math.hypot(S.textLineMatrix[0], S.textLineMatrix[1]),\n        t = Math.hypot(S.ctm[0], S.ctm[1]) * e;\n      if (t !== u.textAdvanceScale) {\n        if (u.vertical) {\n          u.totalHeight += u.height * u.textAdvanceScale;\n          u.height = 0;\n        } else {\n          u.totalWidth += u.width * u.textAdvanceScale;\n          u.width = 0;\n        }\n        u.textAdvanceScale = t;\n      }\n    }\n    function runBidiTransform(e) {\n      let t = e.str.join(\"\");\n      l || (t = function normalizeUnicode(e) {\n        if (!ot) {\n          ot = /([\\u00a0\\u00b5\\u037e\\u0eb3\\u2000-\\u200a\\u202f\\u2126\\ufb00-\\ufb04\\ufb06\\ufb20-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufba1\\ufba4-\\ufba9\\ufbae-\\ufbb1\\ufbd3-\\ufbdc\\ufbde-\\ufbe7\\ufbea-\\ufbf8\\ufbfc-\\ufbfd\\ufc00-\\ufc5d\\ufc64-\\ufcf1\\ufcf5-\\ufd3d\\ufd88\\ufdf4\\ufdfa-\\ufdfb\\ufe71\\ufe77\\ufe79\\ufe7b\\ufe7d]+)|(\\ufb05+)/gu;\n          It = new Map([[\"ﬅ\", \"ſt\"]]);\n        }\n        return e.replaceAll(ot, (e, t, i) => t ? t.normalize(\"NFKC\") : It.get(i));\n      }(t));\n      const i = bidi(t, -1, e.vertical);\n      return {\n        str: i.str,\n        dir: i.dir,\n        width: Math.abs(e.totalWidth),\n        height: Math.abs(e.totalHeight),\n        transform: e.transform,\n        fontName: e.fontName,\n        hasEOL: e.hasEOL\n      };\n    }\n    async function handleSetFont(e, i) {\n      const r = await p.loadFont(e, i, s);\n      if (r.font.isType3Font) try {\n        await r.loadType3Data(p, s, t);\n      } catch {}\n      S.loadedName = r.loadedName;\n      S.font = r.font;\n      S.fontMatrix = r.font.fontMatrix || a;\n    }\n    function applyInverseRotation(e, t, i) {\n      const a = Math.hypot(i[0], i[1]);\n      return [(i[0] * e + i[1] * t) / a, (i[2] * e + i[3] * t) / a];\n    }\n    function compareWithLastPosition(e) {\n      const t = getCurrentTextTransform();\n      let i = t[4],\n        a = t[5];\n      if (S.font?.vertical) {\n        if (i < c[0] || i > c[2] || a + e < c[1] || a > c[3]) return !1;\n      } else if (i + e < c[0] || i > c[2] || a < c[1] || a > c[3]) return !1;\n      if (!S.font || !u.prevTransform) return !0;\n      let s = u.prevTransform[4],\n        r = u.prevTransform[5];\n      if (s === i && r === a) return !0;\n      let n = -1;\n      t[0] && 0 === t[1] && 0 === t[2] ? n = t[0] > 0 ? 0 : 180 : t[1] && 0 === t[0] && 0 === t[3] && (n = t[1] > 0 ? 90 : 270);\n      switch (n) {\n        case 0:\n          break;\n        case 90:\n          [i, a] = [a, i];\n          [s, r] = [r, s];\n          break;\n        case 180:\n          [i, a, s, r] = [-i, -a, -s, -r];\n          break;\n        case 270:\n          [i, a] = [-a, -i];\n          [s, r] = [-r, -s];\n          break;\n        default:\n          [i, a] = applyInverseRotation(i, a, t);\n          [s, r] = applyInverseRotation(s, r, u.prevTransform);\n      }\n      if (S.font.vertical) {\n        const e = (r - a) / u.textAdvanceScale,\n          t = i - s,\n          n = Math.sign(u.height);\n        if (e < n * u.negativeSpaceMax) {\n          if (Math.abs(t) > .5 * u.width) {\n            appendEOL();\n            return !0;\n          }\n          resetLastChars();\n          flushTextContentItem();\n          return !0;\n        }\n        if (Math.abs(t) > u.width) {\n          appendEOL();\n          return !0;\n        }\n        e <= n * u.notASpace && resetLastChars();\n        if (e <= n * u.trackingSpaceMin) {\n          if (shouldAddWhitepsace()) {\n            resetLastChars();\n            flushTextContentItem();\n            pushWhitespace({\n              height: Math.abs(e)\n            });\n          } else u.height += e;\n        } else if (!addFakeSpaces(e, u.prevTransform, n)) if (0 === u.str.length) {\n          resetLastChars();\n          pushWhitespace({\n            height: Math.abs(e)\n          });\n        } else u.height += e;\n        Math.abs(t) > .25 * u.width && flushTextContentItem();\n        return !0;\n      }\n      const g = (i - s) / u.textAdvanceScale,\n        o = a - r,\n        C = Math.sign(u.width);\n      if (g < C * u.negativeSpaceMax) {\n        if (Math.abs(o) > .5 * u.height) {\n          appendEOL();\n          return !0;\n        }\n        resetLastChars();\n        flushTextContentItem();\n        return !0;\n      }\n      if (Math.abs(o) > u.height) {\n        appendEOL();\n        return !0;\n      }\n      g <= C * u.notASpace && resetLastChars();\n      if (g <= C * u.trackingSpaceMin) {\n        if (shouldAddWhitepsace()) {\n          resetLastChars();\n          flushTextContentItem();\n          pushWhitespace({\n            width: Math.abs(g)\n          });\n        } else u.width += g;\n      } else if (!addFakeSpaces(g, u.prevTransform, C)) if (0 === u.str.length) {\n        resetLastChars();\n        pushWhitespace({\n          width: Math.abs(g)\n        });\n      } else u.width += g;\n      Math.abs(o) > .25 * u.height && flushTextContentItem();\n      return !0;\n    }\n    function buildTextContentItem({\n      chars: e,\n      extraSpacing: t\n    }) {\n      const i = S.font;\n      if (!e) {\n        const e = S.charSpacing + t;\n        e && (i.vertical ? S.translateTextMatrix(0, -e) : S.translateTextMatrix(e * S.textHScale, 0));\n        Q && compareWithLastPosition(0);\n        return;\n      }\n      const a = i.charsToGlyphs(e),\n        s = S.fontMatrix[0] * S.fontSize;\n      for (let e = 0, r = a.length; e < r; e++) {\n        const n = a[e],\n          {\n            category: g\n          } = n;\n        if (g.isInvisibleFormatMark) continue;\n        let o = S.charSpacing + (e + 1 === r ? t : 0),\n          c = n.width;\n        i.vertical && (c = n.vmetric ? n.vmetric[0] : -c);\n        let C = c * s;\n        if (!Q && g.isWhitespace) {\n          if (i.vertical) {\n            o += -C + S.wordSpacing;\n            S.translateTextMatrix(0, -o);\n          } else {\n            o += C + S.wordSpacing;\n            S.translateTextMatrix(o * S.textHScale, 0);\n          }\n          saveLastChar(\" \");\n          continue;\n        }\n        if (!g.isZeroWidthDiacritic && !compareWithLastPosition(C)) {\n          i.vertical ? S.translateTextMatrix(0, C) : S.translateTextMatrix(C * S.textHScale, 0);\n          continue;\n        }\n        const h = ensureTextContentItem();\n        g.isZeroWidthDiacritic && (C = 0);\n        if (i.vertical) {\n          S.translateTextMatrix(0, C);\n          C = Math.abs(C);\n          h.height += C;\n        } else {\n          C *= S.textHScale;\n          S.translateTextMatrix(C, 0);\n          h.width += C;\n        }\n        C && (h.prevTransform = getCurrentTextTransform());\n        const l = n.unicode;\n        saveLastChar(l) && h.str.push(\" \");\n        h.str.push(l);\n        o && (i.vertical ? S.translateTextMatrix(0, -o) : S.translateTextMatrix(o * S.textHScale, 0));\n      }\n    }\n    function appendEOL() {\n      resetLastChars();\n      if (u.initialized) {\n        u.hasEOL = !0;\n        flushTextContentItem();\n      } else E.items.push({\n        str: \"\",\n        dir: \"ltr\",\n        width: 0,\n        height: 0,\n        transform: getCurrentTextTransform(),\n        fontName: S.loadedName,\n        hasEOL: !0\n      });\n    }\n    function addFakeSpaces(e, t, i) {\n      if (i * u.spaceInFlowMin <= e && e <= i * u.spaceInFlowMax) {\n        if (u.initialized) {\n          resetLastChars();\n          u.str.push(\" \");\n        }\n        return !1;\n      }\n      const a = u.fontName;\n      let s = 0;\n      if (u.vertical) {\n        s = e;\n        e = 0;\n      }\n      flushTextContentItem();\n      resetLastChars();\n      pushWhitespace({\n        width: Math.abs(e),\n        height: Math.abs(s),\n        transform: t || getCurrentTextTransform(),\n        fontName: a\n      });\n      return !0;\n    }\n    function flushTextContentItem() {\n      if (u.initialized && u.str) {\n        u.vertical ? u.totalHeight += u.height * u.textAdvanceScale : u.totalWidth += u.width * u.textAdvanceScale;\n        E.items.push(runBidiTransform(u));\n        u.initialized = !1;\n        u.str.length = 0;\n      }\n    }\n    function enqueueChunk(e = !1) {\n      const t = E.items.length;\n      if (0 !== t && !(e && t < 10)) {\n        g.enqueue(E, t);\n        E.items = [];\n        E.styles = Object.create(null);\n      }\n    }\n    const k = new TimeSlotManager();\n    return new Promise(function promiseBody(e, a) {\n      const next = function (t) {\n        enqueueChunk(!0);\n        Promise.all([t, g.ready]).then(function () {\n          try {\n            promiseBody(e, a);\n          } catch (e) {\n            a(e);\n          }\n        }, a);\n      };\n      t.ensureNotTerminated();\n      k.reset();\n      const u = {};\n      let d,\n        f = [];\n      for (; !(d = k.check());) {\n        f.length = 0;\n        u.args = f;\n        if (!F.read(u)) break;\n        const e = S;\n        S = r.state;\n        const a = u.fn;\n        f = u.args;\n        switch (0 | a) {\n          case se:\n            var R = f[0].name,\n              N = f[1];\n            if (S.font && R === S.fontName && N === S.fontSize) break;\n            flushTextContentItem();\n            S.fontName = R;\n            S.fontSize = N;\n            next(handleSetFont(R, null));\n            return;\n          case ne:\n            S.textRise = f[0];\n            break;\n          case ie:\n            S.textHScale = f[0] / 100;\n            break;\n          case ae:\n            S.leading = f[0];\n            break;\n          case ge:\n            S.translateTextLineMatrix(f[0], f[1]);\n            S.textMatrix = S.textLineMatrix.slice();\n            break;\n          case oe:\n            S.leading = -f[1];\n            S.translateTextLineMatrix(f[0], f[1]);\n            S.textMatrix = S.textLineMatrix.slice();\n            break;\n          case ce:\n            S.carriageReturn();\n            break;\n          case Ie:\n            S.setTextMatrix(f[0], f[1], f[2], f[3], f[4], f[5]);\n            S.setTextLineMatrix(f[0], f[1], f[2], f[3], f[4], f[5]);\n            updateAdvanceScale();\n            break;\n          case ee:\n            S.charSpacing = f[0];\n            break;\n          case te:\n            S.wordSpacing = f[0];\n            break;\n          case $A:\n            S.textMatrix = i.slice();\n            S.textLineMatrix = i.slice();\n            break;\n          case he:\n            if (!r.state.font) {\n              p.ensureStateFont(r.state);\n              continue;\n            }\n            const a = (S.font.vertical ? 1 : -1) * S.fontSize / 1e3,\n              u = f[0];\n            for (let e = 0, t = u.length; e < t; e++) {\n              const t = u[e];\n              if (\"string\" == typeof t) y.push(t);else if (\"number\" == typeof t && 0 !== t) {\n                const e = y.join(\"\");\n                y.length = 0;\n                buildTextContentItem({\n                  chars: e,\n                  extraSpacing: t * a\n                });\n              }\n            }\n            if (y.length > 0) {\n              const e = y.join(\"\");\n              y.length = 0;\n              buildTextContentItem({\n                chars: e,\n                extraSpacing: 0\n              });\n            }\n            break;\n          case Ce:\n            if (!r.state.font) {\n              p.ensureStateFont(r.state);\n              continue;\n            }\n            buildTextContentItem({\n              chars: f[0],\n              extraSpacing: 0\n            });\n            break;\n          case Be:\n            if (!r.state.font) {\n              p.ensureStateFont(r.state);\n              continue;\n            }\n            S.carriageReturn();\n            buildTextContentItem({\n              chars: f[0],\n              extraSpacing: 0\n            });\n            break;\n          case le:\n            if (!r.state.font) {\n              p.ensureStateFont(r.state);\n              continue;\n            }\n            S.wordSpacing = f[0];\n            S.charSpacing = f[1];\n            S.carriageReturn();\n            buildTextContentItem({\n              chars: f[2],\n              extraSpacing: 0\n            });\n            break;\n          case Ue:\n            flushTextContentItem();\n            w || (w = s.get(\"XObject\") || Dict.empty);\n            var G = f[0] instanceof Name,\n              x = f[0].name;\n            if (G && D.getByName(x)) break;\n            next(new Promise(function (e, i) {\n              if (!G) throw new FormatError(\"XObject must be referred to by name.\");\n              let a = w.getRaw(x);\n              if (a instanceof Ref) {\n                if (D.getByRef(a)) {\n                  e();\n                  return;\n                }\n                if (p.globalImageCache.getData(a, p.pageIndex)) {\n                  e();\n                  return;\n                }\n                a = m.fetch(a);\n              }\n              if (!(a instanceof BaseStream)) throw new FormatError(\"XObject should be a stream\");\n              const E = a.dict.get(\"Subtype\");\n              if (!(E instanceof Name)) throw new FormatError(\"XObject should have a Name subtype\");\n              if (\"Form\" !== E.name) {\n                D.set(x, a.dict.objId, !0);\n                e();\n                return;\n              }\n              const u = r.state.clone(),\n                d = new StateManager(u),\n                f = lookupMatrix(a.dict.getArray(\"Matrix\"), null);\n              f && d.transform(f);\n              enqueueChunk();\n              const y = {\n                enqueueInvoked: !1,\n                enqueue(e, t) {\n                  this.enqueueInvoked = !0;\n                  g.enqueue(e, t);\n                },\n                get desiredSize() {\n                  return g.desiredSize;\n                },\n                get ready() {\n                  return g.ready;\n                }\n              };\n              p.getTextContent({\n                stream: a,\n                task: t,\n                resources: a.dict.get(\"Resources\") || s,\n                stateManager: d,\n                includeMarkedContent: n,\n                sink: y,\n                seenStyles: o,\n                viewBox: c,\n                lang: C,\n                markedContentData: h,\n                disableNormalization: l,\n                keepWhiteSpace: Q\n              }).then(function () {\n                y.enqueueInvoked || D.set(x, a.dict.objId, !0);\n                e();\n              }, i);\n            }).catch(function (e) {\n              if (!(e instanceof AbortException)) {\n                if (!p.options.ignoreErrors) throw e;\n                warn(`getTextContent - ignoring XObject: \"${e}\".`);\n              }\n            }));\n            return;\n          case NA:\n            G = f[0] instanceof Name;\n            x = f[0].name;\n            if (G && b.getByName(x)) break;\n            next(new Promise(function (e, t) {\n              if (!G) throw new FormatError(\"GState must be referred to by name.\");\n              const i = s.get(\"ExtGState\");\n              if (!(i instanceof Dict)) throw new FormatError(\"ExtGState should be a dictionary.\");\n              const a = i.get(x);\n              if (!(a instanceof Dict)) throw new FormatError(\"GState should be a dictionary.\");\n              const r = a.get(\"Font\");\n              if (r) {\n                flushTextContentItem();\n                S.fontName = null;\n                S.fontSize = r[1];\n                handleSetFont(null, r[0]).then(e, t);\n              } else {\n                b.set(x, a.objId, !0);\n                e();\n              }\n            }).catch(function (e) {\n              if (!(e instanceof AbortException)) {\n                if (!p.options.ignoreErrors) throw e;\n                warn(`getTextContent - ignoring ExtGState: \"${e}\".`);\n              }\n            }));\n            return;\n          case He:\n            flushTextContentItem();\n            if (n) {\n              h.level++;\n              E.items.push({\n                type: \"beginMarkedContent\",\n                tag: f[0] instanceof Name ? f[0].name : null\n              });\n            }\n            break;\n          case Je:\n            flushTextContentItem();\n            if (n) {\n              h.level++;\n              let e = null;\n              f[1] instanceof Dict && (e = f[1].get(\"MCID\"));\n              E.items.push({\n                type: \"beginMarkedContentProps\",\n                id: Number.isInteger(e) ? `${p.idFactory.getPageObjId()}_mc${e}` : null,\n                tag: f[0] instanceof Name ? f[0].name : null\n              });\n            }\n            break;\n          case Ye:\n            flushTextContentItem();\n            if (n) {\n              if (0 === h.level) break;\n              h.level--;\n              E.items.push({\n                type: \"endMarkedContent\"\n              });\n            }\n            break;\n          case xA:\n            !e || e.font === S.font && e.fontSize === S.fontSize && e.fontName === S.fontName || flushTextContentItem();\n        }\n        if (E.items.length >= g.desiredSize) {\n          d = !0;\n          break;\n        }\n      }\n      if (d) next(ks);else {\n        flushTextContentItem();\n        enqueueChunk();\n        e();\n      }\n    }).catch(e => {\n      if (!(e instanceof AbortException)) {\n        if (!this.options.ignoreErrors) throw e;\n        warn(`getTextContent - ignoring errors during \"${t.name}\" task: \"${e}\".`);\n        flushTextContentItem();\n        enqueueChunk();\n      }\n    });\n  }\n  async extractDataStructures(e, t) {\n    const i = this.xref;\n    let a;\n    const s = this.readToUnicode(t.toUnicode);\n    if (t.composite) {\n      const i = e.get(\"CIDSystemInfo\");\n      i instanceof Dict && (t.cidSystemInfo = {\n        registry: stringToPDFString(i.get(\"Registry\")),\n        ordering: stringToPDFString(i.get(\"Ordering\")),\n        supplement: i.get(\"Supplement\")\n      });\n      try {\n        const t = e.get(\"CIDToGIDMap\");\n        t instanceof BaseStream && (a = t.getBytes());\n      } catch (e) {\n        if (!this.options.ignoreErrors) throw e;\n        warn(`extractDataStructures - ignoring CIDToGIDMap data: \"${e}\".`);\n      }\n    }\n    const r = [];\n    let n,\n      g = null;\n    if (e.has(\"Encoding\")) {\n      n = e.get(\"Encoding\");\n      if (n instanceof Dict) {\n        g = n.get(\"BaseEncoding\");\n        g = g instanceof Name ? g.name : null;\n        if (n.has(\"Differences\")) {\n          const e = n.get(\"Differences\");\n          let t = 0;\n          for (const a of e) {\n            const e = i.fetchIfRef(a);\n            if (\"number\" == typeof e) t = e;else {\n              if (!(e instanceof Name)) throw new FormatError(`Invalid entry in 'Differences' array: ${e}`);\n              r[t++] = e.name;\n            }\n          }\n        }\n      } else if (n instanceof Name) g = n.name;else {\n        const e = \"Encoding is not a Name nor a Dict\";\n        if (!this.options.ignoreErrors) throw new FormatError(e);\n        warn(e);\n      }\n      \"MacRomanEncoding\" !== g && \"MacExpertEncoding\" !== g && \"WinAnsiEncoding\" !== g && (g = null);\n    }\n    const o = !t.file || t.isInternalFont,\n      c = Zi()[t.name];\n    g && o && c && (g = null);\n    if (g) t.defaultEncoding = getEncoding(g);else {\n      const e = !!(t.flags & Ti),\n        i = !!(t.flags & qi);\n      n = fi;\n      \"TrueType\" !== t.type || i || (n = pi);\n      if (e || c) {\n        n = di;\n        o && (/Symbol/i.test(t.name) ? n = mi : /Dingbats/i.test(t.name) ? n = yi : /Wingdings/i.test(t.name) && (n = pi));\n      }\n      t.defaultEncoding = n;\n    }\n    t.differences = r;\n    t.baseEncodingName = g;\n    t.hasEncoding = !!g || r.length > 0;\n    t.dict = e;\n    t.toUnicode = await s;\n    const C = await this.buildToUnicode(t);\n    t.toUnicode = C;\n    a && (t.cidToGidMap = this.readCidToGidMap(a, C));\n    return t;\n  }\n  _simpleFontToUnicode(e, t = !1) {\n    assert(!e.composite, \"Must be a simple font.\");\n    const i = [],\n      a = e.defaultEncoding.slice(),\n      s = e.baseEncodingName,\n      r = e.differences;\n    for (const e in r) {\n      const t = r[e];\n      \".notdef\" !== t && (a[e] = t);\n    }\n    const n = Ni();\n    for (const r in a) {\n      let g = a[r];\n      if (\"\" === g) continue;\n      let o = n[g];\n      if (void 0 !== o) {\n        i[r] = String.fromCharCode(o);\n        continue;\n      }\n      let c = 0;\n      switch (g[0]) {\n        case \"G\":\n          3 === g.length && (c = parseInt(g.substring(1), 16));\n          break;\n        case \"g\":\n          5 === g.length && (c = parseInt(g.substring(1), 16));\n          break;\n        case \"C\":\n        case \"c\":\n          if (g.length >= 3 && g.length <= 4) {\n            const i = g.substring(1);\n            if (t) {\n              c = parseInt(i, 16);\n              break;\n            }\n            c = +i;\n            if (Number.isNaN(c) && Number.isInteger(parseInt(i, 16))) return this._simpleFontToUnicode(e, !0);\n          }\n          break;\n        case \"u\":\n          o = getUnicodeForGlyph(g, n);\n          -1 !== o && (c = o);\n          break;\n        default:\n          switch (g) {\n            case \"f_h\":\n            case \"f_t\":\n            case \"T_h\":\n              i[r] = g.replaceAll(\"_\", \"\");\n              continue;\n          }\n      }\n      if (c > 0 && c <= 1114111 && Number.isInteger(c)) {\n        if (s && c === +r) {\n          const e = getEncoding(s);\n          if (e && (g = e[r])) {\n            i[r] = String.fromCharCode(n[g]);\n            continue;\n          }\n        }\n        i[r] = String.fromCodePoint(c);\n      }\n    }\n    return i;\n  }\n  async buildToUnicode(e) {\n    e.hasIncludedToUnicodeMap = e.toUnicode?.length > 0;\n    if (e.hasIncludedToUnicodeMap) {\n      !e.composite && e.hasEncoding && (e.fallbackToUnicode = this._simpleFontToUnicode(e));\n      return e.toUnicode;\n    }\n    if (!e.composite) return new ToUnicodeMap(this._simpleFontToUnicode(e));\n    if (e.composite && (e.cMap.builtInCMap && !(e.cMap instanceof IdentityCMap) || \"Adobe\" === e.cidSystemInfo?.registry && (\"GB1\" === e.cidSystemInfo.ordering || \"CNS1\" === e.cidSystemInfo.ordering || \"Japan1\" === e.cidSystemInfo.ordering || \"Korea1\" === e.cidSystemInfo.ordering))) {\n      const {\n          registry: t,\n          ordering: i\n        } = e.cidSystemInfo,\n        a = Name.get(`${t}-${i}-UCS2`),\n        s = await CMapFactory.create({\n          encoding: a,\n          fetchBuiltInCMap: this._fetchBuiltInCMapBound,\n          useCMap: null\n        }),\n        r = [],\n        n = [];\n      e.cMap.forEach(function (e, t) {\n        if (t > 65535) throw new FormatError(\"Max size of CID is 65,535\");\n        const i = s.lookup(t);\n        if (i) {\n          n.length = 0;\n          for (let e = 0, t = i.length; e < t; e += 2) n.push((i.charCodeAt(e) << 8) + i.charCodeAt(e + 1));\n          r[e] = String.fromCharCode(...n);\n        }\n      });\n      return new ToUnicodeMap(r);\n    }\n    return new IdentityToUnicodeMap(e.firstChar, e.lastChar);\n  }\n  async readToUnicode(e) {\n    if (!e) return null;\n    if (e instanceof Name) {\n      const t = await CMapFactory.create({\n        encoding: e,\n        fetchBuiltInCMap: this._fetchBuiltInCMapBound,\n        useCMap: null\n      });\n      return t instanceof IdentityCMap ? new IdentityToUnicodeMap(0, 65535) : new ToUnicodeMap(t.getMap());\n    }\n    if (e instanceof BaseStream) try {\n      const t = await CMapFactory.create({\n        encoding: e,\n        fetchBuiltInCMap: this._fetchBuiltInCMapBound,\n        useCMap: null\n      });\n      if (t instanceof IdentityCMap) return new IdentityToUnicodeMap(0, 65535);\n      const i = new Array(t.length);\n      t.forEach(function (e, t) {\n        if (\"number\" == typeof t) {\n          i[e] = String.fromCodePoint(t);\n          return;\n        }\n        const a = [];\n        for (let e = 0; e < t.length; e += 2) {\n          const i = t.charCodeAt(e) << 8 | t.charCodeAt(e + 1);\n          if (55296 != (63488 & i)) {\n            a.push(i);\n            continue;\n          }\n          e += 2;\n          const s = t.charCodeAt(e) << 8 | t.charCodeAt(e + 1);\n          a.push(((1023 & i) << 10) + (1023 & s) + 65536);\n        }\n        i[e] = String.fromCodePoint(...a);\n      });\n      return new ToUnicodeMap(i);\n    } catch (e) {\n      if (e instanceof AbortException) return null;\n      if (this.options.ignoreErrors) {\n        warn(`readToUnicode - ignoring ToUnicode data: \"${e}\".`);\n        return null;\n      }\n      throw e;\n    }\n    return null;\n  }\n  readCidToGidMap(e, t) {\n    const i = [];\n    for (let a = 0, s = e.length; a < s; a++) {\n      const s = e[a++] << 8 | e[a],\n        r = a >> 1;\n      (0 !== s || t.has(r)) && (i[r] = s);\n    }\n    return i;\n  }\n  extractWidths(e, t, i) {\n    const a = this.xref;\n    let s = [],\n      r = 0;\n    const n = [];\n    let g;\n    if (i.composite) {\n      const t = e.get(\"DW\");\n      r = \"number\" == typeof t ? Math.ceil(t) : 1e3;\n      const o = e.get(\"W\");\n      if (Array.isArray(o)) for (let e = 0, t = o.length; e < t; e++) {\n        let t = a.fetchIfRef(o[e++]);\n        if (!Number.isInteger(t)) break;\n        const i = a.fetchIfRef(o[e]);\n        if (Array.isArray(i)) for (const e of i) {\n          const i = a.fetchIfRef(e);\n          \"number\" == typeof i && (s[t] = i);\n          t++;\n        } else {\n          if (!Number.isInteger(i)) break;\n          {\n            const r = a.fetchIfRef(o[++e]);\n            if (\"number\" != typeof r) continue;\n            for (let e = t; e <= i; e++) s[e] = r;\n          }\n        }\n      }\n      if (i.vertical) {\n        const t = e.getArray(\"DW2\");\n        let i = isNumberArray(t, 2) ? t : [880, -1e3];\n        g = [i[1], .5 * r, i[0]];\n        i = e.get(\"W2\");\n        if (Array.isArray(i)) for (let e = 0, t = i.length; e < t; e++) {\n          let t = a.fetchIfRef(i[e++]);\n          if (!Number.isInteger(t)) break;\n          const s = a.fetchIfRef(i[e]);\n          if (Array.isArray(s)) for (let e = 0, i = s.length; e < i; e++) {\n            const i = [a.fetchIfRef(s[e++]), a.fetchIfRef(s[e++]), a.fetchIfRef(s[e])];\n            isNumberArray(i, null) && (n[t] = i);\n            t++;\n          } else {\n            if (!Number.isInteger(s)) break;\n            {\n              const r = [a.fetchIfRef(i[++e]), a.fetchIfRef(i[++e]), a.fetchIfRef(i[++e])];\n              if (!isNumberArray(r, null)) continue;\n              for (let e = t; e <= s; e++) n[e] = r;\n            }\n          }\n        }\n      }\n    } else {\n      const n = e.get(\"Widths\");\n      if (Array.isArray(n)) {\n        let e = i.firstChar;\n        for (const t of n) {\n          const i = a.fetchIfRef(t);\n          \"number\" == typeof i && (s[e] = i);\n          e++;\n        }\n        const g = t.get(\"MissingWidth\");\n        r = \"number\" == typeof g ? g : 0;\n      } else {\n        const t = e.get(\"BaseFont\");\n        if (t instanceof Name) {\n          const e = this.getBaseFontMetrics(t.name);\n          s = this.buildCharCodeToWidth(e.widths, i);\n          r = e.defaultWidth;\n        }\n      }\n    }\n    let o = !0,\n      c = r;\n    for (const e in s) {\n      const t = s[e];\n      if (t) if (c) {\n        if (c !== t) {\n          o = !1;\n          break;\n        }\n      } else c = t;\n    }\n    o ? i.flags |= vi : i.flags &= ~vi;\n    i.defaultWidth = r;\n    i.widths = s;\n    i.defaultVMetrics = g;\n    i.vmetrics = n;\n  }\n  isSerifFont(e) {\n    const t = e.split(\"-\", 1)[0];\n    return t in Xi() || /serif/gi.test(t);\n  }\n  getBaseFontMetrics(e) {\n    let t = 0,\n      i = Object.create(null),\n      a = !1;\n    let s = Pi()[e] || e;\n    const r = Aa();\n    s in r || (s = this.isSerifFont(e) ? \"Times-Roman\" : \"Helvetica\");\n    const n = r[s];\n    if (\"number\" == typeof n) {\n      t = n;\n      a = !0;\n    } else i = n();\n    return {\n      defaultWidth: t,\n      monospace: a,\n      widths: i\n    };\n  }\n  buildCharCodeToWidth(e, t) {\n    const i = Object.create(null),\n      a = t.differences,\n      s = t.defaultEncoding;\n    for (let t = 0; t < 256; t++) t in a && e[a[t]] ? i[t] = e[a[t]] : t in s && e[s[t]] && (i[t] = e[s[t]]);\n    return i;\n  }\n  preEvaluateFont(e) {\n    const t = e;\n    let i = e.get(\"Subtype\");\n    if (!(i instanceof Name)) throw new FormatError(\"invalid font Subtype\");\n    let a,\n      s = !1;\n    if (\"Type0\" === i.name) {\n      const t = e.get(\"DescendantFonts\");\n      if (!t) throw new FormatError(\"Descendant fonts are not specified\");\n      if (!((e = Array.isArray(t) ? this.xref.fetchIfRef(t[0]) : t) instanceof Dict)) throw new FormatError(\"Descendant font is not a dictionary.\");\n      i = e.get(\"Subtype\");\n      if (!(i instanceof Name)) throw new FormatError(\"invalid font Subtype\");\n      s = !0;\n    }\n    let r = e.get(\"FirstChar\");\n    Number.isInteger(r) || (r = 0);\n    let n = e.get(\"LastChar\");\n    Number.isInteger(n) || (n = s ? 65535 : 255);\n    const g = e.get(\"FontDescriptor\"),\n      o = e.get(\"ToUnicode\") || t.get(\"ToUnicode\");\n    if (g) {\n      a = new MurmurHash3_64();\n      const i = t.getRaw(\"Encoding\");\n      if (i instanceof Name) a.update(i.name);else if (i instanceof Ref) a.update(i.toString());else if (i instanceof Dict) for (const e of i.getRawValues()) if (e instanceof Name) a.update(e.name);else if (e instanceof Ref) a.update(e.toString());else if (Array.isArray(e)) {\n        const t = e.length,\n          i = new Array(t);\n        for (let a = 0; a < t; a++) {\n          const t = e[a];\n          t instanceof Name ? i[a] = t.name : (\"number\" == typeof t || t instanceof Ref) && (i[a] = t.toString());\n        }\n        a.update(i.join());\n      }\n      a.update(`${r}-${n}`);\n      if (o instanceof BaseStream) {\n        const e = o.str || o,\n          t = e.buffer ? new Uint8Array(e.buffer.buffer, 0, e.bufferLength) : new Uint8Array(e.bytes.buffer, e.start, e.end - e.start);\n        a.update(t);\n      } else o instanceof Name && a.update(o.name);\n      const g = e.get(\"Widths\") || t.get(\"Widths\");\n      if (Array.isArray(g)) {\n        const e = [];\n        for (const t of g) (\"number\" == typeof t || t instanceof Ref) && e.push(t.toString());\n        a.update(e.join());\n      }\n      if (s) {\n        a.update(\"compositeFont\");\n        const i = e.get(\"W\") || t.get(\"W\");\n        if (Array.isArray(i)) {\n          const e = [];\n          for (const t of i) if (\"number\" == typeof t || t instanceof Ref) e.push(t.toString());else if (Array.isArray(t)) {\n            const i = [];\n            for (const e of t) (\"number\" == typeof e || e instanceof Ref) && i.push(e.toString());\n            e.push(`[${i.join()}]`);\n          }\n          a.update(e.join());\n        }\n        const s = e.getRaw(\"CIDToGIDMap\") || t.getRaw(\"CIDToGIDMap\");\n        s instanceof Name ? a.update(s.name) : s instanceof Ref ? a.update(s.toString()) : s instanceof BaseStream && a.update(s.peekBytes());\n      }\n    }\n    return {\n      descriptor: g,\n      dict: e,\n      baseDict: t,\n      composite: s,\n      type: i.name,\n      firstChar: r,\n      lastChar: n,\n      toUnicode: o,\n      hash: a ? a.hexdigest() : \"\"\n    };\n  }\n  async translateFont({\n    descriptor: e,\n    dict: t,\n    baseDict: i,\n    composite: s,\n    type: r,\n    firstChar: n,\n    lastChar: g,\n    toUnicode: o,\n    cssFontInfo: c\n  }) {\n    const C = \"Type3\" === r;\n    if (!e) {\n      if (!C) {\n        let e = t.get(\"BaseFont\");\n        if (!(e instanceof Name)) throw new FormatError(\"Base font is not specified\");\n        e = e.name.replaceAll(/[,_]/g, \"-\");\n        const a = this.getBaseFontMetrics(e),\n          s = e.split(\"-\", 1)[0],\n          c = (this.isSerifFont(s) ? Ki : 0) | (a.monospace ? vi : 0) | (Zi()[s] ? Ti : qi),\n          h = {\n            type: r,\n            name: e,\n            loadedName: i.loadedName,\n            systemFontInfo: null,\n            widths: a.widths,\n            defaultWidth: a.defaultWidth,\n            isSimulatedFlags: !0,\n            flags: c,\n            firstChar: n,\n            lastChar: g,\n            toUnicode: o,\n            xHeight: 0,\n            capHeight: 0,\n            italicAngle: 0,\n            isType3Font: C\n          },\n          l = t.get(\"Widths\"),\n          Q = getStandardFontName(e);\n        let E = null;\n        if (Q) {\n          E = await this.fetchStandardFontData(Q);\n          h.isInternalFont = !!E;\n        }\n        !h.isInternalFont && this.options.useSystemFonts && (h.systemFontInfo = getFontSubstitution(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, e, Q, r));\n        const u = await this.extractDataStructures(t, h);\n        if (Array.isArray(l)) {\n          const e = [];\n          let t = n;\n          for (const i of l) {\n            const a = this.xref.fetchIfRef(i);\n            \"number\" == typeof a && (e[t] = a);\n            t++;\n          }\n          u.widths = e;\n        } else u.widths = this.buildCharCodeToWidth(a.widths, u);\n        return new Font(e, E, u);\n      }\n      {\n        const i = lookupNormalRect(t.getArray(\"FontBBox\"), [0, 0, 0, 0]);\n        (e = new Dict(null)).set(\"FontName\", Name.get(r));\n        e.set(\"FontBBox\", i);\n      }\n    }\n    let h = e.get(\"FontName\"),\n      l = t.get(\"BaseFont\");\n    \"string\" == typeof h && (h = Name.get(h));\n    \"string\" == typeof l && (l = Name.get(l));\n    const Q = h?.name,\n      E = l?.name;\n    if (!C && Q !== E) {\n      info(`The FontDescriptor's FontName is \"${Q}\" but should be the same as the Font's BaseFont \"${E}\".`);\n      Q && E && (E.startsWith(Q) || !isKnownFontName(Q) && isKnownFontName(E)) && (h = null);\n    }\n    h ||= l;\n    if (!(h instanceof Name)) throw new FormatError(\"invalid font name\");\n    let u, d, f, p, m;\n    try {\n      u = e.get(\"FontFile\", \"FontFile2\", \"FontFile3\");\n    } catch (e) {\n      if (!this.options.ignoreErrors) throw e;\n      warn(`translateFont - fetching \"${h.name}\" font file: \"${e}\".`);\n      u = new NullStream();\n    }\n    let y = !1,\n      w = null,\n      D = null;\n    if (u) {\n      if (u.dict) {\n        const e = u.dict.get(\"Subtype\");\n        e instanceof Name && (d = e.name);\n        f = u.dict.get(\"Length1\");\n        p = u.dict.get(\"Length2\");\n        m = u.dict.get(\"Length3\");\n      }\n    } else if (c) {\n      const e = getXfaFontName(h.name);\n      if (e) {\n        c.fontFamily = `${c.fontFamily}-PdfJS-XFA`;\n        c.metrics = e.metrics || null;\n        w = e.factors || null;\n        u = await this.fetchStandardFontData(e.name);\n        y = !!u;\n        i = t = getXfaFontDict(h.name);\n        s = !0;\n      }\n    } else if (!C) {\n      const e = getStandardFontName(h.name);\n      if (e) {\n        u = await this.fetchStandardFontData(e);\n        y = !!u;\n      }\n      !y && this.options.useSystemFonts && (D = getFontSubstitution(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, h.name, e, r));\n    }\n    const b = lookupMatrix(t.getArray(\"FontMatrix\"), a),\n      F = lookupNormalRect(e.getArray(\"FontBBox\") || t.getArray(\"FontBBox\"), void 0);\n    let S = e.get(\"Ascent\");\n    \"number\" != typeof S && (S = void 0);\n    let k = e.get(\"Descent\");\n    \"number\" != typeof k && (k = void 0);\n    let R = e.get(\"XHeight\");\n    \"number\" != typeof R && (R = 0);\n    let N = e.get(\"CapHeight\");\n    \"number\" != typeof N && (N = 0);\n    let G = e.get(\"Flags\");\n    Number.isInteger(G) || (G = 0);\n    let x = e.get(\"ItalicAngle\");\n    \"number\" != typeof x && (x = 0);\n    const U = {\n      type: r,\n      name: h.name,\n      subtype: d,\n      file: u,\n      length1: f,\n      length2: p,\n      length3: m,\n      isInternalFont: y,\n      loadedName: i.loadedName,\n      composite: s,\n      fixedPitch: !1,\n      fontMatrix: b,\n      firstChar: n,\n      lastChar: g,\n      toUnicode: o,\n      bbox: F,\n      ascent: S,\n      descent: k,\n      xHeight: R,\n      capHeight: N,\n      flags: G,\n      italicAngle: x,\n      isType3Font: C,\n      cssFontInfo: c,\n      scaleFactors: w,\n      systemFontInfo: D\n    };\n    if (s) {\n      const e = i.get(\"Encoding\");\n      e instanceof Name && (U.cidEncoding = e.name);\n      const t = await CMapFactory.create({\n        encoding: e,\n        fetchBuiltInCMap: this._fetchBuiltInCMapBound,\n        useCMap: null\n      });\n      U.cMap = t;\n      U.vertical = U.cMap.vertical;\n    }\n    const M = await this.extractDataStructures(t, U);\n    this.extractWidths(t, e, M);\n    return new Font(h.name, u, M);\n  }\n  static buildFontPaths(e, t, i, a) {\n    function buildPath(t) {\n      const s = `${e.loadedName}_path_${t}`;\n      try {\n        if (e.renderer.hasBuiltPath(t)) return;\n        i.send(\"commonobj\", [s, \"FontPath\", e.renderer.getPathJs(t)]);\n      } catch (e) {\n        if (a.ignoreErrors) {\n          warn(`buildFontPaths - ignoring ${s} glyph: \"${e}\".`);\n          return;\n        }\n        throw e;\n      }\n    }\n    for (const e of t) {\n      buildPath(e.fontChar);\n      const t = e.accent;\n      t?.fontChar && buildPath(t.fontChar);\n    }\n  }\n  static get fallbackFontDict() {\n    const e = new Dict();\n    e.set(\"BaseFont\", Name.get(\"Helvetica\"));\n    e.set(\"Type\", Name.get(\"FallbackType\"));\n    e.set(\"Subtype\", Name.get(\"FallbackType\"));\n    e.set(\"Encoding\", Name.get(\"WinAnsiEncoding\"));\n    return shadow(this, \"fallbackFontDict\", e);\n  }\n}\nclass TranslatedFont {\n  constructor({\n    loadedName: e,\n    font: t,\n    dict: i,\n    evaluatorOptions: a\n  }) {\n    this.loadedName = e;\n    this.font = t;\n    this.dict = i;\n    this._evaluatorOptions = a || bs;\n    this.type3Loaded = null;\n    this.type3Dependencies = t.isType3Font ? new Set() : null;\n    this.sent = !1;\n  }\n  send(e) {\n    if (!this.sent) {\n      this.sent = !0;\n      e.send(\"commonobj\", [this.loadedName, \"Font\", this.font.exportData(this._evaluatorOptions.fontExtraProperties)]);\n    }\n  }\n  fallback(e) {\n    if (this.font.data) {\n      this.font.disableFontFace = !0;\n      PartialEvaluator.buildFontPaths(this.font, this.font.glyphCacheValues, e, this._evaluatorOptions);\n    }\n  }\n  loadType3Data(e, t, i) {\n    if (this.type3Loaded) return this.type3Loaded;\n    if (!this.font.isType3Font) throw new Error(\"Must be a Type3 font.\");\n    const a = e.clone({\n        ignoreErrors: !1\n      }),\n      s = new RefSet(e.type3FontRefs);\n    this.dict.objId && !s.has(this.dict.objId) && s.put(this.dict.objId);\n    a.type3FontRefs = s;\n    const r = this.font,\n      n = this.type3Dependencies;\n    let g = Promise.resolve();\n    const o = this.dict.get(\"CharProcs\"),\n      c = this.dict.get(\"Resources\") || t,\n      C = Object.create(null),\n      h = Util.normalizeRect(r.bbox || [0, 0, 0, 0]),\n      l = h[2] - h[0],\n      Q = h[3] - h[1],\n      E = Math.hypot(l, Q);\n    for (const e of o.getKeys()) g = g.then(() => {\n      const t = o.get(e),\n        s = new OperatorList();\n      return a.getOperatorList({\n        stream: t,\n        task: i,\n        resources: c,\n        operatorList: s\n      }).then(() => {\n        s.fnArray[0] === Ee && this._removeType3ColorOperators(s, E);\n        C[e] = s.getIR();\n        for (const e of s.dependencies) n.add(e);\n      }).catch(function (t) {\n        warn(`Type3 font resource \"${e}\" is not available.`);\n        const i = new OperatorList();\n        C[e] = i.getIR();\n      });\n    });\n    this.type3Loaded = g.then(() => {\n      r.charProcOperatorList = C;\n      if (this._bbox) {\n        r.isCharBBox = !0;\n        r.bbox = this._bbox;\n      }\n    });\n    return this.type3Loaded;\n  }\n  _removeType3ColorOperators(e, t = NaN) {\n    const i = Util.normalizeRect(e.argsArray[0].slice(2)),\n      a = i[2] - i[0],\n      s = i[3] - i[1],\n      r = Math.hypot(a, s);\n    if (0 === a || 0 === s) {\n      e.fnArray.splice(0, 1);\n      e.argsArray.splice(0, 1);\n    } else if (0 === t || Math.round(r / t) >= 10) {\n      this._bbox || (this._bbox = [1 / 0, 1 / 0, -1 / 0, -1 / 0]);\n      this._bbox[0] = Math.min(this._bbox[0], i[0]);\n      this._bbox[1] = Math.min(this._bbox[1], i[1]);\n      this._bbox[2] = Math.max(this._bbox[2], i[2]);\n      this._bbox[3] = Math.max(this._bbox[3], i[3]);\n    }\n    let n = 0,\n      g = e.length;\n    for (; n < g;) {\n      switch (e.fnArray[n]) {\n        case Ee:\n          break;\n        case ue:\n        case de:\n        case fe:\n        case pe:\n        case me:\n        case ye:\n        case we:\n        case De:\n        case be:\n        case Fe:\n        case Se:\n        case ke:\n        case Re:\n        case kA:\n          e.fnArray.splice(n, 1);\n          e.argsArray.splice(n, 1);\n          g--;\n          continue;\n        case NA:\n          const [t] = e.argsArray[n];\n          let i = 0,\n            a = t.length;\n          for (; i < a;) {\n            const [e] = t[i];\n            switch (e) {\n              case \"TR\":\n              case \"TR2\":\n              case \"HT\":\n              case \"BG\":\n              case \"BG2\":\n              case \"UCR\":\n              case \"UCR2\":\n                t.splice(i, 1);\n                a--;\n                continue;\n            }\n            i++;\n          }\n      }\n      n++;\n    }\n  }\n}\nclass StateManager {\n  constructor(e = new EvalState()) {\n    this.state = e;\n    this.stateStack = [];\n  }\n  save() {\n    const e = this.state;\n    this.stateStack.push(this.state);\n    this.state = e.clone();\n  }\n  restore() {\n    const e = this.stateStack.pop();\n    e && (this.state = e);\n  }\n  transform(e) {\n    this.state.ctm = Util.transform(this.state.ctm, e);\n  }\n}\nclass TextState {\n  constructor() {\n    this.ctm = new Float32Array(i);\n    this.fontName = null;\n    this.fontSize = 0;\n    this.loadedName = null;\n    this.font = null;\n    this.fontMatrix = a;\n    this.textMatrix = i.slice();\n    this.textLineMatrix = i.slice();\n    this.charSpacing = 0;\n    this.wordSpacing = 0;\n    this.leading = 0;\n    this.textHScale = 1;\n    this.textRise = 0;\n  }\n  setTextMatrix(e, t, i, a, s, r) {\n    const n = this.textMatrix;\n    n[0] = e;\n    n[1] = t;\n    n[2] = i;\n    n[3] = a;\n    n[4] = s;\n    n[5] = r;\n  }\n  setTextLineMatrix(e, t, i, a, s, r) {\n    const n = this.textLineMatrix;\n    n[0] = e;\n    n[1] = t;\n    n[2] = i;\n    n[3] = a;\n    n[4] = s;\n    n[5] = r;\n  }\n  translateTextMatrix(e, t) {\n    const i = this.textMatrix;\n    i[4] = i[0] * e + i[2] * t + i[4];\n    i[5] = i[1] * e + i[3] * t + i[5];\n  }\n  translateTextLineMatrix(e, t) {\n    const i = this.textLineMatrix;\n    i[4] = i[0] * e + i[2] * t + i[4];\n    i[5] = i[1] * e + i[3] * t + i[5];\n  }\n  carriageReturn() {\n    this.translateTextLineMatrix(0, -this.leading);\n    this.textMatrix = this.textLineMatrix.slice();\n  }\n  clone() {\n    const e = Object.create(this);\n    e.textMatrix = this.textMatrix.slice();\n    e.textLineMatrix = this.textLineMatrix.slice();\n    e.fontMatrix = this.fontMatrix.slice();\n    return e;\n  }\n}\nclass EvalState {\n  constructor() {\n    this.ctm = new Float32Array(i);\n    this.font = null;\n    this.textRenderingMode = y;\n    this.fillColorSpace = ColorSpace.singletons.gray;\n    this.strokeColorSpace = ColorSpace.singletons.gray;\n  }\n  clone() {\n    return Object.create(this);\n  }\n}\nclass EvaluatorPreprocessor {\n  static get opMap() {\n    return shadow(this, \"opMap\", Object.assign(Object.create(null), {\n      w: {\n        id: wA,\n        numArgs: 1,\n        variableArgs: !1\n      },\n      J: {\n        id: DA,\n        numArgs: 1,\n        variableArgs: !1\n      },\n      j: {\n        id: bA,\n        numArgs: 1,\n        variableArgs: !1\n      },\n      M: {\n        id: FA,\n        numArgs: 1,\n        variableArgs: !1\n      },\n      d: {\n        id: SA,\n        numArgs: 2,\n        variableArgs: !1\n      },\n      ri: {\n        id: kA,\n        numArgs: 1,\n        variableArgs: !1\n      },\n      i: {\n        id: RA,\n        numArgs: 1,\n        variableArgs: !1\n      },\n      gs: {\n        id: NA,\n        numArgs: 1,\n        variableArgs: !1\n      },\n      q: {\n        id: GA,\n        numArgs: 0,\n        variableArgs: !1\n      },\n      Q: {\n        id: xA,\n        numArgs: 0,\n        variableArgs: !1\n      },\n      cm: {\n        id: UA,\n        numArgs: 6,\n        variableArgs: !1\n      },\n      m: {\n        id: MA,\n        numArgs: 2,\n        variableArgs: !1\n      },\n      l: {\n        id: LA,\n        numArgs: 2,\n        variableArgs: !1\n      },\n      c: {\n        id: HA,\n        numArgs: 6,\n        variableArgs: !1\n      },\n      v: {\n        id: JA,\n        numArgs: 4,\n        variableArgs: !1\n      },\n      y: {\n        id: YA,\n        numArgs: 4,\n        variableArgs: !1\n      },\n      h: {\n        id: vA,\n        numArgs: 0,\n        variableArgs: !1\n      },\n      re: {\n        id: KA,\n        numArgs: 4,\n        variableArgs: !1\n      },\n      S: {\n        id: TA,\n        numArgs: 0,\n        variableArgs: !1\n      },\n      s: {\n        id: qA,\n        numArgs: 0,\n        variableArgs: !1\n      },\n      f: {\n        id: OA,\n        numArgs: 0,\n        variableArgs: !1\n      },\n      F: {\n        id: OA,\n        numArgs: 0,\n        variableArgs: !1\n      },\n      \"f*\": {\n        id: PA,\n        numArgs: 0,\n        variableArgs: !1\n      },\n      B: {\n        id: WA,\n        numArgs: 0,\n        variableArgs: !1\n      },\n      \"B*\": {\n        id: jA,\n        numArgs: 0,\n        variableArgs: !1\n      },\n      b: {\n        id: XA,\n        numArgs: 0,\n        variableArgs: !1\n      },\n      \"b*\": {\n        id: ZA,\n        numArgs: 0,\n        variableArgs: !1\n      },\n      n: {\n        id: VA,\n        numArgs: 0,\n        variableArgs: !1\n      },\n      W: {\n        id: zA,\n        numArgs: 0,\n        variableArgs: !1\n      },\n      \"W*\": {\n        id: _A,\n        numArgs: 0,\n        variableArgs: !1\n      },\n      BT: {\n        id: $A,\n        numArgs: 0,\n        variableArgs: !1\n      },\n      ET: {\n        id: Ae,\n        numArgs: 0,\n        variableArgs: !1\n      },\n      Tc: {\n        id: ee,\n        numArgs: 1,\n        variableArgs: !1\n      },\n      Tw: {\n        id: te,\n        numArgs: 1,\n        variableArgs: !1\n      },\n      Tz: {\n        id: ie,\n        numArgs: 1,\n        variableArgs: !1\n      },\n      TL: {\n        id: ae,\n        numArgs: 1,\n        variableArgs: !1\n      },\n      Tf: {\n        id: se,\n        numArgs: 2,\n        variableArgs: !1\n      },\n      Tr: {\n        id: re,\n        numArgs: 1,\n        variableArgs: !1\n      },\n      Ts: {\n        id: ne,\n        numArgs: 1,\n        variableArgs: !1\n      },\n      Td: {\n        id: ge,\n        numArgs: 2,\n        variableArgs: !1\n      },\n      TD: {\n        id: oe,\n        numArgs: 2,\n        variableArgs: !1\n      },\n      Tm: {\n        id: Ie,\n        numArgs: 6,\n        variableArgs: !1\n      },\n      \"T*\": {\n        id: ce,\n        numArgs: 0,\n        variableArgs: !1\n      },\n      Tj: {\n        id: Ce,\n        numArgs: 1,\n        variableArgs: !1\n      },\n      TJ: {\n        id: he,\n        numArgs: 1,\n        variableArgs: !1\n      },\n      \"'\": {\n        id: Be,\n        numArgs: 1,\n        variableArgs: !1\n      },\n      '\"': {\n        id: le,\n        numArgs: 3,\n        variableArgs: !1\n      },\n      d0: {\n        id: Qe,\n        numArgs: 2,\n        variableArgs: !1\n      },\n      d1: {\n        id: Ee,\n        numArgs: 6,\n        variableArgs: !1\n      },\n      CS: {\n        id: ue,\n        numArgs: 1,\n        variableArgs: !1\n      },\n      cs: {\n        id: de,\n        numArgs: 1,\n        variableArgs: !1\n      },\n      SC: {\n        id: fe,\n        numArgs: 4,\n        variableArgs: !0\n      },\n      SCN: {\n        id: pe,\n        numArgs: 33,\n        variableArgs: !0\n      },\n      sc: {\n        id: me,\n        numArgs: 4,\n        variableArgs: !0\n      },\n      scn: {\n        id: ye,\n        numArgs: 33,\n        variableArgs: !0\n      },\n      G: {\n        id: we,\n        numArgs: 1,\n        variableArgs: !1\n      },\n      g: {\n        id: De,\n        numArgs: 1,\n        variableArgs: !1\n      },\n      RG: {\n        id: be,\n        numArgs: 3,\n        variableArgs: !1\n      },\n      rg: {\n        id: Fe,\n        numArgs: 3,\n        variableArgs: !1\n      },\n      K: {\n        id: Se,\n        numArgs: 4,\n        variableArgs: !1\n      },\n      k: {\n        id: ke,\n        numArgs: 4,\n        variableArgs: !1\n      },\n      sh: {\n        id: Re,\n        numArgs: 1,\n        variableArgs: !1\n      },\n      BI: {\n        id: Ne,\n        numArgs: 0,\n        variableArgs: !1\n      },\n      ID: {\n        id: Ge,\n        numArgs: 0,\n        variableArgs: !1\n      },\n      EI: {\n        id: xe,\n        numArgs: 1,\n        variableArgs: !1\n      },\n      Do: {\n        id: Ue,\n        numArgs: 1,\n        variableArgs: !1\n      },\n      MP: {\n        id: Me,\n        numArgs: 1,\n        variableArgs: !1\n      },\n      DP: {\n        id: Le,\n        numArgs: 2,\n        variableArgs: !1\n      },\n      BMC: {\n        id: He,\n        numArgs: 1,\n        variableArgs: !1\n      },\n      BDC: {\n        id: Je,\n        numArgs: 2,\n        variableArgs: !1\n      },\n      EMC: {\n        id: Ye,\n        numArgs: 0,\n        variableArgs: !1\n      },\n      BX: {\n        id: ve,\n        numArgs: 0,\n        variableArgs: !1\n      },\n      EX: {\n        id: Ke,\n        numArgs: 0,\n        variableArgs: !1\n      },\n      BM: null,\n      BD: null,\n      true: null,\n      fa: null,\n      fal: null,\n      fals: null,\n      false: null,\n      nu: null,\n      nul: null,\n      null: null\n    }));\n  }\n  static MAX_INVALID_PATH_OPS = 10;\n  constructor(e, t, i = new StateManager()) {\n    this.parser = new Parser({\n      lexer: new Lexer(e, EvaluatorPreprocessor.opMap),\n      xref: t\n    });\n    this.stateManager = i;\n    this.nonProcessedArgs = [];\n    this._isPathOp = !1;\n    this._numInvalidPathOPS = 0;\n  }\n  get savedStatesDepth() {\n    return this.stateManager.stateStack.length;\n  }\n  read(e) {\n    let t = e.args;\n    for (;;) {\n      const i = this.parser.getObj();\n      if (i instanceof Cmd) {\n        const a = i.cmd,\n          s = EvaluatorPreprocessor.opMap[a];\n        if (!s) {\n          warn(`Unknown command \"${a}\".`);\n          continue;\n        }\n        const r = s.id,\n          n = s.numArgs;\n        let g = null !== t ? t.length : 0;\n        this._isPathOp || (this._numInvalidPathOPS = 0);\n        this._isPathOp = r >= MA && r <= VA;\n        if (s.variableArgs) g > n && info(`Command ${a}: expected [0, ${n}] args, but received ${g} args.`);else {\n          if (g !== n) {\n            const e = this.nonProcessedArgs;\n            for (; g > n;) {\n              e.push(t.shift());\n              g--;\n            }\n            for (; g < n && 0 !== e.length;) {\n              null === t && (t = []);\n              t.unshift(e.pop());\n              g++;\n            }\n          }\n          if (g < n) {\n            const e = `command ${a}: expected ${n} args, but received ${g} args.`;\n            if (this._isPathOp && ++this._numInvalidPathOPS > EvaluatorPreprocessor.MAX_INVALID_PATH_OPS) throw new FormatError(`Invalid ${e}`);\n            warn(`Skipping ${e}`);\n            null !== t && (t.length = 0);\n            continue;\n          }\n        }\n        this.preprocessCommand(r, t);\n        e.fn = r;\n        e.args = t;\n        return !0;\n      }\n      if (i === pt) return !1;\n      if (null !== i) {\n        null === t && (t = []);\n        t.push(i);\n        if (t.length > 33) throw new FormatError(\"Too many arguments\");\n      }\n    }\n  }\n  preprocessCommand(e, t) {\n    switch (0 | e) {\n      case GA:\n        this.stateManager.save();\n        break;\n      case xA:\n        this.stateManager.restore();\n        break;\n      case UA:\n        this.stateManager.transform(t);\n    }\n  }\n}\nclass DefaultAppearanceEvaluator extends EvaluatorPreprocessor {\n  constructor(e) {\n    super(new StringStream(e));\n  }\n  parse() {\n    const e = {\n        fn: 0,\n        args: []\n      },\n      t = {\n        fontSize: 0,\n        fontName: \"\",\n        fontColor: new Uint8ClampedArray(3)\n      };\n    try {\n      for (;;) {\n        e.args.length = 0;\n        if (!this.read(e)) break;\n        if (0 !== this.savedStatesDepth) continue;\n        const {\n          fn: i,\n          args: a\n        } = e;\n        switch (0 | i) {\n          case se:\n            const [e, i] = a;\n            e instanceof Name && (t.fontName = e.name);\n            \"number\" == typeof i && i > 0 && (t.fontSize = i);\n            break;\n          case Fe:\n            ColorSpace.singletons.rgb.getRgbItem(a, 0, t.fontColor, 0);\n            break;\n          case De:\n            ColorSpace.singletons.gray.getRgbItem(a, 0, t.fontColor, 0);\n            break;\n          case ke:\n            ColorSpace.singletons.cmyk.getRgbItem(a, 0, t.fontColor, 0);\n        }\n      }\n    } catch (e) {\n      warn(`parseDefaultAppearance - ignoring errors: \"${e}\".`);\n    }\n    return t;\n  }\n}\nfunction parseDefaultAppearance(e) {\n  return new DefaultAppearanceEvaluator(e).parse();\n}\nclass AppearanceStreamEvaluator extends EvaluatorPreprocessor {\n  constructor(e, t, i) {\n    super(e);\n    this.stream = e;\n    this.evaluatorOptions = t;\n    this.xref = i;\n    this.resources = e.dict?.get(\"Resources\");\n  }\n  parse() {\n    const e = {\n      fn: 0,\n      args: []\n    };\n    let t = {\n        scaleFactor: 1,\n        fontSize: 0,\n        fontName: \"\",\n        fontColor: new Uint8ClampedArray(3),\n        fillColorSpace: ColorSpace.singletons.gray\n      },\n      i = !1;\n    const a = [];\n    try {\n      for (;;) {\n        e.args.length = 0;\n        if (i || !this.read(e)) break;\n        const {\n          fn: s,\n          args: r\n        } = e;\n        switch (0 | s) {\n          case GA:\n            a.push({\n              scaleFactor: t.scaleFactor,\n              fontSize: t.fontSize,\n              fontName: t.fontName,\n              fontColor: t.fontColor.slice(),\n              fillColorSpace: t.fillColorSpace\n            });\n            break;\n          case xA:\n            t = a.pop() || t;\n            break;\n          case Ie:\n            t.scaleFactor *= Math.hypot(r[0], r[1]);\n            break;\n          case se:\n            const [e, s] = r;\n            e instanceof Name && (t.fontName = e.name);\n            \"number\" == typeof s && s > 0 && (t.fontSize = s * t.scaleFactor);\n            break;\n          case de:\n            t.fillColorSpace = ColorSpace.parse({\n              cs: r[0],\n              xref: this.xref,\n              resources: this.resources,\n              pdfFunctionFactory: this._pdfFunctionFactory,\n              localColorSpaceCache: this._localColorSpaceCache\n            });\n            break;\n          case me:\n            t.fillColorSpace.getRgbItem(r, 0, t.fontColor, 0);\n            break;\n          case Fe:\n            ColorSpace.singletons.rgb.getRgbItem(r, 0, t.fontColor, 0);\n            break;\n          case De:\n            ColorSpace.singletons.gray.getRgbItem(r, 0, t.fontColor, 0);\n            break;\n          case ke:\n            ColorSpace.singletons.cmyk.getRgbItem(r, 0, t.fontColor, 0);\n            break;\n          case Ce:\n          case he:\n          case Be:\n          case le:\n            i = !0;\n        }\n      }\n    } catch (e) {\n      warn(`parseAppearanceStream - ignoring errors: \"${e}\".`);\n    }\n    this.stream.reset();\n    delete t.scaleFactor;\n    delete t.fillColorSpace;\n    return t;\n  }\n  get _localColorSpaceCache() {\n    return shadow(this, \"_localColorSpaceCache\", new LocalColorSpaceCache());\n  }\n  get _pdfFunctionFactory() {\n    return shadow(this, \"_pdfFunctionFactory\", new PDFFunctionFactory({\n      xref: this.xref,\n      isEvalSupported: this.evaluatorOptions.isEvalSupported\n    }));\n  }\n}\nfunction getPdfColor(e, t) {\n  if (e[0] === e[1] && e[1] === e[2]) {\n    return `${numberToString(e[0] / 255)} ${t ? \"g\" : \"G\"}`;\n  }\n  return Array.from(e, e => numberToString(e / 255)).join(\" \") + \" \" + (t ? \"rg\" : \"RG\");\n}\nclass FakeUnicodeFont {\n  constructor(e, t) {\n    this.xref = e;\n    this.widths = null;\n    this.firstChar = 1 / 0;\n    this.lastChar = -1 / 0;\n    this.fontFamily = t;\n    const i = new OffscreenCanvas(1, 1);\n    this.ctxMeasure = i.getContext(\"2d\", {\n      willReadFrequently: !0\n    });\n    FakeUnicodeFont._fontNameId || (FakeUnicodeFont._fontNameId = 1);\n    this.fontName = Name.get(`InvalidPDFjsFont_${t}_${FakeUnicodeFont._fontNameId++}`);\n  }\n  get fontDescriptorRef() {\n    if (!FakeUnicodeFont._fontDescriptorRef) {\n      const e = new Dict(this.xref);\n      e.set(\"Type\", Name.get(\"FontDescriptor\"));\n      e.set(\"FontName\", this.fontName);\n      e.set(\"FontFamily\", \"MyriadPro Regular\");\n      e.set(\"FontBBox\", [0, 0, 0, 0]);\n      e.set(\"FontStretch\", Name.get(\"Normal\"));\n      e.set(\"FontWeight\", 400);\n      e.set(\"ItalicAngle\", 0);\n      FakeUnicodeFont._fontDescriptorRef = this.xref.getNewPersistentRef(e);\n    }\n    return FakeUnicodeFont._fontDescriptorRef;\n  }\n  get descendantFontRef() {\n    const e = new Dict(this.xref);\n    e.set(\"BaseFont\", this.fontName);\n    e.set(\"Type\", Name.get(\"Font\"));\n    e.set(\"Subtype\", Name.get(\"CIDFontType0\"));\n    e.set(\"CIDToGIDMap\", Name.get(\"Identity\"));\n    e.set(\"FirstChar\", this.firstChar);\n    e.set(\"LastChar\", this.lastChar);\n    e.set(\"FontDescriptor\", this.fontDescriptorRef);\n    e.set(\"DW\", 1e3);\n    const t = [],\n      i = [...this.widths.entries()].sort();\n    let a = null,\n      s = null;\n    for (const [e, r] of i) if (a) {\n      if (e === a + s.length) s.push(r);else {\n        t.push(a, s);\n        a = e;\n        s = [r];\n      }\n    } else {\n      a = e;\n      s = [r];\n    }\n    a && t.push(a, s);\n    e.set(\"W\", t);\n    const r = new Dict(this.xref);\n    r.set(\"Ordering\", \"Identity\");\n    r.set(\"Registry\", \"Adobe\");\n    r.set(\"Supplement\", 0);\n    e.set(\"CIDSystemInfo\", r);\n    return this.xref.getNewPersistentRef(e);\n  }\n  get baseFontRef() {\n    const e = new Dict(this.xref);\n    e.set(\"BaseFont\", this.fontName);\n    e.set(\"Type\", Name.get(\"Font\"));\n    e.set(\"Subtype\", Name.get(\"Type0\"));\n    e.set(\"Encoding\", Name.get(\"Identity-H\"));\n    e.set(\"DescendantFonts\", [this.descendantFontRef]);\n    e.set(\"ToUnicode\", Name.get(\"Identity-H\"));\n    return this.xref.getNewPersistentRef(e);\n  }\n  get resources() {\n    const e = new Dict(this.xref),\n      t = new Dict(this.xref);\n    t.set(this.fontName.name, this.baseFontRef);\n    e.set(\"Font\", t);\n    return e;\n  }\n  _createContext() {\n    this.widths = new Map();\n    this.ctxMeasure.font = `1000px ${this.fontFamily}`;\n    return this.ctxMeasure;\n  }\n  createFontResources(e) {\n    const t = this._createContext();\n    for (const i of e.split(/\\r\\n?|\\n/)) for (const e of i.split(\"\")) {\n      const i = e.charCodeAt(0);\n      if (this.widths.has(i)) continue;\n      const a = t.measureText(e),\n        s = Math.ceil(a.width);\n      this.widths.set(i, s);\n      this.firstChar = Math.min(i, this.firstChar);\n      this.lastChar = Math.max(i, this.lastChar);\n    }\n    return this.resources;\n  }\n  static getFirstPositionInfo(e, t, i) {\n    const [a, n, g, o] = e;\n    let c = g - a,\n      C = o - n;\n    t % 180 != 0 && ([c, C] = [C, c]);\n    const h = s * i;\n    return {\n      coords: [0, C + r * i - h],\n      bbox: [0, 0, c, C],\n      matrix: 0 !== t ? getRotationMatrix(t, C, h) : void 0\n    };\n  }\n  createAppearance(e, t, i, a, n, g) {\n    const o = this._createContext(),\n      c = [];\n    let C = -1 / 0;\n    for (const t of e.split(/\\r\\n?|\\n/)) {\n      c.push(t);\n      const e = o.measureText(t).width;\n      C = Math.max(C, e);\n      for (const e of codePointIter(t)) {\n        const t = String.fromCodePoint(e);\n        let i = this.widths.get(e);\n        if (void 0 === i) {\n          const a = o.measureText(t);\n          i = Math.ceil(a.width);\n          this.widths.set(e, i);\n          this.firstChar = Math.min(e, this.firstChar);\n          this.lastChar = Math.max(e, this.lastChar);\n        }\n      }\n    }\n    C *= a / 1e3;\n    const [h, l, Q, E] = t;\n    let u = Q - h,\n      d = E - l;\n    i % 180 != 0 && ([u, d] = [d, u]);\n    let f = 1;\n    C > u && (f = u / C);\n    let p = 1;\n    const m = s * a,\n      y = r * a,\n      w = m * c.length;\n    w > d && (p = d / w);\n    const D = a * Math.min(f, p),\n      b = [\"q\", `0 0 ${numberToString(u)} ${numberToString(d)} re W n`, \"BT\", `1 0 0 1 0 ${numberToString(d + y)} Tm 0 Tc ${getPdfColor(n, !0)}`, `/${this.fontName.name} ${numberToString(D)} Tf`],\n      {\n        resources: F\n      } = this;\n    if (1 !== (g = \"number\" == typeof g && g >= 0 && g <= 1 ? g : 1)) {\n      b.push(\"/R0 gs\");\n      const e = new Dict(this.xref),\n        t = new Dict(this.xref);\n      t.set(\"ca\", g);\n      t.set(\"CA\", g);\n      t.set(\"Type\", Name.get(\"ExtGState\"));\n      e.set(\"R0\", t);\n      F.set(\"ExtGState\", e);\n    }\n    const S = numberToString(m);\n    for (const e of c) b.push(`0 -${S} Td <${stringToUTF16HexString(e)}> Tj`);\n    b.push(\"ET\", \"Q\");\n    const k = b.join(\"\\n\"),\n      R = new Dict(this.xref);\n    R.set(\"Subtype\", Name.get(\"Form\"));\n    R.set(\"Type\", Name.get(\"XObject\"));\n    R.set(\"BBox\", [0, 0, u, d]);\n    R.set(\"Length\", k.length);\n    R.set(\"Resources\", F);\n    if (i) {\n      const e = getRotationMatrix(i, u, d);\n      R.set(\"Matrix\", e);\n    }\n    const N = new StringStream(k);\n    N.dict = R;\n    return N;\n  }\n}\nclass NameOrNumberTree {\n  constructor(e, t, i) {\n    this.constructor === NameOrNumberTree && unreachable(\"Cannot initialize NameOrNumberTree.\");\n    this.root = e;\n    this.xref = t;\n    this._type = i;\n  }\n  getAll() {\n    const e = new Map();\n    if (!this.root) return e;\n    const t = this.xref,\n      i = new RefSet();\n    i.put(this.root);\n    const a = [this.root];\n    for (; a.length > 0;) {\n      const s = t.fetchIfRef(a.shift());\n      if (!(s instanceof Dict)) continue;\n      if (s.has(\"Kids\")) {\n        const e = s.get(\"Kids\");\n        if (!Array.isArray(e)) continue;\n        for (const t of e) {\n          if (i.has(t)) throw new FormatError(`Duplicate entry in \"${this._type}\" tree.`);\n          a.push(t);\n          i.put(t);\n        }\n        continue;\n      }\n      const r = s.get(this._type);\n      if (Array.isArray(r)) for (let i = 0, a = r.length; i < a; i += 2) e.set(t.fetchIfRef(r[i]), t.fetchIfRef(r[i + 1]));\n    }\n    return e;\n  }\n  get(e) {\n    if (!this.root) return null;\n    const t = this.xref;\n    let i = t.fetchIfRef(this.root),\n      a = 0;\n    for (; i.has(\"Kids\");) {\n      if (++a > 10) {\n        warn(`Search depth limit reached for \"${this._type}\" tree.`);\n        return null;\n      }\n      const s = i.get(\"Kids\");\n      if (!Array.isArray(s)) return null;\n      let r = 0,\n        n = s.length - 1;\n      for (; r <= n;) {\n        const a = r + n >> 1,\n          g = t.fetchIfRef(s[a]),\n          o = g.get(\"Limits\");\n        if (e < t.fetchIfRef(o[0])) n = a - 1;else {\n          if (!(e > t.fetchIfRef(o[1]))) {\n            i = g;\n            break;\n          }\n          r = a + 1;\n        }\n      }\n      if (r > n) return null;\n    }\n    const s = i.get(this._type);\n    if (Array.isArray(s)) {\n      let i = 0,\n        a = s.length - 2;\n      for (; i <= a;) {\n        const r = i + a >> 1,\n          n = r + (1 & r),\n          g = t.fetchIfRef(s[n]);\n        if (e < g) a = n - 2;else {\n          if (!(e > g)) return t.fetchIfRef(s[n + 1]);\n          i = n + 2;\n        }\n      }\n    }\n    return null;\n  }\n}\nclass NameTree extends NameOrNumberTree {\n  constructor(e, t) {\n    super(e, t, \"Names\");\n  }\n}\nclass NumberTree extends NameOrNumberTree {\n  constructor(e, t) {\n    super(e, t, \"Nums\");\n  }\n}\nfunction clearGlobalCaches() {\n  !function clearPatternCaches() {\n    ya = Object.create(null);\n  }();\n  !function clearPrimitiveCaches() {\n    mt = Object.create(null);\n    yt = Object.create(null);\n    wt = Object.create(null);\n  }();\n  !function clearUnicodeCaches() {\n    Ji.clear();\n  }();\n  JpxImage.cleanup();\n}\nfunction pickPlatformItem(e) {\n  return e instanceof Dict ? e.has(\"UF\") ? e.get(\"UF\") : e.has(\"F\") ? e.get(\"F\") : e.has(\"Unix\") ? e.get(\"Unix\") : e.has(\"Mac\") ? e.get(\"Mac\") : e.has(\"DOS\") ? e.get(\"DOS\") : null : null;\n}\nclass FileSpec {\n  #S = !1;\n  constructor(e, t, i = !1) {\n    if (e instanceof Dict) {\n      this.xref = t;\n      this.root = e;\n      e.has(\"FS\") && (this.fs = e.get(\"FS\"));\n      e.has(\"RF\") && warn(\"Related file specifications are not supported\");\n      i || (e.has(\"EF\") ? this.#S = !0 : warn(\"Non-embedded file specifications are not supported\"));\n    }\n  }\n  get filename() {\n    let e = \"\";\n    const t = pickPlatformItem(this.root);\n    t && \"string\" == typeof t && (e = stringToPDFString(t).replaceAll(\"\\\\\\\\\", \"\\\\\").replaceAll(\"\\\\/\", \"/\").replaceAll(\"\\\\\", \"/\"));\n    return shadow(this, \"filename\", e || \"unnamed\");\n  }\n  get content() {\n    if (!this.#S) return null;\n    this._contentRef ||= pickPlatformItem(this.root?.get(\"EF\"));\n    let e = null;\n    if (this._contentRef) {\n      const t = this.xref.fetchIfRef(this._contentRef);\n      t instanceof BaseStream ? e = t.getBytes() : warn(\"Embedded file specification points to non-existing/invalid content\");\n    } else warn(\"Embedded file specification does not have any content\");\n    return e;\n  }\n  get description() {\n    let e = \"\";\n    const t = this.root?.get(\"Desc\");\n    t && \"string\" == typeof t && (e = stringToPDFString(t));\n    return shadow(this, \"description\", e);\n  }\n  get serializable() {\n    return {\n      rawFilename: this.filename,\n      filename: (e = this.filename, e.substring(e.lastIndexOf(\"/\") + 1)),\n      content: this.content,\n      description: this.description\n    };\n    var e;\n  }\n}\nconst Rs = 0,\n  Ns = -2,\n  Gs = -3,\n  xs = -4,\n  Us = -5,\n  Ms = -6,\n  Ls = -9;\nfunction isWhitespace(e, t) {\n  const i = e[t];\n  return \" \" === i || \"\\n\" === i || \"\\r\" === i || \"\\t\" === i;\n}\nclass XMLParserBase {\n  _resolveEntities(e) {\n    return e.replaceAll(/&([^;]+);/g, (e, t) => {\n      if (\"#x\" === t.substring(0, 2)) return String.fromCodePoint(parseInt(t.substring(2), 16));\n      if (\"#\" === t.substring(0, 1)) return String.fromCodePoint(parseInt(t.substring(1), 10));\n      switch (t) {\n        case \"lt\":\n          return \"<\";\n        case \"gt\":\n          return \">\";\n        case \"amp\":\n          return \"&\";\n        case \"quot\":\n          return '\"';\n        case \"apos\":\n          return \"'\";\n      }\n      return this.onResolveEntity(t);\n    });\n  }\n  _parseContent(e, t) {\n    const i = [];\n    let a = t;\n    function skipWs() {\n      for (; a < e.length && isWhitespace(e, a);) ++a;\n    }\n    for (; a < e.length && !isWhitespace(e, a) && \">\" !== e[a] && \"/\" !== e[a];) ++a;\n    const s = e.substring(t, a);\n    skipWs();\n    for (; a < e.length && \">\" !== e[a] && \"/\" !== e[a] && \"?\" !== e[a];) {\n      skipWs();\n      let t = \"\",\n        s = \"\";\n      for (; a < e.length && !isWhitespace(e, a) && \"=\" !== e[a];) {\n        t += e[a];\n        ++a;\n      }\n      skipWs();\n      if (\"=\" !== e[a]) return null;\n      ++a;\n      skipWs();\n      const r = e[a];\n      if ('\"' !== r && \"'\" !== r) return null;\n      const n = e.indexOf(r, ++a);\n      if (n < 0) return null;\n      s = e.substring(a, n);\n      i.push({\n        name: t,\n        value: this._resolveEntities(s)\n      });\n      a = n + 1;\n      skipWs();\n    }\n    return {\n      name: s,\n      attributes: i,\n      parsed: a - t\n    };\n  }\n  _parseProcessingInstruction(e, t) {\n    let i = t;\n    for (; i < e.length && !isWhitespace(e, i) && \">\" !== e[i] && \"?\" !== e[i] && \"/\" !== e[i];) ++i;\n    const a = e.substring(t, i);\n    !function skipWs() {\n      for (; i < e.length && isWhitespace(e, i);) ++i;\n    }();\n    const s = i;\n    for (; i < e.length && (\"?\" !== e[i] || \">\" !== e[i + 1]);) ++i;\n    return {\n      name: a,\n      value: e.substring(s, i),\n      parsed: i - t\n    };\n  }\n  parseXml(e) {\n    let t = 0;\n    for (; t < e.length;) {\n      let i = t;\n      if (\"<\" === e[t]) {\n        ++i;\n        let t;\n        switch (e[i]) {\n          case \"/\":\n            ++i;\n            t = e.indexOf(\">\", i);\n            if (t < 0) {\n              this.onError(Ls);\n              return;\n            }\n            this.onEndElement(e.substring(i, t));\n            i = t + 1;\n            break;\n          case \"?\":\n            ++i;\n            const a = this._parseProcessingInstruction(e, i);\n            if (\"?>\" !== e.substring(i + a.parsed, i + a.parsed + 2)) {\n              this.onError(Gs);\n              return;\n            }\n            this.onPi(a.name, a.value);\n            i += a.parsed + 2;\n            break;\n          case \"!\":\n            if (\"--\" === e.substring(i + 1, i + 3)) {\n              t = e.indexOf(\"--\\x3e\", i + 3);\n              if (t < 0) {\n                this.onError(Us);\n                return;\n              }\n              this.onComment(e.substring(i + 3, t));\n              i = t + 3;\n            } else if (\"[CDATA[\" === e.substring(i + 1, i + 8)) {\n              t = e.indexOf(\"]]>\", i + 8);\n              if (t < 0) {\n                this.onError(Ns);\n                return;\n              }\n              this.onCdata(e.substring(i + 8, t));\n              i = t + 3;\n            } else {\n              if (\"DOCTYPE\" !== e.substring(i + 1, i + 8)) {\n                this.onError(Ms);\n                return;\n              }\n              {\n                const a = e.indexOf(\"[\", i + 8);\n                let s = !1;\n                t = e.indexOf(\">\", i + 8);\n                if (t < 0) {\n                  this.onError(xs);\n                  return;\n                }\n                if (a > 0 && t > a) {\n                  t = e.indexOf(\"]>\", i + 8);\n                  if (t < 0) {\n                    this.onError(xs);\n                    return;\n                  }\n                  s = !0;\n                }\n                const r = e.substring(i + 8, t + (s ? 1 : 0));\n                this.onDoctype(r);\n                i = t + (s ? 2 : 1);\n              }\n            }\n            break;\n          default:\n            const s = this._parseContent(e, i);\n            if (null === s) {\n              this.onError(Ms);\n              return;\n            }\n            let r = !1;\n            if (\"/>\" === e.substring(i + s.parsed, i + s.parsed + 2)) r = !0;else if (\">\" !== e.substring(i + s.parsed, i + s.parsed + 1)) {\n              this.onError(Ls);\n              return;\n            }\n            this.onBeginElement(s.name, s.attributes, r);\n            i += s.parsed + (r ? 2 : 1);\n        }\n      } else {\n        for (; i < e.length && \"<\" !== e[i];) i++;\n        const a = e.substring(t, i);\n        this.onText(this._resolveEntities(a));\n      }\n      t = i;\n    }\n  }\n  onResolveEntity(e) {\n    return `&${e};`;\n  }\n  onPi(e, t) {}\n  onComment(e) {}\n  onCdata(e) {}\n  onDoctype(e) {}\n  onText(e) {}\n  onBeginElement(e, t, i) {}\n  onEndElement(e) {}\n  onError(e) {}\n}\nclass SimpleDOMNode {\n  constructor(e, t) {\n    this.nodeName = e;\n    this.nodeValue = t;\n    Object.defineProperty(this, \"parentNode\", {\n      value: null,\n      writable: !0\n    });\n  }\n  get firstChild() {\n    return this.childNodes?.[0];\n  }\n  get nextSibling() {\n    const e = this.parentNode.childNodes;\n    if (!e) return;\n    const t = e.indexOf(this);\n    return -1 !== t ? e[t + 1] : void 0;\n  }\n  get textContent() {\n    return this.childNodes ? this.childNodes.map(function (e) {\n      return e.textContent;\n    }).join(\"\") : this.nodeValue || \"\";\n  }\n  get children() {\n    return this.childNodes || [];\n  }\n  hasChildNodes() {\n    return this.childNodes?.length > 0;\n  }\n  searchNode(e, t) {\n    if (t >= e.length) return this;\n    const i = e[t];\n    if (i.name.startsWith(\"#\") && t < e.length - 1) return this.searchNode(e, t + 1);\n    const a = [];\n    let s = this;\n    for (;;) {\n      if (i.name === s.nodeName) {\n        if (0 !== i.pos) {\n          if (0 === a.length) return null;\n          {\n            const [r] = a.pop();\n            let n = 0;\n            for (const a of r.childNodes) if (i.name === a.nodeName) {\n              if (n === i.pos) return a.searchNode(e, t + 1);\n              n++;\n            }\n            return s.searchNode(e, t + 1);\n          }\n        }\n        {\n          const i = s.searchNode(e, t + 1);\n          if (null !== i) return i;\n        }\n      }\n      if (s.childNodes?.length > 0) {\n        a.push([s, 0]);\n        s = s.childNodes[0];\n      } else {\n        if (0 === a.length) return null;\n        for (; 0 !== a.length;) {\n          const [e, t] = a.pop(),\n            i = t + 1;\n          if (i < e.childNodes.length) {\n            a.push([e, i]);\n            s = e.childNodes[i];\n            break;\n          }\n        }\n        if (0 === a.length) return null;\n      }\n    }\n  }\n  dump(e) {\n    if (\"#text\" !== this.nodeName) {\n      e.push(`<${this.nodeName}`);\n      if (this.attributes) for (const t of this.attributes) e.push(` ${t.name}=\"${encodeToXmlString(t.value)}\"`);\n      if (this.hasChildNodes()) {\n        e.push(\">\");\n        for (const t of this.childNodes) t.dump(e);\n        e.push(`</${this.nodeName}>`);\n      } else this.nodeValue ? e.push(`>${encodeToXmlString(this.nodeValue)}</${this.nodeName}>`) : e.push(\"/>\");\n    } else e.push(encodeToXmlString(this.nodeValue));\n  }\n}\nclass SimpleXMLParser extends XMLParserBase {\n  constructor({\n    hasAttributes: e = !1,\n    lowerCaseName: t = !1\n  }) {\n    super();\n    this._currentFragment = null;\n    this._stack = null;\n    this._errorCode = Rs;\n    this._hasAttributes = e;\n    this._lowerCaseName = t;\n  }\n  parseFromString(e) {\n    this._currentFragment = [];\n    this._stack = [];\n    this._errorCode = Rs;\n    this.parseXml(e);\n    if (this._errorCode !== Rs) return;\n    const [t] = this._currentFragment;\n    return t ? {\n      documentElement: t\n    } : void 0;\n  }\n  onText(e) {\n    if (function isWhitespaceString(e) {\n      for (let t = 0, i = e.length; t < i; t++) if (!isWhitespace(e, t)) return !1;\n      return !0;\n    }(e)) return;\n    const t = new SimpleDOMNode(\"#text\", e);\n    this._currentFragment.push(t);\n  }\n  onCdata(e) {\n    const t = new SimpleDOMNode(\"#text\", e);\n    this._currentFragment.push(t);\n  }\n  onBeginElement(e, t, i) {\n    this._lowerCaseName && (e = e.toLowerCase());\n    const a = new SimpleDOMNode(e);\n    a.childNodes = [];\n    this._hasAttributes && (a.attributes = t);\n    this._currentFragment.push(a);\n    if (!i) {\n      this._stack.push(this._currentFragment);\n      this._currentFragment = a.childNodes;\n    }\n  }\n  onEndElement(e) {\n    this._currentFragment = this._stack.pop() || [];\n    const t = this._currentFragment.at(-1);\n    if (!t) return null;\n    for (const e of t.childNodes) e.parentNode = t;\n    return t;\n  }\n  onError(e) {\n    this._errorCode = e;\n  }\n}\nclass MetadataParser {\n  constructor(e) {\n    e = this._repair(e);\n    const t = new SimpleXMLParser({\n      lowerCaseName: !0\n    }).parseFromString(e);\n    this._metadataMap = new Map();\n    this._data = e;\n    t && this._parse(t);\n  }\n  _repair(e) {\n    return e.replace(/^[^<]+/, \"\").replaceAll(/>\\\\376\\\\377([^<]+)/g, function (e, t) {\n      const i = t.replaceAll(/\\\\([0-3])([0-7])([0-7])/g, function (e, t, i, a) {\n          return String.fromCharCode(64 * t + 8 * i + 1 * a);\n        }).replaceAll(/&(amp|apos|gt|lt|quot);/g, function (e, t) {\n          switch (t) {\n            case \"amp\":\n              return \"&\";\n            case \"apos\":\n              return \"'\";\n            case \"gt\":\n              return \">\";\n            case \"lt\":\n              return \"<\";\n            case \"quot\":\n              return '\"';\n          }\n          throw new Error(`_repair: ${t} isn't defined.`);\n        }),\n        a = [\">\"];\n      for (let e = 0, t = i.length; e < t; e += 2) {\n        const t = 256 * i.charCodeAt(e) + i.charCodeAt(e + 1);\n        t >= 32 && t < 127 && 60 !== t && 62 !== t && 38 !== t ? a.push(String.fromCharCode(t)) : a.push(\"&#x\" + (65536 + t).toString(16).substring(1) + \";\");\n      }\n      return a.join(\"\");\n    });\n  }\n  _getSequence(e) {\n    const t = e.nodeName;\n    return \"rdf:bag\" !== t && \"rdf:seq\" !== t && \"rdf:alt\" !== t ? null : e.childNodes.filter(e => \"rdf:li\" === e.nodeName);\n  }\n  _parseArray(e) {\n    if (!e.hasChildNodes()) return;\n    const [t] = e.childNodes,\n      i = this._getSequence(t) || [];\n    this._metadataMap.set(e.nodeName, i.map(e => e.textContent.trim()));\n  }\n  _parse(e) {\n    let t = e.documentElement;\n    if (\"rdf:rdf\" !== t.nodeName) {\n      t = t.firstChild;\n      for (; t && \"rdf:rdf\" !== t.nodeName;) t = t.nextSibling;\n    }\n    if (t && \"rdf:rdf\" === t.nodeName && t.hasChildNodes()) for (const e of t.childNodes) if (\"rdf:description\" === e.nodeName) for (const t of e.childNodes) {\n      const e = t.nodeName;\n      switch (e) {\n        case \"#text\":\n          continue;\n        case \"dc:creator\":\n        case \"dc:subject\":\n          this._parseArray(t);\n          continue;\n      }\n      this._metadataMap.set(e, t.textContent.trim());\n    }\n  }\n  get serializable() {\n    return {\n      parsedData: this._metadataMap,\n      rawData: this._data\n    };\n  }\n}\nclass DecryptStream extends DecodeStream {\n  constructor(e, t, i) {\n    super(t);\n    this.str = e;\n    this.dict = e.dict;\n    this.decrypt = i;\n    this.nextChunk = null;\n    this.initialized = !1;\n  }\n  readBlock() {\n    let e;\n    if (this.initialized) e = this.nextChunk;else {\n      e = this.str.getBytes(512);\n      this.initialized = !0;\n    }\n    if (!e || 0 === e.length) {\n      this.eof = !0;\n      return;\n    }\n    this.nextChunk = this.str.getBytes(512);\n    const t = this.nextChunk?.length > 0;\n    e = (0, this.decrypt)(e, !t);\n    const i = this.bufferLength,\n      a = i + e.length;\n    this.ensureBuffer(a).set(e, i);\n    this.bufferLength = a;\n  }\n}\nclass ARCFourCipher {\n  constructor(e) {\n    this.a = 0;\n    this.b = 0;\n    const t = new Uint8Array(256),\n      i = e.length;\n    for (let e = 0; e < 256; ++e) t[e] = e;\n    for (let a = 0, s = 0; a < 256; ++a) {\n      const r = t[a];\n      s = s + r + e[a % i] & 255;\n      t[a] = t[s];\n      t[s] = r;\n    }\n    this.s = t;\n  }\n  encryptBlock(e) {\n    let t = this.a,\n      i = this.b;\n    const a = this.s,\n      s = e.length,\n      r = new Uint8Array(s);\n    for (let n = 0; n < s; ++n) {\n      t = t + 1 & 255;\n      const s = a[t];\n      i = i + s & 255;\n      const g = a[i];\n      a[t] = g;\n      a[i] = s;\n      r[n] = e[n] ^ a[s + g & 255];\n    }\n    this.a = t;\n    this.b = i;\n    return r;\n  }\n  decryptBlock(e) {\n    return this.encryptBlock(e);\n  }\n  encrypt(e) {\n    return this.encryptBlock(e);\n  }\n}\nconst Hs = function calculateMD5Closure() {\n  const e = new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]),\n    t = new Int32Array([-680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341, -45705983, 1770035416, -1958414417, -42063, -1990404162, 1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632, 643717713, -373897302, -701558691, 38016083, -660478335, -405537848, 568446438, -1019803690, -187363961, 1163531501, -1444681467, -51403784, 1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556, -1530992060, 1272893353, -155497632, -1094730640, 681279174, -358537222, -722521979, 76029189, -640364487, -421815835, 530742520, -995338651, -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606, -1051523, -2054922799, 1873313359, -30611744, -1560198380, 1309151649, -145523070, -1120210379, 718787259, -343485551]);\n  return function hash(i, a, s) {\n    let r = 1732584193,\n      n = -271733879,\n      g = -1732584194,\n      o = 271733878;\n    const c = s + 72 & -64,\n      C = new Uint8Array(c);\n    let h, l;\n    for (h = 0; h < s; ++h) C[h] = i[a++];\n    C[h++] = 128;\n    const Q = c - 8;\n    for (; h < Q;) C[h++] = 0;\n    C[h++] = s << 3 & 255;\n    C[h++] = s >> 5 & 255;\n    C[h++] = s >> 13 & 255;\n    C[h++] = s >> 21 & 255;\n    C[h++] = s >>> 29 & 255;\n    C[h++] = 0;\n    C[h++] = 0;\n    C[h++] = 0;\n    const E = new Int32Array(16);\n    for (h = 0; h < c;) {\n      for (l = 0; l < 16; ++l, h += 4) E[l] = C[h] | C[h + 1] << 8 | C[h + 2] << 16 | C[h + 3] << 24;\n      let i,\n        a,\n        s = r,\n        c = n,\n        Q = g,\n        u = o;\n      for (l = 0; l < 64; ++l) {\n        if (l < 16) {\n          i = c & Q | ~c & u;\n          a = l;\n        } else if (l < 32) {\n          i = u & c | ~u & Q;\n          a = 5 * l + 1 & 15;\n        } else if (l < 48) {\n          i = c ^ Q ^ u;\n          a = 3 * l + 5 & 15;\n        } else {\n          i = Q ^ (c | ~u);\n          a = 7 * l & 15;\n        }\n        const r = u,\n          n = s + i + t[l] + E[a] | 0,\n          g = e[l];\n        u = Q;\n        Q = c;\n        c = c + (n << g | n >>> 32 - g) | 0;\n        s = r;\n      }\n      r = r + s | 0;\n      n = n + c | 0;\n      g = g + Q | 0;\n      o = o + u | 0;\n    }\n    return new Uint8Array([255 & r, r >> 8 & 255, r >> 16 & 255, r >>> 24 & 255, 255 & n, n >> 8 & 255, n >> 16 & 255, n >>> 24 & 255, 255 & g, g >> 8 & 255, g >> 16 & 255, g >>> 24 & 255, 255 & o, o >> 8 & 255, o >> 16 & 255, o >>> 24 & 255]);\n  };\n}();\nclass Word64 {\n  constructor(e, t) {\n    this.high = 0 | e;\n    this.low = 0 | t;\n  }\n  and(e) {\n    this.high &= e.high;\n    this.low &= e.low;\n  }\n  xor(e) {\n    this.high ^= e.high;\n    this.low ^= e.low;\n  }\n  or(e) {\n    this.high |= e.high;\n    this.low |= e.low;\n  }\n  shiftRight(e) {\n    if (e >= 32) {\n      this.low = this.high >>> e - 32 | 0;\n      this.high = 0;\n    } else {\n      this.low = this.low >>> e | this.high << 32 - e;\n      this.high = this.high >>> e | 0;\n    }\n  }\n  shiftLeft(e) {\n    if (e >= 32) {\n      this.high = this.low << e - 32;\n      this.low = 0;\n    } else {\n      this.high = this.high << e | this.low >>> 32 - e;\n      this.low <<= e;\n    }\n  }\n  rotateRight(e) {\n    let t, i;\n    if (32 & e) {\n      i = this.low;\n      t = this.high;\n    } else {\n      t = this.low;\n      i = this.high;\n    }\n    e &= 31;\n    this.low = t >>> e | i << 32 - e;\n    this.high = i >>> e | t << 32 - e;\n  }\n  not() {\n    this.high = ~this.high;\n    this.low = ~this.low;\n  }\n  add(e) {\n    const t = (this.low >>> 0) + (e.low >>> 0);\n    let i = (this.high >>> 0) + (e.high >>> 0);\n    t > 4294967295 && (i += 1);\n    this.low = 0 | t;\n    this.high = 0 | i;\n  }\n  copyTo(e, t) {\n    e[t] = this.high >>> 24 & 255;\n    e[t + 1] = this.high >> 16 & 255;\n    e[t + 2] = this.high >> 8 & 255;\n    e[t + 3] = 255 & this.high;\n    e[t + 4] = this.low >>> 24 & 255;\n    e[t + 5] = this.low >> 16 & 255;\n    e[t + 6] = this.low >> 8 & 255;\n    e[t + 7] = 255 & this.low;\n  }\n  assign(e) {\n    this.high = e.high;\n    this.low = e.low;\n  }\n}\nconst Js = function calculateSHA256Closure() {\n    function rotr(e, t) {\n      return e >>> t | e << 32 - t;\n    }\n    function ch(e, t, i) {\n      return e & t ^ ~e & i;\n    }\n    function maj(e, t, i) {\n      return e & t ^ e & i ^ t & i;\n    }\n    function sigma(e) {\n      return rotr(e, 2) ^ rotr(e, 13) ^ rotr(e, 22);\n    }\n    function sigmaPrime(e) {\n      return rotr(e, 6) ^ rotr(e, 11) ^ rotr(e, 25);\n    }\n    function littleSigma(e) {\n      return rotr(e, 7) ^ rotr(e, 18) ^ e >>> 3;\n    }\n    const e = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];\n    return function hash(t, i, a) {\n      let s = 1779033703,\n        r = 3144134277,\n        n = 1013904242,\n        g = 2773480762,\n        o = 1359893119,\n        c = 2600822924,\n        C = 528734635,\n        h = 1541459225;\n      const l = 64 * Math.ceil((a + 9) / 64),\n        Q = new Uint8Array(l);\n      let E, u;\n      for (E = 0; E < a; ++E) Q[E] = t[i++];\n      Q[E++] = 128;\n      const d = l - 8;\n      for (; E < d;) Q[E++] = 0;\n      Q[E++] = 0;\n      Q[E++] = 0;\n      Q[E++] = 0;\n      Q[E++] = a >>> 29 & 255;\n      Q[E++] = a >> 21 & 255;\n      Q[E++] = a >> 13 & 255;\n      Q[E++] = a >> 5 & 255;\n      Q[E++] = a << 3 & 255;\n      const f = new Uint32Array(64);\n      for (E = 0; E < l;) {\n        for (u = 0; u < 16; ++u) {\n          f[u] = Q[E] << 24 | Q[E + 1] << 16 | Q[E + 2] << 8 | Q[E + 3];\n          E += 4;\n        }\n        for (u = 16; u < 64; ++u) f[u] = (rotr(p = f[u - 2], 17) ^ rotr(p, 19) ^ p >>> 10) + f[u - 7] + littleSigma(f[u - 15]) + f[u - 16] | 0;\n        let t,\n          i,\n          a = s,\n          l = r,\n          d = n,\n          m = g,\n          y = o,\n          w = c,\n          D = C,\n          b = h;\n        for (u = 0; u < 64; ++u) {\n          t = b + sigmaPrime(y) + ch(y, w, D) + e[u] + f[u];\n          i = sigma(a) + maj(a, l, d);\n          b = D;\n          D = w;\n          w = y;\n          y = m + t | 0;\n          m = d;\n          d = l;\n          l = a;\n          a = t + i | 0;\n        }\n        s = s + a | 0;\n        r = r + l | 0;\n        n = n + d | 0;\n        g = g + m | 0;\n        o = o + y | 0;\n        c = c + w | 0;\n        C = C + D | 0;\n        h = h + b | 0;\n      }\n      var p;\n      return new Uint8Array([s >> 24 & 255, s >> 16 & 255, s >> 8 & 255, 255 & s, r >> 24 & 255, r >> 16 & 255, r >> 8 & 255, 255 & r, n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, 255 & n, g >> 24 & 255, g >> 16 & 255, g >> 8 & 255, 255 & g, o >> 24 & 255, o >> 16 & 255, o >> 8 & 255, 255 & o, c >> 24 & 255, c >> 16 & 255, c >> 8 & 255, 255 & c, C >> 24 & 255, C >> 16 & 255, C >> 8 & 255, 255 & C, h >> 24 & 255, h >> 16 & 255, h >> 8 & 255, 255 & h]);\n    };\n  }(),\n  Ys = function calculateSHA512Closure() {\n    function ch(e, t, i, a, s) {\n      e.assign(t);\n      e.and(i);\n      s.assign(t);\n      s.not();\n      s.and(a);\n      e.xor(s);\n    }\n    function maj(e, t, i, a, s) {\n      e.assign(t);\n      e.and(i);\n      s.assign(t);\n      s.and(a);\n      e.xor(s);\n      s.assign(i);\n      s.and(a);\n      e.xor(s);\n    }\n    function sigma(e, t, i) {\n      e.assign(t);\n      e.rotateRight(28);\n      i.assign(t);\n      i.rotateRight(34);\n      e.xor(i);\n      i.assign(t);\n      i.rotateRight(39);\n      e.xor(i);\n    }\n    function sigmaPrime(e, t, i) {\n      e.assign(t);\n      e.rotateRight(14);\n      i.assign(t);\n      i.rotateRight(18);\n      e.xor(i);\n      i.assign(t);\n      i.rotateRight(41);\n      e.xor(i);\n    }\n    function littleSigma(e, t, i) {\n      e.assign(t);\n      e.rotateRight(1);\n      i.assign(t);\n      i.rotateRight(8);\n      e.xor(i);\n      i.assign(t);\n      i.shiftRight(7);\n      e.xor(i);\n    }\n    function littleSigmaPrime(e, t, i) {\n      e.assign(t);\n      e.rotateRight(19);\n      i.assign(t);\n      i.rotateRight(61);\n      e.xor(i);\n      i.assign(t);\n      i.shiftRight(6);\n      e.xor(i);\n    }\n    const e = [new Word64(1116352408, 3609767458), new Word64(1899447441, 602891725), new Word64(3049323471, 3964484399), new Word64(3921009573, 2173295548), new Word64(961987163, 4081628472), new Word64(1508970993, 3053834265), new Word64(2453635748, 2937671579), new Word64(2870763221, 3664609560), new Word64(3624381080, 2734883394), new Word64(310598401, 1164996542), new Word64(607225278, 1323610764), new Word64(1426881987, 3590304994), new Word64(1925078388, 4068182383), new Word64(2162078206, 991336113), new Word64(2614888103, 633803317), new Word64(3248222580, 3479774868), new Word64(3835390401, 2666613458), new Word64(4022224774, 944711139), new Word64(264347078, 2341262773), new Word64(604807628, 2007800933), new Word64(770255983, 1495990901), new Word64(1249150122, 1856431235), new Word64(1555081692, 3175218132), new Word64(1996064986, 2198950837), new Word64(2554220882, 3999719339), new Word64(2821834349, 766784016), new Word64(2952996808, 2566594879), new Word64(3210313671, 3203337956), new Word64(3336571891, 1034457026), new Word64(3584528711, 2466948901), new Word64(113926993, 3758326383), new Word64(338241895, 168717936), new Word64(666307205, 1188179964), new Word64(773529912, 1546045734), new Word64(1294757372, 1522805485), new Word64(1396182291, 2643833823), new Word64(1695183700, 2343527390), new Word64(1986661051, 1014477480), new Word64(2177026350, 1206759142), new Word64(2456956037, 344077627), new Word64(2730485921, 1290863460), new Word64(2820302411, 3158454273), new Word64(3259730800, 3505952657), new Word64(3345764771, 106217008), new Word64(3516065817, 3606008344), new Word64(3600352804, 1432725776), new Word64(4094571909, 1467031594), new Word64(275423344, 851169720), new Word64(430227734, 3100823752), new Word64(506948616, 1363258195), new Word64(659060556, 3750685593), new Word64(883997877, 3785050280), new Word64(958139571, 3318307427), new Word64(1322822218, 3812723403), new Word64(1537002063, 2003034995), new Word64(1747873779, 3602036899), new Word64(1955562222, 1575990012), new Word64(2024104815, 1125592928), new Word64(2227730452, 2716904306), new Word64(2361852424, 442776044), new Word64(2428436474, 593698344), new Word64(2756734187, 3733110249), new Word64(3204031479, 2999351573), new Word64(3329325298, 3815920427), new Word64(3391569614, 3928383900), new Word64(3515267271, 566280711), new Word64(3940187606, 3454069534), new Word64(4118630271, 4000239992), new Word64(116418474, 1914138554), new Word64(174292421, 2731055270), new Word64(289380356, 3203993006), new Word64(460393269, 320620315), new Word64(685471733, 587496836), new Word64(852142971, 1086792851), new Word64(1017036298, 365543100), new Word64(1126000580, 2618297676), new Word64(1288033470, 3409855158), new Word64(1501505948, 4234509866), new Word64(1607167915, 987167468), new Word64(1816402316, 1246189591)];\n    return function hash(t, i, a, s = !1) {\n      let r, n, g, o, c, C, h, l;\n      if (s) {\n        r = new Word64(3418070365, 3238371032);\n        n = new Word64(1654270250, 914150663);\n        g = new Word64(2438529370, 812702999);\n        o = new Word64(355462360, 4144912697);\n        c = new Word64(1731405415, 4290775857);\n        C = new Word64(2394180231, 1750603025);\n        h = new Word64(3675008525, 1694076839);\n        l = new Word64(1203062813, 3204075428);\n      } else {\n        r = new Word64(1779033703, 4089235720);\n        n = new Word64(3144134277, 2227873595);\n        g = new Word64(1013904242, 4271175723);\n        o = new Word64(2773480762, 1595750129);\n        c = new Word64(1359893119, 2917565137);\n        C = new Word64(2600822924, 725511199);\n        h = new Word64(528734635, 4215389547);\n        l = new Word64(1541459225, 327033209);\n      }\n      const Q = 128 * Math.ceil((a + 17) / 128),\n        E = new Uint8Array(Q);\n      let u, d;\n      for (u = 0; u < a; ++u) E[u] = t[i++];\n      E[u++] = 128;\n      const f = Q - 16;\n      for (; u < f;) E[u++] = 0;\n      E[u++] = 0;\n      E[u++] = 0;\n      E[u++] = 0;\n      E[u++] = 0;\n      E[u++] = 0;\n      E[u++] = 0;\n      E[u++] = 0;\n      E[u++] = 0;\n      E[u++] = 0;\n      E[u++] = 0;\n      E[u++] = 0;\n      E[u++] = a >>> 29 & 255;\n      E[u++] = a >> 21 & 255;\n      E[u++] = a >> 13 & 255;\n      E[u++] = a >> 5 & 255;\n      E[u++] = a << 3 & 255;\n      const p = new Array(80);\n      for (u = 0; u < 80; u++) p[u] = new Word64(0, 0);\n      let m = new Word64(0, 0),\n        y = new Word64(0, 0),\n        w = new Word64(0, 0),\n        D = new Word64(0, 0),\n        b = new Word64(0, 0),\n        F = new Word64(0, 0),\n        S = new Word64(0, 0),\n        k = new Word64(0, 0);\n      const R = new Word64(0, 0),\n        N = new Word64(0, 0),\n        G = new Word64(0, 0),\n        x = new Word64(0, 0);\n      let U, M;\n      for (u = 0; u < Q;) {\n        for (d = 0; d < 16; ++d) {\n          p[d].high = E[u] << 24 | E[u + 1] << 16 | E[u + 2] << 8 | E[u + 3];\n          p[d].low = E[u + 4] << 24 | E[u + 5] << 16 | E[u + 6] << 8 | E[u + 7];\n          u += 8;\n        }\n        for (d = 16; d < 80; ++d) {\n          U = p[d];\n          littleSigmaPrime(U, p[d - 2], x);\n          U.add(p[d - 7]);\n          littleSigma(G, p[d - 15], x);\n          U.add(G);\n          U.add(p[d - 16]);\n        }\n        m.assign(r);\n        y.assign(n);\n        w.assign(g);\n        D.assign(o);\n        b.assign(c);\n        F.assign(C);\n        S.assign(h);\n        k.assign(l);\n        for (d = 0; d < 80; ++d) {\n          R.assign(k);\n          sigmaPrime(G, b, x);\n          R.add(G);\n          ch(G, b, F, S, x);\n          R.add(G);\n          R.add(e[d]);\n          R.add(p[d]);\n          sigma(N, m, x);\n          maj(G, m, y, w, x);\n          N.add(G);\n          U = k;\n          k = S;\n          S = F;\n          F = b;\n          D.add(R);\n          b = D;\n          D = w;\n          w = y;\n          y = m;\n          U.assign(R);\n          U.add(N);\n          m = U;\n        }\n        r.add(m);\n        n.add(y);\n        g.add(w);\n        o.add(D);\n        c.add(b);\n        C.add(F);\n        h.add(S);\n        l.add(k);\n      }\n      if (s) {\n        M = new Uint8Array(48);\n        r.copyTo(M, 0);\n        n.copyTo(M, 8);\n        g.copyTo(M, 16);\n        o.copyTo(M, 24);\n        c.copyTo(M, 32);\n        C.copyTo(M, 40);\n      } else {\n        M = new Uint8Array(64);\n        r.copyTo(M, 0);\n        n.copyTo(M, 8);\n        g.copyTo(M, 16);\n        o.copyTo(M, 24);\n        c.copyTo(M, 32);\n        C.copyTo(M, 40);\n        h.copyTo(M, 48);\n        l.copyTo(M, 56);\n      }\n      return M;\n    };\n  }();\nclass NullCipher {\n  decryptBlock(e) {\n    return e;\n  }\n  encrypt(e) {\n    return e;\n  }\n}\nclass AESBaseCipher {\n  constructor() {\n    this.constructor === AESBaseCipher && unreachable(\"Cannot initialize AESBaseCipher.\");\n    this._s = new Uint8Array([99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22]);\n    this._inv_s = new Uint8Array([82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125]);\n    this._mix = new Uint32Array([0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795]);\n    this._mixCol = new Uint8Array(256);\n    for (let e = 0; e < 256; e++) this._mixCol[e] = e < 128 ? e << 1 : e << 1 ^ 27;\n    this.buffer = new Uint8Array(16);\n    this.bufferPosition = 0;\n  }\n  _expandKey(e) {\n    unreachable(\"Cannot call `_expandKey` on the base class\");\n  }\n  _decrypt(e, t) {\n    let i, a, s;\n    const r = new Uint8Array(16);\n    r.set(e);\n    for (let e = 0, i = this._keySize; e < 16; ++e, ++i) r[e] ^= t[i];\n    for (let e = this._cyclesOfRepetition - 1; e >= 1; --e) {\n      i = r[13];\n      r[13] = r[9];\n      r[9] = r[5];\n      r[5] = r[1];\n      r[1] = i;\n      i = r[14];\n      a = r[10];\n      r[14] = r[6];\n      r[10] = r[2];\n      r[6] = i;\n      r[2] = a;\n      i = r[15];\n      a = r[11];\n      s = r[7];\n      r[15] = r[3];\n      r[11] = i;\n      r[7] = a;\n      r[3] = s;\n      for (let e = 0; e < 16; ++e) r[e] = this._inv_s[r[e]];\n      for (let i = 0, a = 16 * e; i < 16; ++i, ++a) r[i] ^= t[a];\n      for (let e = 0; e < 16; e += 4) {\n        const t = this._mix[r[e]],\n          a = this._mix[r[e + 1]],\n          s = this._mix[r[e + 2]],\n          n = this._mix[r[e + 3]];\n        i = t ^ a >>> 8 ^ a << 24 ^ s >>> 16 ^ s << 16 ^ n >>> 24 ^ n << 8;\n        r[e] = i >>> 24 & 255;\n        r[e + 1] = i >> 16 & 255;\n        r[e + 2] = i >> 8 & 255;\n        r[e + 3] = 255 & i;\n      }\n    }\n    i = r[13];\n    r[13] = r[9];\n    r[9] = r[5];\n    r[5] = r[1];\n    r[1] = i;\n    i = r[14];\n    a = r[10];\n    r[14] = r[6];\n    r[10] = r[2];\n    r[6] = i;\n    r[2] = a;\n    i = r[15];\n    a = r[11];\n    s = r[7];\n    r[15] = r[3];\n    r[11] = i;\n    r[7] = a;\n    r[3] = s;\n    for (let e = 0; e < 16; ++e) {\n      r[e] = this._inv_s[r[e]];\n      r[e] ^= t[e];\n    }\n    return r;\n  }\n  _encrypt(e, t) {\n    const i = this._s;\n    let a, s, r;\n    const n = new Uint8Array(16);\n    n.set(e);\n    for (let e = 0; e < 16; ++e) n[e] ^= t[e];\n    for (let e = 1; e < this._cyclesOfRepetition; e++) {\n      for (let e = 0; e < 16; ++e) n[e] = i[n[e]];\n      r = n[1];\n      n[1] = n[5];\n      n[5] = n[9];\n      n[9] = n[13];\n      n[13] = r;\n      r = n[2];\n      s = n[6];\n      n[2] = n[10];\n      n[6] = n[14];\n      n[10] = r;\n      n[14] = s;\n      r = n[3];\n      s = n[7];\n      a = n[11];\n      n[3] = n[15];\n      n[7] = r;\n      n[11] = s;\n      n[15] = a;\n      for (let e = 0; e < 16; e += 4) {\n        const t = n[e + 0],\n          i = n[e + 1],\n          s = n[e + 2],\n          r = n[e + 3];\n        a = t ^ i ^ s ^ r;\n        n[e + 0] ^= a ^ this._mixCol[t ^ i];\n        n[e + 1] ^= a ^ this._mixCol[i ^ s];\n        n[e + 2] ^= a ^ this._mixCol[s ^ r];\n        n[e + 3] ^= a ^ this._mixCol[r ^ t];\n      }\n      for (let i = 0, a = 16 * e; i < 16; ++i, ++a) n[i] ^= t[a];\n    }\n    for (let e = 0; e < 16; ++e) n[e] = i[n[e]];\n    r = n[1];\n    n[1] = n[5];\n    n[5] = n[9];\n    n[9] = n[13];\n    n[13] = r;\n    r = n[2];\n    s = n[6];\n    n[2] = n[10];\n    n[6] = n[14];\n    n[10] = r;\n    n[14] = s;\n    r = n[3];\n    s = n[7];\n    a = n[11];\n    n[3] = n[15];\n    n[7] = r;\n    n[11] = s;\n    n[15] = a;\n    for (let e = 0, i = this._keySize; e < 16; ++e, ++i) n[e] ^= t[i];\n    return n;\n  }\n  _decryptBlock2(e, t) {\n    const i = e.length;\n    let a = this.buffer,\n      s = this.bufferPosition;\n    const r = [];\n    let n = this.iv;\n    for (let t = 0; t < i; ++t) {\n      a[s] = e[t];\n      ++s;\n      if (s < 16) continue;\n      const i = this._decrypt(a, this._key);\n      for (let e = 0; e < 16; ++e) i[e] ^= n[e];\n      n = a;\n      r.push(i);\n      a = new Uint8Array(16);\n      s = 0;\n    }\n    this.buffer = a;\n    this.bufferLength = s;\n    this.iv = n;\n    if (0 === r.length) return new Uint8Array(0);\n    let g = 16 * r.length;\n    if (t) {\n      const e = r.at(-1);\n      let t = e[15];\n      if (t <= 16) {\n        for (let i = 15, a = 16 - t; i >= a; --i) if (e[i] !== t) {\n          t = 0;\n          break;\n        }\n        g -= t;\n        r[r.length - 1] = e.subarray(0, 16 - t);\n      }\n    }\n    const o = new Uint8Array(g);\n    for (let e = 0, t = 0, i = r.length; e < i; ++e, t += 16) o.set(r[e], t);\n    return o;\n  }\n  decryptBlock(e, t, i = null) {\n    const a = e.length,\n      s = this.buffer;\n    let r = this.bufferPosition;\n    if (i) this.iv = i;else {\n      for (let t = 0; r < 16 && t < a; ++t, ++r) s[r] = e[t];\n      if (r < 16) {\n        this.bufferLength = r;\n        return new Uint8Array(0);\n      }\n      this.iv = s;\n      e = e.subarray(16);\n    }\n    this.buffer = new Uint8Array(16);\n    this.bufferLength = 0;\n    this.decryptBlock = this._decryptBlock2;\n    return this.decryptBlock(e, t);\n  }\n  encrypt(e, t) {\n    const i = e.length;\n    let a = this.buffer,\n      s = this.bufferPosition;\n    const r = [];\n    t || (t = new Uint8Array(16));\n    for (let n = 0; n < i; ++n) {\n      a[s] = e[n];\n      ++s;\n      if (s < 16) continue;\n      for (let e = 0; e < 16; ++e) a[e] ^= t[e];\n      const i = this._encrypt(a, this._key);\n      t = i;\n      r.push(i);\n      a = new Uint8Array(16);\n      s = 0;\n    }\n    this.buffer = a;\n    this.bufferLength = s;\n    this.iv = t;\n    if (0 === r.length) return new Uint8Array(0);\n    const n = 16 * r.length,\n      g = new Uint8Array(n);\n    for (let e = 0, t = 0, i = r.length; e < i; ++e, t += 16) g.set(r[e], t);\n    return g;\n  }\n}\nclass AES128Cipher extends AESBaseCipher {\n  constructor(e) {\n    super();\n    this._cyclesOfRepetition = 10;\n    this._keySize = 160;\n    this._rcon = new Uint8Array([141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141]);\n    this._key = this._expandKey(e);\n  }\n  _expandKey(e) {\n    const t = this._s,\n      i = this._rcon,\n      a = new Uint8Array(176);\n    a.set(e);\n    for (let e = 16, s = 1; e < 176; ++s) {\n      let r = a[e - 3],\n        n = a[e - 2],\n        g = a[e - 1],\n        o = a[e - 4];\n      r = t[r];\n      n = t[n];\n      g = t[g];\n      o = t[o];\n      r ^= i[s];\n      for (let t = 0; t < 4; ++t) {\n        a[e] = r ^= a[e - 16];\n        e++;\n        a[e] = n ^= a[e - 16];\n        e++;\n        a[e] = g ^= a[e - 16];\n        e++;\n        a[e] = o ^= a[e - 16];\n        e++;\n      }\n    }\n    return a;\n  }\n}\nclass AES256Cipher extends AESBaseCipher {\n  constructor(e) {\n    super();\n    this._cyclesOfRepetition = 14;\n    this._keySize = 224;\n    this._key = this._expandKey(e);\n  }\n  _expandKey(e) {\n    const t = this._s,\n      i = new Uint8Array(240);\n    i.set(e);\n    let a,\n      s,\n      r,\n      n,\n      g = 1;\n    for (let e = 32, o = 1; e < 240; ++o) {\n      if (e % 32 == 16) {\n        a = t[a];\n        s = t[s];\n        r = t[r];\n        n = t[n];\n      } else if (e % 32 == 0) {\n        a = i[e - 3];\n        s = i[e - 2];\n        r = i[e - 1];\n        n = i[e - 4];\n        a = t[a];\n        s = t[s];\n        r = t[r];\n        n = t[n];\n        a ^= g;\n        (g <<= 1) >= 256 && (g = 255 & (27 ^ g));\n      }\n      for (let t = 0; t < 4; ++t) {\n        i[e] = a ^= i[e - 32];\n        e++;\n        i[e] = s ^= i[e - 32];\n        e++;\n        i[e] = r ^= i[e - 32];\n        e++;\n        i[e] = n ^= i[e - 32];\n        e++;\n      }\n    }\n    return i;\n  }\n}\nclass PDF17 {\n  checkOwnerPassword(e, t, i, a) {\n    const s = new Uint8Array(e.length + 56);\n    s.set(e, 0);\n    s.set(t, e.length);\n    s.set(i, e.length + t.length);\n    return isArrayEqual(Js(s, 0, s.length), a);\n  }\n  checkUserPassword(e, t, i) {\n    const a = new Uint8Array(e.length + 8);\n    a.set(e, 0);\n    a.set(t, e.length);\n    return isArrayEqual(Js(a, 0, a.length), i);\n  }\n  getOwnerKey(e, t, i, a) {\n    const s = new Uint8Array(e.length + 56);\n    s.set(e, 0);\n    s.set(t, e.length);\n    s.set(i, e.length + t.length);\n    const r = Js(s, 0, s.length);\n    return new AES256Cipher(r).decryptBlock(a, !1, new Uint8Array(16));\n  }\n  getUserKey(e, t, i) {\n    const a = new Uint8Array(e.length + 8);\n    a.set(e, 0);\n    a.set(t, e.length);\n    const s = Js(a, 0, a.length);\n    return new AES256Cipher(s).decryptBlock(i, !1, new Uint8Array(16));\n  }\n}\nclass PDF20 {\n  _hash(e, t, i) {\n    let a = Js(t, 0, t.length).subarray(0, 32),\n      s = [0],\n      r = 0;\n    for (; r < 64 || s.at(-1) > r - 32;) {\n      const t = e.length + a.length + i.length,\n        c = new Uint8Array(t);\n      let C = 0;\n      c.set(e, C);\n      C += e.length;\n      c.set(a, C);\n      C += a.length;\n      c.set(i, C);\n      const h = new Uint8Array(64 * t);\n      for (let e = 0, i = 0; e < 64; e++, i += t) h.set(c, i);\n      s = new AES128Cipher(a.subarray(0, 16)).encrypt(h, a.subarray(16, 32));\n      const l = s.slice(0, 16).reduce((e, t) => e + t, 0) % 3;\n      0 === l ? a = Js(s, 0, s.length) : 1 === l ? a = (n = s, g = 0, o = s.length, Ys(n, g, o, !0)) : 2 === l && (a = Ys(s, 0, s.length));\n      r++;\n    }\n    var n, g, o;\n    return a.subarray(0, 32);\n  }\n  checkOwnerPassword(e, t, i, a) {\n    const s = new Uint8Array(e.length + 56);\n    s.set(e, 0);\n    s.set(t, e.length);\n    s.set(i, e.length + t.length);\n    return isArrayEqual(this._hash(e, s, i), a);\n  }\n  checkUserPassword(e, t, i) {\n    const a = new Uint8Array(e.length + 8);\n    a.set(e, 0);\n    a.set(t, e.length);\n    return isArrayEqual(this._hash(e, a, []), i);\n  }\n  getOwnerKey(e, t, i, a) {\n    const s = new Uint8Array(e.length + 56);\n    s.set(e, 0);\n    s.set(t, e.length);\n    s.set(i, e.length + t.length);\n    const r = this._hash(e, s, i);\n    return new AES256Cipher(r).decryptBlock(a, !1, new Uint8Array(16));\n  }\n  getUserKey(e, t, i) {\n    const a = new Uint8Array(e.length + 8);\n    a.set(e, 0);\n    a.set(t, e.length);\n    const s = this._hash(e, a, []);\n    return new AES256Cipher(s).decryptBlock(i, !1, new Uint8Array(16));\n  }\n}\nclass CipherTransform {\n  constructor(e, t) {\n    this.StringCipherConstructor = e;\n    this.StreamCipherConstructor = t;\n  }\n  createStream(e, t) {\n    const i = new this.StreamCipherConstructor();\n    return new DecryptStream(e, t, function cipherTransformDecryptStream(e, t) {\n      return i.decryptBlock(e, t);\n    });\n  }\n  decryptString(e) {\n    const t = new this.StringCipherConstructor();\n    let i = stringToBytes(e);\n    i = t.decryptBlock(i, !0);\n    return bytesToString(i);\n  }\n  encryptString(e) {\n    const t = new this.StringCipherConstructor();\n    if (t instanceof AESBaseCipher) {\n      const i = 16 - e.length % 16;\n      e += String.fromCharCode(i).repeat(i);\n      const a = new Uint8Array(16);\n      if (\"undefined\" != typeof crypto) crypto.getRandomValues(a);else for (let e = 0; e < 16; e++) a[e] = Math.floor(256 * Math.random());\n      let s = stringToBytes(e);\n      s = t.encrypt(s, a);\n      const r = new Uint8Array(16 + s.length);\n      r.set(a);\n      r.set(s, 16);\n      return bytesToString(r);\n    }\n    let i = stringToBytes(e);\n    i = t.encrypt(i);\n    return bytesToString(i);\n  }\n}\nclass CipherTransformFactory {\n  static #k = new Uint8Array([40, 191, 78, 94, 78, 117, 138, 65, 100, 0, 78, 86, 255, 250, 1, 8, 46, 46, 0, 182, 208, 104, 62, 128, 47, 12, 169, 254, 100, 83, 105, 122]);\n  #R(e, t, i, a, s, r, n, g, o, c, C, h) {\n    if (t) {\n      const e = Math.min(127, t.length);\n      t = t.subarray(0, e);\n    } else t = [];\n    const l = 6 === e ? new PDF20() : new PDF17();\n    return l.checkUserPassword(t, g, n) ? l.getUserKey(t, o, C) : t.length && l.checkOwnerPassword(t, a, r, i) ? l.getOwnerKey(t, s, r, c) : null;\n  }\n  #N(e, t, i, a, s, r, n, g) {\n    const o = 40 + i.length + e.length,\n      c = new Uint8Array(o);\n    let C,\n      h,\n      l = 0;\n    if (t) {\n      h = Math.min(32, t.length);\n      for (; l < h; ++l) c[l] = t[l];\n    }\n    C = 0;\n    for (; l < 32;) c[l++] = CipherTransformFactory.#k[C++];\n    for (C = 0, h = i.length; C < h; ++C) c[l++] = i[C];\n    c[l++] = 255 & s;\n    c[l++] = s >> 8 & 255;\n    c[l++] = s >> 16 & 255;\n    c[l++] = s >>> 24 & 255;\n    for (C = 0, h = e.length; C < h; ++C) c[l++] = e[C];\n    if (r >= 4 && !g) {\n      c[l++] = 255;\n      c[l++] = 255;\n      c[l++] = 255;\n      c[l++] = 255;\n    }\n    let Q = Hs(c, 0, l);\n    const E = n >> 3;\n    if (r >= 3) for (C = 0; C < 50; ++C) Q = Hs(Q, 0, E);\n    const u = Q.subarray(0, E);\n    let d, f;\n    if (r >= 3) {\n      for (l = 0; l < 32; ++l) c[l] = CipherTransformFactory.#k[l];\n      for (C = 0, h = e.length; C < h; ++C) c[l++] = e[C];\n      d = new ARCFourCipher(u);\n      f = d.encryptBlock(Hs(c, 0, l));\n      h = u.length;\n      const t = new Uint8Array(h);\n      for (C = 1; C <= 19; ++C) {\n        for (let e = 0; e < h; ++e) t[e] = u[e] ^ C;\n        d = new ARCFourCipher(t);\n        f = d.encryptBlock(f);\n      }\n      for (C = 0, h = f.length; C < h; ++C) if (a[C] !== f[C]) return null;\n    } else {\n      d = new ARCFourCipher(u);\n      f = d.encryptBlock(CipherTransformFactory.#k);\n      for (C = 0, h = f.length; C < h; ++C) if (a[C] !== f[C]) return null;\n    }\n    return u;\n  }\n  #G(e, t, i, a) {\n    const s = new Uint8Array(32);\n    let r = 0;\n    const n = Math.min(32, e.length);\n    for (; r < n; ++r) s[r] = e[r];\n    let g = 0;\n    for (; r < 32;) s[r++] = CipherTransformFactory.#k[g++];\n    let o = Hs(s, 0, r);\n    const c = a >> 3;\n    if (i >= 3) for (g = 0; g < 50; ++g) o = Hs(o, 0, o.length);\n    let C, h;\n    if (i >= 3) {\n      h = t;\n      const e = new Uint8Array(c);\n      for (g = 19; g >= 0; g--) {\n        for (let t = 0; t < c; ++t) e[t] = o[t] ^ g;\n        C = new ARCFourCipher(e);\n        h = C.encryptBlock(h);\n      }\n    } else {\n      C = new ARCFourCipher(o.subarray(0, c));\n      h = C.encryptBlock(t);\n    }\n    return h;\n  }\n  #x(e, t, i, a = !1) {\n    const s = new Uint8Array(i.length + 9),\n      r = i.length;\n    let n;\n    for (n = 0; n < r; ++n) s[n] = i[n];\n    s[n++] = 255 & e;\n    s[n++] = e >> 8 & 255;\n    s[n++] = e >> 16 & 255;\n    s[n++] = 255 & t;\n    s[n++] = t >> 8 & 255;\n    if (a) {\n      s[n++] = 115;\n      s[n++] = 65;\n      s[n++] = 108;\n      s[n++] = 84;\n    }\n    return Hs(s, 0, n).subarray(0, Math.min(i.length + 5, 16));\n  }\n  #U(e, t, i, a, s) {\n    if (!(t instanceof Name)) throw new FormatError(\"Invalid crypt filter name.\");\n    const r = this,\n      n = e.get(t.name),\n      g = n?.get(\"CFM\");\n    if (!g || \"None\" === g.name) return function () {\n      return new NullCipher();\n    };\n    if (\"V2\" === g.name) return function () {\n      return new ARCFourCipher(r.#x(i, a, s, !1));\n    };\n    if (\"AESV2\" === g.name) return function () {\n      return new AES128Cipher(r.#x(i, a, s, !0));\n    };\n    if (\"AESV3\" === g.name) return function () {\n      return new AES256Cipher(s);\n    };\n    throw new FormatError(\"Unknown crypto method\");\n  }\n  constructor(e, t, i) {\n    const a = e.get(\"Filter\");\n    if (!isName(a, \"Standard\")) throw new FormatError(\"unknown encryption method\");\n    this.filterName = a.name;\n    this.dict = e;\n    const s = e.get(\"V\");\n    if (!Number.isInteger(s) || 1 !== s && 2 !== s && 4 !== s && 5 !== s) throw new FormatError(\"unsupported encryption algorithm\");\n    this.algorithm = s;\n    let r = e.get(\"Length\");\n    if (!r) if (s <= 3) r = 40;else {\n      const t = e.get(\"CF\"),\n        i = e.get(\"StmF\");\n      if (t instanceof Dict && i instanceof Name) {\n        t.suppressEncryption = !0;\n        const e = t.get(i.name);\n        r = e?.get(\"Length\") || 128;\n        r < 40 && (r <<= 3);\n      }\n    }\n    if (!Number.isInteger(r) || r < 40 || r % 8 != 0) throw new FormatError(\"invalid key length\");\n    const n = stringToBytes(e.get(\"O\")),\n      g = stringToBytes(e.get(\"U\")),\n      o = n.subarray(0, 32),\n      c = g.subarray(0, 32),\n      C = e.get(\"P\"),\n      h = e.get(\"R\"),\n      l = (4 === s || 5 === s) && !1 !== e.get(\"EncryptMetadata\");\n    this.encryptMetadata = l;\n    const Q = stringToBytes(t);\n    let E, u;\n    if (i) {\n      if (6 === h) try {\n        i = utf8StringToString(i);\n      } catch {\n        warn(\"CipherTransformFactory: Unable to convert UTF8 encoded password.\");\n      }\n      E = stringToBytes(i);\n    }\n    if (5 !== s) u = this.#N(Q, E, o, c, C, h, r, l);else {\n      const t = n.subarray(32, 40),\n        i = n.subarray(40, 48),\n        a = g.subarray(0, 48),\n        s = g.subarray(32, 40),\n        r = g.subarray(40, 48),\n        C = stringToBytes(e.get(\"OE\")),\n        l = stringToBytes(e.get(\"UE\")),\n        Q = stringToBytes(e.get(\"Perms\"));\n      u = this.#R(h, E, o, t, i, a, c, s, r, C, l, Q);\n    }\n    if (!u && !i) throw new PasswordException(\"No password given\", it);\n    if (!u && i) {\n      const e = this.#G(E, o, h, r);\n      u = this.#N(Q, e, o, c, C, h, r, l);\n    }\n    if (!u) throw new PasswordException(\"Incorrect Password\", at);\n    this.encryptionKey = u;\n    if (s >= 4) {\n      const t = e.get(\"CF\");\n      t instanceof Dict && (t.suppressEncryption = !0);\n      this.cf = t;\n      this.stmf = e.get(\"StmF\") || Name.get(\"Identity\");\n      this.strf = e.get(\"StrF\") || Name.get(\"Identity\");\n      this.eff = e.get(\"EFF\") || this.stmf;\n    }\n  }\n  createCipherTransform(e, t) {\n    if (4 === this.algorithm || 5 === this.algorithm) return new CipherTransform(this.#U(this.cf, this.strf, e, t, this.encryptionKey), this.#U(this.cf, this.stmf, e, t, this.encryptionKey));\n    const i = this.#x(e, t, this.encryptionKey, !1),\n      cipherConstructor = function () {\n        return new ARCFourCipher(i);\n      };\n    return new CipherTransform(cipherConstructor, cipherConstructor);\n  }\n}\nasync function writeObject(e, t, i, {\n  encrypt: a = null\n}) {\n  const s = a?.createCipherTransform(e.num, e.gen);\n  i.push(`${e.num} ${e.gen} obj\\n`);\n  t instanceof Dict ? await writeDict(t, i, s) : t instanceof BaseStream ? await writeStream(t, i, s) : (Array.isArray(t) || ArrayBuffer.isView(t)) && (await writeArray(t, i, s));\n  i.push(\"\\nendobj\\n\");\n}\nasync function writeDict(e, t, i) {\n  t.push(\"<<\");\n  for (const a of e.getKeys()) {\n    t.push(` /${escapePDFName(a)} `);\n    await writeValue(e.getRaw(a), t, i);\n  }\n  t.push(\">>\");\n}\nasync function writeStream(e, t, i) {\n  let a = e.getBytes();\n  const {\n      dict: s\n    } = e,\n    [r, n] = await Promise.all([s.getAsync(\"Filter\"), s.getAsync(\"DecodeParms\")]),\n    g = isName(Array.isArray(r) ? await s.xref.fetchIfRefAsync(r[0]) : r, \"FlateDecode\");\n  if (a.length >= 256 || g) try {\n    const e = new CompressionStream(\"deflate\"),\n      t = e.writable.getWriter();\n    t.write(a);\n    t.close();\n    const i = await new Response(e.readable).arrayBuffer();\n    a = new Uint8Array(i);\n    let o, c;\n    if (r) {\n      if (!g) {\n        o = Array.isArray(r) ? [Name.get(\"FlateDecode\"), ...r] : [Name.get(\"FlateDecode\"), r];\n        n && (c = Array.isArray(n) ? [null, ...n] : [null, n]);\n      }\n    } else o = Name.get(\"FlateDecode\");\n    o && s.set(\"Filter\", o);\n    c && s.set(\"DecodeParms\", c);\n  } catch (e) {\n    info(`writeStream - cannot compress data: \"${e}\".`);\n  }\n  let o = bytesToString(a);\n  i && (o = i.encryptString(o));\n  s.set(\"Length\", o.length);\n  await writeDict(s, t, i);\n  t.push(\" stream\\n\", o, \"\\nendstream\");\n}\nasync function writeArray(e, t, i) {\n  t.push(\"[\");\n  let a = !0;\n  for (const s of e) {\n    a ? a = !1 : t.push(\" \");\n    await writeValue(s, t, i);\n  }\n  t.push(\"]\");\n}\nasync function writeValue(e, t, i) {\n  if (e instanceof Name) t.push(`/${escapePDFName(e.name)}`);else if (e instanceof Ref) t.push(`${e.num} ${e.gen} R`);else if (Array.isArray(e) || ArrayBuffer.isView(e)) await writeArray(e, t, i);else if (\"string\" == typeof e) {\n    i && (e = i.encryptString(e));\n    t.push(`(${escapeString(e)})`);\n  } else \"number\" == typeof e ? t.push(numberToString(e)) : \"boolean\" == typeof e ? t.push(e.toString()) : e instanceof Dict ? await writeDict(e, t, i) : e instanceof BaseStream ? await writeStream(e, t, i) : null === e ? t.push(\"null\") : warn(`Unhandled value in writer: ${typeof e}, please file a bug.`);\n}\nfunction writeInt(e, t, i, a) {\n  for (let s = t + i - 1; s > i - 1; s--) {\n    a[s] = 255 & e;\n    e >>= 8;\n  }\n  return i + t;\n}\nfunction writeString(e, t, i) {\n  for (let a = 0, s = e.length; a < s; a++) i[t + a] = 255 & e.charCodeAt(a);\n}\nfunction updateXFA({\n  xfaData: e,\n  xfaDatasetsRef: t,\n  newRefs: i,\n  xref: a\n}) {\n  if (null === e) {\n    e = function writeXFADataForAcroform(e, t) {\n      const i = new SimpleXMLParser({\n        hasAttributes: !0\n      }).parseFromString(e);\n      for (const {\n        xfa: e\n      } of t) {\n        if (!e) continue;\n        const {\n          path: t,\n          value: a\n        } = e;\n        if (!t) continue;\n        const s = parseXFAPath(t);\n        let r = i.documentElement.searchNode(s, 0);\n        !r && s.length > 1 && (r = i.documentElement.searchNode([s.at(-1)], 0));\n        r ? r.childNodes = Array.isArray(a) ? a.map(e => new SimpleDOMNode(\"value\", e)) : [new SimpleDOMNode(\"#text\", a)] : warn(`Node not found for path: ${t}`);\n      }\n      const a = [];\n      i.documentElement.dump(a);\n      return a.join(\"\");\n    }(a.fetchIfRef(t).getString(), i);\n  }\n  const s = a.encrypt;\n  if (s) {\n    e = s.createCipherTransform(t.num, t.gen).encryptString(e);\n  }\n  const r = `${t.num} ${t.gen} obj\\n<< /Type /EmbeddedFile /Length ${e.length}>>\\nstream\\n` + e + \"\\nendstream\\nendobj\\n\";\n  i.push({\n    ref: t,\n    data: r\n  });\n}\nfunction getIndexes(e) {\n  const t = [];\n  for (const {\n    ref: i\n  } of e) i.num === t.at(-2) + t.at(-1) ? t[t.length - 1] += 1 : t.push(i.num, 1);\n  return t;\n}\nfunction computeIDs(e, t, i) {\n  if (Array.isArray(t.fileIds) && t.fileIds.length > 0) {\n    const a = function computeMD5(e, t) {\n      const i = Math.floor(Date.now() / 1e3),\n        a = t.filename || \"\",\n        s = [i.toString(), a, e.toString()];\n      let r = s.reduce((e, t) => e + t.length, 0);\n      for (const e of Object.values(t.info)) {\n        s.push(e);\n        r += e.length;\n      }\n      const n = new Uint8Array(r);\n      let g = 0;\n      for (const e of s) {\n        writeString(e, g, n);\n        g += e.length;\n      }\n      return bytesToString(Hs(n));\n    }(e, t);\n    i.set(\"ID\", [t.fileIds[0], a]);\n  }\n}\nasync function incrementalUpdate({\n  originalData: e,\n  xrefInfo: t,\n  newRefs: i,\n  xref: a = null,\n  hasXfa: s = !1,\n  xfaDatasetsRef: r = null,\n  hasXfaDatasetsEntry: n = !1,\n  needAppearances: g,\n  acroFormRef: o = null,\n  acroForm: c = null,\n  xfaData: C = null,\n  useXrefStream: h = !1\n}) {\n  await async function updateAcroform({\n    xref: e,\n    acroForm: t,\n    acroFormRef: i,\n    hasXfa: a,\n    hasXfaDatasetsEntry: s,\n    xfaDatasetsRef: r,\n    needAppearances: n,\n    newRefs: g\n  }) {\n    !a || s || r || warn(\"XFA - Cannot save it\");\n    if (!n && (!a || !r || s)) return;\n    const o = t.clone();\n    if (a && !s) {\n      const e = t.get(\"XFA\").slice();\n      e.splice(2, 0, \"datasets\");\n      e.splice(3, 0, r);\n      o.set(\"XFA\", e);\n    }\n    n && o.set(\"NeedAppearances\", !0);\n    const c = [];\n    await writeObject(i, o, c, e);\n    g.push({\n      ref: i,\n      data: c.join(\"\")\n    });\n  }({\n    xref: a,\n    acroForm: c,\n    acroFormRef: o,\n    hasXfa: s,\n    hasXfaDatasetsEntry: n,\n    xfaDatasetsRef: r,\n    needAppearances: g,\n    newRefs: i\n  });\n  s && updateXFA({\n    xfaData: C,\n    xfaDatasetsRef: r,\n    newRefs: i,\n    xref: a\n  });\n  const l = [];\n  let Q = e.length;\n  const E = e.at(-1);\n  if (10 !== E && 13 !== E) {\n    l.push(\"\\n\");\n    Q += 1;\n  }\n  const u = function getTrailerDict(e, t, i) {\n    const a = new Dict(null);\n    a.set(\"Prev\", e.startXRef);\n    const s = e.newRef;\n    if (i) {\n      t.push({\n        ref: s,\n        data: \"\"\n      });\n      a.set(\"Size\", s.num + 1);\n      a.set(\"Type\", Name.get(\"XRef\"));\n    } else a.set(\"Size\", s.num);\n    null !== e.rootRef && a.set(\"Root\", e.rootRef);\n    null !== e.infoRef && a.set(\"Info\", e.infoRef);\n    null !== e.encryptRef && a.set(\"Encrypt\", e.encryptRef);\n    return a;\n  }(t, i, h);\n  i = i.sort((e, t) => e.ref.num - t.ref.num);\n  for (const {\n    data: e\n  } of i) null !== e && l.push(e);\n  await (h ? async function getXRefStreamTable(e, t, i, a, s) {\n    const r = [];\n    let n = 0,\n      g = 0;\n    for (const {\n      ref: e,\n      data: a\n    } of i) {\n      let i;\n      n = Math.max(n, t);\n      if (null !== a) {\n        i = Math.min(e.gen, 65535);\n        r.push([1, t, i]);\n        t += a.length;\n      } else {\n        i = Math.min(e.gen + 1, 65535);\n        r.push([0, 0, i]);\n      }\n      g = Math.max(g, i);\n    }\n    a.set(\"Index\", getIndexes(i));\n    const o = [1, getSizeInBytes(n), getSizeInBytes(g)];\n    a.set(\"W\", o);\n    computeIDs(t, e, a);\n    const c = o.reduce((e, t) => e + t, 0),\n      C = new Uint8Array(c * r.length),\n      h = new Stream(C);\n    h.dict = a;\n    let l = 0;\n    for (const [e, t, i] of r) {\n      l = writeInt(e, o[0], l, C);\n      l = writeInt(t, o[1], l, C);\n      l = writeInt(i, o[2], l, C);\n    }\n    await writeObject(e.newRef, h, s, {});\n    s.push(\"startxref\\n\", t.toString(), \"\\n%%EOF\\n\");\n  }(t, Q, i, u, l) : async function getXRefTable(e, t, i, a, s) {\n    s.push(\"xref\\n\");\n    const r = getIndexes(i);\n    let n = 0;\n    for (const {\n      ref: e,\n      data: a\n    } of i) {\n      if (e.num === r[n]) {\n        s.push(`${r[n]} ${r[n + 1]}\\n`);\n        n += 2;\n      }\n      if (null !== a) {\n        s.push(`${t.toString().padStart(10, \"0\")} ${Math.min(e.gen, 65535).toString().padStart(5, \"0\")} n\\r\\n`);\n        t += a.length;\n      } else s.push(`0000000000 ${Math.min(e.gen + 1, 65535).toString().padStart(5, \"0\")} f\\r\\n`);\n    }\n    computeIDs(t, e, a);\n    s.push(\"trailer\\n\");\n    await writeDict(a, s);\n    s.push(\"\\nstartxref\\n\", t.toString(), \"\\n%%EOF\\n\");\n  }(t, Q, i, u, l));\n  const d = l.reduce((e, t) => e + t.length, e.length),\n    f = new Uint8Array(d);\n  f.set(e);\n  let p = e.length;\n  for (const e of l) {\n    writeString(e, p, f);\n    p += e.length;\n  }\n  return f;\n}\nconst vs = 1,\n  Ks = 2,\n  Ts = 3,\n  qs = 4,\n  Os = 5;\nclass StructTreeRoot {\n  constructor(e, t) {\n    this.dict = e;\n    this.ref = t instanceof Ref ? t : null;\n    this.roleMap = new Map();\n    this.structParentIds = null;\n  }\n  init() {\n    this.readRoleMap();\n  }\n  #M(e, t, i) {\n    if (!(e instanceof Ref) || t < 0) return;\n    this.structParentIds ||= new RefSetCache();\n    let a = this.structParentIds.get(e);\n    if (!a) {\n      a = [];\n      this.structParentIds.put(e, a);\n    }\n    a.push([t, i]);\n  }\n  addAnnotationIdToPage(e, t) {\n    this.#M(e, t, qs);\n  }\n  readRoleMap() {\n    const e = this.dict.get(\"RoleMap\");\n    e instanceof Dict && e.forEach((e, t) => {\n      t instanceof Name && this.roleMap.set(e, t.name);\n    });\n  }\n  static async canCreateStructureTree({\n    catalogRef: e,\n    pdfManager: t,\n    newAnnotationsByPage: i\n  }) {\n    if (!(e instanceof Ref)) {\n      warn(\"Cannot save the struct tree: no catalog reference.\");\n      return !1;\n    }\n    let a = 0,\n      s = !0;\n    for (const [e, r] of i) {\n      const {\n        ref: i\n      } = await t.getPage(e);\n      if (!(i instanceof Ref)) {\n        warn(`Cannot save the struct tree: page ${e} has no ref.`);\n        s = !0;\n        break;\n      }\n      for (const e of r) if (e.accessibilityData?.type) {\n        e.parentTreeId = a++;\n        s = !1;\n      }\n    }\n    if (s) {\n      for (const e of i.values()) for (const t of e) delete t.parentTreeId;\n      return !1;\n    }\n    return !0;\n  }\n  static async createStructureTree({\n    newAnnotationsByPage: e,\n    xref: t,\n    catalogRef: i,\n    pdfManager: a,\n    newRefs: s\n  }) {\n    const r = a.catalog.cloneDict(),\n      n = new RefSetCache();\n    n.put(i, r);\n    const g = t.getNewTemporaryRef();\n    r.set(\"StructTreeRoot\", g);\n    const o = new Dict(t);\n    o.set(\"Type\", Name.get(\"StructTreeRoot\"));\n    const c = t.getNewTemporaryRef();\n    o.set(\"ParentTree\", c);\n    const C = [];\n    o.set(\"K\", C);\n    n.put(g, o);\n    const h = new Dict(t),\n      l = [];\n    h.set(\"Nums\", l);\n    const Q = await this.#L({\n      newAnnotationsByPage: e,\n      structTreeRootRef: g,\n      kids: C,\n      nums: l,\n      xref: t,\n      pdfManager: a,\n      cache: n\n    });\n    o.set(\"ParentTreeNextKey\", Q);\n    n.put(c, h);\n    const E = [];\n    for (const [e, i] of n.items()) {\n      E.length = 0;\n      await writeObject(e, i, E, t);\n      s.push({\n        ref: e,\n        data: E.join(\"\")\n      });\n    }\n  }\n  async canUpdateStructTree({\n    pdfManager: e,\n    xref: t,\n    newAnnotationsByPage: i\n  }) {\n    if (!this.ref) {\n      warn(\"Cannot update the struct tree: no root reference.\");\n      return !1;\n    }\n    let a = this.dict.get(\"ParentTreeNextKey\");\n    if (!Number.isInteger(a) || a < 0) {\n      warn(\"Cannot update the struct tree: invalid next key.\");\n      return !1;\n    }\n    const s = this.dict.get(\"ParentTree\");\n    if (!(s instanceof Dict)) {\n      warn(\"Cannot update the struct tree: ParentTree isn't a dict.\");\n      return !1;\n    }\n    const r = s.get(\"Nums\");\n    if (!Array.isArray(r)) {\n      warn(\"Cannot update the struct tree: nums isn't an array.\");\n      return !1;\n    }\n    const n = new NumberTree(s, t);\n    for (const t of i.keys()) {\n      const {\n        pageDict: i\n      } = await e.getPage(t);\n      if (!i.has(\"StructParents\")) continue;\n      const a = i.get(\"StructParents\");\n      if (!Number.isInteger(a) || !Array.isArray(n.get(a))) {\n        warn(`Cannot save the struct tree: page ${t} has a wrong id.`);\n        return !1;\n      }\n    }\n    let g = !0;\n    for (const [t, s] of i) {\n      const {\n        pageDict: i\n      } = await e.getPage(t);\n      StructTreeRoot.#H({\n        elements: s,\n        xref: this.dict.xref,\n        pageDict: i,\n        numberTree: n\n      });\n      for (const e of s) if (e.accessibilityData?.type) {\n        e.parentTreeId = a++;\n        g = !1;\n      }\n    }\n    if (g) {\n      for (const e of i.values()) for (const t of e) {\n        delete t.parentTreeId;\n        delete t.structTreeParent;\n      }\n      return !1;\n    }\n    return !0;\n  }\n  async updateStructureTree({\n    newAnnotationsByPage: e,\n    pdfManager: t,\n    newRefs: i\n  }) {\n    const a = this.dict.xref,\n      s = this.dict.clone(),\n      r = this.ref,\n      n = new RefSetCache();\n    n.put(r, s);\n    let g,\n      o = s.getRaw(\"ParentTree\");\n    if (o instanceof Ref) g = a.fetch(o);else {\n      g = o;\n      o = a.getNewTemporaryRef();\n      s.set(\"ParentTree\", o);\n    }\n    g = g.clone();\n    n.put(o, g);\n    let c = g.getRaw(\"Nums\"),\n      C = null;\n    if (c instanceof Ref) {\n      C = c;\n      c = a.fetch(C);\n    }\n    c = c.slice();\n    C || g.set(\"Nums\", c);\n    const h = await StructTreeRoot.#L({\n      newAnnotationsByPage: e,\n      structTreeRootRef: r,\n      kids: null,\n      nums: c,\n      xref: a,\n      pdfManager: t,\n      cache: n\n    });\n    s.set(\"ParentTreeNextKey\", h);\n    C && n.put(C, c);\n    const l = [];\n    for (const [e, t] of n.items()) {\n      l.length = 0;\n      await writeObject(e, t, l, a);\n      i.push({\n        ref: e,\n        data: l.join(\"\")\n      });\n    }\n  }\n  static async #L({\n    newAnnotationsByPage: e,\n    structTreeRootRef: t,\n    kids: i,\n    nums: a,\n    xref: s,\n    pdfManager: r,\n    cache: n\n  }) {\n    const g = Name.get(\"OBJR\");\n    let o = -1 / 0;\n    for (const [c, C] of e) {\n      const {\n          ref: e\n        } = await r.getPage(c),\n        h = e instanceof Ref;\n      for (const {\n        accessibilityData: r,\n        ref: c,\n        parentTreeId: l,\n        structTreeParent: Q\n      } of C) {\n        if (!r?.type) continue;\n        const {\n          type: C,\n          title: E,\n          lang: u,\n          alt: d,\n          expanded: f,\n          actualText: p\n        } = r;\n        o = Math.max(o, l);\n        const m = s.getNewTemporaryRef(),\n          y = new Dict(s);\n        y.set(\"S\", Name.get(C));\n        E && y.set(\"T\", E);\n        u && y.set(\"Lang\", u);\n        d && y.set(\"Alt\", d);\n        f && y.set(\"E\", f);\n        p && y.set(\"ActualText\", p);\n        await this.#J({\n          structTreeParent: Q,\n          tagDict: y,\n          newTagRef: m,\n          structTreeRootRef: t,\n          fallbackKids: i,\n          xref: s,\n          cache: n\n        });\n        const w = new Dict(s);\n        y.set(\"K\", w);\n        w.set(\"Type\", g);\n        h && w.set(\"Pg\", e);\n        w.set(\"Obj\", c);\n        n.put(m, y);\n        a.push(l, m);\n      }\n    }\n    return o + 1;\n  }\n  static #H({\n    elements: e,\n    xref: t,\n    pageDict: i,\n    numberTree: a\n  }) {\n    const s = new Map();\n    for (const t of e) if (t.structTreeParentId) {\n      const e = parseInt(t.structTreeParentId.split(\"_mc\")[1], 10);\n      let i = s.get(e);\n      if (!i) {\n        i = [];\n        s.set(e, i);\n      }\n      i.push(t);\n    }\n    const r = i.get(\"StructParents\");\n    if (!Number.isInteger(r)) return;\n    const n = a.get(r),\n      updateElement = (e, i, a) => {\n        const r = s.get(e);\n        if (r) {\n          const e = i.getRaw(\"P\"),\n            s = t.fetchIfRef(e);\n          if (e instanceof Ref && s instanceof Dict) {\n            const e = {\n              ref: a,\n              dict: i\n            };\n            for (const t of r) t.structTreeParent = e;\n          }\n          return !0;\n        }\n        return !1;\n      };\n    for (const e of n) {\n      if (!(e instanceof Ref)) continue;\n      const i = t.fetch(e),\n        a = i.get(\"K\");\n      if (Number.isInteger(a)) updateElement(a, i, e);else if (Array.isArray(a)) for (let s of a) {\n        s = t.fetchIfRef(s);\n        if (Number.isInteger(s) && updateElement(s, i, e)) break;\n        if (!(s instanceof Dict)) continue;\n        if (!isName(s.get(\"Type\"), \"MCR\")) break;\n        const a = s.get(\"MCID\");\n        if (Number.isInteger(a) && updateElement(a, i, e)) break;\n      }\n    }\n  }\n  static async #J({\n    structTreeParent: e,\n    tagDict: t,\n    newTagRef: i,\n    structTreeRootRef: a,\n    fallbackKids: s,\n    xref: r,\n    cache: n\n  }) {\n    let g,\n      o = null;\n    if (e) {\n      ({\n        ref: o\n      } = e);\n      g = e.dict.getRaw(\"P\") || a;\n    } else g = a;\n    t.set(\"P\", g);\n    const c = r.fetchIfRef(g);\n    if (!c) {\n      s.push(i);\n      return;\n    }\n    let C = n.get(g);\n    if (!C) {\n      C = c.clone();\n      n.put(g, C);\n    }\n    const h = C.getRaw(\"K\");\n    let l = h instanceof Ref ? n.get(h) : null;\n    if (!l) {\n      l = r.fetchIfRef(h);\n      l = Array.isArray(l) ? l.slice() : [h];\n      const e = r.getNewTemporaryRef();\n      C.set(\"K\", e);\n      n.put(e, l);\n    }\n    const Q = l.indexOf(o);\n    l.splice(Q >= 0 ? Q + 1 : l.length, 0, i);\n  }\n}\nclass StructElementNode {\n  constructor(e, t) {\n    this.tree = e;\n    this.dict = t;\n    this.kids = [];\n    this.parseKids();\n  }\n  get role() {\n    const e = this.dict.get(\"S\"),\n      t = e instanceof Name ? e.name : \"\",\n      {\n        root: i\n      } = this.tree;\n    return i.roleMap.has(t) ? i.roleMap.get(t) : t;\n  }\n  parseKids() {\n    let e = null;\n    const t = this.dict.getRaw(\"Pg\");\n    t instanceof Ref && (e = t.toString());\n    const i = this.dict.get(\"K\");\n    if (Array.isArray(i)) for (const t of i) {\n      const i = this.parseKid(e, t);\n      i && this.kids.push(i);\n    } else {\n      const t = this.parseKid(e, i);\n      t && this.kids.push(t);\n    }\n  }\n  parseKid(e, t) {\n    if (Number.isInteger(t)) return this.tree.pageDict.objId !== e ? null : new StructElement({\n      type: vs,\n      mcid: t,\n      pageObjId: e\n    });\n    let i = null;\n    t instanceof Ref ? i = this.dict.xref.fetch(t) : t instanceof Dict && (i = t);\n    if (!i) return null;\n    const a = i.getRaw(\"Pg\");\n    a instanceof Ref && (e = a.toString());\n    const s = i.get(\"Type\") instanceof Name ? i.get(\"Type\").name : null;\n    if (\"MCR\" === s) {\n      if (this.tree.pageDict.objId !== e) return null;\n      const t = i.getRaw(\"Stm\");\n      return new StructElement({\n        type: Ks,\n        refObjId: t instanceof Ref ? t.toString() : null,\n        pageObjId: e,\n        mcid: i.get(\"MCID\")\n      });\n    }\n    if (\"OBJR\" === s) {\n      if (this.tree.pageDict.objId !== e) return null;\n      const t = i.getRaw(\"Obj\");\n      return new StructElement({\n        type: Ts,\n        refObjId: t instanceof Ref ? t.toString() : null,\n        pageObjId: e\n      });\n    }\n    return new StructElement({\n      type: Os,\n      dict: i\n    });\n  }\n}\nclass StructElement {\n  constructor({\n    type: e,\n    dict: t = null,\n    mcid: i = null,\n    pageObjId: a = null,\n    refObjId: s = null\n  }) {\n    this.type = e;\n    this.dict = t;\n    this.mcid = i;\n    this.pageObjId = a;\n    this.refObjId = s;\n    this.parentNode = null;\n  }\n}\nclass StructTreePage {\n  constructor(e, t) {\n    this.root = e;\n    this.rootDict = e ? e.dict : null;\n    this.pageDict = t;\n    this.nodes = [];\n  }\n  parse(e) {\n    if (!this.root || !this.rootDict) return;\n    const t = this.rootDict.get(\"ParentTree\");\n    if (!t) return;\n    const i = this.pageDict.get(\"StructParents\"),\n      a = e instanceof Ref && this.root.structParentIds?.get(e);\n    if (!Number.isInteger(i) && !a) return;\n    const s = new Map(),\n      r = new NumberTree(t, this.rootDict.xref);\n    if (Number.isInteger(i)) {\n      const e = r.get(i);\n      if (Array.isArray(e)) for (const t of e) t instanceof Ref && this.addNode(this.rootDict.xref.fetch(t), s);\n    }\n    if (a) for (const [e, t] of a) {\n      const i = r.get(e);\n      if (i) {\n        const e = this.addNode(this.rootDict.xref.fetchIfRef(i), s);\n        1 === e?.kids?.length && e.kids[0].type === Ts && (e.kids[0].type = t);\n      }\n    }\n  }\n  addNode(e, t, i = 0) {\n    if (i > 40) {\n      warn(\"StructTree MAX_DEPTH reached.\");\n      return null;\n    }\n    if (t.has(e)) return t.get(e);\n    const a = new StructElementNode(this, e);\n    t.set(e, a);\n    const s = e.get(\"P\");\n    if (!s || isName(s.get(\"Type\"), \"StructTreeRoot\")) {\n      this.addTopLevelNode(e, a) || t.delete(e);\n      return a;\n    }\n    const r = this.addNode(s, t, i + 1);\n    if (!r) return a;\n    let n = !1;\n    for (const t of r.kids) if (t.type === Os && t.dict === e) {\n      t.parentNode = a;\n      n = !0;\n    }\n    n || t.delete(e);\n    return a;\n  }\n  addTopLevelNode(e, t) {\n    const i = this.rootDict.get(\"K\");\n    if (!i) return !1;\n    if (i instanceof Dict) {\n      if (i.objId !== e.objId) return !1;\n      this.nodes[0] = t;\n      return !0;\n    }\n    if (!Array.isArray(i)) return !0;\n    let a = !1;\n    for (let s = 0; s < i.length; s++) {\n      const r = i[s];\n      if (r?.toString() === e.objId) {\n        this.nodes[s] = t;\n        a = !0;\n      }\n    }\n    return a;\n  }\n  get serializable() {\n    function nodeToSerializable(e, t, i = 0) {\n      if (i > 40) {\n        warn(\"StructTree too deep to be fully serialized.\");\n        return;\n      }\n      const a = Object.create(null);\n      a.role = e.role;\n      a.children = [];\n      t.children.push(a);\n      const s = e.dict.get(\"Alt\");\n      \"string\" == typeof s && (a.alt = stringToPDFString(s));\n      const r = e.dict.get(\"Lang\");\n      \"string\" == typeof r && (a.lang = stringToPDFString(r));\n      for (const t of e.kids) {\n        const e = t.type === Os ? t.parentNode : null;\n        e ? nodeToSerializable(e, a, i + 1) : t.type === vs || t.type === Ks ? a.children.push({\n          type: \"content\",\n          id: `p${t.pageObjId}_mc${t.mcid}`\n        }) : t.type === Ts ? a.children.push({\n          type: \"object\",\n          id: t.refObjId\n        }) : t.type === qs && a.children.push({\n          type: \"annotation\",\n          id: `pdfjs_internal_id_${t.refObjId}`\n        });\n      }\n    }\n    const e = Object.create(null);\n    e.children = [];\n    e.role = \"Root\";\n    for (const t of this.nodes) t && nodeToSerializable(t, e);\n    return e;\n  }\n}\nfunction isValidExplicitDest(e) {\n  if (!Array.isArray(e) || e.length < 2) return !1;\n  const [t, i, ...a] = e;\n  if (!(t instanceof Ref || Number.isInteger(t))) return !1;\n  if (!(i instanceof Name)) return !1;\n  let s = !0;\n  switch (i.name) {\n    case \"XYZ\":\n      if (3 !== a.length) return !1;\n      break;\n    case \"Fit\":\n    case \"FitB\":\n      return 0 === a.length;\n    case \"FitH\":\n    case \"FitBH\":\n    case \"FitV\":\n    case \"FitBV\":\n      if (1 !== a.length) return !1;\n      break;\n    case \"FitR\":\n      if (4 !== a.length) return !1;\n      s = !1;\n      break;\n    default:\n      return !1;\n  }\n  for (const e of a) if (!(\"number\" == typeof e || s && null === e)) return !1;\n  return !0;\n}\nfunction fetchDest(e) {\n  e instanceof Dict && (e = e.get(\"D\"));\n  return isValidExplicitDest(e) ? e : null;\n}\nfunction fetchRemoteDest(e) {\n  let t = e.get(\"D\");\n  if (t) {\n    t instanceof Name && (t = t.name);\n    if (\"string\" == typeof t) return stringToPDFString(t);\n    if (isValidExplicitDest(t)) return JSON.stringify(t);\n  }\n  return null;\n}\nclass Catalog {\n  constructor(e, t) {\n    this.pdfManager = e;\n    this.xref = t;\n    this._catDict = t.getCatalogObj();\n    if (!(this._catDict instanceof Dict)) throw new FormatError(\"Catalog object is not a dictionary.\");\n    this.toplevelPagesDict;\n    this._actualNumPages = null;\n    this.fontCache = new RefSetCache();\n    this.builtInCMapCache = new Map();\n    this.standardFontDataCache = new Map();\n    this.globalImageCache = new GlobalImageCache();\n    this.pageKidsCountCache = new RefSetCache();\n    this.pageIndexCache = new RefSetCache();\n    this.nonBlendModesSet = new RefSet();\n    this.systemFontCache = new Map();\n  }\n  cloneDict() {\n    return this._catDict.clone();\n  }\n  get version() {\n    const e = this._catDict.get(\"Version\");\n    if (e instanceof Name) {\n      if (bt.test(e.name)) return shadow(this, \"version\", e.name);\n      warn(`Invalid PDF catalog version: ${e.name}`);\n    }\n    return shadow(this, \"version\", null);\n  }\n  get lang() {\n    const e = this._catDict.get(\"Lang\");\n    return shadow(this, \"lang\", e && \"string\" == typeof e ? stringToPDFString(e) : null);\n  }\n  get needsRendering() {\n    const e = this._catDict.get(\"NeedsRendering\");\n    return shadow(this, \"needsRendering\", \"boolean\" == typeof e && e);\n  }\n  get collection() {\n    let e = null;\n    try {\n      const t = this._catDict.get(\"Collection\");\n      t instanceof Dict && t.size > 0 && (e = t);\n    } catch (e) {\n      if (e instanceof MissingDataException) throw e;\n      info(\"Cannot fetch Collection entry; assuming no collection is present.\");\n    }\n    return shadow(this, \"collection\", e);\n  }\n  get acroForm() {\n    let e = null;\n    try {\n      const t = this._catDict.get(\"AcroForm\");\n      t instanceof Dict && t.size > 0 && (e = t);\n    } catch (e) {\n      if (e instanceof MissingDataException) throw e;\n      info(\"Cannot fetch AcroForm entry; assuming no forms are present.\");\n    }\n    return shadow(this, \"acroForm\", e);\n  }\n  get acroFormRef() {\n    const e = this._catDict.getRaw(\"AcroForm\");\n    return shadow(this, \"acroFormRef\", e instanceof Ref ? e : null);\n  }\n  get metadata() {\n    const e = this._catDict.getRaw(\"Metadata\");\n    if (!(e instanceof Ref)) return shadow(this, \"metadata\", null);\n    let t = null;\n    try {\n      const i = this.xref.fetch(e, !this.xref.encrypt?.encryptMetadata);\n      if (i instanceof BaseStream && i.dict instanceof Dict) {\n        const e = i.dict.get(\"Type\"),\n          a = i.dict.get(\"Subtype\");\n        if (isName(e, \"Metadata\") && isName(a, \"XML\")) {\n          const e = stringToUTF8String(i.getString());\n          e && (t = new MetadataParser(e).serializable);\n        }\n      }\n    } catch (e) {\n      if (e instanceof MissingDataException) throw e;\n      info(`Skipping invalid Metadata: \"${e}\".`);\n    }\n    return shadow(this, \"metadata\", t);\n  }\n  get markInfo() {\n    let e = null;\n    try {\n      e = this._readMarkInfo();\n    } catch (e) {\n      if (e instanceof MissingDataException) throw e;\n      warn(\"Unable to read mark info.\");\n    }\n    return shadow(this, \"markInfo\", e);\n  }\n  _readMarkInfo() {\n    const e = this._catDict.get(\"MarkInfo\");\n    if (!(e instanceof Dict)) return null;\n    const t = {\n      Marked: !1,\n      UserProperties: !1,\n      Suspects: !1\n    };\n    for (const i in t) {\n      const a = e.get(i);\n      \"boolean\" == typeof a && (t[i] = a);\n    }\n    return t;\n  }\n  get structTreeRoot() {\n    let e = null;\n    try {\n      e = this._readStructTreeRoot();\n    } catch (e) {\n      if (e instanceof MissingDataException) throw e;\n      warn(\"Unable read to structTreeRoot info.\");\n    }\n    return shadow(this, \"structTreeRoot\", e);\n  }\n  _readStructTreeRoot() {\n    const e = this._catDict.getRaw(\"StructTreeRoot\"),\n      t = this.xref.fetchIfRef(e);\n    if (!(t instanceof Dict)) return null;\n    const i = new StructTreeRoot(t, e);\n    i.init();\n    return i;\n  }\n  get toplevelPagesDict() {\n    const e = this._catDict.get(\"Pages\");\n    if (!(e instanceof Dict)) throw new FormatError(\"Invalid top-level pages dictionary.\");\n    return shadow(this, \"toplevelPagesDict\", e);\n  }\n  get documentOutline() {\n    let e = null;\n    try {\n      e = this._readDocumentOutline();\n    } catch (e) {\n      if (e instanceof MissingDataException) throw e;\n      warn(\"Unable to read document outline.\");\n    }\n    return shadow(this, \"documentOutline\", e);\n  }\n  _readDocumentOutline() {\n    let e = this._catDict.get(\"Outlines\");\n    if (!(e instanceof Dict)) return null;\n    e = e.getRaw(\"First\");\n    if (!(e instanceof Ref)) return null;\n    const t = {\n        items: []\n      },\n      i = [{\n        obj: e,\n        parent: t\n      }],\n      a = new RefSet();\n    a.put(e);\n    const s = this.xref,\n      r = new Uint8ClampedArray(3);\n    for (; i.length > 0;) {\n      const t = i.shift(),\n        n = s.fetchIfRef(t.obj);\n      if (null === n) continue;\n      n.has(\"Title\") || warn(\"Invalid outline item encountered.\");\n      const g = {\n        url: null,\n        dest: null,\n        action: null\n      };\n      Catalog.parseDestDictionary({\n        destDict: n,\n        resultObj: g,\n        docBaseUrl: this.baseUrl,\n        docAttachments: this.attachments\n      });\n      const o = n.get(\"Title\"),\n        c = n.get(\"F\") || 0,\n        C = n.getArray(\"C\"),\n        h = n.get(\"Count\");\n      let l = r;\n      !isNumberArray(C, 3) || 0 === C[0] && 0 === C[1] && 0 === C[2] || (l = ColorSpace.singletons.rgb.getRgb(C, 0));\n      const Q = {\n        action: g.action,\n        attachment: g.attachment,\n        dest: g.dest,\n        url: g.url,\n        unsafeUrl: g.unsafeUrl,\n        newWindow: g.newWindow,\n        setOCGState: g.setOCGState,\n        title: \"string\" == typeof o ? stringToPDFString(o) : \"\",\n        color: l,\n        count: Number.isInteger(h) ? h : void 0,\n        bold: !!(2 & c),\n        italic: !!(1 & c),\n        items: []\n      };\n      t.parent.items.push(Q);\n      e = n.getRaw(\"First\");\n      if (e instanceof Ref && !a.has(e)) {\n        i.push({\n          obj: e,\n          parent: Q\n        });\n        a.put(e);\n      }\n      e = n.getRaw(\"Next\");\n      if (e instanceof Ref && !a.has(e)) {\n        i.push({\n          obj: e,\n          parent: t.parent\n        });\n        a.put(e);\n      }\n    }\n    return t.items.length > 0 ? t.items : null;\n  }\n  get permissions() {\n    let e = null;\n    try {\n      e = this._readPermissions();\n    } catch (e) {\n      if (e instanceof MissingDataException) throw e;\n      warn(\"Unable to read permissions.\");\n    }\n    return shadow(this, \"permissions\", e);\n  }\n  _readPermissions() {\n    const e = this.xref.trailer.get(\"Encrypt\");\n    if (!(e instanceof Dict)) return null;\n    let t = e.get(\"P\");\n    if (\"number\" != typeof t) return null;\n    t += 2 ** 32;\n    const i = [];\n    for (const e in m) {\n      const a = m[e];\n      t & a && i.push(a);\n    }\n    return i;\n  }\n  get optionalContentConfig() {\n    let e = null;\n    try {\n      const t = this._catDict.get(\"OCProperties\");\n      if (!t) return shadow(this, \"optionalContentConfig\", null);\n      const i = t.get(\"D\");\n      if (!i) return shadow(this, \"optionalContentConfig\", null);\n      const a = t.get(\"OCGs\");\n      if (!Array.isArray(a)) return shadow(this, \"optionalContentConfig\", null);\n      const s = [],\n        r = new RefSet();\n      for (const e of a) if (e instanceof Ref && !r.has(e)) {\n        r.put(e);\n        s.push(this.#Y(e));\n      }\n      e = this.#v(i, r);\n      e.groups = s;\n    } catch (e) {\n      if (e instanceof MissingDataException) throw e;\n      warn(`Unable to read optional content config: ${e}`);\n    }\n    return shadow(this, \"optionalContentConfig\", e);\n  }\n  #Y(e) {\n    const t = this.xref.fetch(e),\n      i = {\n        id: e.toString(),\n        name: null,\n        intent: null,\n        usage: {\n          print: null,\n          view: null\n        }\n      },\n      a = t.get(\"Name\");\n    \"string\" == typeof a && (i.name = stringToPDFString(a));\n    let s = t.getArray(\"Intent\");\n    Array.isArray(s) || (s = [s]);\n    s.every(e => e instanceof Name) && (i.intent = s.map(e => e.name));\n    const r = t.get(\"Usage\");\n    if (!(r instanceof Dict)) return i;\n    const n = i.usage,\n      g = r.get(\"Print\");\n    if (g instanceof Dict) {\n      const e = g.get(\"PrintState\");\n      if (e instanceof Name) switch (e.name) {\n        case \"ON\":\n        case \"OFF\":\n          n.print = {\n            printState: e.name\n          };\n      }\n    }\n    const o = r.get(\"View\");\n    if (o instanceof Dict) {\n      const e = o.get(\"ViewState\");\n      if (e instanceof Name) switch (e.name) {\n        case \"ON\":\n        case \"OFF\":\n          n.view = {\n            viewState: e.name\n          };\n      }\n    }\n    return i;\n  }\n  #v(e, t) {\n    function parseOnOff(e) {\n      const i = [];\n      if (Array.isArray(e)) for (const a of e) a instanceof Ref && t.has(a) && i.push(a.toString());\n      return i;\n    }\n    function parseOrder(e, i = 0) {\n      if (!Array.isArray(e)) return null;\n      const s = [];\n      for (const r of e) {\n        if (r instanceof Ref && t.has(r)) {\n          a.put(r);\n          s.push(r.toString());\n          continue;\n        }\n        const e = parseNestedOrder(r, i);\n        e && s.push(e);\n      }\n      if (i > 0) return s;\n      const r = [];\n      for (const e of t) a.has(e) || r.push(e.toString());\n      r.length && s.push({\n        name: null,\n        order: r\n      });\n      return s;\n    }\n    function parseNestedOrder(e, t) {\n      if (++t > s) {\n        warn(\"parseNestedOrder - reached MAX_NESTED_LEVELS.\");\n        return null;\n      }\n      const a = i.fetchIfRef(e);\n      if (!Array.isArray(a)) return null;\n      const r = i.fetchIfRef(a[0]);\n      if (\"string\" != typeof r) return null;\n      const n = parseOrder(a.slice(1), t);\n      return n && n.length ? {\n        name: stringToPDFString(r),\n        order: n\n      } : null;\n    }\n    const i = this.xref,\n      a = new RefSet(),\n      s = 10;\n    return {\n      name: \"string\" == typeof e.get(\"Name\") ? stringToPDFString(e.get(\"Name\")) : null,\n      creator: \"string\" == typeof e.get(\"Creator\") ? stringToPDFString(e.get(\"Creator\")) : null,\n      baseState: e.get(\"BaseState\") instanceof Name ? e.get(\"BaseState\").name : null,\n      on: parseOnOff(e.get(\"ON\")),\n      off: parseOnOff(e.get(\"OFF\")),\n      order: parseOrder(e.get(\"Order\")),\n      groups: null\n    };\n  }\n  setActualNumPages(e = null) {\n    this._actualNumPages = e;\n  }\n  get hasActualNumPages() {\n    return null !== this._actualNumPages;\n  }\n  get _pagesCount() {\n    const e = this.toplevelPagesDict.get(\"Count\");\n    if (!Number.isInteger(e)) throw new FormatError(\"Page count in top-level pages dictionary is not an integer.\");\n    return shadow(this, \"_pagesCount\", e);\n  }\n  get numPages() {\n    return this.hasActualNumPages ? this._actualNumPages : this._pagesCount;\n  }\n  get destinations() {\n    const e = this._readDests(),\n      t = Object.create(null);\n    if (e instanceof NameTree) for (const [i, a] of e.getAll()) {\n      const e = fetchDest(a);\n      e && (t[stringToPDFString(i)] = e);\n    } else e instanceof Dict && e.forEach(function (e, i) {\n      const a = fetchDest(i);\n      a && (t[e] = a);\n    });\n    return shadow(this, \"destinations\", t);\n  }\n  getDestination(e) {\n    const t = this._readDests();\n    if (t instanceof NameTree) {\n      const i = fetchDest(t.get(e));\n      if (i) return i;\n      const a = this.destinations[e];\n      if (a) {\n        warn(`Found \"${e}\" at an incorrect position in the NameTree.`);\n        return a;\n      }\n    } else if (t instanceof Dict) {\n      const i = fetchDest(t.get(e));\n      if (i) return i;\n    }\n    return null;\n  }\n  _readDests() {\n    const e = this._catDict.get(\"Names\");\n    return e?.has(\"Dests\") ? new NameTree(e.getRaw(\"Dests\"), this.xref) : this._catDict.has(\"Dests\") ? this._catDict.get(\"Dests\") : void 0;\n  }\n  get pageLabels() {\n    let e = null;\n    try {\n      e = this._readPageLabels();\n    } catch (e) {\n      if (e instanceof MissingDataException) throw e;\n      warn(\"Unable to read page labels.\");\n    }\n    return shadow(this, \"pageLabels\", e);\n  }\n  _readPageLabels() {\n    const e = this._catDict.getRaw(\"PageLabels\");\n    if (!e) return null;\n    const t = new Array(this.numPages);\n    let i = null,\n      a = \"\";\n    const s = new NumberTree(e, this.xref).getAll();\n    let r = \"\",\n      n = 1;\n    for (let e = 0, g = this.numPages; e < g; e++) {\n      const g = s.get(e);\n      if (void 0 !== g) {\n        if (!(g instanceof Dict)) throw new FormatError(\"PageLabel is not a dictionary.\");\n        if (g.has(\"Type\") && !isName(g.get(\"Type\"), \"PageLabel\")) throw new FormatError(\"Invalid type in PageLabel dictionary.\");\n        if (g.has(\"S\")) {\n          const e = g.get(\"S\");\n          if (!(e instanceof Name)) throw new FormatError(\"Invalid style in PageLabel dictionary.\");\n          i = e.name;\n        } else i = null;\n        if (g.has(\"P\")) {\n          const e = g.get(\"P\");\n          if (\"string\" != typeof e) throw new FormatError(\"Invalid prefix in PageLabel dictionary.\");\n          a = stringToPDFString(e);\n        } else a = \"\";\n        if (g.has(\"St\")) {\n          const e = g.get(\"St\");\n          if (!(Number.isInteger(e) && e >= 1)) throw new FormatError(\"Invalid start in PageLabel dictionary.\");\n          n = e;\n        } else n = 1;\n      }\n      switch (i) {\n        case \"D\":\n          r = n;\n          break;\n        case \"R\":\n        case \"r\":\n          r = toRomanNumerals(n, \"r\" === i);\n          break;\n        case \"A\":\n        case \"a\":\n          const e = 26,\n            t = \"a\" === i ? 97 : 65,\n            a = n - 1;\n          r = String.fromCharCode(t + a % e).repeat(Math.floor(a / e) + 1);\n          break;\n        default:\n          if (i) throw new FormatError(`Invalid style \"${i}\" in PageLabel dictionary.`);\n          r = \"\";\n      }\n      t[e] = a + r;\n      n++;\n    }\n    return t;\n  }\n  get pageLayout() {\n    const e = this._catDict.get(\"PageLayout\");\n    let t = \"\";\n    if (e instanceof Name) switch (e.name) {\n      case \"SinglePage\":\n      case \"OneColumn\":\n      case \"TwoColumnLeft\":\n      case \"TwoColumnRight\":\n      case \"TwoPageLeft\":\n      case \"TwoPageRight\":\n        t = e.name;\n    }\n    return shadow(this, \"pageLayout\", t);\n  }\n  get pageMode() {\n    const e = this._catDict.get(\"PageMode\");\n    let t = \"UseNone\";\n    if (e instanceof Name) switch (e.name) {\n      case \"UseNone\":\n      case \"UseOutlines\":\n      case \"UseThumbs\":\n      case \"FullScreen\":\n      case \"UseOC\":\n      case \"UseAttachments\":\n        t = e.name;\n    }\n    return shadow(this, \"pageMode\", t);\n  }\n  get viewerPreferences() {\n    const e = this._catDict.get(\"ViewerPreferences\");\n    if (!(e instanceof Dict)) return shadow(this, \"viewerPreferences\", null);\n    let t = null;\n    for (const i of e.getKeys()) {\n      const a = e.get(i);\n      let s;\n      switch (i) {\n        case \"HideToolbar\":\n        case \"HideMenubar\":\n        case \"HideWindowUI\":\n        case \"FitWindow\":\n        case \"CenterWindow\":\n        case \"DisplayDocTitle\":\n        case \"PickTrayByPDFSize\":\n          \"boolean\" == typeof a && (s = a);\n          break;\n        case \"NonFullScreenPageMode\":\n          if (a instanceof Name) switch (a.name) {\n            case \"UseNone\":\n            case \"UseOutlines\":\n            case \"UseThumbs\":\n            case \"UseOC\":\n              s = a.name;\n              break;\n            default:\n              s = \"UseNone\";\n          }\n          break;\n        case \"Direction\":\n          if (a instanceof Name) switch (a.name) {\n            case \"L2R\":\n            case \"R2L\":\n              s = a.name;\n              break;\n            default:\n              s = \"L2R\";\n          }\n          break;\n        case \"ViewArea\":\n        case \"ViewClip\":\n        case \"PrintArea\":\n        case \"PrintClip\":\n          if (a instanceof Name) switch (a.name) {\n            case \"MediaBox\":\n            case \"CropBox\":\n            case \"BleedBox\":\n            case \"TrimBox\":\n            case \"ArtBox\":\n              s = a.name;\n              break;\n            default:\n              s = \"CropBox\";\n          }\n          break;\n        case \"PrintScaling\":\n          if (a instanceof Name) switch (a.name) {\n            case \"None\":\n            case \"AppDefault\":\n              s = a.name;\n              break;\n            default:\n              s = \"AppDefault\";\n          }\n          break;\n        case \"Duplex\":\n          if (a instanceof Name) switch (a.name) {\n            case \"Simplex\":\n            case \"DuplexFlipShortEdge\":\n            case \"DuplexFlipLongEdge\":\n              s = a.name;\n              break;\n            default:\n              s = \"None\";\n          }\n          break;\n        case \"PrintPageRange\":\n          if (Array.isArray(a) && a.length % 2 == 0) {\n            a.every((e, t, i) => Number.isInteger(e) && e > 0 && (0 === t || e >= i[t - 1]) && e <= this.numPages) && (s = a);\n          }\n          break;\n        case \"NumCopies\":\n          Number.isInteger(a) && a > 0 && (s = a);\n          break;\n        default:\n          warn(`Ignoring non-standard key in ViewerPreferences: ${i}.`);\n          continue;\n      }\n      if (void 0 !== s) {\n        t || (t = Object.create(null));\n        t[i] = s;\n      } else warn(`Bad value, for key \"${i}\", in ViewerPreferences: ${a}.`);\n    }\n    return shadow(this, \"viewerPreferences\", t);\n  }\n  get openAction() {\n    const e = this._catDict.get(\"OpenAction\"),\n      t = Object.create(null);\n    if (e instanceof Dict) {\n      const i = new Dict(this.xref);\n      i.set(\"A\", e);\n      const a = {\n        url: null,\n        dest: null,\n        action: null\n      };\n      Catalog.parseDestDictionary({\n        destDict: i,\n        resultObj: a\n      });\n      Array.isArray(a.dest) ? t.dest = a.dest : a.action && (t.action = a.action);\n    } else Array.isArray(e) && (t.dest = e);\n    return shadow(this, \"openAction\", objectSize(t) > 0 ? t : null);\n  }\n  get attachments() {\n    const e = this._catDict.get(\"Names\");\n    let t = null;\n    if (e instanceof Dict && e.has(\"EmbeddedFiles\")) {\n      const i = new NameTree(e.getRaw(\"EmbeddedFiles\"), this.xref);\n      for (const [e, a] of i.getAll()) {\n        const i = new FileSpec(a, this.xref);\n        t || (t = Object.create(null));\n        t[stringToPDFString(e)] = i.serializable;\n      }\n    }\n    return shadow(this, \"attachments\", t);\n  }\n  get xfaImages() {\n    const e = this._catDict.get(\"Names\");\n    let t = null;\n    if (e instanceof Dict && e.has(\"XFAImages\")) {\n      const i = new NameTree(e.getRaw(\"XFAImages\"), this.xref);\n      for (const [e, a] of i.getAll()) {\n        t || (t = new Dict(this.xref));\n        t.set(stringToPDFString(e), a);\n      }\n    }\n    return shadow(this, \"xfaImages\", t);\n  }\n  _collectJavaScript() {\n    const e = this._catDict.get(\"Names\");\n    let t = null;\n    function appendIfJavaScriptDict(e, i) {\n      if (!(i instanceof Dict)) return;\n      if (!isName(i.get(\"S\"), \"JavaScript\")) return;\n      let a = i.get(\"JS\");\n      if (a instanceof BaseStream) a = a.getString();else if (\"string\" != typeof a) return;\n      a = stringToPDFString(a).replaceAll(\"\\0\", \"\");\n      a && (t ||= new Map()).set(e, a);\n    }\n    if (e instanceof Dict && e.has(\"JavaScript\")) {\n      const t = new NameTree(e.getRaw(\"JavaScript\"), this.xref);\n      for (const [e, i] of t.getAll()) appendIfJavaScriptDict(stringToPDFString(e), i);\n    }\n    const i = this._catDict.get(\"OpenAction\");\n    i && appendIfJavaScriptDict(\"OpenAction\", i);\n    return t;\n  }\n  get jsActions() {\n    const e = this._collectJavaScript();\n    let t = collectActions(this.xref, this._catDict, dA);\n    if (e) {\n      t ||= Object.create(null);\n      for (const [i, a] of e) i in t ? t[i].push(a) : t[i] = [a];\n    }\n    return shadow(this, \"jsActions\", t);\n  }\n  async fontFallback(e, t) {\n    const i = await Promise.all(this.fontCache);\n    for (const a of i) if (a.loadedName === e) {\n      a.fallback(t);\n      return;\n    }\n  }\n  async cleanup(e = !1) {\n    clearGlobalCaches();\n    this.globalImageCache.clear(e);\n    this.pageKidsCountCache.clear();\n    this.pageIndexCache.clear();\n    this.nonBlendModesSet.clear();\n    const t = await Promise.all(this.fontCache);\n    for (const {\n      dict: e\n    } of t) delete e.cacheKey;\n    this.fontCache.clear();\n    this.builtInCMapCache.clear();\n    this.standardFontDataCache.clear();\n    this.systemFontCache.clear();\n  }\n  async getPageDict(e) {\n    const t = [this.toplevelPagesDict],\n      i = new RefSet(),\n      a = this._catDict.getRaw(\"Pages\");\n    a instanceof Ref && i.put(a);\n    const s = this.xref,\n      r = this.pageKidsCountCache,\n      n = this.pageIndexCache;\n    let g = 0;\n    for (; t.length;) {\n      const a = t.pop();\n      if (a instanceof Ref) {\n        const o = r.get(a);\n        if (o >= 0 && g + o <= e) {\n          g += o;\n          continue;\n        }\n        if (i.has(a)) throw new FormatError(\"Pages tree contains circular reference.\");\n        i.put(a);\n        const c = await s.fetchAsync(a);\n        if (c instanceof Dict) {\n          let t = c.getRaw(\"Type\");\n          t instanceof Ref && (t = await s.fetchAsync(t));\n          if (isName(t, \"Page\") || !c.has(\"Kids\")) {\n            r.has(a) || r.put(a, 1);\n            n.has(a) || n.put(a, g);\n            if (g === e) return [c, a];\n            g++;\n            continue;\n          }\n        }\n        t.push(c);\n        continue;\n      }\n      if (!(a instanceof Dict)) throw new FormatError(\"Page dictionary kid reference points to wrong type of object.\");\n      const {\n        objId: o\n      } = a;\n      let c = a.getRaw(\"Count\");\n      c instanceof Ref && (c = await s.fetchAsync(c));\n      if (Number.isInteger(c) && c >= 0) {\n        o && !r.has(o) && r.put(o, c);\n        if (g + c <= e) {\n          g += c;\n          continue;\n        }\n      }\n      let C = a.getRaw(\"Kids\");\n      C instanceof Ref && (C = await s.fetchAsync(C));\n      if (!Array.isArray(C)) {\n        let t = a.getRaw(\"Type\");\n        t instanceof Ref && (t = await s.fetchAsync(t));\n        if (isName(t, \"Page\") || !a.has(\"Kids\")) {\n          if (g === e) return [a, null];\n          g++;\n          continue;\n        }\n        throw new FormatError(\"Page dictionary kids object is not an array.\");\n      }\n      for (let e = C.length - 1; e >= 0; e--) t.push(C[e]);\n    }\n    throw new Error(`Page index ${e} not found.`);\n  }\n  async getAllPageDicts(e = !1) {\n    const {\n        ignoreErrors: t\n      } = this.pdfManager.evaluatorOptions,\n      i = [{\n        currentNode: this.toplevelPagesDict,\n        posInKids: 0\n      }],\n      a = new RefSet(),\n      s = this._catDict.getRaw(\"Pages\");\n    s instanceof Ref && a.put(s);\n    const r = new Map(),\n      n = this.xref,\n      g = this.pageIndexCache;\n    let o = 0;\n    function addPageDict(e, t) {\n      t && !g.has(t) && g.put(t, o);\n      r.set(o++, [e, t]);\n    }\n    function addPageError(i) {\n      if (i instanceof XRefEntryException && !e) throw i;\n      if (e && t && 0 === o) {\n        warn(`getAllPageDicts - Skipping invalid first page: \"${i}\".`);\n        i = Dict.empty;\n      }\n      r.set(o++, [i, null]);\n    }\n    for (; i.length > 0;) {\n      const e = i.at(-1),\n        {\n          currentNode: t,\n          posInKids: s\n        } = e;\n      let r = t.getRaw(\"Kids\");\n      if (r instanceof Ref) try {\n        r = await n.fetchAsync(r);\n      } catch (e) {\n        addPageError(e);\n        break;\n      }\n      if (!Array.isArray(r)) {\n        addPageError(new FormatError(\"Page dictionary kids object is not an array.\"));\n        break;\n      }\n      if (s >= r.length) {\n        i.pop();\n        continue;\n      }\n      const g = r[s];\n      let o;\n      if (g instanceof Ref) {\n        if (a.has(g)) {\n          addPageError(new FormatError(\"Pages tree contains circular reference.\"));\n          break;\n        }\n        a.put(g);\n        try {\n          o = await n.fetchAsync(g);\n        } catch (e) {\n          addPageError(e);\n          break;\n        }\n      } else o = g;\n      if (!(o instanceof Dict)) {\n        addPageError(new FormatError(\"Page dictionary kid reference points to wrong type of object.\"));\n        break;\n      }\n      let c = o.getRaw(\"Type\");\n      if (c instanceof Ref) try {\n        c = await n.fetchAsync(c);\n      } catch (e) {\n        addPageError(e);\n        break;\n      }\n      isName(c, \"Page\") || !o.has(\"Kids\") ? addPageDict(o, g instanceof Ref ? g : null) : i.push({\n        currentNode: o,\n        posInKids: 0\n      });\n      e.posInKids++;\n    }\n    return r;\n  }\n  getPageIndex(e) {\n    const t = this.pageIndexCache.get(e);\n    if (void 0 !== t) return Promise.resolve(t);\n    const i = this.xref;\n    let a = 0;\n    const next = t => function pagesBeforeRef(t) {\n      let a,\n        s = 0;\n      return i.fetchAsync(t).then(function (i) {\n        if (isRefsEqual(t, e) && !isDict(i, \"Page\") && !(i instanceof Dict && !i.has(\"Type\") && i.has(\"Contents\"))) throw new FormatError(\"The reference does not point to a /Page dictionary.\");\n        if (!i) return null;\n        if (!(i instanceof Dict)) throw new FormatError(\"Node must be a dictionary.\");\n        a = i.getRaw(\"Parent\");\n        return i.getAsync(\"Parent\");\n      }).then(function (e) {\n        if (!e) return null;\n        if (!(e instanceof Dict)) throw new FormatError(\"Parent must be a dictionary.\");\n        return e.getAsync(\"Kids\");\n      }).then(function (e) {\n        if (!e) return null;\n        const r = [];\n        let n = !1;\n        for (const a of e) {\n          if (!(a instanceof Ref)) throw new FormatError(\"Kid must be a reference.\");\n          if (isRefsEqual(a, t)) {\n            n = !0;\n            break;\n          }\n          r.push(i.fetchAsync(a).then(function (e) {\n            if (!(e instanceof Dict)) throw new FormatError(\"Kid node must be a dictionary.\");\n            e.has(\"Count\") ? s += e.get(\"Count\") : s++;\n          }));\n        }\n        if (!n) throw new FormatError(\"Kid reference not found in parent's kids.\");\n        return Promise.all(r).then(function () {\n          return [s, a];\n        });\n      });\n    }(t).then(t => {\n      if (!t) {\n        this.pageIndexCache.put(e, a);\n        return a;\n      }\n      const [i, s] = t;\n      a += i;\n      return next(s);\n    });\n    return next(e);\n  }\n  get baseUrl() {\n    const e = this._catDict.get(\"URI\");\n    if (e instanceof Dict) {\n      const t = e.get(\"Base\");\n      if (\"string\" == typeof t) {\n        const e = createValidAbsoluteUrl(t, null, {\n          tryConvertEncoding: !0\n        });\n        if (e) return shadow(this, \"baseUrl\", e.href);\n      }\n    }\n    return shadow(this, \"baseUrl\", this.pdfManager.docBaseUrl);\n  }\n  static parseDestDictionary({\n    destDict: e,\n    resultObj: t,\n    docBaseUrl: i = null,\n    docAttachments: a = null\n  }) {\n    if (!(e instanceof Dict)) {\n      warn(\"parseDestDictionary: `destDict` must be a dictionary.\");\n      return;\n    }\n    let s,\n      r,\n      n = e.get(\"A\");\n    if (!(n instanceof Dict)) if (e.has(\"Dest\")) n = e.get(\"Dest\");else {\n      n = e.get(\"AA\");\n      n instanceof Dict && (n.has(\"D\") ? n = n.get(\"D\") : n.has(\"U\") && (n = n.get(\"U\")));\n    }\n    if (n instanceof Dict) {\n      const e = n.get(\"S\");\n      if (!(e instanceof Name)) {\n        warn(\"parseDestDictionary: Invalid type in Action dictionary.\");\n        return;\n      }\n      const i = e.name;\n      switch (i) {\n        case \"ResetForm\":\n          const e = n.get(\"Flags\"),\n            g = 0 == (1 & (\"number\" == typeof e ? e : 0)),\n            o = [],\n            c = [];\n          for (const e of n.get(\"Fields\") || []) e instanceof Ref ? c.push(e.toString()) : \"string\" == typeof e && o.push(stringToPDFString(e));\n          t.resetForm = {\n            fields: o,\n            refs: c,\n            include: g\n          };\n          break;\n        case \"URI\":\n          s = n.get(\"URI\");\n          s instanceof Name && (s = \"/\" + s.name);\n          break;\n        case \"GoTo\":\n          r = n.get(\"D\");\n          break;\n        case \"Launch\":\n        case \"GoToR\":\n          const C = n.get(\"F\");\n          if (C instanceof Dict) {\n            const e = new FileSpec(C, null, !0),\n              {\n                rawFilename: t\n              } = e.serializable;\n            s = t;\n          } else \"string\" == typeof C && (s = C);\n          const h = fetchRemoteDest(n);\n          h && \"string\" == typeof s && (s = s.split(\"#\", 1)[0] + \"#\" + h);\n          const l = n.get(\"NewWindow\");\n          \"boolean\" == typeof l && (t.newWindow = l);\n          break;\n        case \"GoToE\":\n          const Q = n.get(\"T\");\n          let E;\n          if (a && Q instanceof Dict) {\n            const e = Q.get(\"R\"),\n              t = Q.get(\"N\");\n            isName(e, \"C\") && \"string\" == typeof t && (E = a[stringToPDFString(t)]);\n          }\n          if (E) {\n            t.attachment = E;\n            const e = fetchRemoteDest(n);\n            e && (t.attachmentDest = e);\n          } else warn('parseDestDictionary - unimplemented \"GoToE\" action.');\n          break;\n        case \"Named\":\n          const u = n.get(\"N\");\n          u instanceof Name && (t.action = u.name);\n          break;\n        case \"SetOCGState\":\n          const d = n.get(\"State\"),\n            f = n.get(\"PreserveRB\");\n          if (!Array.isArray(d) || 0 === d.length) break;\n          const p = [];\n          for (const e of d) if (e instanceof Name) switch (e.name) {\n            case \"ON\":\n            case \"OFF\":\n            case \"Toggle\":\n              p.push(e.name);\n          } else e instanceof Ref && p.push(e.toString());\n          if (p.length !== d.length) break;\n          t.setOCGState = {\n            state: p,\n            preserveRB: \"boolean\" != typeof f || f\n          };\n          break;\n        case \"JavaScript\":\n          const m = n.get(\"JS\");\n          let y;\n          m instanceof BaseStream ? y = m.getString() : \"string\" == typeof m && (y = m);\n          const w = y && recoverJsURL(stringToPDFString(y));\n          if (w) {\n            s = w.url;\n            t.newWindow = w.newWindow;\n            break;\n          }\n        default:\n          if (\"JavaScript\" === i || \"SubmitForm\" === i) break;\n          warn(`parseDestDictionary - unsupported action: \"${i}\".`);\n      }\n    } else e.has(\"Dest\") && (r = e.get(\"Dest\"));\n    if (\"string\" == typeof s) {\n      const e = createValidAbsoluteUrl(s, i, {\n        addDefaultProtocol: !0,\n        tryConvertEncoding: !0\n      });\n      e && (t.url = e.href);\n      t.unsafeUrl = s;\n    }\n    if (r) {\n      r instanceof Name && (r = r.name);\n      \"string\" == typeof r ? t.dest = stringToPDFString(r) : isValidExplicitDest(r) && (t.dest = r);\n    }\n  }\n}\nfunction addChildren(e, t) {\n  if (e instanceof Dict) e = e.getRawValues();else if (e instanceof BaseStream) e = e.dict.getRawValues();else if (!Array.isArray(e)) return;\n  for (const a of e) ((i = a) instanceof Ref || i instanceof Dict || i instanceof BaseStream || Array.isArray(i)) && t.push(a);\n  var i;\n}\nclass ObjectLoader {\n  constructor(e, t, i) {\n    this.dict = e;\n    this.keys = t;\n    this.xref = i;\n    this.refSet = null;\n  }\n  async load() {\n    if (this.xref.stream.isDataLoaded) return;\n    const {\n      keys: e,\n      dict: t\n    } = this;\n    this.refSet = new RefSet();\n    const i = [];\n    for (const a of e) {\n      const e = t.getRaw(a);\n      void 0 !== e && i.push(e);\n    }\n    return this._walk(i);\n  }\n  async _walk(e) {\n    const t = [],\n      i = [];\n    for (; e.length;) {\n      let a = e.pop();\n      if (a instanceof Ref) {\n        if (this.refSet.has(a)) continue;\n        try {\n          this.refSet.put(a);\n          a = this.xref.fetch(a);\n        } catch (e) {\n          if (!(e instanceof MissingDataException)) {\n            warn(`ObjectLoader._walk - requesting all data: \"${e}\".`);\n            this.refSet = null;\n            const {\n              manager: t\n            } = this.xref.stream;\n            return t.requestAllChunks();\n          }\n          t.push(a);\n          i.push({\n            begin: e.begin,\n            end: e.end\n          });\n        }\n      }\n      if (a instanceof BaseStream) {\n        const e = a.getBaseStreams();\n        if (e) {\n          let s = !1;\n          for (const t of e) if (!t.isDataLoaded) {\n            s = !0;\n            i.push({\n              begin: t.start,\n              end: t.end\n            });\n          }\n          s && t.push(a);\n        }\n      }\n      addChildren(a, e);\n    }\n    if (i.length) {\n      await this.xref.stream.manager.requestRanges(i);\n      for (const e of t) e instanceof Ref && this.refSet.remove(e);\n      return this._walk(t);\n    }\n    this.refSet = null;\n  }\n}\nconst Ws = Symbol(),\n  js = Symbol(),\n  Xs = Symbol(),\n  Zs = Symbol(),\n  Vs = Symbol(),\n  zs = Symbol(),\n  _s = Symbol(),\n  $s = Symbol(),\n  Ar = Symbol(),\n  er = Symbol(\"content\"),\n  tr = Symbol(\"data\"),\n  ir = Symbol(),\n  ar = Symbol(\"extra\"),\n  sr = Symbol(),\n  rr = Symbol(),\n  nr = Symbol(),\n  gr = Symbol(),\n  or = Symbol(),\n  Ir = Symbol(),\n  cr = Symbol(),\n  Cr = Symbol(),\n  hr = Symbol(),\n  lr = Symbol(),\n  Qr = Symbol(),\n  Er = Symbol(),\n  ur = Symbol(),\n  dr = Symbol(),\n  fr = Symbol(),\n  pr = Symbol(),\n  mr = Symbol(),\n  yr = Symbol(),\n  wr = Symbol(),\n  Dr = Symbol(),\n  br = Symbol(),\n  Fr = Symbol(),\n  Sr = Symbol(),\n  kr = Symbol(),\n  Rr = Symbol(),\n  Nr = Symbol(),\n  Gr = Symbol(),\n  xr = Symbol(),\n  Ur = Symbol(),\n  Mr = Symbol(),\n  Lr = Symbol(),\n  Hr = Symbol(),\n  Jr = Symbol(\"namespaceId\"),\n  Yr = Symbol(\"nodeName\"),\n  vr = Symbol(),\n  Kr = Symbol(),\n  Tr = Symbol(),\n  qr = Symbol(),\n  Or = Symbol(),\n  Pr = Symbol(),\n  Wr = Symbol(),\n  jr = Symbol(),\n  Xr = Symbol(\"root\"),\n  Zr = Symbol(),\n  Vr = Symbol(),\n  zr = Symbol(),\n  _r = Symbol(),\n  $r = Symbol(),\n  An = Symbol(),\n  en = Symbol(),\n  tn = Symbol(),\n  an = Symbol(),\n  sn = Symbol(),\n  rn = Symbol(),\n  nn = Symbol(\"uid\"),\n  gn = Symbol(),\n  on = {\n    config: {\n      id: 0,\n      check: e => e.startsWith(\"http://www.xfa.org/schema/xci/\")\n    },\n    connectionSet: {\n      id: 1,\n      check: e => e.startsWith(\"http://www.xfa.org/schema/xfa-connection-set/\")\n    },\n    datasets: {\n      id: 2,\n      check: e => e.startsWith(\"http://www.xfa.org/schema/xfa-data/\")\n    },\n    form: {\n      id: 3,\n      check: e => e.startsWith(\"http://www.xfa.org/schema/xfa-form/\")\n    },\n    localeSet: {\n      id: 4,\n      check: e => e.startsWith(\"http://www.xfa.org/schema/xfa-locale-set/\")\n    },\n    pdf: {\n      id: 5,\n      check: e => \"http://ns.adobe.com/xdp/pdf/\" === e\n    },\n    signature: {\n      id: 6,\n      check: e => \"http://www.w3.org/2000/09/xmldsig#\" === e\n    },\n    sourceSet: {\n      id: 7,\n      check: e => e.startsWith(\"http://www.xfa.org/schema/xfa-source-set/\")\n    },\n    stylesheet: {\n      id: 8,\n      check: e => \"http://www.w3.org/1999/XSL/Transform\" === e\n    },\n    template: {\n      id: 9,\n      check: e => e.startsWith(\"http://www.xfa.org/schema/xfa-template/\")\n    },\n    xdc: {\n      id: 10,\n      check: e => e.startsWith(\"http://www.xfa.org/schema/xdc/\")\n    },\n    xdp: {\n      id: 11,\n      check: e => \"http://ns.adobe.com/xdp/\" === e\n    },\n    xfdf: {\n      id: 12,\n      check: e => \"http://ns.adobe.com/xfdf/\" === e\n    },\n    xhtml: {\n      id: 13,\n      check: e => \"http://www.w3.org/1999/xhtml\" === e\n    },\n    xmpmeta: {\n      id: 14,\n      check: e => \"http://ns.adobe.com/xmpmeta/\" === e\n    }\n  },\n  In = {\n    pt: e => e,\n    cm: e => e / 2.54 * 72,\n    mm: e => e / 25.4 * 72,\n    in: e => 72 * e,\n    px: e => e\n  },\n  cn = /([+-]?\\d+\\.?\\d*)(.*)/;\nfunction stripQuotes(e) {\n  return e.startsWith(\"'\") || e.startsWith('\"') ? e.slice(1, -1) : e;\n}\nfunction getInteger({\n  data: e,\n  defaultValue: t,\n  validate: i\n}) {\n  if (!e) return t;\n  e = e.trim();\n  const a = parseInt(e, 10);\n  return !isNaN(a) && i(a) ? a : t;\n}\nfunction getFloat({\n  data: e,\n  defaultValue: t,\n  validate: i\n}) {\n  if (!e) return t;\n  e = e.trim();\n  const a = parseFloat(e);\n  return !isNaN(a) && i(a) ? a : t;\n}\nfunction getKeyword({\n  data: e,\n  defaultValue: t,\n  validate: i\n}) {\n  return e && i(e = e.trim()) ? e : t;\n}\nfunction getStringOption(e, t) {\n  return getKeyword({\n    data: e,\n    defaultValue: t[0],\n    validate: e => t.includes(e)\n  });\n}\nfunction getMeasurement(e, t = \"0\") {\n  t ||= \"0\";\n  if (!e) return getMeasurement(t);\n  const i = e.trim().match(cn);\n  if (!i) return getMeasurement(t);\n  const [, a, s] = i,\n    r = parseFloat(a);\n  if (isNaN(r)) return getMeasurement(t);\n  if (0 === r) return 0;\n  const n = In[s];\n  return n ? n(r) : r;\n}\nfunction getRatio(e) {\n  if (!e) return {\n    num: 1,\n    den: 1\n  };\n  const t = e.trim().split(/\\s*:\\s*/).map(e => parseFloat(e)).filter(e => !isNaN(e));\n  1 === t.length && t.push(1);\n  if (0 === t.length) return {\n    num: 1,\n    den: 1\n  };\n  const [i, a] = t;\n  return {\n    num: i,\n    den: a\n  };\n}\nfunction getRelevant(e) {\n  return e ? e.trim().split(/\\s+/).map(e => ({\n    excluded: \"-\" === e[0],\n    viewname: e.substring(1)\n  })) : [];\n}\nclass HTMLResult {\n  static get FAILURE() {\n    return shadow(this, \"FAILURE\", new HTMLResult(!1, null, null, null));\n  }\n  static get EMPTY() {\n    return shadow(this, \"EMPTY\", new HTMLResult(!0, null, null, null));\n  }\n  constructor(e, t, i, a) {\n    this.success = e;\n    this.html = t;\n    this.bbox = i;\n    this.breakNode = a;\n  }\n  isBreak() {\n    return !!this.breakNode;\n  }\n  static breakNode(e) {\n    return new HTMLResult(!1, null, null, e);\n  }\n  static success(e, t = null) {\n    return new HTMLResult(!0, e, t, null);\n  }\n}\nclass FontFinder {\n  constructor(e) {\n    this.fonts = new Map();\n    this.cache = new Map();\n    this.warned = new Set();\n    this.defaultFont = null;\n    this.add(e);\n  }\n  add(e, t = null) {\n    for (const t of e) this.addPdfFont(t);\n    for (const e of this.fonts.values()) e.regular || (e.regular = e.italic || e.bold || e.bolditalic);\n    if (!t || 0 === t.size) return;\n    const i = this.fonts.get(\"PdfJS-Fallback-PdfJS-XFA\");\n    for (const e of t) this.fonts.set(e, i);\n  }\n  addPdfFont(e) {\n    const t = e.cssFontInfo,\n      i = t.fontFamily;\n    let a = this.fonts.get(i);\n    if (!a) {\n      a = Object.create(null);\n      this.fonts.set(i, a);\n      this.defaultFont || (this.defaultFont = a);\n    }\n    let s = \"\";\n    const r = parseFloat(t.fontWeight);\n    0 !== parseFloat(t.italicAngle) ? s = r >= 700 ? \"bolditalic\" : \"italic\" : r >= 700 && (s = \"bold\");\n    if (!s) {\n      (e.name.includes(\"Bold\") || e.psName?.includes(\"Bold\")) && (s = \"bold\");\n      (e.name.includes(\"Italic\") || e.name.endsWith(\"It\") || e.psName?.includes(\"Italic\") || e.psName?.endsWith(\"It\")) && (s += \"italic\");\n    }\n    s || (s = \"regular\");\n    a[s] = e;\n  }\n  getDefault() {\n    return this.defaultFont;\n  }\n  find(e, t = !0) {\n    let i = this.fonts.get(e) || this.cache.get(e);\n    if (i) return i;\n    const a = /,|-|_| |bolditalic|bold|italic|regular|it/gi;\n    let s = e.replaceAll(a, \"\");\n    i = this.fonts.get(s);\n    if (i) {\n      this.cache.set(e, i);\n      return i;\n    }\n    s = s.toLowerCase();\n    const r = [];\n    for (const [e, t] of this.fonts.entries()) e.replaceAll(a, \"\").toLowerCase().startsWith(s) && r.push(t);\n    if (0 === r.length) for (const [, e] of this.fonts.entries()) e.regular.name?.replaceAll(a, \"\").toLowerCase().startsWith(s) && r.push(e);\n    if (0 === r.length) {\n      s = s.replaceAll(/psmt|mt/gi, \"\");\n      for (const [e, t] of this.fonts.entries()) e.replaceAll(a, \"\").toLowerCase().startsWith(s) && r.push(t);\n    }\n    if (0 === r.length) for (const e of this.fonts.values()) e.regular.name?.replaceAll(a, \"\").toLowerCase().startsWith(s) && r.push(e);\n    if (r.length >= 1) {\n      1 !== r.length && t && warn(`XFA - Too many choices to guess the correct font: ${e}`);\n      this.cache.set(e, r[0]);\n      return r[0];\n    }\n    if (t && !this.warned.has(e)) {\n      this.warned.add(e);\n      warn(`XFA - Cannot find the font: ${e}`);\n    }\n    return null;\n  }\n}\nfunction selectFont(e, t) {\n  return \"italic\" === e.posture ? \"bold\" === e.weight ? t.bolditalic : t.italic : \"bold\" === e.weight ? t.bold : t.regular;\n}\nclass FontInfo {\n  constructor(e, t, i, a) {\n    this.lineHeight = i;\n    this.paraMargin = t || {\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0\n    };\n    if (!e) {\n      [this.pdfFont, this.xfaFont] = this.defaultFont(a);\n      return;\n    }\n    this.xfaFont = {\n      typeface: e.typeface,\n      posture: e.posture,\n      weight: e.weight,\n      size: e.size,\n      letterSpacing: e.letterSpacing\n    };\n    const s = a.find(e.typeface);\n    if (s) {\n      this.pdfFont = selectFont(e, s);\n      this.pdfFont || ([this.pdfFont, this.xfaFont] = this.defaultFont(a));\n    } else [this.pdfFont, this.xfaFont] = this.defaultFont(a);\n  }\n  defaultFont(e) {\n    const t = e.find(\"Helvetica\", !1) || e.find(\"Myriad Pro\", !1) || e.find(\"Arial\", !1) || e.getDefault();\n    if (t?.regular) {\n      const e = t.regular;\n      return [e, {\n        typeface: e.cssFontInfo.fontFamily,\n        posture: \"normal\",\n        weight: \"normal\",\n        size: 10,\n        letterSpacing: 0\n      }];\n    }\n    return [null, {\n      typeface: \"Courier\",\n      posture: \"normal\",\n      weight: \"normal\",\n      size: 10,\n      letterSpacing: 0\n    }];\n  }\n}\nclass FontSelector {\n  constructor(e, t, i, a) {\n    this.fontFinder = a;\n    this.stack = [new FontInfo(e, t, i, a)];\n  }\n  pushData(e, t, i) {\n    const a = this.stack.at(-1);\n    for (const t of [\"typeface\", \"posture\", \"weight\", \"size\", \"letterSpacing\"]) e[t] || (e[t] = a.xfaFont[t]);\n    for (const e of [\"top\", \"bottom\", \"left\", \"right\"]) isNaN(t[e]) && (t[e] = a.paraMargin[e]);\n    const s = new FontInfo(e, t, i || a.lineHeight, this.fontFinder);\n    s.pdfFont || (s.pdfFont = a.pdfFont);\n    this.stack.push(s);\n  }\n  popFont() {\n    this.stack.pop();\n  }\n  topFont() {\n    return this.stack.at(-1);\n  }\n}\nclass TextMeasure {\n  constructor(e, t, i, a) {\n    this.glyphs = [];\n    this.fontSelector = new FontSelector(e, t, i, a);\n    this.extraHeight = 0;\n  }\n  pushData(e, t, i) {\n    this.fontSelector.pushData(e, t, i);\n  }\n  popFont(e) {\n    return this.fontSelector.popFont();\n  }\n  addPara() {\n    const e = this.fontSelector.topFont();\n    this.extraHeight += e.paraMargin.top + e.paraMargin.bottom;\n  }\n  addString(e) {\n    if (!e) return;\n    const t = this.fontSelector.topFont(),\n      i = t.xfaFont.size;\n    if (t.pdfFont) {\n      const a = t.xfaFont.letterSpacing,\n        s = t.pdfFont,\n        r = s.lineHeight || 1.2,\n        n = t.lineHeight || Math.max(1.2, r) * i,\n        g = r - (void 0 === s.lineGap ? .2 : s.lineGap),\n        o = Math.max(1, g) * i,\n        c = i / 1e3,\n        C = s.defaultWidth || s.charsToGlyphs(\" \")[0].width;\n      for (const t of e.split(/[\\u2029\\n]/)) {\n        const e = s.encodeString(t).join(\"\"),\n          i = s.charsToGlyphs(e);\n        for (const e of i) {\n          const t = e.width || C;\n          this.glyphs.push([t * c + a, n, o, e.unicode, !1]);\n        }\n        this.glyphs.push([0, 0, 0, \"\\n\", !0]);\n      }\n      this.glyphs.pop();\n    } else {\n      for (const t of e.split(/[\\u2029\\n]/)) {\n        for (const e of t.split(\"\")) this.glyphs.push([i, 1.2 * i, i, e, !1]);\n        this.glyphs.push([0, 0, 0, \"\\n\", !0]);\n      }\n      this.glyphs.pop();\n    }\n  }\n  compute(e) {\n    let t = -1,\n      i = 0,\n      a = 0,\n      s = 0,\n      r = 0,\n      n = 0,\n      g = !1,\n      o = !0;\n    for (let c = 0, C = this.glyphs.length; c < C; c++) {\n      const [C, h, l, Q, E] = this.glyphs[c],\n        u = \" \" === Q,\n        d = o ? l : h;\n      if (E) {\n        a = Math.max(a, r);\n        r = 0;\n        s += n;\n        n = d;\n        t = -1;\n        i = 0;\n        o = !1;\n      } else if (u) {\n        if (r + C > e) {\n          a = Math.max(a, r);\n          r = 0;\n          s += n;\n          n = d;\n          t = -1;\n          i = 0;\n          g = !0;\n          o = !1;\n        } else {\n          n = Math.max(d, n);\n          i = r;\n          r += C;\n          t = c;\n        }\n      } else if (r + C > e) {\n        s += n;\n        n = d;\n        if (-1 !== t) {\n          c = t;\n          a = Math.max(a, i);\n          r = 0;\n          t = -1;\n          i = 0;\n        } else {\n          a = Math.max(a, r);\n          r = C;\n        }\n        g = !0;\n        o = !1;\n      } else {\n        r += C;\n        n = Math.max(d, n);\n      }\n    }\n    a = Math.max(a, r);\n    s += n + this.extraHeight;\n    return {\n      width: 1.02 * a,\n      height: s,\n      isBroken: g\n    };\n  }\n}\nconst Cn = /^[^.[]+/,\n  hn = /^[^\\]]+/,\n  Bn = {\n    dot: 0,\n    dotDot: 1,\n    dotHash: 2,\n    dotBracket: 3,\n    dotParen: 4\n  },\n  ln = new Map([[\"$data\", (e, t) => e.datasets ? e.datasets.data : e], [\"$record\", (e, t) => (e.datasets ? e.datasets.data : e)[Er]()[0]], [\"$template\", (e, t) => e.template], [\"$connectionSet\", (e, t) => e.connectionSet], [\"$form\", (e, t) => e.form], [\"$layout\", (e, t) => e.layout], [\"$host\", (e, t) => e.host], [\"$dataWindow\", (e, t) => e.dataWindow], [\"$event\", (e, t) => e.event], [\"!\", (e, t) => e.datasets], [\"$xfa\", (e, t) => e], [\"xfa\", (e, t) => e], [\"$\", (e, t) => t]]),\n  Qn = new WeakMap();\nfunction parseExpression(e, t, i = !0) {\n  let a = e.match(Cn);\n  if (!a) return null;\n  let [s] = a;\n  const r = [{\n    name: s,\n    cacheName: \".\" + s,\n    index: 0,\n    js: null,\n    formCalc: null,\n    operator: Bn.dot\n  }];\n  let n = s.length;\n  for (; n < e.length;) {\n    const o = n;\n    if (\"[\" === e.charAt(n++)) {\n      a = e.slice(n).match(hn);\n      if (!a) {\n        warn(\"XFA - Invalid index in SOM expression\");\n        return null;\n      }\n      r.at(-1).index = \"*\" === (g = (g = a[0]).trim()) ? 1 / 0 : parseInt(g, 10) || 0;\n      n += a[0].length + 1;\n      continue;\n    }\n    let c;\n    switch (e.charAt(n)) {\n      case \".\":\n        if (!t) return null;\n        n++;\n        c = Bn.dotDot;\n        break;\n      case \"#\":\n        n++;\n        c = Bn.dotHash;\n        break;\n      case \"[\":\n        if (i) {\n          warn(\"XFA - SOM expression contains a FormCalc subexpression which is not supported for now.\");\n          return null;\n        }\n        c = Bn.dotBracket;\n        break;\n      case \"(\":\n        if (i) {\n          warn(\"XFA - SOM expression contains a JavaScript subexpression which is not supported for now.\");\n          return null;\n        }\n        c = Bn.dotParen;\n        break;\n      default:\n        c = Bn.dot;\n    }\n    a = e.slice(n).match(Cn);\n    if (!a) break;\n    [s] = a;\n    n += s.length;\n    r.push({\n      name: s,\n      cacheName: e.slice(o, n),\n      operator: c,\n      index: 0,\n      js: null,\n      formCalc: null\n    });\n  }\n  var g;\n  return r;\n}\nfunction searchNode(e, t, i, a = !0, s = !0) {\n  const r = parseExpression(i, a);\n  if (!r) return null;\n  const n = ln.get(r[0].name);\n  let g,\n    o = 0;\n  if (n) {\n    g = !0;\n    e = [n(e, t)];\n    o = 1;\n  } else {\n    g = null === t;\n    e = [t || e];\n  }\n  for (let i = r.length; o < i; o++) {\n    const {\n        name: i,\n        cacheName: a,\n        operator: n,\n        index: c\n      } = r[o],\n      C = [];\n    for (const t of e) {\n      if (!t.isXFAObject) continue;\n      let e, r;\n      if (s) {\n        r = Qn.get(t);\n        if (!r) {\n          r = new Map();\n          Qn.set(t, r);\n        }\n        e = r.get(a);\n      }\n      if (!e) {\n        switch (n) {\n          case Bn.dot:\n            e = t[cr](i, !1);\n            break;\n          case Bn.dotDot:\n            e = t[cr](i, !0);\n            break;\n          case Bn.dotHash:\n            e = t[Ir](i);\n            e = e.isXFAObjectArray ? e.children : [e];\n        }\n        s && r.set(a, e);\n      }\n      e.length > 0 && C.push(e);\n    }\n    if (0 !== C.length || g || 0 !== o) e = isFinite(c) ? C.filter(e => c < e.length).map(e => e[c]) : C.flat();else {\n      const i = t[pr]();\n      if (!(t = i)) return null;\n      o = -1;\n      e = [t];\n    }\n  }\n  return 0 === e.length ? null : e;\n}\nfunction createDataNode(e, t, i) {\n  const a = parseExpression(i);\n  if (!a) return null;\n  if (a.some(e => e.operator === Bn.dotDot)) return null;\n  const s = ln.get(a[0].name);\n  let r = 0;\n  if (s) {\n    e = s(e, t);\n    r = 1;\n  } else e = t || e;\n  for (let t = a.length; r < t; r++) {\n    const {\n      name: t,\n      operator: i,\n      index: s\n    } = a[r];\n    if (!isFinite(s)) {\n      a[r].index = 0;\n      return e.createNodes(a.slice(r));\n    }\n    let n;\n    switch (i) {\n      case Bn.dot:\n        n = e[cr](t, !1);\n        break;\n      case Bn.dotDot:\n        n = e[cr](t, !0);\n        break;\n      case Bn.dotHash:\n        n = e[Ir](t);\n        n = n.isXFAObjectArray ? n.children : [n];\n    }\n    if (0 === n.length) return e.createNodes(a.slice(r));\n    if (!(s < n.length)) {\n      a[r].index = s - n.length;\n      return e.createNodes(a.slice(r));\n    }\n    {\n      const t = n[s];\n      if (!t.isXFAObject) {\n        warn(\"XFA - Cannot create a node.\");\n        return null;\n      }\n      e = t;\n    }\n  }\n  return null;\n}\nconst En = Symbol(),\n  un = Symbol(),\n  dn = Symbol(),\n  fn = Symbol(\"_children\"),\n  pn = Symbol(),\n  mn = Symbol(),\n  yn = Symbol(),\n  wn = Symbol(),\n  Dn = Symbol(),\n  bn = Symbol(),\n  Fn = Symbol(),\n  Sn = Symbol(),\n  kn = Symbol(),\n  Rn = Symbol(\"parent\"),\n  Nn = Symbol(),\n  Gn = Symbol(),\n  xn = Symbol();\nlet Un = 0;\nconst Mn = on.datasets.id;\nclass XFAObject {\n  constructor(e, t, i = !1) {\n    this[Jr] = e;\n    this[Yr] = t;\n    this[Fn] = i;\n    this[Rn] = null;\n    this[fn] = [];\n    this[nn] = `${t}${Un++}`;\n    this[yr] = null;\n  }\n  get isXFAObject() {\n    return !0;\n  }\n  get isXFAObjectArray() {\n    return !1;\n  }\n  createNodes(e) {\n    let t = this,\n      i = null;\n    for (const {\n      name: a,\n      index: s\n    } of e) {\n      for (let e = 0, r = isFinite(s) ? s : 0; e <= r; e++) {\n        const e = t[Jr] === Mn ? -1 : t[Jr];\n        i = new XmlObject(e, a);\n        t[Xs](i);\n      }\n      t = i;\n    }\n    return i;\n  }\n  [Kr](e) {\n    if (!this[Fn] || !this[Tr](e)) return !1;\n    const t = e[Yr],\n      i = this[t];\n    if (!(i instanceof XFAObjectArray)) {\n      null !== i && this[jr](i);\n      this[t] = e;\n      this[Xs](e);\n      return !0;\n    }\n    if (i.push(e)) {\n      this[Xs](e);\n      return !0;\n    }\n    let a = \"\";\n    this.id ? a = ` (id: ${this.id})` : this.name && (a = ` (name: ${this.name} ${this.h.value})`);\n    warn(`XFA - node \"${this[Yr]}\"${a} has already enough \"${t}\"!`);\n    return !1;\n  }\n  [Tr](e) {\n    return this.hasOwnProperty(e[Yr]) && e[Jr] === this[Jr];\n  }\n  [Gr]() {\n    return !1;\n  }\n  [Ws]() {\n    return !1;\n  }\n  [Sr]() {\n    return !1;\n  }\n  [kr]() {\n    return !1;\n  }\n  [Pr]() {\n    this.para && this[mr]()[ar].paraStack.pop();\n  }\n  [Wr]() {\n    this[mr]()[ar].paraStack.push(this.para);\n  }\n  [zr](e) {\n    this.id && this[Jr] === on.template.id && e.set(this.id, this);\n  }\n  [mr]() {\n    return this[yr].template;\n  }\n  [xr]() {\n    return !1;\n  }\n  [Ur]() {\n    return !1;\n  }\n  [Xs](e) {\n    e[Rn] = this;\n    this[fn].push(e);\n    !e[yr] && this[yr] && (e[yr] = this[yr]);\n  }\n  [jr](e) {\n    const t = this[fn].indexOf(e);\n    this[fn].splice(t, 1);\n  }\n  [wr]() {\n    return this.hasOwnProperty(\"value\");\n  }\n  [$r](e) {}\n  [qr](e) {}\n  [sr]() {}\n  [Vs](e) {\n    delete this[Fn];\n    if (this[_s]) {\n      e.clean(this[_s]);\n      delete this[_s];\n    }\n  }\n  [br](e) {\n    return this[fn].indexOf(e);\n  }\n  [Fr](e, t) {\n    t[Rn] = this;\n    this[fn].splice(e, 0, t);\n    !t[yr] && this[yr] && (t[yr] = this[yr]);\n  }\n  [Mr]() {\n    return !this.name;\n  }\n  [Hr]() {\n    return \"\";\n  }\n  [en]() {\n    return 0 === this[fn].length ? this[er] : this[fn].map(e => e[en]()).join(\"\");\n  }\n  get [dn]() {\n    const e = Object.getPrototypeOf(this);\n    if (!e._attributes) {\n      const t = e._attributes = new Set();\n      for (const e of Object.getOwnPropertyNames(this)) {\n        if (null === this[e] || this[e] instanceof XFAObject || this[e] instanceof XFAObjectArray) break;\n        t.add(e);\n      }\n    }\n    return shadow(this, dn, e._attributes);\n  }\n  [Nr](e) {\n    let t = this;\n    for (; t;) {\n      if (t === e) return !0;\n      t = t[pr]();\n    }\n    return !1;\n  }\n  [pr]() {\n    return this[Rn];\n  }\n  [fr]() {\n    return this[pr]();\n  }\n  [Er](e = null) {\n    return e ? this[e] : this[fn];\n  }\n  [ir]() {\n    const e = Object.create(null);\n    this[er] && (e.$content = this[er]);\n    for (const t of Object.getOwnPropertyNames(this)) {\n      const i = this[t];\n      null !== i && (i instanceof XFAObject ? e[t] = i[ir]() : i instanceof XFAObjectArray ? i.isEmpty() || (e[t] = i.dump()) : e[t] = i);\n    }\n    return e;\n  }\n  [rn]() {\n    return null;\n  }\n  [an]() {\n    return HTMLResult.EMPTY;\n  }\n  *[ur]() {\n    for (const e of this[Er]()) yield e;\n  }\n  *[wn](e, t) {\n    for (const i of this[ur]()) if (!e || t === e.has(i[Yr])) {\n      const e = this[or](),\n        t = i[an](e);\n      t.success || (this[ar].failingNode = i);\n      yield t;\n    }\n  }\n  [rr]() {\n    return null;\n  }\n  [js](e, t) {\n    this[ar].children.push(e);\n  }\n  [or]() {}\n  [Zs]({\n    filter: e = null,\n    include: t = !0\n  }) {\n    if (this[ar].generator) {\n      const e = this[or](),\n        t = this[ar].failingNode[an](e);\n      if (!t.success) return t;\n      t.html && this[js](t.html, t.bbox);\n      delete this[ar].failingNode;\n    } else this[ar].generator = this[wn](e, t);\n    for (;;) {\n      const e = this[ar].generator.next();\n      if (e.done) break;\n      const t = e.value;\n      if (!t.success) return t;\n      t.html && this[js](t.html, t.bbox);\n    }\n    this[ar].generator = null;\n    return HTMLResult.EMPTY;\n  }\n  [_r](e) {\n    this[Gn] = new Set(Object.keys(e));\n  }\n  [bn](e) {\n    const t = this[dn],\n      i = this[Gn];\n    return [...e].filter(e => t.has(e) && !i.has(e));\n  }\n  [Zr](e, t = new Set()) {\n    for (const i of this[fn]) i[Nn](e, t);\n  }\n  [Nn](e, t) {\n    const i = this[Dn](e, t);\n    i ? this[En](i, e, t) : this[Zr](e, t);\n  }\n  [Dn](e, t) {\n    const {\n      use: i,\n      usehref: a\n    } = this;\n    if (!i && !a) return null;\n    let s = null,\n      r = null,\n      n = null,\n      g = i;\n    if (a) {\n      g = a;\n      a.startsWith(\"#som(\") && a.endsWith(\")\") ? r = a.slice(5, -1) : a.startsWith(\".#som(\") && a.endsWith(\")\") ? r = a.slice(6, -1) : a.startsWith(\"#\") ? n = a.slice(1) : a.startsWith(\".#\") && (n = a.slice(2));\n    } else i.startsWith(\"#\") ? n = i.slice(1) : r = i;\n    this.use = this.usehref = \"\";\n    if (n) s = e.get(n);else {\n      s = searchNode(e.get(Xr), this, r, !0, !1);\n      s && (s = s[0]);\n    }\n    if (!s) {\n      warn(`XFA - Invalid prototype reference: ${g}.`);\n      return null;\n    }\n    if (s[Yr] !== this[Yr]) {\n      warn(`XFA - Incompatible prototype: ${s[Yr]} !== ${this[Yr]}.`);\n      return null;\n    }\n    if (t.has(s)) {\n      warn(\"XFA - Cycle detected in prototypes use.\");\n      return null;\n    }\n    t.add(s);\n    const o = s[Dn](e, t);\n    o && s[En](o, e, t);\n    s[Zr](e, t);\n    t.delete(s);\n    return s;\n  }\n  [En](e, t, i) {\n    if (i.has(e)) {\n      warn(\"XFA - Cycle detected in prototypes use.\");\n      return;\n    }\n    !this[er] && e[er] && (this[er] = e[er]);\n    new Set(i).add(e);\n    for (const t of this[bn](e[Gn])) {\n      this[t] = e[t];\n      this[Gn] && this[Gn].add(t);\n    }\n    for (const a of Object.getOwnPropertyNames(this)) {\n      if (this[dn].has(a)) continue;\n      const s = this[a],\n        r = e[a];\n      if (s instanceof XFAObjectArray) {\n        for (const e of s[fn]) e[Nn](t, i);\n        for (let a = s[fn].length, n = r[fn].length; a < n; a++) {\n          const r = e[fn][a][$s]();\n          if (!s.push(r)) break;\n          r[Rn] = this;\n          this[fn].push(r);\n          r[Nn](t, i);\n        }\n      } else if (null === s) {\n        if (null !== r) {\n          const e = r[$s]();\n          e[Rn] = this;\n          this[a] = e;\n          this[fn].push(e);\n          e[Nn](t, i);\n        }\n      } else {\n        s[Zr](t, i);\n        r && s[En](r, t, i);\n      }\n    }\n  }\n  static [pn](e) {\n    return Array.isArray(e) ? e.map(e => XFAObject[pn](e)) : \"object\" == typeof e && null !== e ? Object.assign({}, e) : e;\n  }\n  [$s]() {\n    const e = Object.create(Object.getPrototypeOf(this));\n    for (const t of Object.getOwnPropertySymbols(this)) try {\n      e[t] = this[t];\n    } catch {\n      shadow(e, t, this[t]);\n    }\n    e[nn] = `${e[Yr]}${Un++}`;\n    e[fn] = [];\n    for (const t of Object.getOwnPropertyNames(this)) {\n      if (this[dn].has(t)) {\n        e[t] = XFAObject[pn](this[t]);\n        continue;\n      }\n      const i = this[t];\n      e[t] = i instanceof XFAObjectArray ? new XFAObjectArray(i[Sn]) : null;\n    }\n    for (const t of this[fn]) {\n      const i = t[Yr],\n        a = t[$s]();\n      e[fn].push(a);\n      a[Rn] = e;\n      null === e[i] ? e[i] = a : e[i][fn].push(a);\n    }\n    return e;\n  }\n  [Er](e = null) {\n    return e ? this[fn].filter(t => t[Yr] === e) : this[fn];\n  }\n  [Ir](e) {\n    return this[e];\n  }\n  [cr](e, t, i = !0) {\n    return Array.from(this[Cr](e, t, i));\n  }\n  *[Cr](e, t, i = !0) {\n    if (\"parent\" !== e) {\n      for (const i of this[fn]) {\n        i[Yr] === e && (yield i);\n        i.name === e && (yield i);\n        (t || i[Mr]()) && (yield* i[Cr](e, t, !1));\n      }\n      i && this[dn].has(e) && (yield new XFAAttribute(this, e, this[e]));\n    } else yield this[Rn];\n  }\n}\nclass XFAObjectArray {\n  constructor(e = 1 / 0) {\n    this[Sn] = e;\n    this[fn] = [];\n  }\n  get isXFAObject() {\n    return !1;\n  }\n  get isXFAObjectArray() {\n    return !0;\n  }\n  push(e) {\n    if (this[fn].length <= this[Sn]) {\n      this[fn].push(e);\n      return !0;\n    }\n    warn(`XFA - node \"${e[Yr]}\" accepts no more than ${this[Sn]} children`);\n    return !1;\n  }\n  isEmpty() {\n    return 0 === this[fn].length;\n  }\n  dump() {\n    return 1 === this[fn].length ? this[fn][0][ir]() : this[fn].map(e => e[ir]());\n  }\n  [$s]() {\n    const e = new XFAObjectArray(this[Sn]);\n    e[fn] = this[fn].map(e => e[$s]());\n    return e;\n  }\n  get children() {\n    return this[fn];\n  }\n  clear() {\n    this[fn].length = 0;\n  }\n}\nclass XFAAttribute {\n  constructor(e, t, i) {\n    this[Rn] = e;\n    this[Yr] = t;\n    this[er] = i;\n    this[Ar] = !1;\n    this[nn] = \"attribute\" + Un++;\n  }\n  [pr]() {\n    return this[Rn];\n  }\n  [Rr]() {\n    return !0;\n  }\n  [hr]() {\n    return this[er].trim();\n  }\n  [$r](e) {\n    e = e.value || \"\";\n    this[er] = e.toString();\n  }\n  [en]() {\n    return this[er];\n  }\n  [Nr](e) {\n    return this[Rn] === e || this[Rn][Nr](e);\n  }\n}\nclass XmlObject extends XFAObject {\n  constructor(e, t, i = {}) {\n    super(e, t);\n    this[er] = \"\";\n    this[mn] = null;\n    if (\"#text\" !== t) {\n      const e = new Map();\n      this[un] = e;\n      for (const [t, a] of Object.entries(i)) e.set(t, new XFAAttribute(this, t, a));\n      if (i.hasOwnProperty(vr)) {\n        const e = i[vr].xfa.dataNode;\n        void 0 !== e && (\"dataGroup\" === e ? this[mn] = !1 : \"dataValue\" === e && (this[mn] = !0));\n      }\n    }\n    this[Ar] = !1;\n  }\n  [sn](e) {\n    const t = this[Yr];\n    if (\"#text\" === t) {\n      e.push(encodeToXmlString(this[er]));\n      return;\n    }\n    const i = utf8StringToString(t),\n      a = this[Jr] === Mn ? \"xfa:\" : \"\";\n    e.push(`<${a}${i}`);\n    for (const [t, i] of this[un].entries()) {\n      const a = utf8StringToString(t);\n      e.push(` ${a}=\"${encodeToXmlString(i[er])}\"`);\n    }\n    null !== this[mn] && (this[mn] ? e.push(' xfa:dataNode=\"dataValue\"') : e.push(' xfa:dataNode=\"dataGroup\"'));\n    if (this[er] || 0 !== this[fn].length) {\n      e.push(\">\");\n      if (this[er]) \"string\" == typeof this[er] ? e.push(encodeToXmlString(this[er])) : this[er][sn](e);else for (const t of this[fn]) t[sn](e);\n      e.push(`</${a}${i}>`);\n    } else e.push(\"/>\");\n  }\n  [Kr](e) {\n    if (this[er]) {\n      const e = new XmlObject(this[Jr], \"#text\");\n      this[Xs](e);\n      e[er] = this[er];\n      this[er] = \"\";\n    }\n    this[Xs](e);\n    return !0;\n  }\n  [qr](e) {\n    this[er] += e;\n  }\n  [sr]() {\n    if (this[er] && this[fn].length > 0) {\n      const e = new XmlObject(this[Jr], \"#text\");\n      this[Xs](e);\n      e[er] = this[er];\n      delete this[er];\n    }\n  }\n  [an]() {\n    return \"#text\" === this[Yr] ? HTMLResult.success({\n      name: \"#text\",\n      value: this[er]\n    }) : HTMLResult.EMPTY;\n  }\n  [Er](e = null) {\n    return e ? this[fn].filter(t => t[Yr] === e) : this[fn];\n  }\n  [gr]() {\n    return this[un];\n  }\n  [Ir](e) {\n    const t = this[un].get(e);\n    return void 0 !== t ? t : this[Er](e);\n  }\n  *[Cr](e, t) {\n    const i = this[un].get(e);\n    i && (yield i);\n    for (const i of this[fn]) {\n      i[Yr] === e && (yield i);\n      t && (yield* i[Cr](e, t));\n    }\n  }\n  *[nr](e, t) {\n    const i = this[un].get(e);\n    !i || t && i[Ar] || (yield i);\n    for (const i of this[fn]) yield* i[nr](e, t);\n  }\n  *[Qr](e, t, i) {\n    for (const a of this[fn]) {\n      a[Yr] !== e || i && a[Ar] || (yield a);\n      t && (yield* a[Qr](e, t, i));\n    }\n  }\n  [Rr]() {\n    return null === this[mn] ? 0 === this[fn].length || this[fn][0][Jr] === on.xhtml.id : this[mn];\n  }\n  [hr]() {\n    return null === this[mn] ? 0 === this[fn].length ? this[er].trim() : this[fn][0][Jr] === on.xhtml.id ? this[fn][0][en]().trim() : null : this[er].trim();\n  }\n  [$r](e) {\n    e = e.value || \"\";\n    this[er] = e.toString();\n  }\n  [ir](e = !1) {\n    const t = Object.create(null);\n    e && (t.$ns = this[Jr]);\n    this[er] && (t.$content = this[er]);\n    t.$name = this[Yr];\n    t.children = [];\n    for (const i of this[fn]) t.children.push(i[ir](e));\n    t.attributes = Object.create(null);\n    for (const [e, i] of this[un]) t.attributes[e] = i[er];\n    return t;\n  }\n}\nclass ContentObject extends XFAObject {\n  constructor(e, t) {\n    super(e, t);\n    this[er] = \"\";\n  }\n  [qr](e) {\n    this[er] += e;\n  }\n  [sr]() {}\n}\nclass OptionObject extends ContentObject {\n  constructor(e, t, i) {\n    super(e, t);\n    this[kn] = i;\n  }\n  [sr]() {\n    this[er] = getKeyword({\n      data: this[er],\n      defaultValue: this[kn][0],\n      validate: e => this[kn].includes(e)\n    });\n  }\n  [Vs](e) {\n    super[Vs](e);\n    delete this[kn];\n  }\n}\nclass StringObject extends ContentObject {\n  [sr]() {\n    this[er] = this[er].trim();\n  }\n}\nclass IntegerObject extends ContentObject {\n  constructor(e, t, i, a) {\n    super(e, t);\n    this[yn] = i;\n    this[xn] = a;\n  }\n  [sr]() {\n    this[er] = getInteger({\n      data: this[er],\n      defaultValue: this[yn],\n      validate: this[xn]\n    });\n  }\n  [Vs](e) {\n    super[Vs](e);\n    delete this[yn];\n    delete this[xn];\n  }\n}\nclass Option01 extends IntegerObject {\n  constructor(e, t) {\n    super(e, t, 0, e => 1 === e);\n  }\n}\nclass Option10 extends IntegerObject {\n  constructor(e, t) {\n    super(e, t, 1, e => 0 === e);\n  }\n}\nfunction measureToString(e) {\n  return \"string\" == typeof e ? \"0px\" : Number.isInteger(e) ? `${e}px` : `${e.toFixed(2)}px`;\n}\nconst Ln = {\n  anchorType(e, t) {\n    const i = e[fr]();\n    if (i && (!i.layout || \"position\" === i.layout)) {\n      \"transform\" in t || (t.transform = \"\");\n      switch (e.anchorType) {\n        case \"bottomCenter\":\n          t.transform += \"translate(-50%, -100%)\";\n          break;\n        case \"bottomLeft\":\n          t.transform += \"translate(0,-100%)\";\n          break;\n        case \"bottomRight\":\n          t.transform += \"translate(-100%,-100%)\";\n          break;\n        case \"middleCenter\":\n          t.transform += \"translate(-50%,-50%)\";\n          break;\n        case \"middleLeft\":\n          t.transform += \"translate(0,-50%)\";\n          break;\n        case \"middleRight\":\n          t.transform += \"translate(-100%,-50%)\";\n          break;\n        case \"topCenter\":\n          t.transform += \"translate(-50%,0)\";\n          break;\n        case \"topRight\":\n          t.transform += \"translate(-100%,0)\";\n      }\n    }\n  },\n  dimensions(e, t) {\n    const i = e[fr]();\n    let a = e.w;\n    const s = e.h;\n    if (i.layout?.includes(\"row\")) {\n      const t = i[ar],\n        s = e.colSpan;\n      let r;\n      if (-1 === s) {\n        r = t.columnWidths.slice(t.currentColumn).reduce((e, t) => e + t, 0);\n        t.currentColumn = 0;\n      } else {\n        r = t.columnWidths.slice(t.currentColumn, t.currentColumn + s).reduce((e, t) => e + t, 0);\n        t.currentColumn = (t.currentColumn + e.colSpan) % t.columnWidths.length;\n      }\n      isNaN(r) || (a = e.w = r);\n    }\n    t.width = \"\" !== a ? measureToString(a) : \"auto\";\n    t.height = \"\" !== s ? measureToString(s) : \"auto\";\n  },\n  position(e, t) {\n    const i = e[fr]();\n    if (!i?.layout || \"position\" === i.layout) {\n      t.position = \"absolute\";\n      t.left = measureToString(e.x);\n      t.top = measureToString(e.y);\n    }\n  },\n  rotate(e, t) {\n    if (e.rotate) {\n      \"transform\" in t || (t.transform = \"\");\n      t.transform += `rotate(-${e.rotate}deg)`;\n      t.transformOrigin = \"top left\";\n    }\n  },\n  presence(e, t) {\n    switch (e.presence) {\n      case \"invisible\":\n        t.visibility = \"hidden\";\n        break;\n      case \"hidden\":\n      case \"inactive\":\n        t.display = \"none\";\n    }\n  },\n  hAlign(e, t) {\n    if (\"para\" === e[Yr]) switch (e.hAlign) {\n      case \"justifyAll\":\n        t.textAlign = \"justify-all\";\n        break;\n      case \"radix\":\n        t.textAlign = \"left\";\n        break;\n      default:\n        t.textAlign = e.hAlign;\n    } else switch (e.hAlign) {\n      case \"left\":\n        t.alignSelf = \"start\";\n        break;\n      case \"center\":\n        t.alignSelf = \"center\";\n        break;\n      case \"right\":\n        t.alignSelf = \"end\";\n    }\n  },\n  margin(e, t) {\n    e.margin && (t.margin = e.margin[rn]().margin);\n  }\n};\nfunction setMinMaxDimensions(e, t) {\n  if (\"position\" === e[fr]().layout) {\n    e.minW > 0 && (t.minWidth = measureToString(e.minW));\n    e.maxW > 0 && (t.maxWidth = measureToString(e.maxW));\n    e.minH > 0 && (t.minHeight = measureToString(e.minH));\n    e.maxH > 0 && (t.maxHeight = measureToString(e.maxH));\n  }\n}\nfunction layoutText(e, t, i, a, s, r) {\n  const n = new TextMeasure(t, i, a, s);\n  \"string\" == typeof e ? n.addString(e) : e[Or](n);\n  return n.compute(r);\n}\nfunction layoutNode(e, t) {\n  let i = null,\n    a = null,\n    s = !1;\n  if ((!e.w || !e.h) && e.value) {\n    let r = 0,\n      n = 0;\n    if (e.margin) {\n      r = e.margin.leftInset + e.margin.rightInset;\n      n = e.margin.topInset + e.margin.bottomInset;\n    }\n    let g = null,\n      o = null;\n    if (e.para) {\n      o = Object.create(null);\n      g = \"\" === e.para.lineHeight ? null : e.para.lineHeight;\n      o.top = \"\" === e.para.spaceAbove ? 0 : e.para.spaceAbove;\n      o.bottom = \"\" === e.para.spaceBelow ? 0 : e.para.spaceBelow;\n      o.left = \"\" === e.para.marginLeft ? 0 : e.para.marginLeft;\n      o.right = \"\" === e.para.marginRight ? 0 : e.para.marginRight;\n    }\n    let c = e.font;\n    if (!c) {\n      const t = e[mr]();\n      let i = e[pr]();\n      for (; i && i !== t;) {\n        if (i.font) {\n          c = i.font;\n          break;\n        }\n        i = i[pr]();\n      }\n    }\n    const C = (e.w || t.width) - r,\n      h = e[yr].fontFinder;\n    if (e.value.exData && e.value.exData[er] && \"text/html\" === e.value.exData.contentType) {\n      const t = layoutText(e.value.exData[er], c, o, g, h, C);\n      a = t.width;\n      i = t.height;\n      s = t.isBroken;\n    } else {\n      const t = e.value[en]();\n      if (t) {\n        const e = layoutText(t, c, o, g, h, C);\n        a = e.width;\n        i = e.height;\n        s = e.isBroken;\n      }\n    }\n    null === a || e.w || (a += r);\n    null === i || e.h || (i += n);\n  }\n  return {\n    w: a,\n    h: i,\n    isBroken: s\n  };\n}\nfunction computeBbox(e, t, i) {\n  let a;\n  if (\"\" !== e.w && \"\" !== e.h) a = [e.x, e.y, e.w, e.h];else {\n    if (!i) return null;\n    let s = e.w;\n    if (\"\" === s) {\n      if (0 === e.maxW) {\n        const t = e[fr]();\n        s = \"position\" === t.layout && \"\" !== t.w ? 0 : e.minW;\n      } else s = Math.min(e.maxW, i.width);\n      t.attributes.style.width = measureToString(s);\n    }\n    let r = e.h;\n    if (\"\" === r) {\n      if (0 === e.maxH) {\n        const t = e[fr]();\n        r = \"position\" === t.layout && \"\" !== t.h ? 0 : e.minH;\n      } else r = Math.min(e.maxH, i.height);\n      t.attributes.style.height = measureToString(r);\n    }\n    a = [e.x, e.y, s, r];\n  }\n  return a;\n}\nfunction fixDimensions(e) {\n  const t = e[fr]();\n  if (t.layout?.includes(\"row\")) {\n    const i = t[ar],\n      a = e.colSpan;\n    let s;\n    s = -1 === a ? i.columnWidths.slice(i.currentColumn).reduce((e, t) => e + t, 0) : i.columnWidths.slice(i.currentColumn, i.currentColumn + a).reduce((e, t) => e + t, 0);\n    isNaN(s) || (e.w = s);\n  }\n  t.layout && \"position\" !== t.layout && (e.x = e.y = 0);\n  \"table\" === e.layout && \"\" === e.w && Array.isArray(e.columnWidths) && (e.w = e.columnWidths.reduce((e, t) => e + t, 0));\n}\nfunction layoutClass(e) {\n  switch (e.layout) {\n    case \"position\":\n    default:\n      return \"xfaPosition\";\n    case \"lr-tb\":\n      return \"xfaLrTb\";\n    case \"rl-row\":\n      return \"xfaRlRow\";\n    case \"rl-tb\":\n      return \"xfaRlTb\";\n    case \"row\":\n      return \"xfaRow\";\n    case \"table\":\n      return \"xfaTable\";\n    case \"tb\":\n      return \"xfaTb\";\n  }\n}\nfunction toStyle(e, ...t) {\n  const i = Object.create(null);\n  for (const a of t) {\n    const t = e[a];\n    if (null !== t) if (Ln.hasOwnProperty(a)) Ln[a](e, i);else if (t instanceof XFAObject) {\n      const e = t[rn]();\n      e ? Object.assign(i, e) : warn(`(DEBUG) - XFA - style for ${a} not implemented yet`);\n    }\n  }\n  return i;\n}\nfunction createWrapper(e, t) {\n  const {\n      attributes: i\n    } = t,\n    {\n      style: a\n    } = i,\n    s = {\n      name: \"div\",\n      attributes: {\n        class: [\"xfaWrapper\"],\n        style: Object.create(null)\n      },\n      children: []\n    };\n  i.class.push(\"xfaWrapped\");\n  if (e.border) {\n    const {\n      widths: i,\n      insets: r\n    } = e.border[ar];\n    let n,\n      g,\n      o = r[0],\n      c = r[3];\n    const C = r[0] + r[2],\n      h = r[1] + r[3];\n    switch (e.border.hand) {\n      case \"even\":\n        o -= i[0] / 2;\n        c -= i[3] / 2;\n        n = `calc(100% + ${(i[1] + i[3]) / 2 - h}px)`;\n        g = `calc(100% + ${(i[0] + i[2]) / 2 - C}px)`;\n        break;\n      case \"left\":\n        o -= i[0];\n        c -= i[3];\n        n = `calc(100% + ${i[1] + i[3] - h}px)`;\n        g = `calc(100% + ${i[0] + i[2] - C}px)`;\n        break;\n      case \"right\":\n        n = h ? `calc(100% - ${h}px)` : \"100%\";\n        g = C ? `calc(100% - ${C}px)` : \"100%\";\n    }\n    const l = [\"xfaBorder\"];\n    isPrintOnly(e.border) && l.push(\"xfaPrintOnly\");\n    const Q = {\n      name: \"div\",\n      attributes: {\n        class: l,\n        style: {\n          top: `${o}px`,\n          left: `${c}px`,\n          width: n,\n          height: g\n        }\n      },\n      children: []\n    };\n    for (const e of [\"border\", \"borderWidth\", \"borderColor\", \"borderRadius\", \"borderStyle\"]) if (void 0 !== a[e]) {\n      Q.attributes.style[e] = a[e];\n      delete a[e];\n    }\n    s.children.push(Q, t);\n  } else s.children.push(t);\n  for (const e of [\"background\", \"backgroundClip\", \"top\", \"left\", \"width\", \"height\", \"minWidth\", \"minHeight\", \"maxWidth\", \"maxHeight\", \"transform\", \"transformOrigin\", \"visibility\"]) if (void 0 !== a[e]) {\n    s.attributes.style[e] = a[e];\n    delete a[e];\n  }\n  s.attributes.style.position = \"absolute\" === a.position ? \"absolute\" : \"relative\";\n  delete a.position;\n  if (a.alignSelf) {\n    s.attributes.style.alignSelf = a.alignSelf;\n    delete a.alignSelf;\n  }\n  return s;\n}\nfunction fixTextIndent(e) {\n  const t = getMeasurement(e.textIndent, \"0px\");\n  if (t >= 0) return;\n  const i = \"padding\" + (\"left\" === (\"right\" === e.textAlign ? \"right\" : \"left\") ? \"Left\" : \"Right\"),\n    a = getMeasurement(e[i], \"0px\");\n  e[i] = a - t + \"px\";\n}\nfunction setAccess(e, t) {\n  switch (e.access) {\n    case \"nonInteractive\":\n      t.push(\"xfaNonInteractive\");\n      break;\n    case \"readOnly\":\n      t.push(\"xfaReadOnly\");\n      break;\n    case \"protected\":\n      t.push(\"xfaDisabled\");\n  }\n}\nfunction isPrintOnly(e) {\n  return e.relevant.length > 0 && !e.relevant[0].excluded && \"print\" === e.relevant[0].viewname;\n}\nfunction getCurrentPara(e) {\n  const t = e[mr]()[ar].paraStack;\n  return t.length ? t.at(-1) : null;\n}\nfunction setPara(e, t, i) {\n  if (i.attributes.class?.includes(\"xfaRich\")) {\n    if (t) {\n      \"\" === e.h && (t.height = \"auto\");\n      \"\" === e.w && (t.width = \"auto\");\n    }\n    const a = getCurrentPara(e);\n    if (a) {\n      const e = i.attributes.style;\n      e.display = \"flex\";\n      e.flexDirection = \"column\";\n      switch (a.vAlign) {\n        case \"top\":\n          e.justifyContent = \"start\";\n          break;\n        case \"bottom\":\n          e.justifyContent = \"end\";\n          break;\n        case \"middle\":\n          e.justifyContent = \"center\";\n      }\n      const t = a[rn]();\n      for (const [i, a] of Object.entries(t)) i in e || (e[i] = a);\n    }\n  }\n}\nfunction setFontFamily(e, t, i, a) {\n  if (!i) {\n    delete a.fontFamily;\n    return;\n  }\n  const s = stripQuotes(e.typeface);\n  a.fontFamily = `\"${s}\"`;\n  const r = i.find(s);\n  if (r) {\n    const {\n      fontFamily: i\n    } = r.regular.cssFontInfo;\n    i !== s && (a.fontFamily = `\"${i}\"`);\n    const n = getCurrentPara(t);\n    if (n && \"\" !== n.lineHeight) return;\n    if (a.lineHeight) return;\n    const g = selectFont(e, r);\n    g && (a.lineHeight = Math.max(1.2, g.lineHeight));\n  }\n}\nfunction fixURL(e) {\n  const t = createValidAbsoluteUrl(e, null, {\n    addDefaultProtocol: !0,\n    tryConvertEncoding: !0\n  });\n  return t ? t.href : null;\n}\nfunction createLine(e, t) {\n  return {\n    name: \"div\",\n    attributes: {\n      class: [\"lr-tb\" === e.layout ? \"xfaLr\" : \"xfaRl\"]\n    },\n    children: t\n  };\n}\nfunction flushHTML(e) {\n  if (!e[ar]) return null;\n  const t = {\n    name: \"div\",\n    attributes: e[ar].attributes,\n    children: e[ar].children\n  };\n  if (e[ar].failingNode) {\n    const i = e[ar].failingNode[rr]();\n    i && (e.layout.endsWith(\"-tb\") ? t.children.push(createLine(e, [i])) : t.children.push(i));\n  }\n  return 0 === t.children.length ? null : t;\n}\nfunction addHTML(e, t, i) {\n  const a = e[ar],\n    s = a.availableSpace,\n    [r, n, g, o] = i;\n  switch (e.layout) {\n    case \"position\":\n      a.width = Math.max(a.width, r + g);\n      a.height = Math.max(a.height, n + o);\n      a.children.push(t);\n      break;\n    case \"lr-tb\":\n    case \"rl-tb\":\n      if (!a.line || 1 === a.attempt) {\n        a.line = createLine(e, []);\n        a.children.push(a.line);\n        a.numberInLine = 0;\n      }\n      a.numberInLine += 1;\n      a.line.children.push(t);\n      if (0 === a.attempt) {\n        a.currentWidth += g;\n        a.height = Math.max(a.height, a.prevHeight + o);\n      } else {\n        a.currentWidth = g;\n        a.prevHeight = a.height;\n        a.height += o;\n        a.attempt = 0;\n      }\n      a.width = Math.max(a.width, a.currentWidth);\n      break;\n    case \"rl-row\":\n    case \"row\":\n      {\n        a.children.push(t);\n        a.width += g;\n        a.height = Math.max(a.height, o);\n        const e = measureToString(a.height);\n        for (const t of a.children) t.attributes.style.height = e;\n        break;\n      }\n    case \"table\":\n    case \"tb\":\n      a.width = Math.min(s.width, Math.max(a.width, g));\n      a.height += o;\n      a.children.push(t);\n  }\n}\nfunction getAvailableSpace(e) {\n  const t = e[ar].availableSpace,\n    i = e.margin ? e.margin.topInset + e.margin.bottomInset : 0,\n    a = e.margin ? e.margin.leftInset + e.margin.rightInset : 0;\n  switch (e.layout) {\n    case \"lr-tb\":\n    case \"rl-tb\":\n      return 0 === e[ar].attempt ? {\n        width: t.width - a - e[ar].currentWidth,\n        height: t.height - i - e[ar].prevHeight\n      } : {\n        width: t.width - a,\n        height: t.height - i - e[ar].height\n      };\n    case \"rl-row\":\n    case \"row\":\n      return {\n        width: e[ar].columnWidths.slice(e[ar].currentColumn).reduce((e, t) => e + t),\n        height: t.height - a\n      };\n    case \"table\":\n    case \"tb\":\n      return {\n        width: t.width - a,\n        height: t.height - i - e[ar].height\n      };\n    default:\n      return t;\n  }\n}\nfunction checkDimensions(e, t) {\n  if (null === e[mr]()[ar].firstUnsplittable) return !0;\n  if (0 === e.w || 0 === e.h) return !0;\n  const i = e[fr](),\n    a = i[ar]?.attempt || 0,\n    [, s, r, n] = function getTransformedBBox(e) {\n      let t,\n        i,\n        a = \"\" === e.w ? NaN : e.w,\n        s = \"\" === e.h ? NaN : e.h,\n        [r, n] = [0, 0];\n      switch (e.anchorType || \"\") {\n        case \"bottomCenter\":\n          [r, n] = [a / 2, s];\n          break;\n        case \"bottomLeft\":\n          [r, n] = [0, s];\n          break;\n        case \"bottomRight\":\n          [r, n] = [a, s];\n          break;\n        case \"middleCenter\":\n          [r, n] = [a / 2, s / 2];\n          break;\n        case \"middleLeft\":\n          [r, n] = [0, s / 2];\n          break;\n        case \"middleRight\":\n          [r, n] = [a, s / 2];\n          break;\n        case \"topCenter\":\n          [r, n] = [a / 2, 0];\n          break;\n        case \"topRight\":\n          [r, n] = [a, 0];\n      }\n      switch (e.rotate || 0) {\n        case 0:\n          [t, i] = [-r, -n];\n          break;\n        case 90:\n          [t, i] = [-n, r];\n          [a, s] = [s, -a];\n          break;\n        case 180:\n          [t, i] = [r, n];\n          [a, s] = [-a, -s];\n          break;\n        case 270:\n          [t, i] = [n, -r];\n          [a, s] = [-s, a];\n      }\n      return [e.x + t + Math.min(0, a), e.y + i + Math.min(0, s), Math.abs(a), Math.abs(s)];\n    }(e);\n  switch (i.layout) {\n    case \"lr-tb\":\n    case \"rl-tb\":\n      return 0 === a ? e[mr]()[ar].noLayoutFailure ? \"\" !== e.w ? Math.round(r - t.width) <= 2 : t.width > 2 : !(\"\" !== e.h && Math.round(n - t.height) > 2) && (\"\" !== e.w ? Math.round(r - t.width) <= 2 || 0 === i[ar].numberInLine && t.height > 2 : t.width > 2) : !!e[mr]()[ar].noLayoutFailure || !(\"\" !== e.h && Math.round(n - t.height) > 2) && (\"\" === e.w || Math.round(r - t.width) <= 2 || !i[Ur]()) && t.height > 2;\n    case \"table\":\n    case \"tb\":\n      return !!e[mr]()[ar].noLayoutFailure || (\"\" === e.h || e[xr]() ? (\"\" === e.w || Math.round(r - t.width) <= 2 || !i[Ur]()) && t.height > 2 : Math.round(n - t.height) <= 2);\n    case \"position\":\n      if (e[mr]()[ar].noLayoutFailure) return !0;\n      if (\"\" === e.h || Math.round(n + s - t.height) <= 2) return !0;\n      return n + s > e[mr]()[ar].currentContentArea.h;\n    case \"rl-row\":\n    case \"row\":\n      return !!e[mr]()[ar].noLayoutFailure || \"\" === e.h || Math.round(n - t.height) <= 2;\n    default:\n      return !0;\n  }\n}\nconst Hn = on.template.id,\n  Jn = \"http://www.w3.org/2000/svg\",\n  Yn = /^H(\\d+)$/,\n  vn = new Set([\"image/gif\", \"image/jpeg\", \"image/jpg\", \"image/pjpeg\", \"image/png\", \"image/apng\", \"image/x-png\", \"image/bmp\", \"image/x-ms-bmp\", \"image/tiff\", \"image/tif\", \"application/octet-stream\"]),\n  Kn = [[[66, 77], \"image/bmp\"], [[255, 216, 255], \"image/jpeg\"], [[73, 73, 42, 0], \"image/tiff\"], [[77, 77, 0, 42], \"image/tiff\"], [[71, 73, 70, 56, 57, 97], \"image/gif\"], [[137, 80, 78, 71, 13, 10, 26, 10], \"image/png\"]];\nfunction getBorderDims(e) {\n  if (!e || !e.border) return {\n    w: 0,\n    h: 0\n  };\n  const t = e.border[lr]();\n  return t ? {\n    w: t.widths[0] + t.widths[2] + t.insets[0] + t.insets[2],\n    h: t.widths[1] + t.widths[3] + t.insets[1] + t.insets[3]\n  } : {\n    w: 0,\n    h: 0\n  };\n}\nfunction hasMargin(e) {\n  return e.margin && (e.margin.topInset || e.margin.rightInset || e.margin.bottomInset || e.margin.leftInset);\n}\nfunction _setValue(e, t) {\n  if (!e.value) {\n    const t = new Value({});\n    e[Xs](t);\n    e.value = t;\n  }\n  e.value[$r](t);\n}\nfunction* getContainedChildren(e) {\n  for (const t of e[Er]()) t instanceof SubformSet ? yield* t[ur]() : yield t;\n}\nfunction isRequired(e) {\n  return \"error\" === e.validate?.nullTest;\n}\nfunction setTabIndex(e) {\n  for (; e;) {\n    if (!e.traversal) {\n      e[An] = e[pr]()[An];\n      return;\n    }\n    if (e[An]) return;\n    let t = null;\n    for (const i of e.traversal[Er]()) if (\"next\" === i.operation) {\n      t = i;\n      break;\n    }\n    if (!t || !t.ref) {\n      e[An] = e[pr]()[An];\n      return;\n    }\n    const i = e[mr]();\n    e[An] = ++i[An];\n    const a = i[Vr](t.ref, e);\n    if (!a) return;\n    e = a[0];\n  }\n}\nfunction applyAssist(e, t) {\n  const i = e.assist;\n  if (i) {\n    const e = i[an]();\n    e && (t.title = e);\n    const a = i.role.match(Yn);\n    if (a) {\n      const e = \"heading\",\n        i = a[1];\n      t.role = e;\n      t[\"aria-level\"] = i;\n    }\n  }\n  if (\"table\" === e.layout) t.role = \"table\";else if (\"row\" === e.layout) t.role = \"row\";else {\n    const i = e[pr]();\n    \"row\" === i.layout && (t.role = \"TH\" === i.assist?.role ? \"columnheader\" : \"cell\");\n  }\n}\nfunction ariaLabel(e) {\n  if (!e.assist) return null;\n  const t = e.assist;\n  return t.speak && \"\" !== t.speak[er] ? t.speak[er] : t.toolTip ? t.toolTip[er] : null;\n}\nfunction valueToHtml(e) {\n  return HTMLResult.success({\n    name: \"div\",\n    attributes: {\n      class: [\"xfaRich\"],\n      style: Object.create(null)\n    },\n    children: [{\n      name: \"span\",\n      attributes: {\n        style: Object.create(null)\n      },\n      value: e\n    }]\n  });\n}\nfunction setFirstUnsplittable(e) {\n  const t = e[mr]();\n  if (null === t[ar].firstUnsplittable) {\n    t[ar].firstUnsplittable = e;\n    t[ar].noLayoutFailure = !0;\n  }\n}\nfunction unsetFirstUnsplittable(e) {\n  const t = e[mr]();\n  t[ar].firstUnsplittable === e && (t[ar].noLayoutFailure = !1);\n}\nfunction handleBreak(e) {\n  if (e[ar]) return !1;\n  e[ar] = Object.create(null);\n  if (\"auto\" === e.targetType) return !1;\n  const t = e[mr]();\n  let i = null;\n  if (e.target) {\n    i = t[Vr](e.target, e[pr]());\n    if (!i) return !1;\n    i = i[0];\n  }\n  const {\n    currentPageArea: a,\n    currentContentArea: s\n  } = t[ar];\n  if (\"pageArea\" === e.targetType) {\n    i instanceof PageArea || (i = null);\n    if (e.startNew) {\n      e[ar].target = i || a;\n      return !0;\n    }\n    if (i && i !== a) {\n      e[ar].target = i;\n      return !0;\n    }\n    return !1;\n  }\n  i instanceof ContentArea || (i = null);\n  const r = i && i[pr]();\n  let n,\n    g = r;\n  if (e.startNew) {\n    if (i) {\n      const e = r.contentArea.children,\n        t = e.indexOf(s),\n        a = e.indexOf(i);\n      -1 !== t && t < a && (g = null);\n      n = a - 1;\n    } else n = a.contentArea.children.indexOf(s);\n  } else {\n    if (!i || i === s) return !1;\n    n = r.contentArea.children.indexOf(i) - 1;\n    g = r === a ? null : r;\n  }\n  e[ar].target = g;\n  e[ar].index = n;\n  return !0;\n}\nfunction handleOverflow(e, t, i) {\n  const a = e[mr](),\n    s = a[ar].noLayoutFailure,\n    r = t[fr];\n  t[fr] = () => e;\n  a[ar].noLayoutFailure = !0;\n  const n = t[an](i);\n  e[js](n.html, n.bbox);\n  a[ar].noLayoutFailure = s;\n  t[fr] = r;\n}\nclass AppearanceFilter extends StringObject {\n  constructor(e) {\n    super(Hn, \"appearanceFilter\");\n    this.id = e.id || \"\";\n    this.type = getStringOption(e.type, [\"optional\", \"required\"]);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n}\nclass Arc extends XFAObject {\n  constructor(e) {\n    super(Hn, \"arc\", !0);\n    this.circular = getInteger({\n      data: e.circular,\n      defaultValue: 0,\n      validate: e => 1 === e\n    });\n    this.hand = getStringOption(e.hand, [\"even\", \"left\", \"right\"]);\n    this.id = e.id || \"\";\n    this.startAngle = getFloat({\n      data: e.startAngle,\n      defaultValue: 0,\n      validate: e => !0\n    });\n    this.sweepAngle = getFloat({\n      data: e.sweepAngle,\n      defaultValue: 360,\n      validate: e => !0\n    });\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.edge = null;\n    this.fill = null;\n  }\n  [an]() {\n    const e = this.edge || new Edge({}),\n      t = e[rn](),\n      i = Object.create(null);\n    \"visible\" === this.fill?.presence ? Object.assign(i, this.fill[rn]()) : i.fill = \"transparent\";\n    i.strokeWidth = measureToString(\"visible\" === e.presence ? e.thickness : 0);\n    i.stroke = t.color;\n    let a;\n    const s = {\n      xmlns: Jn,\n      style: {\n        width: \"100%\",\n        height: \"100%\",\n        overflow: \"visible\"\n      }\n    };\n    if (360 === this.sweepAngle) a = {\n      name: \"ellipse\",\n      attributes: {\n        xmlns: Jn,\n        cx: \"50%\",\n        cy: \"50%\",\n        rx: \"50%\",\n        ry: \"50%\",\n        style: i\n      }\n    };else {\n      const e = this.startAngle * Math.PI / 180,\n        t = this.sweepAngle * Math.PI / 180,\n        r = this.sweepAngle > 180 ? 1 : 0,\n        [n, g, o, c] = [50 * (1 + Math.cos(e)), 50 * (1 - Math.sin(e)), 50 * (1 + Math.cos(e + t)), 50 * (1 - Math.sin(e + t))];\n      a = {\n        name: \"path\",\n        attributes: {\n          xmlns: Jn,\n          d: `M ${n} ${g} A 50 50 0 ${r} 0 ${o} ${c}`,\n          vectorEffect: \"non-scaling-stroke\",\n          style: i\n        }\n      };\n      Object.assign(s, {\n        viewBox: \"0 0 100 100\",\n        preserveAspectRatio: \"none\"\n      });\n    }\n    const r = {\n      name: \"svg\",\n      children: [a],\n      attributes: s\n    };\n    if (hasMargin(this[pr]()[pr]())) return HTMLResult.success({\n      name: \"div\",\n      attributes: {\n        style: {\n          display: \"inline\",\n          width: \"100%\",\n          height: \"100%\"\n        }\n      },\n      children: [r]\n    });\n    r.attributes.style.position = \"absolute\";\n    return HTMLResult.success(r);\n  }\n}\nclass Area extends XFAObject {\n  constructor(e) {\n    super(Hn, \"area\", !0);\n    this.colSpan = getInteger({\n      data: e.colSpan,\n      defaultValue: 1,\n      validate: e => e >= 1 || -1 === e\n    });\n    this.id = e.id || \"\";\n    this.name = e.name || \"\";\n    this.relevant = getRelevant(e.relevant);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.x = getMeasurement(e.x, \"0pt\");\n    this.y = getMeasurement(e.y, \"0pt\");\n    this.desc = null;\n    this.extras = null;\n    this.area = new XFAObjectArray();\n    this.draw = new XFAObjectArray();\n    this.exObject = new XFAObjectArray();\n    this.exclGroup = new XFAObjectArray();\n    this.field = new XFAObjectArray();\n    this.subform = new XFAObjectArray();\n    this.subformSet = new XFAObjectArray();\n  }\n  *[ur]() {\n    yield* getContainedChildren(this);\n  }\n  [Mr]() {\n    return !0;\n  }\n  [kr]() {\n    return !0;\n  }\n  [js](e, t) {\n    const [i, a, s, r] = t;\n    this[ar].width = Math.max(this[ar].width, i + s);\n    this[ar].height = Math.max(this[ar].height, a + r);\n    this[ar].children.push(e);\n  }\n  [or]() {\n    return this[ar].availableSpace;\n  }\n  [an](e) {\n    const t = toStyle(this, \"position\"),\n      i = {\n        style: t,\n        id: this[nn],\n        class: [\"xfaArea\"]\n      };\n    isPrintOnly(this) && i.class.push(\"xfaPrintOnly\");\n    this.name && (i.xfaName = this.name);\n    const a = [];\n    this[ar] = {\n      children: a,\n      width: 0,\n      height: 0,\n      availableSpace: e\n    };\n    const s = this[Zs]({\n      filter: new Set([\"area\", \"draw\", \"field\", \"exclGroup\", \"subform\", \"subformSet\"]),\n      include: !0\n    });\n    if (!s.success) {\n      if (s.isBreak()) return s;\n      delete this[ar];\n      return HTMLResult.FAILURE;\n    }\n    t.width = measureToString(this[ar].width);\n    t.height = measureToString(this[ar].height);\n    const r = {\n        name: \"div\",\n        attributes: i,\n        children: a\n      },\n      n = [this.x, this.y, this[ar].width, this[ar].height];\n    delete this[ar];\n    return HTMLResult.success(r, n);\n  }\n}\nclass Assist extends XFAObject {\n  constructor(e) {\n    super(Hn, \"assist\", !0);\n    this.id = e.id || \"\";\n    this.role = e.role || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.speak = null;\n    this.toolTip = null;\n  }\n  [an]() {\n    return this.toolTip?.[er] || null;\n  }\n}\nclass Barcode extends XFAObject {\n  constructor(e) {\n    super(Hn, \"barcode\", !0);\n    this.charEncoding = getKeyword({\n      data: e.charEncoding ? e.charEncoding.toLowerCase() : \"\",\n      defaultValue: \"\",\n      validate: e => [\"utf-8\", \"big-five\", \"fontspecific\", \"gbk\", \"gb-18030\", \"gb-2312\", \"ksc-5601\", \"none\", \"shift-jis\", \"ucs-2\", \"utf-16\"].includes(e) || e.match(/iso-8859-\\d{2}/)\n    });\n    this.checksum = getStringOption(e.checksum, [\"none\", \"1mod10\", \"1mod10_1mod11\", \"2mod10\", \"auto\"]);\n    this.dataColumnCount = getInteger({\n      data: e.dataColumnCount,\n      defaultValue: -1,\n      validate: e => e >= 0\n    });\n    this.dataLength = getInteger({\n      data: e.dataLength,\n      defaultValue: -1,\n      validate: e => e >= 0\n    });\n    this.dataPrep = getStringOption(e.dataPrep, [\"none\", \"flateCompress\"]);\n    this.dataRowCount = getInteger({\n      data: e.dataRowCount,\n      defaultValue: -1,\n      validate: e => e >= 0\n    });\n    this.endChar = e.endChar || \"\";\n    this.errorCorrectionLevel = getInteger({\n      data: e.errorCorrectionLevel,\n      defaultValue: -1,\n      validate: e => e >= 0 && e <= 8\n    });\n    this.id = e.id || \"\";\n    this.moduleHeight = getMeasurement(e.moduleHeight, \"5mm\");\n    this.moduleWidth = getMeasurement(e.moduleWidth, \"0.25mm\");\n    this.printCheckDigit = getInteger({\n      data: e.printCheckDigit,\n      defaultValue: 0,\n      validate: e => 1 === e\n    });\n    this.rowColumnRatio = getRatio(e.rowColumnRatio);\n    this.startChar = e.startChar || \"\";\n    this.textLocation = getStringOption(e.textLocation, [\"below\", \"above\", \"aboveEmbedded\", \"belowEmbedded\", \"none\"]);\n    this.truncate = getInteger({\n      data: e.truncate,\n      defaultValue: 0,\n      validate: e => 1 === e\n    });\n    this.type = getStringOption(e.type ? e.type.toLowerCase() : \"\", [\"aztec\", \"codabar\", \"code2of5industrial\", \"code2of5interleaved\", \"code2of5matrix\", \"code2of5standard\", \"code3of9\", \"code3of9extended\", \"code11\", \"code49\", \"code93\", \"code128\", \"code128a\", \"code128b\", \"code128c\", \"code128sscc\", \"datamatrix\", \"ean8\", \"ean8add2\", \"ean8add5\", \"ean13\", \"ean13add2\", \"ean13add5\", \"ean13pwcd\", \"fim\", \"logmars\", \"maxicode\", \"msi\", \"pdf417\", \"pdf417macro\", \"plessey\", \"postauscust2\", \"postauscust3\", \"postausreplypaid\", \"postausstandard\", \"postukrm4scc\", \"postusdpbc\", \"postusimb\", \"postusstandard\", \"postus5zip\", \"qrcode\", \"rfid\", \"rss14\", \"rss14expanded\", \"rss14limited\", \"rss14stacked\", \"rss14stackedomni\", \"rss14truncated\", \"telepen\", \"ucc128\", \"ucc128random\", \"ucc128sscc\", \"upca\", \"upcaadd2\", \"upcaadd5\", \"upcapwcd\", \"upce\", \"upceadd2\", \"upceadd5\", \"upcean2\", \"upcean5\", \"upsmaxicode\"]);\n    this.upsMode = getStringOption(e.upsMode, [\"usCarrier\", \"internationalCarrier\", \"secureSymbol\", \"standardSymbol\"]);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.wideNarrowRatio = getRatio(e.wideNarrowRatio);\n    this.encrypt = null;\n    this.extras = null;\n  }\n}\nclass Bind extends XFAObject {\n  constructor(e) {\n    super(Hn, \"bind\", !0);\n    this.match = getStringOption(e.match, [\"once\", \"dataRef\", \"global\", \"none\"]);\n    this.ref = e.ref || \"\";\n    this.picture = null;\n  }\n}\nclass BindItems extends XFAObject {\n  constructor(e) {\n    super(Hn, \"bindItems\");\n    this.connection = e.connection || \"\";\n    this.labelRef = e.labelRef || \"\";\n    this.ref = e.ref || \"\";\n    this.valueRef = e.valueRef || \"\";\n  }\n}\nclass Bookend extends XFAObject {\n  constructor(e) {\n    super(Hn, \"bookend\");\n    this.id = e.id || \"\";\n    this.leader = e.leader || \"\";\n    this.trailer = e.trailer || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n}\nclass BooleanElement extends Option01 {\n  constructor(e) {\n    super(Hn, \"boolean\");\n    this.id = e.id || \"\";\n    this.name = e.name || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n  [an](e) {\n    return valueToHtml(1 === this[er] ? \"1\" : \"0\");\n  }\n}\nclass Border extends XFAObject {\n  constructor(e) {\n    super(Hn, \"border\", !0);\n    this.break = getStringOption(e.break, [\"close\", \"open\"]);\n    this.hand = getStringOption(e.hand, [\"even\", \"left\", \"right\"]);\n    this.id = e.id || \"\";\n    this.presence = getStringOption(e.presence, [\"visible\", \"hidden\", \"inactive\", \"invisible\"]);\n    this.relevant = getRelevant(e.relevant);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.corner = new XFAObjectArray(4);\n    this.edge = new XFAObjectArray(4);\n    this.extras = null;\n    this.fill = null;\n    this.margin = null;\n  }\n  [lr]() {\n    if (!this[ar]) {\n      const e = this.edge.children.slice();\n      if (e.length < 4) {\n        const t = e.at(-1) || new Edge({});\n        for (let i = e.length; i < 4; i++) e.push(t);\n      }\n      const t = e.map(e => e.thickness),\n        i = [0, 0, 0, 0];\n      if (this.margin) {\n        i[0] = this.margin.topInset;\n        i[1] = this.margin.rightInset;\n        i[2] = this.margin.bottomInset;\n        i[3] = this.margin.leftInset;\n      }\n      this[ar] = {\n        widths: t,\n        insets: i,\n        edges: e\n      };\n    }\n    return this[ar];\n  }\n  [rn]() {\n    const {\n        edges: e\n      } = this[lr](),\n      t = e.map(e => {\n        const t = e[rn]();\n        t.color ||= \"#000000\";\n        return t;\n      }),\n      i = Object.create(null);\n    this.margin && Object.assign(i, this.margin[rn]());\n    \"visible\" === this.fill?.presence && Object.assign(i, this.fill[rn]());\n    if (this.corner.children.some(e => 0 !== e.radius)) {\n      const e = this.corner.children.map(e => e[rn]());\n      if (2 === e.length || 3 === e.length) {\n        const t = e.at(-1);\n        for (let i = e.length; i < 4; i++) e.push(t);\n      }\n      i.borderRadius = e.map(e => e.radius).join(\" \");\n    }\n    switch (this.presence) {\n      case \"invisible\":\n      case \"hidden\":\n        i.borderStyle = \"\";\n        break;\n      case \"inactive\":\n        i.borderStyle = \"none\";\n        break;\n      default:\n        i.borderStyle = t.map(e => e.style).join(\" \");\n    }\n    i.borderWidth = t.map(e => e.width).join(\" \");\n    i.borderColor = t.map(e => e.color).join(\" \");\n    return i;\n  }\n}\nclass Break extends XFAObject {\n  constructor(e) {\n    super(Hn, \"break\", !0);\n    this.after = getStringOption(e.after, [\"auto\", \"contentArea\", \"pageArea\", \"pageEven\", \"pageOdd\"]);\n    this.afterTarget = e.afterTarget || \"\";\n    this.before = getStringOption(e.before, [\"auto\", \"contentArea\", \"pageArea\", \"pageEven\", \"pageOdd\"]);\n    this.beforeTarget = e.beforeTarget || \"\";\n    this.bookendLeader = e.bookendLeader || \"\";\n    this.bookendTrailer = e.bookendTrailer || \"\";\n    this.id = e.id || \"\";\n    this.overflowLeader = e.overflowLeader || \"\";\n    this.overflowTarget = e.overflowTarget || \"\";\n    this.overflowTrailer = e.overflowTrailer || \"\";\n    this.startNew = getInteger({\n      data: e.startNew,\n      defaultValue: 0,\n      validate: e => 1 === e\n    });\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.extras = null;\n  }\n}\nclass BreakAfter extends XFAObject {\n  constructor(e) {\n    super(Hn, \"breakAfter\", !0);\n    this.id = e.id || \"\";\n    this.leader = e.leader || \"\";\n    this.startNew = getInteger({\n      data: e.startNew,\n      defaultValue: 0,\n      validate: e => 1 === e\n    });\n    this.target = e.target || \"\";\n    this.targetType = getStringOption(e.targetType, [\"auto\", \"contentArea\", \"pageArea\"]);\n    this.trailer = e.trailer || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.script = null;\n  }\n}\nclass BreakBefore extends XFAObject {\n  constructor(e) {\n    super(Hn, \"breakBefore\", !0);\n    this.id = e.id || \"\";\n    this.leader = e.leader || \"\";\n    this.startNew = getInteger({\n      data: e.startNew,\n      defaultValue: 0,\n      validate: e => 1 === e\n    });\n    this.target = e.target || \"\";\n    this.targetType = getStringOption(e.targetType, [\"auto\", \"contentArea\", \"pageArea\"]);\n    this.trailer = e.trailer || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.script = null;\n  }\n  [an](e) {\n    this[ar] = {};\n    return HTMLResult.FAILURE;\n  }\n}\nclass Button extends XFAObject {\n  constructor(e) {\n    super(Hn, \"button\", !0);\n    this.highlight = getStringOption(e.highlight, [\"inverted\", \"none\", \"outline\", \"push\"]);\n    this.id = e.id || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.extras = null;\n  }\n  [an](e) {\n    const t = this[pr]()[pr](),\n      i = {\n        name: \"button\",\n        attributes: {\n          id: this[nn],\n          class: [\"xfaButton\"],\n          style: {}\n        },\n        children: []\n      };\n    for (const e of t.event.children) {\n      if (\"click\" !== e.activity || !e.script) continue;\n      const t = recoverJsURL(e.script[er]);\n      if (!t) continue;\n      const a = fixURL(t.url);\n      a && i.children.push({\n        name: \"a\",\n        attributes: {\n          id: \"link\" + this[nn],\n          href: a,\n          newWindow: t.newWindow,\n          class: [\"xfaLink\"],\n          style: {}\n        },\n        children: []\n      });\n    }\n    return HTMLResult.success(i);\n  }\n}\nclass Calculate extends XFAObject {\n  constructor(e) {\n    super(Hn, \"calculate\", !0);\n    this.id = e.id || \"\";\n    this.override = getStringOption(e.override, [\"disabled\", \"error\", \"ignore\", \"warning\"]);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.extras = null;\n    this.message = null;\n    this.script = null;\n  }\n}\nclass Caption extends XFAObject {\n  constructor(e) {\n    super(Hn, \"caption\", !0);\n    this.id = e.id || \"\";\n    this.placement = getStringOption(e.placement, [\"left\", \"bottom\", \"inline\", \"right\", \"top\"]);\n    this.presence = getStringOption(e.presence, [\"visible\", \"hidden\", \"inactive\", \"invisible\"]);\n    this.reserve = Math.ceil(getMeasurement(e.reserve));\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.extras = null;\n    this.font = null;\n    this.margin = null;\n    this.para = null;\n    this.value = null;\n  }\n  [$r](e) {\n    _setValue(this, e);\n  }\n  [lr](e) {\n    if (!this[ar]) {\n      let {\n        width: t,\n        height: i\n      } = e;\n      switch (this.placement) {\n        case \"left\":\n        case \"right\":\n        case \"inline\":\n          t = this.reserve <= 0 ? t : this.reserve;\n          break;\n        case \"top\":\n        case \"bottom\":\n          i = this.reserve <= 0 ? i : this.reserve;\n      }\n      this[ar] = layoutNode(this, {\n        width: t,\n        height: i\n      });\n    }\n    return this[ar];\n  }\n  [an](e) {\n    if (!this.value) return HTMLResult.EMPTY;\n    this[Wr]();\n    const t = this.value[an](e).html;\n    if (!t) {\n      this[Pr]();\n      return HTMLResult.EMPTY;\n    }\n    const i = this.reserve;\n    if (this.reserve <= 0) {\n      const {\n        w: t,\n        h: i\n      } = this[lr](e);\n      switch (this.placement) {\n        case \"left\":\n        case \"right\":\n        case \"inline\":\n          this.reserve = t;\n          break;\n        case \"top\":\n        case \"bottom\":\n          this.reserve = i;\n      }\n    }\n    const a = [];\n    \"string\" == typeof t ? a.push({\n      name: \"#text\",\n      value: t\n    }) : a.push(t);\n    const s = toStyle(this, \"font\", \"margin\", \"visibility\");\n    switch (this.placement) {\n      case \"left\":\n      case \"right\":\n        this.reserve > 0 && (s.width = measureToString(this.reserve));\n        break;\n      case \"top\":\n      case \"bottom\":\n        this.reserve > 0 && (s.height = measureToString(this.reserve));\n    }\n    setPara(this, null, t);\n    this[Pr]();\n    this.reserve = i;\n    return HTMLResult.success({\n      name: \"div\",\n      attributes: {\n        style: s,\n        class: [\"xfaCaption\"]\n      },\n      children: a\n    });\n  }\n}\nclass Certificate extends StringObject {\n  constructor(e) {\n    super(Hn, \"certificate\");\n    this.id = e.id || \"\";\n    this.name = e.name || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n}\nclass Certificates extends XFAObject {\n  constructor(e) {\n    super(Hn, \"certificates\", !0);\n    this.credentialServerPolicy = getStringOption(e.credentialServerPolicy, [\"optional\", \"required\"]);\n    this.id = e.id || \"\";\n    this.url = e.url || \"\";\n    this.urlPolicy = e.urlPolicy || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.encryption = null;\n    this.issuers = null;\n    this.keyUsage = null;\n    this.oids = null;\n    this.signing = null;\n    this.subjectDNs = null;\n  }\n}\nclass CheckButton extends XFAObject {\n  constructor(e) {\n    super(Hn, \"checkButton\", !0);\n    this.id = e.id || \"\";\n    this.mark = getStringOption(e.mark, [\"default\", \"check\", \"circle\", \"cross\", \"diamond\", \"square\", \"star\"]);\n    this.shape = getStringOption(e.shape, [\"square\", \"round\"]);\n    this.size = getMeasurement(e.size, \"10pt\");\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.border = null;\n    this.extras = null;\n    this.margin = null;\n  }\n  [an](e) {\n    const t = toStyle(\"margin\"),\n      i = measureToString(this.size);\n    t.width = t.height = i;\n    let a, s, r;\n    const n = this[pr]()[pr](),\n      g = n.items.children.length && n.items.children[0][an]().html || [],\n      o = {\n        on: (void 0 !== g[0] ? g[0] : \"on\").toString(),\n        off: (void 0 !== g[1] ? g[1] : \"off\").toString()\n      },\n      c = (n.value?.[en]() || \"off\") === o.on || void 0,\n      C = n[fr](),\n      h = n[nn];\n    let l;\n    if (C instanceof ExclGroup) {\n      r = C[nn];\n      a = \"radio\";\n      s = \"xfaRadio\";\n      l = C[tr]?.[nn] || C[nn];\n    } else {\n      a = \"checkbox\";\n      s = \"xfaCheckbox\";\n      l = n[tr]?.[nn] || n[nn];\n    }\n    const Q = {\n      name: \"input\",\n      attributes: {\n        class: [s],\n        style: t,\n        fieldId: h,\n        dataId: l,\n        type: a,\n        checked: c,\n        xfaOn: o.on,\n        xfaOff: o.off,\n        \"aria-label\": ariaLabel(n),\n        \"aria-required\": !1\n      }\n    };\n    r && (Q.attributes.name = r);\n    if (isRequired(n)) {\n      Q.attributes[\"aria-required\"] = !0;\n      Q.attributes.required = !0;\n    }\n    return HTMLResult.success({\n      name: \"label\",\n      attributes: {\n        class: [\"xfaLabel\"]\n      },\n      children: [Q]\n    });\n  }\n}\nclass ChoiceList extends XFAObject {\n  constructor(e) {\n    super(Hn, \"choiceList\", !0);\n    this.commitOn = getStringOption(e.commitOn, [\"select\", \"exit\"]);\n    this.id = e.id || \"\";\n    this.open = getStringOption(e.open, [\"userControl\", \"always\", \"multiSelect\", \"onEntry\"]);\n    this.textEntry = getInteger({\n      data: e.textEntry,\n      defaultValue: 0,\n      validate: e => 1 === e\n    });\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.border = null;\n    this.extras = null;\n    this.margin = null;\n  }\n  [an](e) {\n    const t = toStyle(this, \"border\", \"margin\"),\n      i = this[pr]()[pr](),\n      a = {\n        fontSize: `calc(${i.font?.size || 10}px * var(--scale-factor))`\n      },\n      s = [];\n    if (i.items.children.length > 0) {\n      const e = i.items;\n      let t = 0,\n        r = 0;\n      if (2 === e.children.length) {\n        t = e.children[0].save;\n        r = 1 - t;\n      }\n      const n = e.children[t][an]().html,\n        g = e.children[r][an]().html;\n      let o = !1;\n      const c = i.value?.[en]() || \"\";\n      for (let e = 0, t = n.length; e < t; e++) {\n        const t = {\n          name: \"option\",\n          attributes: {\n            value: g[e] || n[e],\n            style: a\n          },\n          value: n[e]\n        };\n        g[e] === c && (t.attributes.selected = o = !0);\n        s.push(t);\n      }\n      o || s.splice(0, 0, {\n        name: \"option\",\n        attributes: {\n          hidden: !0,\n          selected: !0\n        },\n        value: \" \"\n      });\n    }\n    const r = {\n      class: [\"xfaSelect\"],\n      fieldId: i[nn],\n      dataId: i[tr]?.[nn] || i[nn],\n      style: t,\n      \"aria-label\": ariaLabel(i),\n      \"aria-required\": !1\n    };\n    if (isRequired(i)) {\n      r[\"aria-required\"] = !0;\n      r.required = !0;\n    }\n    \"multiSelect\" === this.open && (r.multiple = !0);\n    return HTMLResult.success({\n      name: \"label\",\n      attributes: {\n        class: [\"xfaLabel\"]\n      },\n      children: [{\n        name: \"select\",\n        children: s,\n        attributes: r\n      }]\n    });\n  }\n}\nclass Color extends XFAObject {\n  constructor(e) {\n    super(Hn, \"color\", !0);\n    this.cSpace = getStringOption(e.cSpace, [\"SRGB\"]);\n    this.id = e.id || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.value = e.value ? function getColor(e, t = [0, 0, 0]) {\n      let [i, a, s] = t;\n      if (!e) return {\n        r: i,\n        g: a,\n        b: s\n      };\n      const r = e.trim().split(/\\s*,\\s*/).map(e => Math.min(Math.max(0, parseInt(e.trim(), 10)), 255)).map(e => isNaN(e) ? 0 : e);\n      if (r.length < 3) return {\n        r: i,\n        g: a,\n        b: s\n      };\n      [i, a, s] = r;\n      return {\n        r: i,\n        g: a,\n        b: s\n      };\n    }(e.value) : \"\";\n    this.extras = null;\n  }\n  [wr]() {\n    return !1;\n  }\n  [rn]() {\n    return this.value ? Util.makeHexColor(this.value.r, this.value.g, this.value.b) : null;\n  }\n}\nclass Comb extends XFAObject {\n  constructor(e) {\n    super(Hn, \"comb\");\n    this.id = e.id || \"\";\n    this.numberOfCells = getInteger({\n      data: e.numberOfCells,\n      defaultValue: 0,\n      validate: e => e >= 0\n    });\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n}\nclass Connect extends XFAObject {\n  constructor(e) {\n    super(Hn, \"connect\", !0);\n    this.connection = e.connection || \"\";\n    this.id = e.id || \"\";\n    this.ref = e.ref || \"\";\n    this.usage = getStringOption(e.usage, [\"exportAndImport\", \"exportOnly\", \"importOnly\"]);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.picture = null;\n  }\n}\nclass ContentArea extends XFAObject {\n  constructor(e) {\n    super(Hn, \"contentArea\", !0);\n    this.h = getMeasurement(e.h);\n    this.id = e.id || \"\";\n    this.name = e.name || \"\";\n    this.relevant = getRelevant(e.relevant);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.w = getMeasurement(e.w);\n    this.x = getMeasurement(e.x, \"0pt\");\n    this.y = getMeasurement(e.y, \"0pt\");\n    this.desc = null;\n    this.extras = null;\n  }\n  [an](e) {\n    const t = {\n        left: measureToString(this.x),\n        top: measureToString(this.y),\n        width: measureToString(this.w),\n        height: measureToString(this.h)\n      },\n      i = [\"xfaContentarea\"];\n    isPrintOnly(this) && i.push(\"xfaPrintOnly\");\n    return HTMLResult.success({\n      name: \"div\",\n      children: [],\n      attributes: {\n        style: t,\n        class: i,\n        id: this[nn]\n      }\n    });\n  }\n}\nclass Corner extends XFAObject {\n  constructor(e) {\n    super(Hn, \"corner\", !0);\n    this.id = e.id || \"\";\n    this.inverted = getInteger({\n      data: e.inverted,\n      defaultValue: 0,\n      validate: e => 1 === e\n    });\n    this.join = getStringOption(e.join, [\"square\", \"round\"]);\n    this.presence = getStringOption(e.presence, [\"visible\", \"hidden\", \"inactive\", \"invisible\"]);\n    this.radius = getMeasurement(e.radius);\n    this.stroke = getStringOption(e.stroke, [\"solid\", \"dashDot\", \"dashDotDot\", \"dashed\", \"dotted\", \"embossed\", \"etched\", \"lowered\", \"raised\"]);\n    this.thickness = getMeasurement(e.thickness, \"0.5pt\");\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.color = null;\n    this.extras = null;\n  }\n  [rn]() {\n    const e = toStyle(this, \"visibility\");\n    e.radius = measureToString(\"square\" === this.join ? 0 : this.radius);\n    return e;\n  }\n}\nclass DateElement extends ContentObject {\n  constructor(e) {\n    super(Hn, \"date\");\n    this.id = e.id || \"\";\n    this.name = e.name || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n  [sr]() {\n    const e = this[er].trim();\n    this[er] = e ? new Date(e) : null;\n  }\n  [an](e) {\n    return valueToHtml(this[er] ? this[er].toString() : \"\");\n  }\n}\nclass DateTime extends ContentObject {\n  constructor(e) {\n    super(Hn, \"dateTime\");\n    this.id = e.id || \"\";\n    this.name = e.name || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n  [sr]() {\n    const e = this[er].trim();\n    this[er] = e ? new Date(e) : null;\n  }\n  [an](e) {\n    return valueToHtml(this[er] ? this[er].toString() : \"\");\n  }\n}\nclass DateTimeEdit extends XFAObject {\n  constructor(e) {\n    super(Hn, \"dateTimeEdit\", !0);\n    this.hScrollPolicy = getStringOption(e.hScrollPolicy, [\"auto\", \"off\", \"on\"]);\n    this.id = e.id || \"\";\n    this.picker = getStringOption(e.picker, [\"host\", \"none\"]);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.border = null;\n    this.comb = null;\n    this.extras = null;\n    this.margin = null;\n  }\n  [an](e) {\n    const t = toStyle(this, \"border\", \"font\", \"margin\"),\n      i = this[pr]()[pr](),\n      a = {\n        name: \"input\",\n        attributes: {\n          type: \"text\",\n          fieldId: i[nn],\n          dataId: i[tr]?.[nn] || i[nn],\n          class: [\"xfaTextfield\"],\n          style: t,\n          \"aria-label\": ariaLabel(i),\n          \"aria-required\": !1\n        }\n      };\n    if (isRequired(i)) {\n      a.attributes[\"aria-required\"] = !0;\n      a.attributes.required = !0;\n    }\n    return HTMLResult.success({\n      name: \"label\",\n      attributes: {\n        class: [\"xfaLabel\"]\n      },\n      children: [a]\n    });\n  }\n}\nclass Decimal extends ContentObject {\n  constructor(e) {\n    super(Hn, \"decimal\");\n    this.fracDigits = getInteger({\n      data: e.fracDigits,\n      defaultValue: 2,\n      validate: e => !0\n    });\n    this.id = e.id || \"\";\n    this.leadDigits = getInteger({\n      data: e.leadDigits,\n      defaultValue: -1,\n      validate: e => !0\n    });\n    this.name = e.name || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n  [sr]() {\n    const e = parseFloat(this[er].trim());\n    this[er] = isNaN(e) ? null : e;\n  }\n  [an](e) {\n    return valueToHtml(null !== this[er] ? this[er].toString() : \"\");\n  }\n}\nclass DefaultUi extends XFAObject {\n  constructor(e) {\n    super(Hn, \"defaultUi\", !0);\n    this.id = e.id || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.extras = null;\n  }\n}\nclass Desc extends XFAObject {\n  constructor(e) {\n    super(Hn, \"desc\", !0);\n    this.id = e.id || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.boolean = new XFAObjectArray();\n    this.date = new XFAObjectArray();\n    this.dateTime = new XFAObjectArray();\n    this.decimal = new XFAObjectArray();\n    this.exData = new XFAObjectArray();\n    this.float = new XFAObjectArray();\n    this.image = new XFAObjectArray();\n    this.integer = new XFAObjectArray();\n    this.text = new XFAObjectArray();\n    this.time = new XFAObjectArray();\n  }\n}\nclass DigestMethod extends OptionObject {\n  constructor(e) {\n    super(Hn, \"digestMethod\", [\"\", \"SHA1\", \"SHA256\", \"SHA512\", \"RIPEMD160\"]);\n    this.id = e.id || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n}\nclass DigestMethods extends XFAObject {\n  constructor(e) {\n    super(Hn, \"digestMethods\", !0);\n    this.id = e.id || \"\";\n    this.type = getStringOption(e.type, [\"optional\", \"required\"]);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.digestMethod = new XFAObjectArray();\n  }\n}\nclass Draw extends XFAObject {\n  constructor(e) {\n    super(Hn, \"draw\", !0);\n    this.anchorType = getStringOption(e.anchorType, [\"topLeft\", \"bottomCenter\", \"bottomLeft\", \"bottomRight\", \"middleCenter\", \"middleLeft\", \"middleRight\", \"topCenter\", \"topRight\"]);\n    this.colSpan = getInteger({\n      data: e.colSpan,\n      defaultValue: 1,\n      validate: e => e >= 1 || -1 === e\n    });\n    this.h = e.h ? getMeasurement(e.h) : \"\";\n    this.hAlign = getStringOption(e.hAlign, [\"left\", \"center\", \"justify\", \"justifyAll\", \"radix\", \"right\"]);\n    this.id = e.id || \"\";\n    this.locale = e.locale || \"\";\n    this.maxH = getMeasurement(e.maxH, \"0pt\");\n    this.maxW = getMeasurement(e.maxW, \"0pt\");\n    this.minH = getMeasurement(e.minH, \"0pt\");\n    this.minW = getMeasurement(e.minW, \"0pt\");\n    this.name = e.name || \"\";\n    this.presence = getStringOption(e.presence, [\"visible\", \"hidden\", \"inactive\", \"invisible\"]);\n    this.relevant = getRelevant(e.relevant);\n    this.rotate = getInteger({\n      data: e.rotate,\n      defaultValue: 0,\n      validate: e => e % 90 == 0\n    });\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.w = e.w ? getMeasurement(e.w) : \"\";\n    this.x = getMeasurement(e.x, \"0pt\");\n    this.y = getMeasurement(e.y, \"0pt\");\n    this.assist = null;\n    this.border = null;\n    this.caption = null;\n    this.desc = null;\n    this.extras = null;\n    this.font = null;\n    this.keep = null;\n    this.margin = null;\n    this.para = null;\n    this.traversal = null;\n    this.ui = null;\n    this.value = null;\n    this.setProperty = new XFAObjectArray();\n  }\n  [$r](e) {\n    _setValue(this, e);\n  }\n  [an](e) {\n    setTabIndex(this);\n    if (\"hidden\" === this.presence || \"inactive\" === this.presence) return HTMLResult.EMPTY;\n    fixDimensions(this);\n    this[Wr]();\n    const t = this.w,\n      i = this.h,\n      {\n        w: a,\n        h: s,\n        isBroken: r\n      } = layoutNode(this, e);\n    if (a && \"\" === this.w) {\n      if (r && this[fr]()[Ur]()) {\n        this[Pr]();\n        return HTMLResult.FAILURE;\n      }\n      this.w = a;\n    }\n    s && \"\" === this.h && (this.h = s);\n    setFirstUnsplittable(this);\n    if (!checkDimensions(this, e)) {\n      this.w = t;\n      this.h = i;\n      this[Pr]();\n      return HTMLResult.FAILURE;\n    }\n    unsetFirstUnsplittable(this);\n    const n = toStyle(this, \"font\", \"hAlign\", \"dimensions\", \"position\", \"presence\", \"rotate\", \"anchorType\", \"border\", \"margin\");\n    setMinMaxDimensions(this, n);\n    if (n.margin) {\n      n.padding = n.margin;\n      delete n.margin;\n    }\n    const g = [\"xfaDraw\"];\n    this.font && g.push(\"xfaFont\");\n    isPrintOnly(this) && g.push(\"xfaPrintOnly\");\n    const o = {\n      style: n,\n      id: this[nn],\n      class: g\n    };\n    this.name && (o.xfaName = this.name);\n    const c = {\n      name: \"div\",\n      attributes: o,\n      children: []\n    };\n    applyAssist(this, o);\n    const C = computeBbox(this, c, e),\n      h = this.value ? this.value[an](e).html : null;\n    if (null === h) {\n      this.w = t;\n      this.h = i;\n      this[Pr]();\n      return HTMLResult.success(createWrapper(this, c), C);\n    }\n    c.children.push(h);\n    setPara(this, n, h);\n    this.w = t;\n    this.h = i;\n    this[Pr]();\n    return HTMLResult.success(createWrapper(this, c), C);\n  }\n}\nclass Edge extends XFAObject {\n  constructor(e) {\n    super(Hn, \"edge\", !0);\n    this.cap = getStringOption(e.cap, [\"square\", \"butt\", \"round\"]);\n    this.id = e.id || \"\";\n    this.presence = getStringOption(e.presence, [\"visible\", \"hidden\", \"inactive\", \"invisible\"]);\n    this.stroke = getStringOption(e.stroke, [\"solid\", \"dashDot\", \"dashDotDot\", \"dashed\", \"dotted\", \"embossed\", \"etched\", \"lowered\", \"raised\"]);\n    this.thickness = getMeasurement(e.thickness, \"0.5pt\");\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.color = null;\n    this.extras = null;\n  }\n  [rn]() {\n    const e = toStyle(this, \"visibility\");\n    Object.assign(e, {\n      linecap: this.cap,\n      width: measureToString(this.thickness),\n      color: this.color ? this.color[rn]() : \"#000000\",\n      style: \"\"\n    });\n    if (\"visible\" !== this.presence) e.style = \"none\";else switch (this.stroke) {\n      case \"solid\":\n        e.style = \"solid\";\n        break;\n      case \"dashDot\":\n      case \"dashDotDot\":\n      case \"dashed\":\n        e.style = \"dashed\";\n        break;\n      case \"dotted\":\n        e.style = \"dotted\";\n        break;\n      case \"embossed\":\n        e.style = \"ridge\";\n        break;\n      case \"etched\":\n        e.style = \"groove\";\n        break;\n      case \"lowered\":\n        e.style = \"inset\";\n        break;\n      case \"raised\":\n        e.style = \"outset\";\n    }\n    return e;\n  }\n}\nclass Encoding extends OptionObject {\n  constructor(e) {\n    super(Hn, \"encoding\", [\"adbe.x509.rsa_sha1\", \"adbe.pkcs7.detached\", \"adbe.pkcs7.sha1\"]);\n    this.id = e.id || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n}\nclass Encodings extends XFAObject {\n  constructor(e) {\n    super(Hn, \"encodings\", !0);\n    this.id = e.id || \"\";\n    this.type = getStringOption(e.type, [\"optional\", \"required\"]);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.encoding = new XFAObjectArray();\n  }\n}\nclass Encrypt extends XFAObject {\n  constructor(e) {\n    super(Hn, \"encrypt\", !0);\n    this.id = e.id || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.certificate = null;\n  }\n}\nclass EncryptData extends XFAObject {\n  constructor(e) {\n    super(Hn, \"encryptData\", !0);\n    this.id = e.id || \"\";\n    this.operation = getStringOption(e.operation, [\"encrypt\", \"decrypt\"]);\n    this.target = e.target || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.filter = null;\n    this.manifest = null;\n  }\n}\nclass Encryption extends XFAObject {\n  constructor(e) {\n    super(Hn, \"encryption\", !0);\n    this.id = e.id || \"\";\n    this.type = getStringOption(e.type, [\"optional\", \"required\"]);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.certificate = new XFAObjectArray();\n  }\n}\nclass EncryptionMethod extends OptionObject {\n  constructor(e) {\n    super(Hn, \"encryptionMethod\", [\"\", \"AES256-CBC\", \"TRIPLEDES-CBC\", \"AES128-CBC\", \"AES192-CBC\"]);\n    this.id = e.id || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n}\nclass EncryptionMethods extends XFAObject {\n  constructor(e) {\n    super(Hn, \"encryptionMethods\", !0);\n    this.id = e.id || \"\";\n    this.type = getStringOption(e.type, [\"optional\", \"required\"]);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.encryptionMethod = new XFAObjectArray();\n  }\n}\nclass Event extends XFAObject {\n  constructor(e) {\n    super(Hn, \"event\", !0);\n    this.activity = getStringOption(e.activity, [\"click\", \"change\", \"docClose\", \"docReady\", \"enter\", \"exit\", \"full\", \"indexChange\", \"initialize\", \"mouseDown\", \"mouseEnter\", \"mouseExit\", \"mouseUp\", \"postExecute\", \"postOpen\", \"postPrint\", \"postSave\", \"postSign\", \"postSubmit\", \"preExecute\", \"preOpen\", \"prePrint\", \"preSave\", \"preSign\", \"preSubmit\", \"ready\", \"validationState\"]);\n    this.id = e.id || \"\";\n    this.listen = getStringOption(e.listen, [\"refOnly\", \"refAndDescendents\"]);\n    this.name = e.name || \"\";\n    this.ref = e.ref || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.extras = null;\n    this.encryptData = null;\n    this.execute = null;\n    this.script = null;\n    this.signData = null;\n    this.submit = null;\n  }\n}\nclass ExData extends ContentObject {\n  constructor(e) {\n    super(Hn, \"exData\");\n    this.contentType = e.contentType || \"\";\n    this.href = e.href || \"\";\n    this.id = e.id || \"\";\n    this.maxLength = getInteger({\n      data: e.maxLength,\n      defaultValue: -1,\n      validate: e => e >= -1\n    });\n    this.name = e.name || \"\";\n    this.rid = e.rid || \"\";\n    this.transferEncoding = getStringOption(e.transferEncoding, [\"none\", \"base64\", \"package\"]);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n  [Sr]() {\n    return \"text/html\" === this.contentType;\n  }\n  [Kr](e) {\n    if (\"text/html\" === this.contentType && e[Jr] === on.xhtml.id) {\n      this[er] = e;\n      return !0;\n    }\n    if (\"text/xml\" === this.contentType) {\n      this[er] = e;\n      return !0;\n    }\n    return !1;\n  }\n  [an](e) {\n    return \"text/html\" === this.contentType && this[er] ? this[er][an](e) : HTMLResult.EMPTY;\n  }\n}\nclass ExObject extends XFAObject {\n  constructor(e) {\n    super(Hn, \"exObject\", !0);\n    this.archive = e.archive || \"\";\n    this.classId = e.classId || \"\";\n    this.codeBase = e.codeBase || \"\";\n    this.codeType = e.codeType || \"\";\n    this.id = e.id || \"\";\n    this.name = e.name || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.extras = null;\n    this.boolean = new XFAObjectArray();\n    this.date = new XFAObjectArray();\n    this.dateTime = new XFAObjectArray();\n    this.decimal = new XFAObjectArray();\n    this.exData = new XFAObjectArray();\n    this.exObject = new XFAObjectArray();\n    this.float = new XFAObjectArray();\n    this.image = new XFAObjectArray();\n    this.integer = new XFAObjectArray();\n    this.text = new XFAObjectArray();\n    this.time = new XFAObjectArray();\n  }\n}\nclass ExclGroup extends XFAObject {\n  constructor(e) {\n    super(Hn, \"exclGroup\", !0);\n    this.access = getStringOption(e.access, [\"open\", \"nonInteractive\", \"protected\", \"readOnly\"]);\n    this.accessKey = e.accessKey || \"\";\n    this.anchorType = getStringOption(e.anchorType, [\"topLeft\", \"bottomCenter\", \"bottomLeft\", \"bottomRight\", \"middleCenter\", \"middleLeft\", \"middleRight\", \"topCenter\", \"topRight\"]);\n    this.colSpan = getInteger({\n      data: e.colSpan,\n      defaultValue: 1,\n      validate: e => e >= 1 || -1 === e\n    });\n    this.h = e.h ? getMeasurement(e.h) : \"\";\n    this.hAlign = getStringOption(e.hAlign, [\"left\", \"center\", \"justify\", \"justifyAll\", \"radix\", \"right\"]);\n    this.id = e.id || \"\";\n    this.layout = getStringOption(e.layout, [\"position\", \"lr-tb\", \"rl-row\", \"rl-tb\", \"row\", \"table\", \"tb\"]);\n    this.maxH = getMeasurement(e.maxH, \"0pt\");\n    this.maxW = getMeasurement(e.maxW, \"0pt\");\n    this.minH = getMeasurement(e.minH, \"0pt\");\n    this.minW = getMeasurement(e.minW, \"0pt\");\n    this.name = e.name || \"\";\n    this.presence = getStringOption(e.presence, [\"visible\", \"hidden\", \"inactive\", \"invisible\"]);\n    this.relevant = getRelevant(e.relevant);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.w = e.w ? getMeasurement(e.w) : \"\";\n    this.x = getMeasurement(e.x, \"0pt\");\n    this.y = getMeasurement(e.y, \"0pt\");\n    this.assist = null;\n    this.bind = null;\n    this.border = null;\n    this.calculate = null;\n    this.caption = null;\n    this.desc = null;\n    this.extras = null;\n    this.margin = null;\n    this.para = null;\n    this.traversal = null;\n    this.validate = null;\n    this.connect = new XFAObjectArray();\n    this.event = new XFAObjectArray();\n    this.field = new XFAObjectArray();\n    this.setProperty = new XFAObjectArray();\n  }\n  [kr]() {\n    return !0;\n  }\n  [wr]() {\n    return !0;\n  }\n  [$r](e) {\n    for (const t of this.field.children) {\n      if (!t.value) {\n        const e = new Value({});\n        t[Xs](e);\n        t.value = e;\n      }\n      t.value[$r](e);\n    }\n  }\n  [Ur]() {\n    return this.layout.endsWith(\"-tb\") && 0 === this[ar].attempt && this[ar].numberInLine > 0 || this[pr]()[Ur]();\n  }\n  [xr]() {\n    const e = this[fr]();\n    if (!e[xr]()) return !1;\n    if (void 0 !== this[ar]._isSplittable) return this[ar]._isSplittable;\n    if (\"position\" === this.layout || this.layout.includes(\"row\")) {\n      this[ar]._isSplittable = !1;\n      return !1;\n    }\n    if (e.layout?.endsWith(\"-tb\") && 0 !== e[ar].numberInLine) return !1;\n    this[ar]._isSplittable = !0;\n    return !0;\n  }\n  [rr]() {\n    return flushHTML(this);\n  }\n  [js](e, t) {\n    addHTML(this, e, t);\n  }\n  [or]() {\n    return getAvailableSpace(this);\n  }\n  [an](e) {\n    setTabIndex(this);\n    if (\"hidden\" === this.presence || \"inactive\" === this.presence || 0 === this.h || 0 === this.w) return HTMLResult.EMPTY;\n    fixDimensions(this);\n    const t = [],\n      i = {\n        id: this[nn],\n        class: []\n      };\n    setAccess(this, i.class);\n    this[ar] || (this[ar] = Object.create(null));\n    Object.assign(this[ar], {\n      children: t,\n      attributes: i,\n      attempt: 0,\n      line: null,\n      numberInLine: 0,\n      availableSpace: {\n        width: Math.min(this.w || 1 / 0, e.width),\n        height: Math.min(this.h || 1 / 0, e.height)\n      },\n      width: 0,\n      height: 0,\n      prevHeight: 0,\n      currentWidth: 0\n    });\n    const a = this[xr]();\n    a || setFirstUnsplittable(this);\n    if (!checkDimensions(this, e)) return HTMLResult.FAILURE;\n    const s = new Set([\"field\"]);\n    if (this.layout.includes(\"row\")) {\n      const e = this[fr]().columnWidths;\n      if (Array.isArray(e) && e.length > 0) {\n        this[ar].columnWidths = e;\n        this[ar].currentColumn = 0;\n      }\n    }\n    const r = toStyle(this, \"anchorType\", \"dimensions\", \"position\", \"presence\", \"border\", \"margin\", \"hAlign\"),\n      n = [\"xfaExclgroup\"],\n      g = layoutClass(this);\n    g && n.push(g);\n    isPrintOnly(this) && n.push(\"xfaPrintOnly\");\n    i.style = r;\n    i.class = n;\n    this.name && (i.xfaName = this.name);\n    this[Wr]();\n    const o = \"lr-tb\" === this.layout || \"rl-tb\" === this.layout,\n      c = o ? 2 : 1;\n    for (; this[ar].attempt < c; this[ar].attempt++) {\n      o && 1 === this[ar].attempt && (this[ar].numberInLine = 0);\n      const e = this[Zs]({\n        filter: s,\n        include: !0\n      });\n      if (e.success) break;\n      if (e.isBreak()) {\n        this[Pr]();\n        return e;\n      }\n      if (o && 0 === this[ar].attempt && 0 === this[ar].numberInLine && !this[mr]()[ar].noLayoutFailure) {\n        this[ar].attempt = c;\n        break;\n      }\n    }\n    this[Pr]();\n    a || unsetFirstUnsplittable(this);\n    if (this[ar].attempt === c) {\n      a || delete this[ar];\n      return HTMLResult.FAILURE;\n    }\n    let C = 0,\n      h = 0;\n    if (this.margin) {\n      C = this.margin.leftInset + this.margin.rightInset;\n      h = this.margin.topInset + this.margin.bottomInset;\n    }\n    const l = Math.max(this[ar].width + C, this.w || 0),\n      Q = Math.max(this[ar].height + h, this.h || 0),\n      E = [this.x, this.y, l, Q];\n    \"\" === this.w && (r.width = measureToString(l));\n    \"\" === this.h && (r.height = measureToString(Q));\n    const u = {\n      name: \"div\",\n      attributes: i,\n      children: t\n    };\n    applyAssist(this, i);\n    delete this[ar];\n    return HTMLResult.success(createWrapper(this, u), E);\n  }\n}\nclass Execute extends XFAObject {\n  constructor(e) {\n    super(Hn, \"execute\");\n    this.connection = e.connection || \"\";\n    this.executeType = getStringOption(e.executeType, [\"import\", \"remerge\"]);\n    this.id = e.id || \"\";\n    this.runAt = getStringOption(e.runAt, [\"client\", \"both\", \"server\"]);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n}\nclass Extras extends XFAObject {\n  constructor(e) {\n    super(Hn, \"extras\", !0);\n    this.id = e.id || \"\";\n    this.name = e.name || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.boolean = new XFAObjectArray();\n    this.date = new XFAObjectArray();\n    this.dateTime = new XFAObjectArray();\n    this.decimal = new XFAObjectArray();\n    this.exData = new XFAObjectArray();\n    this.extras = new XFAObjectArray();\n    this.float = new XFAObjectArray();\n    this.image = new XFAObjectArray();\n    this.integer = new XFAObjectArray();\n    this.text = new XFAObjectArray();\n    this.time = new XFAObjectArray();\n  }\n}\nclass Field extends XFAObject {\n  constructor(e) {\n    super(Hn, \"field\", !0);\n    this.access = getStringOption(e.access, [\"open\", \"nonInteractive\", \"protected\", \"readOnly\"]);\n    this.accessKey = e.accessKey || \"\";\n    this.anchorType = getStringOption(e.anchorType, [\"topLeft\", \"bottomCenter\", \"bottomLeft\", \"bottomRight\", \"middleCenter\", \"middleLeft\", \"middleRight\", \"topCenter\", \"topRight\"]);\n    this.colSpan = getInteger({\n      data: e.colSpan,\n      defaultValue: 1,\n      validate: e => e >= 1 || -1 === e\n    });\n    this.h = e.h ? getMeasurement(e.h) : \"\";\n    this.hAlign = getStringOption(e.hAlign, [\"left\", \"center\", \"justify\", \"justifyAll\", \"radix\", \"right\"]);\n    this.id = e.id || \"\";\n    this.locale = e.locale || \"\";\n    this.maxH = getMeasurement(e.maxH, \"0pt\");\n    this.maxW = getMeasurement(e.maxW, \"0pt\");\n    this.minH = getMeasurement(e.minH, \"0pt\");\n    this.minW = getMeasurement(e.minW, \"0pt\");\n    this.name = e.name || \"\";\n    this.presence = getStringOption(e.presence, [\"visible\", \"hidden\", \"inactive\", \"invisible\"]);\n    this.relevant = getRelevant(e.relevant);\n    this.rotate = getInteger({\n      data: e.rotate,\n      defaultValue: 0,\n      validate: e => e % 90 == 0\n    });\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.w = e.w ? getMeasurement(e.w) : \"\";\n    this.x = getMeasurement(e.x, \"0pt\");\n    this.y = getMeasurement(e.y, \"0pt\");\n    this.assist = null;\n    this.bind = null;\n    this.border = null;\n    this.calculate = null;\n    this.caption = null;\n    this.desc = null;\n    this.extras = null;\n    this.font = null;\n    this.format = null;\n    this.items = new XFAObjectArray(2);\n    this.keep = null;\n    this.margin = null;\n    this.para = null;\n    this.traversal = null;\n    this.ui = null;\n    this.validate = null;\n    this.value = null;\n    this.bindItems = new XFAObjectArray();\n    this.connect = new XFAObjectArray();\n    this.event = new XFAObjectArray();\n    this.setProperty = new XFAObjectArray();\n  }\n  [kr]() {\n    return !0;\n  }\n  [$r](e) {\n    _setValue(this, e);\n  }\n  [an](e) {\n    setTabIndex(this);\n    if (!this.ui) {\n      this.ui = new Ui({});\n      this.ui[yr] = this[yr];\n      this[Xs](this.ui);\n      let e;\n      switch (this.items.children.length) {\n        case 0:\n          e = new TextEdit({});\n          this.ui.textEdit = e;\n          break;\n        case 1:\n          e = new CheckButton({});\n          this.ui.checkButton = e;\n          break;\n        case 2:\n          e = new ChoiceList({});\n          this.ui.choiceList = e;\n      }\n      this.ui[Xs](e);\n    }\n    if (!this.ui || \"hidden\" === this.presence || \"inactive\" === this.presence || 0 === this.h || 0 === this.w) return HTMLResult.EMPTY;\n    this.caption && delete this.caption[ar];\n    this[Wr]();\n    const t = this.caption ? this.caption[an](e).html : null,\n      i = this.w,\n      a = this.h;\n    let s = 0,\n      r = 0;\n    if (this.margin) {\n      s = this.margin.leftInset + this.margin.rightInset;\n      r = this.margin.topInset + this.margin.bottomInset;\n    }\n    let n = null;\n    if (\"\" === this.w || \"\" === this.h) {\n      let t = null,\n        i = null,\n        a = 0,\n        g = 0;\n      if (this.ui.checkButton) a = g = this.ui.checkButton.size;else {\n        const {\n          w: t,\n          h: i\n        } = layoutNode(this, e);\n        if (null !== t) {\n          a = t;\n          g = i;\n        } else g = function fonts_getMetrics(e, t = !1) {\n          let i = null;\n          if (e) {\n            const t = stripQuotes(e.typeface),\n              a = e[yr].fontFinder.find(t);\n            i = selectFont(e, a);\n          }\n          if (!i) return {\n            lineHeight: 12,\n            lineGap: 2,\n            lineNoGap: 10\n          };\n          const a = e.size || 10,\n            s = i.lineHeight ? Math.max(t ? 0 : 1.2, i.lineHeight) : 1.2,\n            r = void 0 === i.lineGap ? .2 : i.lineGap;\n          return {\n            lineHeight: s * a,\n            lineGap: r * a,\n            lineNoGap: Math.max(1, s - r) * a\n          };\n        }(this.font, !0).lineNoGap;\n      }\n      n = getBorderDims(this.ui[lr]());\n      a += n.w;\n      g += n.h;\n      if (this.caption) {\n        const {\n          w: s,\n          h: r,\n          isBroken: n\n        } = this.caption[lr](e);\n        if (n && this[fr]()[Ur]()) {\n          this[Pr]();\n          return HTMLResult.FAILURE;\n        }\n        t = s;\n        i = r;\n        switch (this.caption.placement) {\n          case \"left\":\n          case \"right\":\n          case \"inline\":\n            t += a;\n            break;\n          case \"top\":\n          case \"bottom\":\n            i += g;\n        }\n      } else {\n        t = a;\n        i = g;\n      }\n      if (t && \"\" === this.w) {\n        t += s;\n        this.w = Math.min(this.maxW <= 0 ? 1 / 0 : this.maxW, this.minW + 1 < t ? t : this.minW);\n      }\n      if (i && \"\" === this.h) {\n        i += r;\n        this.h = Math.min(this.maxH <= 0 ? 1 / 0 : this.maxH, this.minH + 1 < i ? i : this.minH);\n      }\n    }\n    this[Pr]();\n    fixDimensions(this);\n    setFirstUnsplittable(this);\n    if (!checkDimensions(this, e)) {\n      this.w = i;\n      this.h = a;\n      this[Pr]();\n      return HTMLResult.FAILURE;\n    }\n    unsetFirstUnsplittable(this);\n    const g = toStyle(this, \"font\", \"dimensions\", \"position\", \"rotate\", \"anchorType\", \"presence\", \"margin\", \"hAlign\");\n    setMinMaxDimensions(this, g);\n    const o = [\"xfaField\"];\n    this.font && o.push(\"xfaFont\");\n    isPrintOnly(this) && o.push(\"xfaPrintOnly\");\n    const c = {\n      style: g,\n      id: this[nn],\n      class: o\n    };\n    if (g.margin) {\n      g.padding = g.margin;\n      delete g.margin;\n    }\n    setAccess(this, o);\n    this.name && (c.xfaName = this.name);\n    const C = [],\n      h = {\n        name: \"div\",\n        attributes: c,\n        children: C\n      };\n    applyAssist(this, c);\n    const l = this.border ? this.border[rn]() : null,\n      Q = computeBbox(this, h, e),\n      E = this.ui[an]().html;\n    if (!E) {\n      Object.assign(g, l);\n      return HTMLResult.success(createWrapper(this, h), Q);\n    }\n    this[An] && (E.children?.[0] ? E.children[0].attributes.tabindex = this[An] : E.attributes.tabindex = this[An]);\n    E.attributes.style || (E.attributes.style = Object.create(null));\n    let u = null;\n    if (this.ui.button) {\n      1 === E.children.length && ([u] = E.children.splice(0, 1));\n      Object.assign(E.attributes.style, l);\n    } else Object.assign(g, l);\n    C.push(E);\n    if (this.value) if (this.ui.imageEdit) E.children.push(this.value[an]().html);else if (!this.ui.button) {\n      let e = \"\";\n      if (this.value.exData) e = this.value.exData[en]();else if (this.value.text) e = this.value.text[lr]();else {\n        const t = this.value[an]().html;\n        null !== t && (e = t.children[0].value);\n      }\n      this.ui.textEdit && this.value.text?.maxChars && (E.children[0].attributes.maxLength = this.value.text.maxChars);\n      if (e) {\n        if (this.ui.numericEdit) {\n          e = parseFloat(e);\n          e = isNaN(e) ? \"\" : e.toString();\n        }\n        \"textarea\" === E.children[0].name ? E.children[0].attributes.textContent = e : E.children[0].attributes.value = e;\n      }\n    }\n    if (!this.ui.imageEdit && E.children?.[0] && this.h) {\n      n = n || getBorderDims(this.ui[lr]());\n      let t = 0;\n      if (this.caption && [\"top\", \"bottom\"].includes(this.caption.placement)) {\n        t = this.caption.reserve;\n        t <= 0 && (t = this.caption[lr](e).h);\n        const i = this.h - t - r - n.h;\n        E.children[0].attributes.style.height = measureToString(i);\n      } else E.children[0].attributes.style.height = \"100%\";\n    }\n    u && E.children.push(u);\n    if (!t) {\n      E.attributes.class && E.attributes.class.push(\"xfaLeft\");\n      this.w = i;\n      this.h = a;\n      return HTMLResult.success(createWrapper(this, h), Q);\n    }\n    if (this.ui.button) {\n      g.padding && delete g.padding;\n      \"div\" === t.name && (t.name = \"span\");\n      E.children.push(t);\n      return HTMLResult.success(h, Q);\n    }\n    this.ui.checkButton && (t.attributes.class[0] = \"xfaCaptionForCheckButton\");\n    E.attributes.class || (E.attributes.class = []);\n    E.children.splice(0, 0, t);\n    switch (this.caption.placement) {\n      case \"left\":\n      case \"inline\":\n        E.attributes.class.push(\"xfaLeft\");\n        break;\n      case \"right\":\n        E.attributes.class.push(\"xfaRight\");\n        break;\n      case \"top\":\n        E.attributes.class.push(\"xfaTop\");\n        break;\n      case \"bottom\":\n        E.attributes.class.push(\"xfaBottom\");\n    }\n    this.w = i;\n    this.h = a;\n    return HTMLResult.success(createWrapper(this, h), Q);\n  }\n}\nclass Fill extends XFAObject {\n  constructor(e) {\n    super(Hn, \"fill\", !0);\n    this.id = e.id || \"\";\n    this.presence = getStringOption(e.presence, [\"visible\", \"hidden\", \"inactive\", \"invisible\"]);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.color = null;\n    this.extras = null;\n    this.linear = null;\n    this.pattern = null;\n    this.radial = null;\n    this.solid = null;\n    this.stipple = null;\n  }\n  [rn]() {\n    const e = this[pr](),\n      t = e[pr]()[pr](),\n      i = Object.create(null);\n    let a = \"color\",\n      s = a;\n    if (e instanceof Border) {\n      a = \"background-color\";\n      s = \"background\";\n      t instanceof Ui && (i.backgroundColor = \"white\");\n    }\n    if (e instanceof Rectangle || e instanceof Arc) {\n      a = s = \"fill\";\n      i.fill = \"white\";\n    }\n    for (const e of Object.getOwnPropertyNames(this)) {\n      if (\"extras\" === e || \"color\" === e) continue;\n      const t = this[e];\n      if (!(t instanceof XFAObject)) continue;\n      const r = t[rn](this.color);\n      r && (i[r.startsWith(\"#\") ? a : s] = r);\n      return i;\n    }\n    if (this.color?.value) {\n      const e = this.color[rn]();\n      i[e.startsWith(\"#\") ? a : s] = e;\n    }\n    return i;\n  }\n}\nclass Filter extends XFAObject {\n  constructor(e) {\n    super(Hn, \"filter\", !0);\n    this.addRevocationInfo = getStringOption(e.addRevocationInfo, [\"\", \"required\", \"optional\", \"none\"]);\n    this.id = e.id || \"\";\n    this.name = e.name || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.version = getInteger({\n      data: this.version,\n      defaultValue: 5,\n      validate: e => e >= 1 && e <= 5\n    });\n    this.appearanceFilter = null;\n    this.certificates = null;\n    this.digestMethods = null;\n    this.encodings = null;\n    this.encryptionMethods = null;\n    this.handler = null;\n    this.lockDocument = null;\n    this.mdp = null;\n    this.reasons = null;\n    this.timeStamp = null;\n  }\n}\nclass Float extends ContentObject {\n  constructor(e) {\n    super(Hn, \"float\");\n    this.id = e.id || \"\";\n    this.name = e.name || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n  [sr]() {\n    const e = parseFloat(this[er].trim());\n    this[er] = isNaN(e) ? null : e;\n  }\n  [an](e) {\n    return valueToHtml(null !== this[er] ? this[er].toString() : \"\");\n  }\n}\nclass template_Font extends XFAObject {\n  constructor(e) {\n    super(Hn, \"font\", !0);\n    this.baselineShift = getMeasurement(e.baselineShift);\n    this.fontHorizontalScale = getFloat({\n      data: e.fontHorizontalScale,\n      defaultValue: 100,\n      validate: e => e >= 0\n    });\n    this.fontVerticalScale = getFloat({\n      data: e.fontVerticalScale,\n      defaultValue: 100,\n      validate: e => e >= 0\n    });\n    this.id = e.id || \"\";\n    this.kerningMode = getStringOption(e.kerningMode, [\"none\", \"pair\"]);\n    this.letterSpacing = getMeasurement(e.letterSpacing, \"0\");\n    this.lineThrough = getInteger({\n      data: e.lineThrough,\n      defaultValue: 0,\n      validate: e => 1 === e || 2 === e\n    });\n    this.lineThroughPeriod = getStringOption(e.lineThroughPeriod, [\"all\", \"word\"]);\n    this.overline = getInteger({\n      data: e.overline,\n      defaultValue: 0,\n      validate: e => 1 === e || 2 === e\n    });\n    this.overlinePeriod = getStringOption(e.overlinePeriod, [\"all\", \"word\"]);\n    this.posture = getStringOption(e.posture, [\"normal\", \"italic\"]);\n    this.size = getMeasurement(e.size, \"10pt\");\n    this.typeface = e.typeface || \"Courier\";\n    this.underline = getInteger({\n      data: e.underline,\n      defaultValue: 0,\n      validate: e => 1 === e || 2 === e\n    });\n    this.underlinePeriod = getStringOption(e.underlinePeriod, [\"all\", \"word\"]);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.weight = getStringOption(e.weight, [\"normal\", \"bold\"]);\n    this.extras = null;\n    this.fill = null;\n  }\n  [Vs](e) {\n    super[Vs](e);\n    this[yr].usedTypefaces.add(this.typeface);\n  }\n  [rn]() {\n    const e = toStyle(this, \"fill\"),\n      t = e.color;\n    if (t) if (\"#000000\" === t) delete e.color;else if (!t.startsWith(\"#\")) {\n      e.background = t;\n      e.backgroundClip = \"text\";\n      e.color = \"transparent\";\n    }\n    this.baselineShift && (e.verticalAlign = measureToString(this.baselineShift));\n    e.fontKerning = \"none\" === this.kerningMode ? \"none\" : \"normal\";\n    e.letterSpacing = measureToString(this.letterSpacing);\n    if (0 !== this.lineThrough) {\n      e.textDecoration = \"line-through\";\n      2 === this.lineThrough && (e.textDecorationStyle = \"double\");\n    }\n    if (0 !== this.overline) {\n      e.textDecoration = \"overline\";\n      2 === this.overline && (e.textDecorationStyle = \"double\");\n    }\n    e.fontStyle = this.posture;\n    e.fontSize = measureToString(.99 * this.size);\n    setFontFamily(this, this, this[yr].fontFinder, e);\n    if (0 !== this.underline) {\n      e.textDecoration = \"underline\";\n      2 === this.underline && (e.textDecorationStyle = \"double\");\n    }\n    e.fontWeight = this.weight;\n    return e;\n  }\n}\nclass Format extends XFAObject {\n  constructor(e) {\n    super(Hn, \"format\", !0);\n    this.id = e.id || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.extras = null;\n    this.picture = null;\n  }\n}\nclass Handler extends StringObject {\n  constructor(e) {\n    super(Hn, \"handler\");\n    this.id = e.id || \"\";\n    this.type = getStringOption(e.type, [\"optional\", \"required\"]);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n}\nclass Hyphenation extends XFAObject {\n  constructor(e) {\n    super(Hn, \"hyphenation\");\n    this.excludeAllCaps = getInteger({\n      data: e.excludeAllCaps,\n      defaultValue: 0,\n      validate: e => 1 === e\n    });\n    this.excludeInitialCap = getInteger({\n      data: e.excludeInitialCap,\n      defaultValue: 0,\n      validate: e => 1 === e\n    });\n    this.hyphenate = getInteger({\n      data: e.hyphenate,\n      defaultValue: 0,\n      validate: e => 1 === e\n    });\n    this.id = e.id || \"\";\n    this.pushCharacterCount = getInteger({\n      data: e.pushCharacterCount,\n      defaultValue: 3,\n      validate: e => e >= 0\n    });\n    this.remainCharacterCount = getInteger({\n      data: e.remainCharacterCount,\n      defaultValue: 3,\n      validate: e => e >= 0\n    });\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.wordCharacterCount = getInteger({\n      data: e.wordCharacterCount,\n      defaultValue: 7,\n      validate: e => e >= 0\n    });\n  }\n}\nclass Image extends StringObject {\n  constructor(e) {\n    super(Hn, \"image\");\n    this.aspect = getStringOption(e.aspect, [\"fit\", \"actual\", \"height\", \"none\", \"width\"]);\n    this.contentType = e.contentType || \"\";\n    this.href = e.href || \"\";\n    this.id = e.id || \"\";\n    this.name = e.name || \"\";\n    this.transferEncoding = getStringOption(e.transferEncoding, [\"base64\", \"none\", \"package\"]);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n  [an]() {\n    if (this.contentType && !vn.has(this.contentType.toLowerCase())) return HTMLResult.EMPTY;\n    let e = this[yr].images && this[yr].images.get(this.href);\n    if (!e && (this.href || !this[er])) return HTMLResult.EMPTY;\n    e || \"base64\" !== this.transferEncoding || (e = stringToBytes(atob(this[er])));\n    if (!e) return HTMLResult.EMPTY;\n    if (!this.contentType) {\n      for (const [t, i] of Kn) if (e.length > t.length && t.every((t, i) => t === e[i])) {\n        this.contentType = i;\n        break;\n      }\n      if (!this.contentType) return HTMLResult.EMPTY;\n    }\n    const t = new Blob([e], {\n      type: this.contentType\n    });\n    let i;\n    switch (this.aspect) {\n      case \"fit\":\n      case \"actual\":\n        break;\n      case \"height\":\n        i = {\n          height: \"100%\",\n          objectFit: \"fill\"\n        };\n        break;\n      case \"none\":\n        i = {\n          width: \"100%\",\n          height: \"100%\",\n          objectFit: \"fill\"\n        };\n        break;\n      case \"width\":\n        i = {\n          width: \"100%\",\n          objectFit: \"fill\"\n        };\n    }\n    const a = this[pr]();\n    return HTMLResult.success({\n      name: \"img\",\n      attributes: {\n        class: [\"xfaImage\"],\n        style: i,\n        src: URL.createObjectURL(t),\n        alt: a ? ariaLabel(a[pr]()) : null\n      }\n    });\n  }\n}\nclass ImageEdit extends XFAObject {\n  constructor(e) {\n    super(Hn, \"imageEdit\", !0);\n    this.data = getStringOption(e.data, [\"link\", \"embed\"]);\n    this.id = e.id || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.border = null;\n    this.extras = null;\n    this.margin = null;\n  }\n  [an](e) {\n    return \"embed\" === this.data ? HTMLResult.success({\n      name: \"div\",\n      children: [],\n      attributes: {}\n    }) : HTMLResult.EMPTY;\n  }\n}\nclass Integer extends ContentObject {\n  constructor(e) {\n    super(Hn, \"integer\");\n    this.id = e.id || \"\";\n    this.name = e.name || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n  [sr]() {\n    const e = parseInt(this[er].trim(), 10);\n    this[er] = isNaN(e) ? null : e;\n  }\n  [an](e) {\n    return valueToHtml(null !== this[er] ? this[er].toString() : \"\");\n  }\n}\nclass Issuers extends XFAObject {\n  constructor(e) {\n    super(Hn, \"issuers\", !0);\n    this.id = e.id || \"\";\n    this.type = getStringOption(e.type, [\"optional\", \"required\"]);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.certificate = new XFAObjectArray();\n  }\n}\nclass Items extends XFAObject {\n  constructor(e) {\n    super(Hn, \"items\", !0);\n    this.id = e.id || \"\";\n    this.name = e.name || \"\";\n    this.presence = getStringOption(e.presence, [\"visible\", \"hidden\", \"inactive\", \"invisible\"]);\n    this.ref = e.ref || \"\";\n    this.save = getInteger({\n      data: e.save,\n      defaultValue: 0,\n      validate: e => 1 === e\n    });\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.boolean = new XFAObjectArray();\n    this.date = new XFAObjectArray();\n    this.dateTime = new XFAObjectArray();\n    this.decimal = new XFAObjectArray();\n    this.exData = new XFAObjectArray();\n    this.float = new XFAObjectArray();\n    this.image = new XFAObjectArray();\n    this.integer = new XFAObjectArray();\n    this.text = new XFAObjectArray();\n    this.time = new XFAObjectArray();\n  }\n  [an]() {\n    const e = [];\n    for (const t of this[Er]()) e.push(t[en]());\n    return HTMLResult.success(e);\n  }\n}\nclass Keep extends XFAObject {\n  constructor(e) {\n    super(Hn, \"keep\", !0);\n    this.id = e.id || \"\";\n    const t = [\"none\", \"contentArea\", \"pageArea\"];\n    this.intact = getStringOption(e.intact, t);\n    this.next = getStringOption(e.next, t);\n    this.previous = getStringOption(e.previous, t);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.extras = null;\n  }\n}\nclass KeyUsage extends XFAObject {\n  constructor(e) {\n    super(Hn, \"keyUsage\");\n    const t = [\"\", \"yes\", \"no\"];\n    this.crlSign = getStringOption(e.crlSign, t);\n    this.dataEncipherment = getStringOption(e.dataEncipherment, t);\n    this.decipherOnly = getStringOption(e.decipherOnly, t);\n    this.digitalSignature = getStringOption(e.digitalSignature, t);\n    this.encipherOnly = getStringOption(e.encipherOnly, t);\n    this.id = e.id || \"\";\n    this.keyAgreement = getStringOption(e.keyAgreement, t);\n    this.keyCertSign = getStringOption(e.keyCertSign, t);\n    this.keyEncipherment = getStringOption(e.keyEncipherment, t);\n    this.nonRepudiation = getStringOption(e.nonRepudiation, t);\n    this.type = getStringOption(e.type, [\"optional\", \"required\"]);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n}\nclass Line extends XFAObject {\n  constructor(e) {\n    super(Hn, \"line\", !0);\n    this.hand = getStringOption(e.hand, [\"even\", \"left\", \"right\"]);\n    this.id = e.id || \"\";\n    this.slope = getStringOption(e.slope, [\"\\\\\", \"/\"]);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.edge = null;\n  }\n  [an]() {\n    const e = this[pr]()[pr](),\n      t = this.edge || new Edge({}),\n      i = t[rn](),\n      a = Object.create(null),\n      s = \"visible\" === t.presence ? t.thickness : 0;\n    a.strokeWidth = measureToString(s);\n    a.stroke = i.color;\n    let r,\n      n,\n      g,\n      o,\n      c = \"100%\",\n      C = \"100%\";\n    if (e.w <= s) {\n      [r, n, g, o] = [\"50%\", 0, \"50%\", \"100%\"];\n      c = a.strokeWidth;\n    } else if (e.h <= s) {\n      [r, n, g, o] = [0, \"50%\", \"100%\", \"50%\"];\n      C = a.strokeWidth;\n    } else \"\\\\\" === this.slope ? [r, n, g, o] = [0, 0, \"100%\", \"100%\"] : [r, n, g, o] = [0, \"100%\", \"100%\", 0];\n    const h = {\n      name: \"svg\",\n      children: [{\n        name: \"line\",\n        attributes: {\n          xmlns: Jn,\n          x1: r,\n          y1: n,\n          x2: g,\n          y2: o,\n          style: a\n        }\n      }],\n      attributes: {\n        xmlns: Jn,\n        width: c,\n        height: C,\n        style: {\n          overflow: \"visible\"\n        }\n      }\n    };\n    if (hasMargin(e)) return HTMLResult.success({\n      name: \"div\",\n      attributes: {\n        style: {\n          display: \"inline\",\n          width: \"100%\",\n          height: \"100%\"\n        }\n      },\n      children: [h]\n    });\n    h.attributes.style.position = \"absolute\";\n    return HTMLResult.success(h);\n  }\n}\nclass Linear extends XFAObject {\n  constructor(e) {\n    super(Hn, \"linear\", !0);\n    this.id = e.id || \"\";\n    this.type = getStringOption(e.type, [\"toRight\", \"toBottom\", \"toLeft\", \"toTop\"]);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.color = null;\n    this.extras = null;\n  }\n  [rn](e) {\n    e = e ? e[rn]() : \"#FFFFFF\";\n    return `linear-gradient(${this.type.replace(/([RBLT])/, \" $1\").toLowerCase()}, ${e}, ${this.color ? this.color[rn]() : \"#000000\"})`;\n  }\n}\nclass LockDocument extends ContentObject {\n  constructor(e) {\n    super(Hn, \"lockDocument\");\n    this.id = e.id || \"\";\n    this.type = getStringOption(e.type, [\"optional\", \"required\"]);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n  [sr]() {\n    this[er] = getStringOption(this[er], [\"auto\", \"0\", \"1\"]);\n  }\n}\nclass Manifest extends XFAObject {\n  constructor(e) {\n    super(Hn, \"manifest\", !0);\n    this.action = getStringOption(e.action, [\"include\", \"all\", \"exclude\"]);\n    this.id = e.id || \"\";\n    this.name = e.name || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.extras = null;\n    this.ref = new XFAObjectArray();\n  }\n}\nclass Margin extends XFAObject {\n  constructor(e) {\n    super(Hn, \"margin\", !0);\n    this.bottomInset = getMeasurement(e.bottomInset, \"0\");\n    this.id = e.id || \"\";\n    this.leftInset = getMeasurement(e.leftInset, \"0\");\n    this.rightInset = getMeasurement(e.rightInset, \"0\");\n    this.topInset = getMeasurement(e.topInset, \"0\");\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.extras = null;\n  }\n  [rn]() {\n    return {\n      margin: measureToString(this.topInset) + \" \" + measureToString(this.rightInset) + \" \" + measureToString(this.bottomInset) + \" \" + measureToString(this.leftInset)\n    };\n  }\n}\nclass Mdp extends XFAObject {\n  constructor(e) {\n    super(Hn, \"mdp\");\n    this.id = e.id || \"\";\n    this.permissions = getInteger({\n      data: e.permissions,\n      defaultValue: 2,\n      validate: e => 1 === e || 3 === e\n    });\n    this.signatureType = getStringOption(e.signatureType, [\"filler\", \"author\"]);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n}\nclass Medium extends XFAObject {\n  constructor(e) {\n    super(Hn, \"medium\");\n    this.id = e.id || \"\";\n    this.imagingBBox = function getBBox(e) {\n      const t = -1;\n      if (!e) return {\n        x: t,\n        y: t,\n        width: t,\n        height: t\n      };\n      const i = e.trim().split(/\\s*,\\s*/).map(e => getMeasurement(e, \"-1\"));\n      if (i.length < 4 || i[2] < 0 || i[3] < 0) return {\n        x: t,\n        y: t,\n        width: t,\n        height: t\n      };\n      const [a, s, r, n] = i;\n      return {\n        x: a,\n        y: s,\n        width: r,\n        height: n\n      };\n    }(e.imagingBBox);\n    this.long = getMeasurement(e.long);\n    this.orientation = getStringOption(e.orientation, [\"portrait\", \"landscape\"]);\n    this.short = getMeasurement(e.short);\n    this.stock = e.stock || \"\";\n    this.trayIn = getStringOption(e.trayIn, [\"auto\", \"delegate\", \"pageFront\"]);\n    this.trayOut = getStringOption(e.trayOut, [\"auto\", \"delegate\"]);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n}\nclass Message extends XFAObject {\n  constructor(e) {\n    super(Hn, \"message\", !0);\n    this.id = e.id || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.text = new XFAObjectArray();\n  }\n}\nclass NumericEdit extends XFAObject {\n  constructor(e) {\n    super(Hn, \"numericEdit\", !0);\n    this.hScrollPolicy = getStringOption(e.hScrollPolicy, [\"auto\", \"off\", \"on\"]);\n    this.id = e.id || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.border = null;\n    this.comb = null;\n    this.extras = null;\n    this.margin = null;\n  }\n  [an](e) {\n    const t = toStyle(this, \"border\", \"font\", \"margin\"),\n      i = this[pr]()[pr](),\n      a = {\n        name: \"input\",\n        attributes: {\n          type: \"text\",\n          fieldId: i[nn],\n          dataId: i[tr]?.[nn] || i[nn],\n          class: [\"xfaTextfield\"],\n          style: t,\n          \"aria-label\": ariaLabel(i),\n          \"aria-required\": !1\n        }\n      };\n    if (isRequired(i)) {\n      a.attributes[\"aria-required\"] = !0;\n      a.attributes.required = !0;\n    }\n    return HTMLResult.success({\n      name: \"label\",\n      attributes: {\n        class: [\"xfaLabel\"]\n      },\n      children: [a]\n    });\n  }\n}\nclass Occur extends XFAObject {\n  constructor(e) {\n    super(Hn, \"occur\", !0);\n    this.id = e.id || \"\";\n    this.initial = \"\" !== e.initial ? getInteger({\n      data: e.initial,\n      defaultValue: \"\",\n      validate: e => !0\n    }) : \"\";\n    this.max = \"\" !== e.max ? getInteger({\n      data: e.max,\n      defaultValue: 1,\n      validate: e => !0\n    }) : \"\";\n    this.min = \"\" !== e.min ? getInteger({\n      data: e.min,\n      defaultValue: 1,\n      validate: e => !0\n    }) : \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.extras = null;\n  }\n  [Vs]() {\n    const e = this[pr](),\n      t = this.min;\n    \"\" === this.min && (this.min = e instanceof PageArea || e instanceof PageSet ? 0 : 1);\n    \"\" === this.max && (this.max = \"\" === t ? e instanceof PageArea || e instanceof PageSet ? -1 : 1 : this.min);\n    -1 !== this.max && this.max < this.min && (this.max = this.min);\n    \"\" === this.initial && (this.initial = e instanceof Template ? 1 : this.min);\n  }\n}\nclass Oid extends StringObject {\n  constructor(e) {\n    super(Hn, \"oid\");\n    this.id = e.id || \"\";\n    this.name = e.name || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n}\nclass Oids extends XFAObject {\n  constructor(e) {\n    super(Hn, \"oids\", !0);\n    this.id = e.id || \"\";\n    this.type = getStringOption(e.type, [\"optional\", \"required\"]);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.oid = new XFAObjectArray();\n  }\n}\nclass Overflow extends XFAObject {\n  constructor(e) {\n    super(Hn, \"overflow\");\n    this.id = e.id || \"\";\n    this.leader = e.leader || \"\";\n    this.target = e.target || \"\";\n    this.trailer = e.trailer || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n  [lr]() {\n    if (!this[ar]) {\n      const e = this[pr](),\n        t = this[mr](),\n        i = t[Vr](this.target, e),\n        a = t[Vr](this.leader, e),\n        s = t[Vr](this.trailer, e);\n      this[ar] = {\n        target: i?.[0] || null,\n        leader: a?.[0] || null,\n        trailer: s?.[0] || null,\n        addLeader: !1,\n        addTrailer: !1\n      };\n    }\n    return this[ar];\n  }\n}\nclass PageArea extends XFAObject {\n  constructor(e) {\n    super(Hn, \"pageArea\", !0);\n    this.blankOrNotBlank = getStringOption(e.blankOrNotBlank, [\"any\", \"blank\", \"notBlank\"]);\n    this.id = e.id || \"\";\n    this.initialNumber = getInteger({\n      data: e.initialNumber,\n      defaultValue: 1,\n      validate: e => !0\n    });\n    this.name = e.name || \"\";\n    this.numbered = getInteger({\n      data: e.numbered,\n      defaultValue: 1,\n      validate: e => !0\n    });\n    this.oddOrEven = getStringOption(e.oddOrEven, [\"any\", \"even\", \"odd\"]);\n    this.pagePosition = getStringOption(e.pagePosition, [\"any\", \"first\", \"last\", \"only\", \"rest\"]);\n    this.relevant = getRelevant(e.relevant);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.desc = null;\n    this.extras = null;\n    this.medium = null;\n    this.occur = null;\n    this.area = new XFAObjectArray();\n    this.contentArea = new XFAObjectArray();\n    this.draw = new XFAObjectArray();\n    this.exclGroup = new XFAObjectArray();\n    this.field = new XFAObjectArray();\n    this.subform = new XFAObjectArray();\n  }\n  [Lr]() {\n    if (!this[ar]) {\n      this[ar] = {\n        numberOfUse: 0\n      };\n      return !0;\n    }\n    return !this.occur || -1 === this.occur.max || this[ar].numberOfUse < this.occur.max;\n  }\n  [zs]() {\n    delete this[ar];\n  }\n  [dr]() {\n    this[ar] || (this[ar] = {\n      numberOfUse: 0\n    });\n    const e = this[pr]();\n    if (\"orderedOccurrence\" === e.relation && this[Lr]()) {\n      this[ar].numberOfUse += 1;\n      return this;\n    }\n    return e[dr]();\n  }\n  [or]() {\n    return this[ar].space || {\n      width: 0,\n      height: 0\n    };\n  }\n  [an]() {\n    this[ar] || (this[ar] = {\n      numberOfUse: 1\n    });\n    const e = [];\n    this[ar].children = e;\n    const t = Object.create(null);\n    if (this.medium && this.medium.short && this.medium.long) {\n      t.width = measureToString(this.medium.short);\n      t.height = measureToString(this.medium.long);\n      this[ar].space = {\n        width: this.medium.short,\n        height: this.medium.long\n      };\n      if (\"landscape\" === this.medium.orientation) {\n        const e = t.width;\n        t.width = t.height;\n        t.height = e;\n        this[ar].space = {\n          width: this.medium.long,\n          height: this.medium.short\n        };\n      }\n    } else warn(\"XFA - No medium specified in pageArea: please file a bug.\");\n    this[Zs]({\n      filter: new Set([\"area\", \"draw\", \"field\", \"subform\"]),\n      include: !0\n    });\n    this[Zs]({\n      filter: new Set([\"contentArea\"]),\n      include: !0\n    });\n    return HTMLResult.success({\n      name: \"div\",\n      children: e,\n      attributes: {\n        class: [\"xfaPage\"],\n        id: this[nn],\n        style: t,\n        xfaName: this.name\n      }\n    });\n  }\n}\nclass PageSet extends XFAObject {\n  constructor(e) {\n    super(Hn, \"pageSet\", !0);\n    this.duplexImposition = getStringOption(e.duplexImposition, [\"longEdge\", \"shortEdge\"]);\n    this.id = e.id || \"\";\n    this.name = e.name || \"\";\n    this.relation = getStringOption(e.relation, [\"orderedOccurrence\", \"duplexPaginated\", \"simplexPaginated\"]);\n    this.relevant = getRelevant(e.relevant);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.extras = null;\n    this.occur = null;\n    this.pageArea = new XFAObjectArray();\n    this.pageSet = new XFAObjectArray();\n  }\n  [zs]() {\n    for (const e of this.pageArea.children) e[zs]();\n    for (const e of this.pageSet.children) e[zs]();\n  }\n  [Lr]() {\n    return !this.occur || -1 === this.occur.max || this[ar].numberOfUse < this.occur.max;\n  }\n  [dr]() {\n    this[ar] || (this[ar] = {\n      numberOfUse: 1,\n      pageIndex: -1,\n      pageSetIndex: -1\n    });\n    if (\"orderedOccurrence\" === this.relation) {\n      if (this[ar].pageIndex + 1 < this.pageArea.children.length) {\n        this[ar].pageIndex += 1;\n        return this.pageArea.children[this[ar].pageIndex][dr]();\n      }\n      if (this[ar].pageSetIndex + 1 < this.pageSet.children.length) {\n        this[ar].pageSetIndex += 1;\n        return this.pageSet.children[this[ar].pageSetIndex][dr]();\n      }\n      if (this[Lr]()) {\n        this[ar].numberOfUse += 1;\n        this[ar].pageIndex = -1;\n        this[ar].pageSetIndex = -1;\n        return this[dr]();\n      }\n      const e = this[pr]();\n      if (e instanceof PageSet) return e[dr]();\n      this[zs]();\n      return this[dr]();\n    }\n    const e = this[mr]()[ar].pageNumber,\n      t = e % 2 == 0 ? \"even\" : \"odd\",\n      i = 0 === e ? \"first\" : \"rest\";\n    let a = this.pageArea.children.find(e => e.oddOrEven === t && e.pagePosition === i);\n    if (a) return a;\n    a = this.pageArea.children.find(e => \"any\" === e.oddOrEven && e.pagePosition === i);\n    if (a) return a;\n    a = this.pageArea.children.find(e => \"any\" === e.oddOrEven && \"any\" === e.pagePosition);\n    return a || this.pageArea.children[0];\n  }\n}\nclass Para extends XFAObject {\n  constructor(e) {\n    super(Hn, \"para\", !0);\n    this.hAlign = getStringOption(e.hAlign, [\"left\", \"center\", \"justify\", \"justifyAll\", \"radix\", \"right\"]);\n    this.id = e.id || \"\";\n    this.lineHeight = e.lineHeight ? getMeasurement(e.lineHeight, \"0pt\") : \"\";\n    this.marginLeft = e.marginLeft ? getMeasurement(e.marginLeft, \"0pt\") : \"\";\n    this.marginRight = e.marginRight ? getMeasurement(e.marginRight, \"0pt\") : \"\";\n    this.orphans = getInteger({\n      data: e.orphans,\n      defaultValue: 0,\n      validate: e => e >= 0\n    });\n    this.preserve = e.preserve || \"\";\n    this.radixOffset = e.radixOffset ? getMeasurement(e.radixOffset, \"0pt\") : \"\";\n    this.spaceAbove = e.spaceAbove ? getMeasurement(e.spaceAbove, \"0pt\") : \"\";\n    this.spaceBelow = e.spaceBelow ? getMeasurement(e.spaceBelow, \"0pt\") : \"\";\n    this.tabDefault = e.tabDefault ? getMeasurement(this.tabDefault) : \"\";\n    this.tabStops = (e.tabStops || \"\").trim().split(/\\s+/).map((e, t) => t % 2 == 1 ? getMeasurement(e) : e);\n    this.textIndent = e.textIndent ? getMeasurement(e.textIndent, \"0pt\") : \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.vAlign = getStringOption(e.vAlign, [\"top\", \"bottom\", \"middle\"]);\n    this.widows = getInteger({\n      data: e.widows,\n      defaultValue: 0,\n      validate: e => e >= 0\n    });\n    this.hyphenation = null;\n  }\n  [rn]() {\n    const e = toStyle(this, \"hAlign\");\n    \"\" !== this.marginLeft && (e.paddingLeft = measureToString(this.marginLeft));\n    \"\" !== this.marginRight && (e.paddingight = measureToString(this.marginRight));\n    \"\" !== this.spaceAbove && (e.paddingTop = measureToString(this.spaceAbove));\n    \"\" !== this.spaceBelow && (e.paddingBottom = measureToString(this.spaceBelow));\n    if (\"\" !== this.textIndent) {\n      e.textIndent = measureToString(this.textIndent);\n      fixTextIndent(e);\n    }\n    this.lineHeight > 0 && (e.lineHeight = measureToString(this.lineHeight));\n    \"\" !== this.tabDefault && (e.tabSize = measureToString(this.tabDefault));\n    this.tabStops.length;\n    this.hyphenatation && Object.assign(e, this.hyphenatation[rn]());\n    return e;\n  }\n}\nclass PasswordEdit extends XFAObject {\n  constructor(e) {\n    super(Hn, \"passwordEdit\", !0);\n    this.hScrollPolicy = getStringOption(e.hScrollPolicy, [\"auto\", \"off\", \"on\"]);\n    this.id = e.id || \"\";\n    this.passwordChar = e.passwordChar || \"*\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.border = null;\n    this.extras = null;\n    this.margin = null;\n  }\n}\nclass template_Pattern extends XFAObject {\n  constructor(e) {\n    super(Hn, \"pattern\", !0);\n    this.id = e.id || \"\";\n    this.type = getStringOption(e.type, [\"crossHatch\", \"crossDiagonal\", \"diagonalLeft\", \"diagonalRight\", \"horizontal\", \"vertical\"]);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.color = null;\n    this.extras = null;\n  }\n  [rn](e) {\n    e = e ? e[rn]() : \"#FFFFFF\";\n    const t = this.color ? this.color[rn]() : \"#000000\",\n      i = \"repeating-linear-gradient\",\n      a = `${e},${e} 5px,${t} 5px,${t} 10px`;\n    switch (this.type) {\n      case \"crossHatch\":\n        return `${i}(to top,${a}) ${i}(to right,${a})`;\n      case \"crossDiagonal\":\n        return `${i}(45deg,${a}) ${i}(-45deg,${a})`;\n      case \"diagonalLeft\":\n        return `${i}(45deg,${a})`;\n      case \"diagonalRight\":\n        return `${i}(-45deg,${a})`;\n      case \"horizontal\":\n        return `${i}(to top,${a})`;\n      case \"vertical\":\n        return `${i}(to right,${a})`;\n    }\n    return \"\";\n  }\n}\nclass Picture extends StringObject {\n  constructor(e) {\n    super(Hn, \"picture\");\n    this.id = e.id || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n}\nclass Proto extends XFAObject {\n  constructor(e) {\n    super(Hn, \"proto\", !0);\n    this.appearanceFilter = new XFAObjectArray();\n    this.arc = new XFAObjectArray();\n    this.area = new XFAObjectArray();\n    this.assist = new XFAObjectArray();\n    this.barcode = new XFAObjectArray();\n    this.bindItems = new XFAObjectArray();\n    this.bookend = new XFAObjectArray();\n    this.boolean = new XFAObjectArray();\n    this.border = new XFAObjectArray();\n    this.break = new XFAObjectArray();\n    this.breakAfter = new XFAObjectArray();\n    this.breakBefore = new XFAObjectArray();\n    this.button = new XFAObjectArray();\n    this.calculate = new XFAObjectArray();\n    this.caption = new XFAObjectArray();\n    this.certificate = new XFAObjectArray();\n    this.certificates = new XFAObjectArray();\n    this.checkButton = new XFAObjectArray();\n    this.choiceList = new XFAObjectArray();\n    this.color = new XFAObjectArray();\n    this.comb = new XFAObjectArray();\n    this.connect = new XFAObjectArray();\n    this.contentArea = new XFAObjectArray();\n    this.corner = new XFAObjectArray();\n    this.date = new XFAObjectArray();\n    this.dateTime = new XFAObjectArray();\n    this.dateTimeEdit = new XFAObjectArray();\n    this.decimal = new XFAObjectArray();\n    this.defaultUi = new XFAObjectArray();\n    this.desc = new XFAObjectArray();\n    this.digestMethod = new XFAObjectArray();\n    this.digestMethods = new XFAObjectArray();\n    this.draw = new XFAObjectArray();\n    this.edge = new XFAObjectArray();\n    this.encoding = new XFAObjectArray();\n    this.encodings = new XFAObjectArray();\n    this.encrypt = new XFAObjectArray();\n    this.encryptData = new XFAObjectArray();\n    this.encryption = new XFAObjectArray();\n    this.encryptionMethod = new XFAObjectArray();\n    this.encryptionMethods = new XFAObjectArray();\n    this.event = new XFAObjectArray();\n    this.exData = new XFAObjectArray();\n    this.exObject = new XFAObjectArray();\n    this.exclGroup = new XFAObjectArray();\n    this.execute = new XFAObjectArray();\n    this.extras = new XFAObjectArray();\n    this.field = new XFAObjectArray();\n    this.fill = new XFAObjectArray();\n    this.filter = new XFAObjectArray();\n    this.float = new XFAObjectArray();\n    this.font = new XFAObjectArray();\n    this.format = new XFAObjectArray();\n    this.handler = new XFAObjectArray();\n    this.hyphenation = new XFAObjectArray();\n    this.image = new XFAObjectArray();\n    this.imageEdit = new XFAObjectArray();\n    this.integer = new XFAObjectArray();\n    this.issuers = new XFAObjectArray();\n    this.items = new XFAObjectArray();\n    this.keep = new XFAObjectArray();\n    this.keyUsage = new XFAObjectArray();\n    this.line = new XFAObjectArray();\n    this.linear = new XFAObjectArray();\n    this.lockDocument = new XFAObjectArray();\n    this.manifest = new XFAObjectArray();\n    this.margin = new XFAObjectArray();\n    this.mdp = new XFAObjectArray();\n    this.medium = new XFAObjectArray();\n    this.message = new XFAObjectArray();\n    this.numericEdit = new XFAObjectArray();\n    this.occur = new XFAObjectArray();\n    this.oid = new XFAObjectArray();\n    this.oids = new XFAObjectArray();\n    this.overflow = new XFAObjectArray();\n    this.pageArea = new XFAObjectArray();\n    this.pageSet = new XFAObjectArray();\n    this.para = new XFAObjectArray();\n    this.passwordEdit = new XFAObjectArray();\n    this.pattern = new XFAObjectArray();\n    this.picture = new XFAObjectArray();\n    this.radial = new XFAObjectArray();\n    this.reason = new XFAObjectArray();\n    this.reasons = new XFAObjectArray();\n    this.rectangle = new XFAObjectArray();\n    this.ref = new XFAObjectArray();\n    this.script = new XFAObjectArray();\n    this.setProperty = new XFAObjectArray();\n    this.signData = new XFAObjectArray();\n    this.signature = new XFAObjectArray();\n    this.signing = new XFAObjectArray();\n    this.solid = new XFAObjectArray();\n    this.speak = new XFAObjectArray();\n    this.stipple = new XFAObjectArray();\n    this.subform = new XFAObjectArray();\n    this.subformSet = new XFAObjectArray();\n    this.subjectDN = new XFAObjectArray();\n    this.subjectDNs = new XFAObjectArray();\n    this.submit = new XFAObjectArray();\n    this.text = new XFAObjectArray();\n    this.textEdit = new XFAObjectArray();\n    this.time = new XFAObjectArray();\n    this.timeStamp = new XFAObjectArray();\n    this.toolTip = new XFAObjectArray();\n    this.traversal = new XFAObjectArray();\n    this.traverse = new XFAObjectArray();\n    this.ui = new XFAObjectArray();\n    this.validate = new XFAObjectArray();\n    this.value = new XFAObjectArray();\n    this.variables = new XFAObjectArray();\n  }\n}\nclass Radial extends XFAObject {\n  constructor(e) {\n    super(Hn, \"radial\", !0);\n    this.id = e.id || \"\";\n    this.type = getStringOption(e.type, [\"toEdge\", \"toCenter\"]);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.color = null;\n    this.extras = null;\n  }\n  [rn](e) {\n    e = e ? e[rn]() : \"#FFFFFF\";\n    const t = this.color ? this.color[rn]() : \"#000000\";\n    return `radial-gradient(circle at center, ${\"toEdge\" === this.type ? `${e},${t}` : `${t},${e}`})`;\n  }\n}\nclass Reason extends StringObject {\n  constructor(e) {\n    super(Hn, \"reason\");\n    this.id = e.id || \"\";\n    this.name = e.name || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n}\nclass Reasons extends XFAObject {\n  constructor(e) {\n    super(Hn, \"reasons\", !0);\n    this.id = e.id || \"\";\n    this.type = getStringOption(e.type, [\"optional\", \"required\"]);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.reason = new XFAObjectArray();\n  }\n}\nclass Rectangle extends XFAObject {\n  constructor(e) {\n    super(Hn, \"rectangle\", !0);\n    this.hand = getStringOption(e.hand, [\"even\", \"left\", \"right\"]);\n    this.id = e.id || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.corner = new XFAObjectArray(4);\n    this.edge = new XFAObjectArray(4);\n    this.fill = null;\n  }\n  [an]() {\n    const e = this.edge.children.length ? this.edge.children[0] : new Edge({}),\n      t = e[rn](),\n      i = Object.create(null);\n    \"visible\" === this.fill?.presence ? Object.assign(i, this.fill[rn]()) : i.fill = \"transparent\";\n    i.strokeWidth = measureToString(\"visible\" === e.presence ? e.thickness : 0);\n    i.stroke = t.color;\n    const a = (this.corner.children.length ? this.corner.children[0] : new Corner({}))[rn](),\n      s = {\n        name: \"svg\",\n        children: [{\n          name: \"rect\",\n          attributes: {\n            xmlns: Jn,\n            width: \"100%\",\n            height: \"100%\",\n            x: 0,\n            y: 0,\n            rx: a.radius,\n            ry: a.radius,\n            style: i\n          }\n        }],\n        attributes: {\n          xmlns: Jn,\n          style: {\n            overflow: \"visible\"\n          },\n          width: \"100%\",\n          height: \"100%\"\n        }\n      };\n    if (hasMargin(this[pr]()[pr]())) return HTMLResult.success({\n      name: \"div\",\n      attributes: {\n        style: {\n          display: \"inline\",\n          width: \"100%\",\n          height: \"100%\"\n        }\n      },\n      children: [s]\n    });\n    s.attributes.style.position = \"absolute\";\n    return HTMLResult.success(s);\n  }\n}\nclass RefElement extends StringObject {\n  constructor(e) {\n    super(Hn, \"ref\");\n    this.id = e.id || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n}\nclass Script extends StringObject {\n  constructor(e) {\n    super(Hn, \"script\");\n    this.binding = e.binding || \"\";\n    this.contentType = e.contentType || \"\";\n    this.id = e.id || \"\";\n    this.name = e.name || \"\";\n    this.runAt = getStringOption(e.runAt, [\"client\", \"both\", \"server\"]);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n}\nclass SetProperty extends XFAObject {\n  constructor(e) {\n    super(Hn, \"setProperty\");\n    this.connection = e.connection || \"\";\n    this.ref = e.ref || \"\";\n    this.target = e.target || \"\";\n  }\n}\nclass SignData extends XFAObject {\n  constructor(e) {\n    super(Hn, \"signData\", !0);\n    this.id = e.id || \"\";\n    this.operation = getStringOption(e.operation, [\"sign\", \"clear\", \"verify\"]);\n    this.ref = e.ref || \"\";\n    this.target = e.target || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.filter = null;\n    this.manifest = null;\n  }\n}\nclass Signature extends XFAObject {\n  constructor(e) {\n    super(Hn, \"signature\", !0);\n    this.id = e.id || \"\";\n    this.type = getStringOption(e.type, [\"PDF1.3\", \"PDF1.6\"]);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.border = null;\n    this.extras = null;\n    this.filter = null;\n    this.manifest = null;\n    this.margin = null;\n  }\n}\nclass Signing extends XFAObject {\n  constructor(e) {\n    super(Hn, \"signing\", !0);\n    this.id = e.id || \"\";\n    this.type = getStringOption(e.type, [\"optional\", \"required\"]);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.certificate = new XFAObjectArray();\n  }\n}\nclass Solid extends XFAObject {\n  constructor(e) {\n    super(Hn, \"solid\", !0);\n    this.id = e.id || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.extras = null;\n  }\n  [rn](e) {\n    return e ? e[rn]() : \"#FFFFFF\";\n  }\n}\nclass Speak extends StringObject {\n  constructor(e) {\n    super(Hn, \"speak\");\n    this.disable = getInteger({\n      data: e.disable,\n      defaultValue: 0,\n      validate: e => 1 === e\n    });\n    this.id = e.id || \"\";\n    this.priority = getStringOption(e.priority, [\"custom\", \"caption\", \"name\", \"toolTip\"]);\n    this.rid = e.rid || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n}\nclass Stipple extends XFAObject {\n  constructor(e) {\n    super(Hn, \"stipple\", !0);\n    this.id = e.id || \"\";\n    this.rate = getInteger({\n      data: e.rate,\n      defaultValue: 50,\n      validate: e => e >= 0 && e <= 100\n    });\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.color = null;\n    this.extras = null;\n  }\n  [rn](e) {\n    const t = this.rate / 100;\n    return Util.makeHexColor(Math.round(e.value.r * (1 - t) + this.value.r * t), Math.round(e.value.g * (1 - t) + this.value.g * t), Math.round(e.value.b * (1 - t) + this.value.b * t));\n  }\n}\nclass Subform extends XFAObject {\n  constructor(e) {\n    super(Hn, \"subform\", !0);\n    this.access = getStringOption(e.access, [\"open\", \"nonInteractive\", \"protected\", \"readOnly\"]);\n    this.allowMacro = getInteger({\n      data: e.allowMacro,\n      defaultValue: 0,\n      validate: e => 1 === e\n    });\n    this.anchorType = getStringOption(e.anchorType, [\"topLeft\", \"bottomCenter\", \"bottomLeft\", \"bottomRight\", \"middleCenter\", \"middleLeft\", \"middleRight\", \"topCenter\", \"topRight\"]);\n    this.colSpan = getInteger({\n      data: e.colSpan,\n      defaultValue: 1,\n      validate: e => e >= 1 || -1 === e\n    });\n    this.columnWidths = (e.columnWidths || \"\").trim().split(/\\s+/).map(e => \"-1\" === e ? -1 : getMeasurement(e));\n    this.h = e.h ? getMeasurement(e.h) : \"\";\n    this.hAlign = getStringOption(e.hAlign, [\"left\", \"center\", \"justify\", \"justifyAll\", \"radix\", \"right\"]);\n    this.id = e.id || \"\";\n    this.layout = getStringOption(e.layout, [\"position\", \"lr-tb\", \"rl-row\", \"rl-tb\", \"row\", \"table\", \"tb\"]);\n    this.locale = e.locale || \"\";\n    this.maxH = getMeasurement(e.maxH, \"0pt\");\n    this.maxW = getMeasurement(e.maxW, \"0pt\");\n    this.mergeMode = getStringOption(e.mergeMode, [\"consumeData\", \"matchTemplate\"]);\n    this.minH = getMeasurement(e.minH, \"0pt\");\n    this.minW = getMeasurement(e.minW, \"0pt\");\n    this.name = e.name || \"\";\n    this.presence = getStringOption(e.presence, [\"visible\", \"hidden\", \"inactive\", \"invisible\"]);\n    this.relevant = getRelevant(e.relevant);\n    this.restoreState = getStringOption(e.restoreState, [\"manual\", \"auto\"]);\n    this.scope = getStringOption(e.scope, [\"name\", \"none\"]);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.w = e.w ? getMeasurement(e.w) : \"\";\n    this.x = getMeasurement(e.x, \"0pt\");\n    this.y = getMeasurement(e.y, \"0pt\");\n    this.assist = null;\n    this.bind = null;\n    this.bookend = null;\n    this.border = null;\n    this.break = null;\n    this.calculate = null;\n    this.desc = null;\n    this.extras = null;\n    this.keep = null;\n    this.margin = null;\n    this.occur = null;\n    this.overflow = null;\n    this.pageSet = null;\n    this.para = null;\n    this.traversal = null;\n    this.validate = null;\n    this.variables = null;\n    this.area = new XFAObjectArray();\n    this.breakAfter = new XFAObjectArray();\n    this.breakBefore = new XFAObjectArray();\n    this.connect = new XFAObjectArray();\n    this.draw = new XFAObjectArray();\n    this.event = new XFAObjectArray();\n    this.exObject = new XFAObjectArray();\n    this.exclGroup = new XFAObjectArray();\n    this.field = new XFAObjectArray();\n    this.proto = new XFAObjectArray();\n    this.setProperty = new XFAObjectArray();\n    this.subform = new XFAObjectArray();\n    this.subformSet = new XFAObjectArray();\n  }\n  [fr]() {\n    const e = this[pr]();\n    return e instanceof SubformSet ? e[fr]() : e;\n  }\n  [kr]() {\n    return !0;\n  }\n  [Ur]() {\n    return this.layout.endsWith(\"-tb\") && 0 === this[ar].attempt && this[ar].numberInLine > 0 || this[pr]()[Ur]();\n  }\n  *[ur]() {\n    yield* getContainedChildren(this);\n  }\n  [rr]() {\n    return flushHTML(this);\n  }\n  [js](e, t) {\n    addHTML(this, e, t);\n  }\n  [or]() {\n    return getAvailableSpace(this);\n  }\n  [xr]() {\n    const e = this[fr]();\n    if (!e[xr]()) return !1;\n    if (void 0 !== this[ar]._isSplittable) return this[ar]._isSplittable;\n    if (\"position\" === this.layout || this.layout.includes(\"row\")) {\n      this[ar]._isSplittable = !1;\n      return !1;\n    }\n    if (this.keep && \"none\" !== this.keep.intact) {\n      this[ar]._isSplittable = !1;\n      return !1;\n    }\n    if (e.layout?.endsWith(\"-tb\") && 0 !== e[ar].numberInLine) return !1;\n    this[ar]._isSplittable = !0;\n    return !0;\n  }\n  [an](e) {\n    setTabIndex(this);\n    if (this.break) {\n      if (\"auto\" !== this.break.after || \"\" !== this.break.afterTarget) {\n        const e = new BreakAfter({\n          targetType: this.break.after,\n          target: this.break.afterTarget,\n          startNew: this.break.startNew.toString()\n        });\n        e[yr] = this[yr];\n        this[Xs](e);\n        this.breakAfter.push(e);\n      }\n      if (\"auto\" !== this.break.before || \"\" !== this.break.beforeTarget) {\n        const e = new BreakBefore({\n          targetType: this.break.before,\n          target: this.break.beforeTarget,\n          startNew: this.break.startNew.toString()\n        });\n        e[yr] = this[yr];\n        this[Xs](e);\n        this.breakBefore.push(e);\n      }\n      if (\"\" !== this.break.overflowTarget) {\n        const e = new Overflow({\n          target: this.break.overflowTarget,\n          leader: this.break.overflowLeader,\n          trailer: this.break.overflowTrailer\n        });\n        e[yr] = this[yr];\n        this[Xs](e);\n        this.overflow.push(e);\n      }\n      this[jr](this.break);\n      this.break = null;\n    }\n    if (\"hidden\" === this.presence || \"inactive\" === this.presence) return HTMLResult.EMPTY;\n    (this.breakBefore.children.length > 1 || this.breakAfter.children.length > 1) && warn(\"XFA - Several breakBefore or breakAfter in subforms: please file a bug.\");\n    if (this.breakBefore.children.length >= 1) {\n      const e = this.breakBefore.children[0];\n      if (handleBreak(e)) return HTMLResult.breakNode(e);\n    }\n    if (this[ar]?.afterBreakAfter) return HTMLResult.EMPTY;\n    fixDimensions(this);\n    const t = [],\n      i = {\n        id: this[nn],\n        class: []\n      };\n    setAccess(this, i.class);\n    this[ar] || (this[ar] = Object.create(null));\n    Object.assign(this[ar], {\n      children: t,\n      line: null,\n      attributes: i,\n      attempt: 0,\n      numberInLine: 0,\n      availableSpace: {\n        width: Math.min(this.w || 1 / 0, e.width),\n        height: Math.min(this.h || 1 / 0, e.height)\n      },\n      width: 0,\n      height: 0,\n      prevHeight: 0,\n      currentWidth: 0\n    });\n    const a = this[mr](),\n      s = a[ar].noLayoutFailure,\n      r = this[xr]();\n    r || setFirstUnsplittable(this);\n    if (!checkDimensions(this, e)) return HTMLResult.FAILURE;\n    const n = new Set([\"area\", \"draw\", \"exclGroup\", \"field\", \"subform\", \"subformSet\"]);\n    if (this.layout.includes(\"row\")) {\n      const e = this[fr]().columnWidths;\n      if (Array.isArray(e) && e.length > 0) {\n        this[ar].columnWidths = e;\n        this[ar].currentColumn = 0;\n      }\n    }\n    const g = toStyle(this, \"anchorType\", \"dimensions\", \"position\", \"presence\", \"border\", \"margin\", \"hAlign\"),\n      o = [\"xfaSubform\"],\n      c = layoutClass(this);\n    c && o.push(c);\n    i.style = g;\n    i.class = o;\n    this.name && (i.xfaName = this.name);\n    if (this.overflow) {\n      const t = this.overflow[lr]();\n      if (t.addLeader) {\n        t.addLeader = !1;\n        handleOverflow(this, t.leader, e);\n      }\n    }\n    this[Wr]();\n    const C = \"lr-tb\" === this.layout || \"rl-tb\" === this.layout,\n      h = C ? 2 : 1;\n    for (; this[ar].attempt < h; this[ar].attempt++) {\n      C && 1 === this[ar].attempt && (this[ar].numberInLine = 0);\n      const e = this[Zs]({\n        filter: n,\n        include: !0\n      });\n      if (e.success) break;\n      if (e.isBreak()) {\n        this[Pr]();\n        return e;\n      }\n      if (C && 0 === this[ar].attempt && 0 === this[ar].numberInLine && !a[ar].noLayoutFailure) {\n        this[ar].attempt = h;\n        break;\n      }\n    }\n    this[Pr]();\n    r || unsetFirstUnsplittable(this);\n    a[ar].noLayoutFailure = s;\n    if (this[ar].attempt === h) {\n      this.overflow && (this[mr]()[ar].overflowNode = this.overflow);\n      r || delete this[ar];\n      return HTMLResult.FAILURE;\n    }\n    if (this.overflow) {\n      const t = this.overflow[lr]();\n      if (t.addTrailer) {\n        t.addTrailer = !1;\n        handleOverflow(this, t.trailer, e);\n      }\n    }\n    let l = 0,\n      Q = 0;\n    if (this.margin) {\n      l = this.margin.leftInset + this.margin.rightInset;\n      Q = this.margin.topInset + this.margin.bottomInset;\n    }\n    const E = Math.max(this[ar].width + l, this.w || 0),\n      u = Math.max(this[ar].height + Q, this.h || 0),\n      d = [this.x, this.y, E, u];\n    \"\" === this.w && (g.width = measureToString(E));\n    \"\" === this.h && (g.height = measureToString(u));\n    if ((\"0px\" === g.width || \"0px\" === g.height) && 0 === t.length) return HTMLResult.EMPTY;\n    const f = {\n      name: \"div\",\n      attributes: i,\n      children: t\n    };\n    applyAssist(this, i);\n    const p = HTMLResult.success(createWrapper(this, f), d);\n    if (this.breakAfter.children.length >= 1) {\n      const e = this.breakAfter.children[0];\n      if (handleBreak(e)) {\n        this[ar].afterBreakAfter = p;\n        return HTMLResult.breakNode(e);\n      }\n    }\n    delete this[ar];\n    return p;\n  }\n}\nclass SubformSet extends XFAObject {\n  constructor(e) {\n    super(Hn, \"subformSet\", !0);\n    this.id = e.id || \"\";\n    this.name = e.name || \"\";\n    this.relation = getStringOption(e.relation, [\"ordered\", \"choice\", \"unordered\"]);\n    this.relevant = getRelevant(e.relevant);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.bookend = null;\n    this.break = null;\n    this.desc = null;\n    this.extras = null;\n    this.occur = null;\n    this.overflow = null;\n    this.breakAfter = new XFAObjectArray();\n    this.breakBefore = new XFAObjectArray();\n    this.subform = new XFAObjectArray();\n    this.subformSet = new XFAObjectArray();\n  }\n  *[ur]() {\n    yield* getContainedChildren(this);\n  }\n  [fr]() {\n    let e = this[pr]();\n    for (; !(e instanceof Subform);) e = e[pr]();\n    return e;\n  }\n  [kr]() {\n    return !0;\n  }\n}\nclass SubjectDN extends ContentObject {\n  constructor(e) {\n    super(Hn, \"subjectDN\");\n    this.delimiter = e.delimiter || \",\";\n    this.id = e.id || \"\";\n    this.name = e.name || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n  [sr]() {\n    this[er] = new Map(this[er].split(this.delimiter).map(e => {\n      (e = e.split(\"=\", 2))[0] = e[0].trim();\n      return e;\n    }));\n  }\n}\nclass SubjectDNs extends XFAObject {\n  constructor(e) {\n    super(Hn, \"subjectDNs\", !0);\n    this.id = e.id || \"\";\n    this.type = getStringOption(e.type, [\"optional\", \"required\"]);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.subjectDN = new XFAObjectArray();\n  }\n}\nclass Submit extends XFAObject {\n  constructor(e) {\n    super(Hn, \"submit\", !0);\n    this.embedPDF = getInteger({\n      data: e.embedPDF,\n      defaultValue: 0,\n      validate: e => 1 === e\n    });\n    this.format = getStringOption(e.format, [\"xdp\", \"formdata\", \"pdf\", \"urlencoded\", \"xfd\", \"xml\"]);\n    this.id = e.id || \"\";\n    this.target = e.target || \"\";\n    this.textEncoding = getKeyword({\n      data: e.textEncoding ? e.textEncoding.toLowerCase() : \"\",\n      defaultValue: \"\",\n      validate: e => [\"utf-8\", \"big-five\", \"fontspecific\", \"gbk\", \"gb-18030\", \"gb-2312\", \"ksc-5601\", \"none\", \"shift-jis\", \"ucs-2\", \"utf-16\"].includes(e) || e.match(/iso-8859-\\d{2}/)\n    });\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.xdpContent = e.xdpContent || \"\";\n    this.encrypt = null;\n    this.encryptData = new XFAObjectArray();\n    this.signData = new XFAObjectArray();\n  }\n}\nclass Template extends XFAObject {\n  constructor(e) {\n    super(Hn, \"template\", !0);\n    this.baseProfile = getStringOption(e.baseProfile, [\"full\", \"interactiveForms\"]);\n    this.extras = null;\n    this.subform = new XFAObjectArray();\n  }\n  [sr]() {\n    0 === this.subform.children.length && warn(\"XFA - No subforms in template node.\");\n    this.subform.children.length >= 2 && warn(\"XFA - Several subforms in template node: please file a bug.\");\n    this[An] = 5e3;\n  }\n  [xr]() {\n    return !0;\n  }\n  [Vr](e, t) {\n    return e.startsWith(\"#\") ? [this[Dr].get(e.slice(1))] : searchNode(this, t, e, !0, !0);\n  }\n  *[tn]() {\n    if (!this.subform.children.length) return HTMLResult.success({\n      name: \"div\",\n      children: []\n    });\n    this[ar] = {\n      overflowNode: null,\n      firstUnsplittable: null,\n      currentContentArea: null,\n      currentPageArea: null,\n      noLayoutFailure: !1,\n      pageNumber: 1,\n      pagePosition: \"first\",\n      oddOrEven: \"odd\",\n      blankOrNotBlank: \"nonBlank\",\n      paraStack: []\n    };\n    const e = this.subform.children[0];\n    e.pageSet[zs]();\n    const t = e.pageSet.pageArea.children,\n      i = {\n        name: \"div\",\n        children: []\n      };\n    let a = null,\n      s = null,\n      r = null;\n    if (e.breakBefore.children.length >= 1) {\n      s = e.breakBefore.children[0];\n      r = s.target;\n    } else if (e.subform.children.length >= 1 && e.subform.children[0].breakBefore.children.length >= 1) {\n      s = e.subform.children[0].breakBefore.children[0];\n      r = s.target;\n    } else if (e.break?.beforeTarget) {\n      s = e.break;\n      r = s.beforeTarget;\n    } else if (e.subform.children.length >= 1 && e.subform.children[0].break?.beforeTarget) {\n      s = e.subform.children[0].break;\n      r = s.beforeTarget;\n    }\n    if (s) {\n      const e = this[Vr](r, s[pr]());\n      if (e instanceof PageArea) {\n        a = e;\n        s[ar] = {};\n      }\n    }\n    a || (a = t[0]);\n    a[ar] = {\n      numberOfUse: 1\n    };\n    const n = a[pr]();\n    n[ar] = {\n      numberOfUse: 1,\n      pageIndex: n.pageArea.children.indexOf(a),\n      pageSetIndex: 0\n    };\n    let g,\n      o = null,\n      c = null,\n      C = !0,\n      h = 0,\n      l = 0;\n    for (;;) {\n      if (C) h = 0;else {\n        i.children.pop();\n        if (3 == ++h) {\n          warn(\"XFA - Something goes wrong: please file a bug.\");\n          return i;\n        }\n      }\n      g = null;\n      this[ar].currentPageArea = a;\n      const t = a[an]().html;\n      i.children.push(t);\n      if (o) {\n        this[ar].noLayoutFailure = !0;\n        t.children.push(o[an](a[ar].space).html);\n        o = null;\n      }\n      if (c) {\n        this[ar].noLayoutFailure = !0;\n        t.children.push(c[an](a[ar].space).html);\n        c = null;\n      }\n      const s = a.contentArea.children,\n        r = t.children.filter(e => e.attributes.class.includes(\"xfaContentarea\"));\n      C = !1;\n      this[ar].firstUnsplittable = null;\n      this[ar].noLayoutFailure = !1;\n      const flush = t => {\n        const i = e[rr]();\n        if (i) {\n          C ||= i.children?.length > 0;\n          r[t].children.push(i);\n        }\n      };\n      for (let t = l, a = s.length; t < a; t++) {\n        const a = this[ar].currentContentArea = s[t],\n          n = {\n            width: a.w,\n            height: a.h\n          };\n        l = 0;\n        if (o) {\n          r[t].children.push(o[an](n).html);\n          o = null;\n        }\n        if (c) {\n          r[t].children.push(c[an](n).html);\n          c = null;\n        }\n        const h = e[an](n);\n        if (h.success) {\n          if (h.html) {\n            C ||= h.html.children?.length > 0;\n            r[t].children.push(h.html);\n          } else !C && i.children.length > 1 && i.children.pop();\n          return i;\n        }\n        if (h.isBreak()) {\n          const e = h.breakNode;\n          flush(t);\n          if (\"auto\" === e.targetType) continue;\n          if (e.leader) {\n            o = this[Vr](e.leader, e[pr]());\n            o = o ? o[0] : null;\n          }\n          if (e.trailer) {\n            c = this[Vr](e.trailer, e[pr]());\n            c = c ? c[0] : null;\n          }\n          if (\"pageArea\" === e.targetType) {\n            g = e[ar].target;\n            t = 1 / 0;\n          } else if (e[ar].target) {\n            g = e[ar].target;\n            l = e[ar].index + 1;\n            t = 1 / 0;\n          } else t = e[ar].index;\n        } else if (this[ar].overflowNode) {\n          const e = this[ar].overflowNode;\n          this[ar].overflowNode = null;\n          const i = e[lr](),\n            a = i.target;\n          i.addLeader = null !== i.leader;\n          i.addTrailer = null !== i.trailer;\n          flush(t);\n          const r = t;\n          t = 1 / 0;\n          if (a instanceof PageArea) g = a;else if (a instanceof ContentArea) {\n            const e = s.indexOf(a);\n            if (-1 !== e) e > r ? t = e - 1 : l = e;else {\n              g = a[pr]();\n              l = g.contentArea.children.indexOf(a);\n            }\n          }\n        } else flush(t);\n      }\n      this[ar].pageNumber += 1;\n      g && (g[Lr]() ? g[ar].numberOfUse += 1 : g = null);\n      a = g || a[dr]();\n      yield null;\n    }\n  }\n}\nclass Text extends ContentObject {\n  constructor(e) {\n    super(Hn, \"text\");\n    this.id = e.id || \"\";\n    this.maxChars = getInteger({\n      data: e.maxChars,\n      defaultValue: 0,\n      validate: e => e >= 0\n    });\n    this.name = e.name || \"\";\n    this.rid = e.rid || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n  [Ws]() {\n    return !0;\n  }\n  [Kr](e) {\n    if (e[Jr] === on.xhtml.id) {\n      this[er] = e;\n      return !0;\n    }\n    warn(`XFA - Invalid content in Text: ${e[Yr]}.`);\n    return !1;\n  }\n  [qr](e) {\n    this[er] instanceof XFAObject || super[qr](e);\n  }\n  [sr]() {\n    \"string\" == typeof this[er] && (this[er] = this[er].replaceAll(\"\\r\\n\", \"\\n\"));\n  }\n  [lr]() {\n    return \"string\" == typeof this[er] ? this[er].split(/[\\u2029\\u2028\\n]/).reduce((e, t) => {\n      t && e.push(t);\n      return e;\n    }, []).join(\"\\n\") : this[er][en]();\n  }\n  [an](e) {\n    if (\"string\" == typeof this[er]) {\n      const e = valueToHtml(this[er]).html;\n      if (this[er].includes(\"\\u2029\")) {\n        e.name = \"div\";\n        e.children = [];\n        this[er].split(\"\\u2029\").map(e => e.split(/[\\u2028\\n]/).reduce((e, t) => {\n          e.push({\n            name: \"span\",\n            value: t\n          }, {\n            name: \"br\"\n          });\n          return e;\n        }, [])).forEach(t => {\n          e.children.push({\n            name: \"p\",\n            children: t\n          });\n        });\n      } else if (/[\\u2028\\n]/.test(this[er])) {\n        e.name = \"div\";\n        e.children = [];\n        this[er].split(/[\\u2028\\n]/).forEach(t => {\n          e.children.push({\n            name: \"span\",\n            value: t\n          }, {\n            name: \"br\"\n          });\n        });\n      }\n      return HTMLResult.success(e);\n    }\n    return this[er][an](e);\n  }\n}\nclass TextEdit extends XFAObject {\n  constructor(e) {\n    super(Hn, \"textEdit\", !0);\n    this.allowRichText = getInteger({\n      data: e.allowRichText,\n      defaultValue: 0,\n      validate: e => 1 === e\n    });\n    this.hScrollPolicy = getStringOption(e.hScrollPolicy, [\"auto\", \"off\", \"on\"]);\n    this.id = e.id || \"\";\n    this.multiLine = getInteger({\n      data: e.multiLine,\n      defaultValue: \"\",\n      validate: e => 0 === e || 1 === e\n    });\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.vScrollPolicy = getStringOption(e.vScrollPolicy, [\"auto\", \"off\", \"on\"]);\n    this.border = null;\n    this.comb = null;\n    this.extras = null;\n    this.margin = null;\n  }\n  [an](e) {\n    const t = toStyle(this, \"border\", \"font\", \"margin\");\n    let i;\n    const a = this[pr]()[pr]();\n    \"\" === this.multiLine && (this.multiLine = a instanceof Draw ? 1 : 0);\n    i = 1 === this.multiLine ? {\n      name: \"textarea\",\n      attributes: {\n        dataId: a[tr]?.[nn] || a[nn],\n        fieldId: a[nn],\n        class: [\"xfaTextfield\"],\n        style: t,\n        \"aria-label\": ariaLabel(a),\n        \"aria-required\": !1\n      }\n    } : {\n      name: \"input\",\n      attributes: {\n        type: \"text\",\n        dataId: a[tr]?.[nn] || a[nn],\n        fieldId: a[nn],\n        class: [\"xfaTextfield\"],\n        style: t,\n        \"aria-label\": ariaLabel(a),\n        \"aria-required\": !1\n      }\n    };\n    if (isRequired(a)) {\n      i.attributes[\"aria-required\"] = !0;\n      i.attributes.required = !0;\n    }\n    return HTMLResult.success({\n      name: \"label\",\n      attributes: {\n        class: [\"xfaLabel\"]\n      },\n      children: [i]\n    });\n  }\n}\nclass Time extends StringObject {\n  constructor(e) {\n    super(Hn, \"time\");\n    this.id = e.id || \"\";\n    this.name = e.name || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n  [sr]() {\n    const e = this[er].trim();\n    this[er] = e ? new Date(e) : null;\n  }\n  [an](e) {\n    return valueToHtml(this[er] ? this[er].toString() : \"\");\n  }\n}\nclass TimeStamp extends XFAObject {\n  constructor(e) {\n    super(Hn, \"timeStamp\");\n    this.id = e.id || \"\";\n    this.server = e.server || \"\";\n    this.type = getStringOption(e.type, [\"optional\", \"required\"]);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n}\nclass ToolTip extends StringObject {\n  constructor(e) {\n    super(Hn, \"toolTip\");\n    this.id = e.id || \"\";\n    this.rid = e.rid || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n}\nclass Traversal extends XFAObject {\n  constructor(e) {\n    super(Hn, \"traversal\", !0);\n    this.id = e.id || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.extras = null;\n    this.traverse = new XFAObjectArray();\n  }\n}\nclass Traverse extends XFAObject {\n  constructor(e) {\n    super(Hn, \"traverse\", !0);\n    this.id = e.id || \"\";\n    this.operation = getStringOption(e.operation, [\"next\", \"back\", \"down\", \"first\", \"left\", \"right\", \"up\"]);\n    this.ref = e.ref || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.extras = null;\n    this.script = null;\n  }\n  get name() {\n    return this.operation;\n  }\n  [Mr]() {\n    return !1;\n  }\n}\nclass Ui extends XFAObject {\n  constructor(e) {\n    super(Hn, \"ui\", !0);\n    this.id = e.id || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.extras = null;\n    this.picture = null;\n    this.barcode = null;\n    this.button = null;\n    this.checkButton = null;\n    this.choiceList = null;\n    this.dateTimeEdit = null;\n    this.defaultUi = null;\n    this.imageEdit = null;\n    this.numericEdit = null;\n    this.passwordEdit = null;\n    this.signature = null;\n    this.textEdit = null;\n  }\n  [lr]() {\n    if (void 0 === this[ar]) {\n      for (const e of Object.getOwnPropertyNames(this)) {\n        if (\"extras\" === e || \"picture\" === e) continue;\n        const t = this[e];\n        if (t instanceof XFAObject) {\n          this[ar] = t;\n          return t;\n        }\n      }\n      this[ar] = null;\n    }\n    return this[ar];\n  }\n  [an](e) {\n    const t = this[lr]();\n    return t ? t[an](e) : HTMLResult.EMPTY;\n  }\n}\nclass Validate extends XFAObject {\n  constructor(e) {\n    super(Hn, \"validate\", !0);\n    this.formatTest = getStringOption(e.formatTest, [\"warning\", \"disabled\", \"error\"]);\n    this.id = e.id || \"\";\n    this.nullTest = getStringOption(e.nullTest, [\"disabled\", \"error\", \"warning\"]);\n    this.scriptTest = getStringOption(e.scriptTest, [\"error\", \"disabled\", \"warning\"]);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.extras = null;\n    this.message = null;\n    this.picture = null;\n    this.script = null;\n  }\n}\nclass Value extends XFAObject {\n  constructor(e) {\n    super(Hn, \"value\", !0);\n    this.id = e.id || \"\";\n    this.override = getInteger({\n      data: e.override,\n      defaultValue: 0,\n      validate: e => 1 === e\n    });\n    this.relevant = getRelevant(e.relevant);\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.arc = null;\n    this.boolean = null;\n    this.date = null;\n    this.dateTime = null;\n    this.decimal = null;\n    this.exData = null;\n    this.float = null;\n    this.image = null;\n    this.integer = null;\n    this.line = null;\n    this.rectangle = null;\n    this.text = null;\n    this.time = null;\n  }\n  [$r](e) {\n    const t = this[pr]();\n    if (t instanceof Field && t.ui?.imageEdit) {\n      if (!this.image) {\n        this.image = new Image({});\n        this[Xs](this.image);\n      }\n      this.image[er] = e[er];\n      return;\n    }\n    const i = e[Yr];\n    if (null === this[i]) {\n      for (const e of Object.getOwnPropertyNames(this)) {\n        const t = this[e];\n        if (t instanceof XFAObject) {\n          this[e] = null;\n          this[jr](t);\n        }\n      }\n      this[e[Yr]] = e;\n      this[Xs](e);\n    } else this[i][er] = e[er];\n  }\n  [en]() {\n    if (this.exData) return \"string\" == typeof this.exData[er] ? this.exData[er].trim() : this.exData[er][en]().trim();\n    for (const e of Object.getOwnPropertyNames(this)) {\n      if (\"image\" === e) continue;\n      const t = this[e];\n      if (t instanceof XFAObject) return (t[er] || \"\").toString().trim();\n    }\n    return null;\n  }\n  [an](e) {\n    for (const t of Object.getOwnPropertyNames(this)) {\n      const i = this[t];\n      if (i instanceof XFAObject) return i[an](e);\n    }\n    return HTMLResult.EMPTY;\n  }\n}\nclass Variables extends XFAObject {\n  constructor(e) {\n    super(Hn, \"variables\", !0);\n    this.id = e.id || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n    this.boolean = new XFAObjectArray();\n    this.date = new XFAObjectArray();\n    this.dateTime = new XFAObjectArray();\n    this.decimal = new XFAObjectArray();\n    this.exData = new XFAObjectArray();\n    this.float = new XFAObjectArray();\n    this.image = new XFAObjectArray();\n    this.integer = new XFAObjectArray();\n    this.manifest = new XFAObjectArray();\n    this.script = new XFAObjectArray();\n    this.text = new XFAObjectArray();\n    this.time = new XFAObjectArray();\n  }\n  [Mr]() {\n    return !0;\n  }\n}\nclass TemplateNamespace {\n  static [gn](e, t) {\n    if (TemplateNamespace.hasOwnProperty(e)) {\n      const i = TemplateNamespace[e](t);\n      i[_r](t);\n      return i;\n    }\n  }\n  static appearanceFilter(e) {\n    return new AppearanceFilter(e);\n  }\n  static arc(e) {\n    return new Arc(e);\n  }\n  static area(e) {\n    return new Area(e);\n  }\n  static assist(e) {\n    return new Assist(e);\n  }\n  static barcode(e) {\n    return new Barcode(e);\n  }\n  static bind(e) {\n    return new Bind(e);\n  }\n  static bindItems(e) {\n    return new BindItems(e);\n  }\n  static bookend(e) {\n    return new Bookend(e);\n  }\n  static boolean(e) {\n    return new BooleanElement(e);\n  }\n  static border(e) {\n    return new Border(e);\n  }\n  static break(e) {\n    return new Break(e);\n  }\n  static breakAfter(e) {\n    return new BreakAfter(e);\n  }\n  static breakBefore(e) {\n    return new BreakBefore(e);\n  }\n  static button(e) {\n    return new Button(e);\n  }\n  static calculate(e) {\n    return new Calculate(e);\n  }\n  static caption(e) {\n    return new Caption(e);\n  }\n  static certificate(e) {\n    return new Certificate(e);\n  }\n  static certificates(e) {\n    return new Certificates(e);\n  }\n  static checkButton(e) {\n    return new CheckButton(e);\n  }\n  static choiceList(e) {\n    return new ChoiceList(e);\n  }\n  static color(e) {\n    return new Color(e);\n  }\n  static comb(e) {\n    return new Comb(e);\n  }\n  static connect(e) {\n    return new Connect(e);\n  }\n  static contentArea(e) {\n    return new ContentArea(e);\n  }\n  static corner(e) {\n    return new Corner(e);\n  }\n  static date(e) {\n    return new DateElement(e);\n  }\n  static dateTime(e) {\n    return new DateTime(e);\n  }\n  static dateTimeEdit(e) {\n    return new DateTimeEdit(e);\n  }\n  static decimal(e) {\n    return new Decimal(e);\n  }\n  static defaultUi(e) {\n    return new DefaultUi(e);\n  }\n  static desc(e) {\n    return new Desc(e);\n  }\n  static digestMethod(e) {\n    return new DigestMethod(e);\n  }\n  static digestMethods(e) {\n    return new DigestMethods(e);\n  }\n  static draw(e) {\n    return new Draw(e);\n  }\n  static edge(e) {\n    return new Edge(e);\n  }\n  static encoding(e) {\n    return new Encoding(e);\n  }\n  static encodings(e) {\n    return new Encodings(e);\n  }\n  static encrypt(e) {\n    return new Encrypt(e);\n  }\n  static encryptData(e) {\n    return new EncryptData(e);\n  }\n  static encryption(e) {\n    return new Encryption(e);\n  }\n  static encryptionMethod(e) {\n    return new EncryptionMethod(e);\n  }\n  static encryptionMethods(e) {\n    return new EncryptionMethods(e);\n  }\n  static event(e) {\n    return new Event(e);\n  }\n  static exData(e) {\n    return new ExData(e);\n  }\n  static exObject(e) {\n    return new ExObject(e);\n  }\n  static exclGroup(e) {\n    return new ExclGroup(e);\n  }\n  static execute(e) {\n    return new Execute(e);\n  }\n  static extras(e) {\n    return new Extras(e);\n  }\n  static field(e) {\n    return new Field(e);\n  }\n  static fill(e) {\n    return new Fill(e);\n  }\n  static filter(e) {\n    return new Filter(e);\n  }\n  static float(e) {\n    return new Float(e);\n  }\n  static font(e) {\n    return new template_Font(e);\n  }\n  static format(e) {\n    return new Format(e);\n  }\n  static handler(e) {\n    return new Handler(e);\n  }\n  static hyphenation(e) {\n    return new Hyphenation(e);\n  }\n  static image(e) {\n    return new Image(e);\n  }\n  static imageEdit(e) {\n    return new ImageEdit(e);\n  }\n  static integer(e) {\n    return new Integer(e);\n  }\n  static issuers(e) {\n    return new Issuers(e);\n  }\n  static items(e) {\n    return new Items(e);\n  }\n  static keep(e) {\n    return new Keep(e);\n  }\n  static keyUsage(e) {\n    return new KeyUsage(e);\n  }\n  static line(e) {\n    return new Line(e);\n  }\n  static linear(e) {\n    return new Linear(e);\n  }\n  static lockDocument(e) {\n    return new LockDocument(e);\n  }\n  static manifest(e) {\n    return new Manifest(e);\n  }\n  static margin(e) {\n    return new Margin(e);\n  }\n  static mdp(e) {\n    return new Mdp(e);\n  }\n  static medium(e) {\n    return new Medium(e);\n  }\n  static message(e) {\n    return new Message(e);\n  }\n  static numericEdit(e) {\n    return new NumericEdit(e);\n  }\n  static occur(e) {\n    return new Occur(e);\n  }\n  static oid(e) {\n    return new Oid(e);\n  }\n  static oids(e) {\n    return new Oids(e);\n  }\n  static overflow(e) {\n    return new Overflow(e);\n  }\n  static pageArea(e) {\n    return new PageArea(e);\n  }\n  static pageSet(e) {\n    return new PageSet(e);\n  }\n  static para(e) {\n    return new Para(e);\n  }\n  static passwordEdit(e) {\n    return new PasswordEdit(e);\n  }\n  static pattern(e) {\n    return new template_Pattern(e);\n  }\n  static picture(e) {\n    return new Picture(e);\n  }\n  static proto(e) {\n    return new Proto(e);\n  }\n  static radial(e) {\n    return new Radial(e);\n  }\n  static reason(e) {\n    return new Reason(e);\n  }\n  static reasons(e) {\n    return new Reasons(e);\n  }\n  static rectangle(e) {\n    return new Rectangle(e);\n  }\n  static ref(e) {\n    return new RefElement(e);\n  }\n  static script(e) {\n    return new Script(e);\n  }\n  static setProperty(e) {\n    return new SetProperty(e);\n  }\n  static signData(e) {\n    return new SignData(e);\n  }\n  static signature(e) {\n    return new Signature(e);\n  }\n  static signing(e) {\n    return new Signing(e);\n  }\n  static solid(e) {\n    return new Solid(e);\n  }\n  static speak(e) {\n    return new Speak(e);\n  }\n  static stipple(e) {\n    return new Stipple(e);\n  }\n  static subform(e) {\n    return new Subform(e);\n  }\n  static subformSet(e) {\n    return new SubformSet(e);\n  }\n  static subjectDN(e) {\n    return new SubjectDN(e);\n  }\n  static subjectDNs(e) {\n    return new SubjectDNs(e);\n  }\n  static submit(e) {\n    return new Submit(e);\n  }\n  static template(e) {\n    return new Template(e);\n  }\n  static text(e) {\n    return new Text(e);\n  }\n  static textEdit(e) {\n    return new TextEdit(e);\n  }\n  static time(e) {\n    return new Time(e);\n  }\n  static timeStamp(e) {\n    return new TimeStamp(e);\n  }\n  static toolTip(e) {\n    return new ToolTip(e);\n  }\n  static traversal(e) {\n    return new Traversal(e);\n  }\n  static traverse(e) {\n    return new Traverse(e);\n  }\n  static ui(e) {\n    return new Ui(e);\n  }\n  static validate(e) {\n    return new Validate(e);\n  }\n  static value(e) {\n    return new Value(e);\n  }\n  static variables(e) {\n    return new Variables(e);\n  }\n}\nconst Tn = on.datasets.id;\nfunction createText(e) {\n  const t = new Text({});\n  t[er] = e;\n  return t;\n}\nclass Binder {\n  constructor(e) {\n    this.root = e;\n    this.datasets = e.datasets;\n    this.data = e.datasets?.data || new XmlObject(on.datasets.id, \"data\");\n    this.emptyMerge = 0 === this.data[Er]().length;\n    this.root.form = this.form = e.template[$s]();\n  }\n  _isConsumeData() {\n    return !this.emptyMerge && this._mergeMode;\n  }\n  _isMatchTemplate() {\n    return !this._isConsumeData();\n  }\n  bind() {\n    this._bindElement(this.form, this.data);\n    return this.form;\n  }\n  getData() {\n    return this.data;\n  }\n  _bindValue(e, t, i) {\n    e[tr] = t;\n    if (e[wr]()) {\n      if (t[Rr]()) {\n        const i = t[hr]();\n        e[$r](createText(i));\n      } else if (e instanceof Field && \"multiSelect\" === e.ui?.choiceList?.open) {\n        const i = t[Er]().map(e => e[er].trim()).join(\"\\n\");\n        e[$r](createText(i));\n      } else this._isConsumeData() && warn(\"XFA - Nodes haven't the same type.\");\n    } else !t[Rr]() || this._isMatchTemplate() ? this._bindElement(e, t) : warn(\"XFA - Nodes haven't the same type.\");\n  }\n  _findDataByNameToConsume(e, t, i, a) {\n    if (!e) return null;\n    let s, r;\n    for (let a = 0; a < 3; a++) {\n      s = i[Qr](e, !1, !0);\n      for (;;) {\n        r = s.next().value;\n        if (!r) break;\n        if (t === r[Rr]()) return r;\n      }\n      if (i[Jr] === on.datasets.id && \"data\" === i[Yr]) break;\n      i = i[pr]();\n    }\n    if (!a) return null;\n    s = this.data[Qr](e, !0, !1);\n    r = s.next().value;\n    if (r) return r;\n    s = this.data[nr](e, !0);\n    r = s.next().value;\n    return r?.[Rr]() ? r : null;\n  }\n  _setProperties(e, t) {\n    if (e.hasOwnProperty(\"setProperty\")) for (const {\n      ref: i,\n      target: a,\n      connection: s\n    } of e.setProperty.children) {\n      if (s) continue;\n      if (!i) continue;\n      const r = searchNode(this.root, t, i, !1, !1);\n      if (!r) {\n        warn(`XFA - Invalid reference: ${i}.`);\n        continue;\n      }\n      const [n] = r;\n      if (!n[Nr](this.data)) {\n        warn(\"XFA - Invalid node: must be a data node.\");\n        continue;\n      }\n      const g = searchNode(this.root, e, a, !1, !1);\n      if (!g) {\n        warn(`XFA - Invalid target: ${a}.`);\n        continue;\n      }\n      const [o] = g;\n      if (!o[Nr](e)) {\n        warn(\"XFA - Invalid target: must be a property or subproperty.\");\n        continue;\n      }\n      const c = o[pr]();\n      if (o instanceof SetProperty || c instanceof SetProperty) {\n        warn(\"XFA - Invalid target: cannot be a setProperty or one of its properties.\");\n        continue;\n      }\n      if (o instanceof BindItems || c instanceof BindItems) {\n        warn(\"XFA - Invalid target: cannot be a bindItems or one of its properties.\");\n        continue;\n      }\n      const C = n[en](),\n        h = o[Yr];\n      if (o instanceof XFAAttribute) {\n        const e = Object.create(null);\n        e[h] = C;\n        const t = Reflect.construct(Object.getPrototypeOf(c).constructor, [e]);\n        c[h] = t[h];\n      } else if (o.hasOwnProperty(er)) {\n        o[tr] = n;\n        o[er] = C;\n        o[sr]();\n      } else warn(\"XFA - Invalid node to use in setProperty\");\n    }\n  }\n  _bindItems(e, t) {\n    if (!e.hasOwnProperty(\"items\") || !e.hasOwnProperty(\"bindItems\") || e.bindItems.isEmpty()) return;\n    for (const t of e.items.children) e[jr](t);\n    e.items.clear();\n    const i = new Items({}),\n      a = new Items({});\n    e[Xs](i);\n    e.items.push(i);\n    e[Xs](a);\n    e.items.push(a);\n    for (const {\n      ref: s,\n      labelRef: r,\n      valueRef: n,\n      connection: g\n    } of e.bindItems.children) {\n      if (g) continue;\n      if (!s) continue;\n      const e = searchNode(this.root, t, s, !1, !1);\n      if (e) for (const t of e) {\n        if (!t[Nr](this.datasets)) {\n          warn(`XFA - Invalid ref (${s}): must be a datasets child.`);\n          continue;\n        }\n        const e = searchNode(this.root, t, r, !0, !1);\n        if (!e) {\n          warn(`XFA - Invalid label: ${r}.`);\n          continue;\n        }\n        const [g] = e;\n        if (!g[Nr](this.datasets)) {\n          warn(\"XFA - Invalid label: must be a datasets child.\");\n          continue;\n        }\n        const o = searchNode(this.root, t, n, !0, !1);\n        if (!o) {\n          warn(`XFA - Invalid value: ${n}.`);\n          continue;\n        }\n        const [c] = o;\n        if (!c[Nr](this.datasets)) {\n          warn(\"XFA - Invalid value: must be a datasets child.\");\n          continue;\n        }\n        const C = createText(g[en]()),\n          h = createText(c[en]());\n        i[Xs](C);\n        i.text.push(C);\n        a[Xs](h);\n        a.text.push(h);\n      } else warn(`XFA - Invalid reference: ${s}.`);\n    }\n  }\n  _bindOccurrences(e, t, i) {\n    let a;\n    if (t.length > 1) {\n      a = e[$s]();\n      a[jr](a.occur);\n      a.occur = null;\n    }\n    this._bindValue(e, t[0], i);\n    this._setProperties(e, t[0]);\n    this._bindItems(e, t[0]);\n    if (1 === t.length) return;\n    const s = e[pr](),\n      r = e[Yr],\n      n = s[br](e);\n    for (let e = 1, g = t.length; e < g; e++) {\n      const g = t[e],\n        o = a[$s]();\n      s[r].push(o);\n      s[Fr](n + e, o);\n      this._bindValue(o, g, i);\n      this._setProperties(o, g);\n      this._bindItems(o, g);\n    }\n  }\n  _createOccurrences(e) {\n    if (!this.emptyMerge) return;\n    const {\n      occur: t\n    } = e;\n    if (!t || t.initial <= 1) return;\n    const i = e[pr](),\n      a = e[Yr];\n    if (!(i[a] instanceof XFAObjectArray)) return;\n    let s;\n    s = e.name ? i[a].children.filter(t => t.name === e.name).length : i[a].children.length;\n    const r = i[br](e) + 1,\n      n = t.initial - s;\n    if (n) {\n      const t = e[$s]();\n      t[jr](t.occur);\n      t.occur = null;\n      i[a].push(t);\n      i[Fr](r, t);\n      for (let e = 1; e < n; e++) {\n        const s = t[$s]();\n        i[a].push(s);\n        i[Fr](r + e, s);\n      }\n    }\n  }\n  _getOccurInfo(e) {\n    const {\n      name: t,\n      occur: i\n    } = e;\n    if (!i || !t) return [1, 1];\n    const a = -1 === i.max ? 1 / 0 : i.max;\n    return [i.min, a];\n  }\n  _setAndBind(e, t) {\n    this._setProperties(e, t);\n    this._bindItems(e, t);\n    this._bindElement(e, t);\n  }\n  _bindElement(e, t) {\n    const i = [];\n    this._createOccurrences(e);\n    for (const a of e[Er]()) {\n      if (a[tr]) continue;\n      if (void 0 === this._mergeMode && \"subform\" === a[Yr]) {\n        this._mergeMode = \"consumeData\" === a.mergeMode;\n        const e = t[Er]();\n        if (e.length > 0) this._bindOccurrences(a, [e[0]], null);else if (this.emptyMerge) {\n          const e = t[Jr] === Tn ? -1 : t[Jr],\n            i = a[tr] = new XmlObject(e, a.name || \"root\");\n          t[Xs](i);\n          this._bindElement(a, i);\n        }\n        continue;\n      }\n      if (!a[kr]()) continue;\n      let e = !1,\n        s = null,\n        r = null,\n        n = null;\n      if (a.bind) {\n        switch (a.bind.match) {\n          case \"none\":\n            this._setAndBind(a, t);\n            continue;\n          case \"global\":\n            e = !0;\n            break;\n          case \"dataRef\":\n            if (!a.bind.ref) {\n              warn(`XFA - ref is empty in node ${a[Yr]}.`);\n              this._setAndBind(a, t);\n              continue;\n            }\n            r = a.bind.ref;\n        }\n        a.bind.picture && (s = a.bind.picture[er]);\n      }\n      const [g, o] = this._getOccurInfo(a);\n      if (r) {\n        n = searchNode(this.root, t, r, !0, !1);\n        if (null === n) {\n          n = createDataNode(this.data, t, r);\n          if (!n) continue;\n          this._isConsumeData() && (n[Ar] = !0);\n          this._setAndBind(a, n);\n          continue;\n        }\n        this._isConsumeData() && (n = n.filter(e => !e[Ar]));\n        n.length > o ? n = n.slice(0, o) : 0 === n.length && (n = null);\n        n && this._isConsumeData() && n.forEach(e => {\n          e[Ar] = !0;\n        });\n      } else {\n        if (!a.name) {\n          this._setAndBind(a, t);\n          continue;\n        }\n        if (this._isConsumeData()) {\n          const i = [];\n          for (; i.length < o;) {\n            const s = this._findDataByNameToConsume(a.name, a[wr](), t, e);\n            if (!s) break;\n            s[Ar] = !0;\n            i.push(s);\n          }\n          n = i.length > 0 ? i : null;\n        } else {\n          n = t[Qr](a.name, !1, this.emptyMerge).next().value;\n          if (!n) {\n            if (0 === g) {\n              i.push(a);\n              continue;\n            }\n            const e = t[Jr] === Tn ? -1 : t[Jr];\n            n = a[tr] = new XmlObject(e, a.name);\n            this.emptyMerge && (n[Ar] = !0);\n            t[Xs](n);\n            this._setAndBind(a, n);\n            continue;\n          }\n          this.emptyMerge && (n[Ar] = !0);\n          n = [n];\n        }\n      }\n      n ? this._bindOccurrences(a, n, s) : g > 0 ? this._setAndBind(a, t) : i.push(a);\n    }\n    i.forEach(e => e[pr]()[jr](e));\n  }\n}\nclass DataHandler {\n  constructor(e, t) {\n    this.data = t;\n    this.dataset = e.datasets || null;\n  }\n  serialize(e) {\n    const t = [[-1, this.data[Er]()]];\n    for (; t.length > 0;) {\n      const i = t.at(-1),\n        [a, s] = i;\n      if (a + 1 === s.length) {\n        t.pop();\n        continue;\n      }\n      const r = s[++i[0]],\n        n = e.get(r[nn]);\n      if (n) r[$r](n);else {\n        const t = r[gr]();\n        for (const i of t.values()) {\n          const t = e.get(i[nn]);\n          if (t) {\n            i[$r](t);\n            break;\n          }\n        }\n      }\n      const g = r[Er]();\n      g.length > 0 && t.push([-1, g]);\n    }\n    const i = ['<xfa:datasets xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\">'];\n    if (this.dataset) for (const e of this.dataset[Er]()) \"data\" !== e[Yr] && e[sn](i);\n    this.data[sn](i);\n    i.push(\"</xfa:datasets>\");\n    return i.join(\"\");\n  }\n}\nconst qn = on.config.id;\nclass Acrobat extends XFAObject {\n  constructor(e) {\n    super(qn, \"acrobat\", !0);\n    this.acrobat7 = null;\n    this.autoSave = null;\n    this.common = null;\n    this.validate = null;\n    this.validateApprovalSignatures = null;\n    this.submitUrl = new XFAObjectArray();\n  }\n}\nclass Acrobat7 extends XFAObject {\n  constructor(e) {\n    super(qn, \"acrobat7\", !0);\n    this.dynamicRender = null;\n  }\n}\nclass ADBE_JSConsole extends OptionObject {\n  constructor(e) {\n    super(qn, \"ADBE_JSConsole\", [\"delegate\", \"Enable\", \"Disable\"]);\n  }\n}\nclass ADBE_JSDebugger extends OptionObject {\n  constructor(e) {\n    super(qn, \"ADBE_JSDebugger\", [\"delegate\", \"Enable\", \"Disable\"]);\n  }\n}\nclass AddSilentPrint extends Option01 {\n  constructor(e) {\n    super(qn, \"addSilentPrint\");\n  }\n}\nclass AddViewerPreferences extends Option01 {\n  constructor(e) {\n    super(qn, \"addViewerPreferences\");\n  }\n}\nclass AdjustData extends Option10 {\n  constructor(e) {\n    super(qn, \"adjustData\");\n  }\n}\nclass AdobeExtensionLevel extends IntegerObject {\n  constructor(e) {\n    super(qn, \"adobeExtensionLevel\", 0, e => e >= 1 && e <= 8);\n  }\n}\nclass Agent extends XFAObject {\n  constructor(e) {\n    super(qn, \"agent\", !0);\n    this.name = e.name ? e.name.trim() : \"\";\n    this.common = new XFAObjectArray();\n  }\n}\nclass AlwaysEmbed extends ContentObject {\n  constructor(e) {\n    super(qn, \"alwaysEmbed\");\n  }\n}\nclass Amd extends StringObject {\n  constructor(e) {\n    super(qn, \"amd\");\n  }\n}\nclass config_Area extends XFAObject {\n  constructor(e) {\n    super(qn, \"area\");\n    this.level = getInteger({\n      data: e.level,\n      defaultValue: 0,\n      validate: e => e >= 1 && e <= 3\n    });\n    this.name = getStringOption(e.name, [\"\", \"barcode\", \"coreinit\", \"deviceDriver\", \"font\", \"general\", \"layout\", \"merge\", \"script\", \"signature\", \"sourceSet\", \"templateCache\"]);\n  }\n}\nclass Attributes extends OptionObject {\n  constructor(e) {\n    super(qn, \"attributes\", [\"preserve\", \"delegate\", \"ignore\"]);\n  }\n}\nclass AutoSave extends OptionObject {\n  constructor(e) {\n    super(qn, \"autoSave\", [\"disabled\", \"enabled\"]);\n  }\n}\nclass Base extends StringObject {\n  constructor(e) {\n    super(qn, \"base\");\n  }\n}\nclass BatchOutput extends XFAObject {\n  constructor(e) {\n    super(qn, \"batchOutput\");\n    this.format = getStringOption(e.format, [\"none\", \"concat\", \"zip\", \"zipCompress\"]);\n  }\n}\nclass BehaviorOverride extends ContentObject {\n  constructor(e) {\n    super(qn, \"behaviorOverride\");\n  }\n  [sr]() {\n    this[er] = new Map(this[er].trim().split(/\\s+/).filter(e => e.includes(\":\")).map(e => e.split(\":\", 2)));\n  }\n}\nclass Cache extends XFAObject {\n  constructor(e) {\n    super(qn, \"cache\", !0);\n    this.templateCache = null;\n  }\n}\nclass Change extends Option01 {\n  constructor(e) {\n    super(qn, \"change\");\n  }\n}\nclass Common extends XFAObject {\n  constructor(e) {\n    super(qn, \"common\", !0);\n    this.data = null;\n    this.locale = null;\n    this.localeSet = null;\n    this.messaging = null;\n    this.suppressBanner = null;\n    this.template = null;\n    this.validationMessaging = null;\n    this.versionControl = null;\n    this.log = new XFAObjectArray();\n  }\n}\nclass Compress extends XFAObject {\n  constructor(e) {\n    super(qn, \"compress\");\n    this.scope = getStringOption(e.scope, [\"imageOnly\", \"document\"]);\n  }\n}\nclass CompressLogicalStructure extends Option01 {\n  constructor(e) {\n    super(qn, \"compressLogicalStructure\");\n  }\n}\nclass CompressObjectStream extends Option10 {\n  constructor(e) {\n    super(qn, \"compressObjectStream\");\n  }\n}\nclass Compression extends XFAObject {\n  constructor(e) {\n    super(qn, \"compression\", !0);\n    this.compressLogicalStructure = null;\n    this.compressObjectStream = null;\n    this.level = null;\n    this.type = null;\n  }\n}\nclass Config extends XFAObject {\n  constructor(e) {\n    super(qn, \"config\", !0);\n    this.acrobat = null;\n    this.present = null;\n    this.trace = null;\n    this.agent = new XFAObjectArray();\n  }\n}\nclass Conformance extends OptionObject {\n  constructor(e) {\n    super(qn, \"conformance\", [\"A\", \"B\"]);\n  }\n}\nclass ContentCopy extends Option01 {\n  constructor(e) {\n    super(qn, \"contentCopy\");\n  }\n}\nclass Copies extends IntegerObject {\n  constructor(e) {\n    super(qn, \"copies\", 1, e => e >= 1);\n  }\n}\nclass Creator extends StringObject {\n  constructor(e) {\n    super(qn, \"creator\");\n  }\n}\nclass CurrentPage extends IntegerObject {\n  constructor(e) {\n    super(qn, \"currentPage\", 0, e => e >= 0);\n  }\n}\nclass Data extends XFAObject {\n  constructor(e) {\n    super(qn, \"data\", !0);\n    this.adjustData = null;\n    this.attributes = null;\n    this.incrementalLoad = null;\n    this.outputXSL = null;\n    this.range = null;\n    this.record = null;\n    this.startNode = null;\n    this.uri = null;\n    this.window = null;\n    this.xsl = null;\n    this.excludeNS = new XFAObjectArray();\n    this.transform = new XFAObjectArray();\n  }\n}\nclass Debug extends XFAObject {\n  constructor(e) {\n    super(qn, \"debug\", !0);\n    this.uri = null;\n  }\n}\nclass DefaultTypeface extends ContentObject {\n  constructor(e) {\n    super(qn, \"defaultTypeface\");\n    this.writingScript = getStringOption(e.writingScript, [\"*\", \"Arabic\", \"Cyrillic\", \"EastEuropeanRoman\", \"Greek\", \"Hebrew\", \"Japanese\", \"Korean\", \"Roman\", \"SimplifiedChinese\", \"Thai\", \"TraditionalChinese\", \"Vietnamese\"]);\n  }\n}\nclass Destination extends OptionObject {\n  constructor(e) {\n    super(qn, \"destination\", [\"pdf\", \"pcl\", \"ps\", \"webClient\", \"zpl\"]);\n  }\n}\nclass DocumentAssembly extends Option01 {\n  constructor(e) {\n    super(qn, \"documentAssembly\");\n  }\n}\nclass Driver extends XFAObject {\n  constructor(e) {\n    super(qn, \"driver\", !0);\n    this.name = e.name ? e.name.trim() : \"\";\n    this.fontInfo = null;\n    this.xdc = null;\n  }\n}\nclass DuplexOption extends OptionObject {\n  constructor(e) {\n    super(qn, \"duplexOption\", [\"simplex\", \"duplexFlipLongEdge\", \"duplexFlipShortEdge\"]);\n  }\n}\nclass DynamicRender extends OptionObject {\n  constructor(e) {\n    super(qn, \"dynamicRender\", [\"forbidden\", \"required\"]);\n  }\n}\nclass Embed extends Option01 {\n  constructor(e) {\n    super(qn, \"embed\");\n  }\n}\nclass config_Encrypt extends Option01 {\n  constructor(e) {\n    super(qn, \"encrypt\");\n  }\n}\nclass config_Encryption extends XFAObject {\n  constructor(e) {\n    super(qn, \"encryption\", !0);\n    this.encrypt = null;\n    this.encryptionLevel = null;\n    this.permissions = null;\n  }\n}\nclass EncryptionLevel extends OptionObject {\n  constructor(e) {\n    super(qn, \"encryptionLevel\", [\"40bit\", \"128bit\"]);\n  }\n}\nclass Enforce extends StringObject {\n  constructor(e) {\n    super(qn, \"enforce\");\n  }\n}\nclass Equate extends XFAObject {\n  constructor(e) {\n    super(qn, \"equate\");\n    this.force = getInteger({\n      data: e.force,\n      defaultValue: 1,\n      validate: e => 0 === e\n    });\n    this.from = e.from || \"\";\n    this.to = e.to || \"\";\n  }\n}\nclass EquateRange extends XFAObject {\n  constructor(e) {\n    super(qn, \"equateRange\");\n    this.from = e.from || \"\";\n    this.to = e.to || \"\";\n    this._unicodeRange = e.unicodeRange || \"\";\n  }\n  get unicodeRange() {\n    const e = [],\n      t = /U\\+([0-9a-fA-F]+)/,\n      i = this._unicodeRange;\n    for (let a of i.split(\",\").map(e => e.trim()).filter(e => !!e)) {\n      a = a.split(\"-\", 2).map(e => {\n        const i = e.match(t);\n        return i ? parseInt(i[1], 16) : 0;\n      });\n      1 === a.length && a.push(a[0]);\n      e.push(a);\n    }\n    return shadow(this, \"unicodeRange\", e);\n  }\n}\nclass Exclude extends ContentObject {\n  constructor(e) {\n    super(qn, \"exclude\");\n  }\n  [sr]() {\n    this[er] = this[er].trim().split(/\\s+/).filter(e => e && [\"calculate\", \"close\", \"enter\", \"exit\", \"initialize\", \"ready\", \"validate\"].includes(e));\n  }\n}\nclass ExcludeNS extends StringObject {\n  constructor(e) {\n    super(qn, \"excludeNS\");\n  }\n}\nclass FlipLabel extends OptionObject {\n  constructor(e) {\n    super(qn, \"flipLabel\", [\"usePrinterSetting\", \"on\", \"off\"]);\n  }\n}\nclass config_FontInfo extends XFAObject {\n  constructor(e) {\n    super(qn, \"fontInfo\", !0);\n    this.embed = null;\n    this.map = null;\n    this.subsetBelow = null;\n    this.alwaysEmbed = new XFAObjectArray();\n    this.defaultTypeface = new XFAObjectArray();\n    this.neverEmbed = new XFAObjectArray();\n  }\n}\nclass FormFieldFilling extends Option01 {\n  constructor(e) {\n    super(qn, \"formFieldFilling\");\n  }\n}\nclass GroupParent extends StringObject {\n  constructor(e) {\n    super(qn, \"groupParent\");\n  }\n}\nclass IfEmpty extends OptionObject {\n  constructor(e) {\n    super(qn, \"ifEmpty\", [\"dataValue\", \"dataGroup\", \"ignore\", \"remove\"]);\n  }\n}\nclass IncludeXDPContent extends StringObject {\n  constructor(e) {\n    super(qn, \"includeXDPContent\");\n  }\n}\nclass IncrementalLoad extends OptionObject {\n  constructor(e) {\n    super(qn, \"incrementalLoad\", [\"none\", \"forwardOnly\"]);\n  }\n}\nclass IncrementalMerge extends Option01 {\n  constructor(e) {\n    super(qn, \"incrementalMerge\");\n  }\n}\nclass Interactive extends Option01 {\n  constructor(e) {\n    super(qn, \"interactive\");\n  }\n}\nclass Jog extends OptionObject {\n  constructor(e) {\n    super(qn, \"jog\", [\"usePrinterSetting\", \"none\", \"pageSet\"]);\n  }\n}\nclass LabelPrinter extends XFAObject {\n  constructor(e) {\n    super(qn, \"labelPrinter\", !0);\n    this.name = getStringOption(e.name, [\"zpl\", \"dpl\", \"ipl\", \"tcpl\"]);\n    this.batchOutput = null;\n    this.flipLabel = null;\n    this.fontInfo = null;\n    this.xdc = null;\n  }\n}\nclass Layout extends OptionObject {\n  constructor(e) {\n    super(qn, \"layout\", [\"paginate\", \"panel\"]);\n  }\n}\nclass Level extends IntegerObject {\n  constructor(e) {\n    super(qn, \"level\", 0, e => e > 0);\n  }\n}\nclass Linearized extends Option01 {\n  constructor(e) {\n    super(qn, \"linearized\");\n  }\n}\nclass Locale extends StringObject {\n  constructor(e) {\n    super(qn, \"locale\");\n  }\n}\nclass LocaleSet extends StringObject {\n  constructor(e) {\n    super(qn, \"localeSet\");\n  }\n}\nclass Log extends XFAObject {\n  constructor(e) {\n    super(qn, \"log\", !0);\n    this.mode = null;\n    this.threshold = null;\n    this.to = null;\n    this.uri = null;\n  }\n}\nclass MapElement extends XFAObject {\n  constructor(e) {\n    super(qn, \"map\", !0);\n    this.equate = new XFAObjectArray();\n    this.equateRange = new XFAObjectArray();\n  }\n}\nclass MediumInfo extends XFAObject {\n  constructor(e) {\n    super(qn, \"mediumInfo\", !0);\n    this.map = null;\n  }\n}\nclass config_Message extends XFAObject {\n  constructor(e) {\n    super(qn, \"message\", !0);\n    this.msgId = null;\n    this.severity = null;\n  }\n}\nclass Messaging extends XFAObject {\n  constructor(e) {\n    super(qn, \"messaging\", !0);\n    this.message = new XFAObjectArray();\n  }\n}\nclass Mode extends OptionObject {\n  constructor(e) {\n    super(qn, \"mode\", [\"append\", \"overwrite\"]);\n  }\n}\nclass ModifyAnnots extends Option01 {\n  constructor(e) {\n    super(qn, \"modifyAnnots\");\n  }\n}\nclass MsgId extends IntegerObject {\n  constructor(e) {\n    super(qn, \"msgId\", 1, e => e >= 1);\n  }\n}\nclass NameAttr extends StringObject {\n  constructor(e) {\n    super(qn, \"nameAttr\");\n  }\n}\nclass NeverEmbed extends ContentObject {\n  constructor(e) {\n    super(qn, \"neverEmbed\");\n  }\n}\nclass NumberOfCopies extends IntegerObject {\n  constructor(e) {\n    super(qn, \"numberOfCopies\", null, e => e >= 2 && e <= 5);\n  }\n}\nclass OpenAction extends XFAObject {\n  constructor(e) {\n    super(qn, \"openAction\", !0);\n    this.destination = null;\n  }\n}\nclass Output extends XFAObject {\n  constructor(e) {\n    super(qn, \"output\", !0);\n    this.to = null;\n    this.type = null;\n    this.uri = null;\n  }\n}\nclass OutputBin extends StringObject {\n  constructor(e) {\n    super(qn, \"outputBin\");\n  }\n}\nclass OutputXSL extends XFAObject {\n  constructor(e) {\n    super(qn, \"outputXSL\", !0);\n    this.uri = null;\n  }\n}\nclass Overprint extends OptionObject {\n  constructor(e) {\n    super(qn, \"overprint\", [\"none\", \"both\", \"draw\", \"field\"]);\n  }\n}\nclass Packets extends StringObject {\n  constructor(e) {\n    super(qn, \"packets\");\n  }\n  [sr]() {\n    \"*\" !== this[er] && (this[er] = this[er].trim().split(/\\s+/).filter(e => [\"config\", \"datasets\", \"template\", \"xfdf\", \"xslt\"].includes(e)));\n  }\n}\nclass PageOffset extends XFAObject {\n  constructor(e) {\n    super(qn, \"pageOffset\");\n    this.x = getInteger({\n      data: e.x,\n      defaultValue: \"useXDCSetting\",\n      validate: e => !0\n    });\n    this.y = getInteger({\n      data: e.y,\n      defaultValue: \"useXDCSetting\",\n      validate: e => !0\n    });\n  }\n}\nclass PageRange extends StringObject {\n  constructor(e) {\n    super(qn, \"pageRange\");\n  }\n  [sr]() {\n    const e = this[er].trim().split(/\\s+/).map(e => parseInt(e, 10)),\n      t = [];\n    for (let i = 0, a = e.length; i < a; i += 2) t.push(e.slice(i, i + 2));\n    this[er] = t;\n  }\n}\nclass Pagination extends OptionObject {\n  constructor(e) {\n    super(qn, \"pagination\", [\"simplex\", \"duplexShortEdge\", \"duplexLongEdge\"]);\n  }\n}\nclass PaginationOverride extends OptionObject {\n  constructor(e) {\n    super(qn, \"paginationOverride\", [\"none\", \"forceDuplex\", \"forceDuplexLongEdge\", \"forceDuplexShortEdge\", \"forceSimplex\"]);\n  }\n}\nclass Part extends IntegerObject {\n  constructor(e) {\n    super(qn, \"part\", 1, e => !1);\n  }\n}\nclass Pcl extends XFAObject {\n  constructor(e) {\n    super(qn, \"pcl\", !0);\n    this.name = e.name || \"\";\n    this.batchOutput = null;\n    this.fontInfo = null;\n    this.jog = null;\n    this.mediumInfo = null;\n    this.outputBin = null;\n    this.pageOffset = null;\n    this.staple = null;\n    this.xdc = null;\n  }\n}\nclass Pdf extends XFAObject {\n  constructor(e) {\n    super(qn, \"pdf\", !0);\n    this.name = e.name || \"\";\n    this.adobeExtensionLevel = null;\n    this.batchOutput = null;\n    this.compression = null;\n    this.creator = null;\n    this.encryption = null;\n    this.fontInfo = null;\n    this.interactive = null;\n    this.linearized = null;\n    this.openAction = null;\n    this.pdfa = null;\n    this.producer = null;\n    this.renderPolicy = null;\n    this.scriptModel = null;\n    this.silentPrint = null;\n    this.submitFormat = null;\n    this.tagged = null;\n    this.version = null;\n    this.viewerPreferences = null;\n    this.xdc = null;\n  }\n}\nclass Pdfa extends XFAObject {\n  constructor(e) {\n    super(qn, \"pdfa\", !0);\n    this.amd = null;\n    this.conformance = null;\n    this.includeXDPContent = null;\n    this.part = null;\n  }\n}\nclass Permissions extends XFAObject {\n  constructor(e) {\n    super(qn, \"permissions\", !0);\n    this.accessibleContent = null;\n    this.change = null;\n    this.contentCopy = null;\n    this.documentAssembly = null;\n    this.formFieldFilling = null;\n    this.modifyAnnots = null;\n    this.plaintextMetadata = null;\n    this.print = null;\n    this.printHighQuality = null;\n  }\n}\nclass PickTrayByPDFSize extends Option01 {\n  constructor(e) {\n    super(qn, \"pickTrayByPDFSize\");\n  }\n}\nclass config_Picture extends StringObject {\n  constructor(e) {\n    super(qn, \"picture\");\n  }\n}\nclass PlaintextMetadata extends Option01 {\n  constructor(e) {\n    super(qn, \"plaintextMetadata\");\n  }\n}\nclass Presence extends OptionObject {\n  constructor(e) {\n    super(qn, \"presence\", [\"preserve\", \"dissolve\", \"dissolveStructure\", \"ignore\", \"remove\"]);\n  }\n}\nclass Present extends XFAObject {\n  constructor(e) {\n    super(qn, \"present\", !0);\n    this.behaviorOverride = null;\n    this.cache = null;\n    this.common = null;\n    this.copies = null;\n    this.destination = null;\n    this.incrementalMerge = null;\n    this.layout = null;\n    this.output = null;\n    this.overprint = null;\n    this.pagination = null;\n    this.paginationOverride = null;\n    this.script = null;\n    this.validate = null;\n    this.xdp = null;\n    this.driver = new XFAObjectArray();\n    this.labelPrinter = new XFAObjectArray();\n    this.pcl = new XFAObjectArray();\n    this.pdf = new XFAObjectArray();\n    this.ps = new XFAObjectArray();\n    this.submitUrl = new XFAObjectArray();\n    this.webClient = new XFAObjectArray();\n    this.zpl = new XFAObjectArray();\n  }\n}\nclass Print extends Option01 {\n  constructor(e) {\n    super(qn, \"print\");\n  }\n}\nclass PrintHighQuality extends Option01 {\n  constructor(e) {\n    super(qn, \"printHighQuality\");\n  }\n}\nclass PrintScaling extends OptionObject {\n  constructor(e) {\n    super(qn, \"printScaling\", [\"appdefault\", \"noScaling\"]);\n  }\n}\nclass PrinterName extends StringObject {\n  constructor(e) {\n    super(qn, \"printerName\");\n  }\n}\nclass Producer extends StringObject {\n  constructor(e) {\n    super(qn, \"producer\");\n  }\n}\nclass Ps extends XFAObject {\n  constructor(e) {\n    super(qn, \"ps\", !0);\n    this.name = e.name || \"\";\n    this.batchOutput = null;\n    this.fontInfo = null;\n    this.jog = null;\n    this.mediumInfo = null;\n    this.outputBin = null;\n    this.staple = null;\n    this.xdc = null;\n  }\n}\nclass Range extends ContentObject {\n  constructor(e) {\n    super(qn, \"range\");\n  }\n  [sr]() {\n    this[er] = this[er].trim().split(/\\s*,\\s*/, 2).map(e => e.split(\"-\").map(e => parseInt(e.trim(), 10))).filter(e => e.every(e => !isNaN(e))).map(e => {\n      1 === e.length && e.push(e[0]);\n      return e;\n    });\n  }\n}\nclass Record extends ContentObject {\n  constructor(e) {\n    super(qn, \"record\");\n  }\n  [sr]() {\n    this[er] = this[er].trim();\n    const e = parseInt(this[er], 10);\n    !isNaN(e) && e >= 0 && (this[er] = e);\n  }\n}\nclass Relevant extends ContentObject {\n  constructor(e) {\n    super(qn, \"relevant\");\n  }\n  [sr]() {\n    this[er] = this[er].trim().split(/\\s+/);\n  }\n}\nclass Rename extends ContentObject {\n  constructor(e) {\n    super(qn, \"rename\");\n  }\n  [sr]() {\n    this[er] = this[er].trim();\n    (this[er].toLowerCase().startsWith(\"xml\") || new RegExp(\"[\\\\p{L}_][\\\\p{L}\\\\d._\\\\p{M}-]*\", \"u\").test(this[er])) && warn(\"XFA - Rename: invalid XFA name\");\n  }\n}\nclass RenderPolicy extends OptionObject {\n  constructor(e) {\n    super(qn, \"renderPolicy\", [\"server\", \"client\"]);\n  }\n}\nclass RunScripts extends OptionObject {\n  constructor(e) {\n    super(qn, \"runScripts\", [\"both\", \"client\", \"none\", \"server\"]);\n  }\n}\nclass config_Script extends XFAObject {\n  constructor(e) {\n    super(qn, \"script\", !0);\n    this.currentPage = null;\n    this.exclude = null;\n    this.runScripts = null;\n  }\n}\nclass ScriptModel extends OptionObject {\n  constructor(e) {\n    super(qn, \"scriptModel\", [\"XFA\", \"none\"]);\n  }\n}\nclass Severity extends OptionObject {\n  constructor(e) {\n    super(qn, \"severity\", [\"ignore\", \"error\", \"information\", \"trace\", \"warning\"]);\n  }\n}\nclass SilentPrint extends XFAObject {\n  constructor(e) {\n    super(qn, \"silentPrint\", !0);\n    this.addSilentPrint = null;\n    this.printerName = null;\n  }\n}\nclass Staple extends XFAObject {\n  constructor(e) {\n    super(qn, \"staple\");\n    this.mode = getStringOption(e.mode, [\"usePrinterSetting\", \"on\", \"off\"]);\n  }\n}\nclass StartNode extends StringObject {\n  constructor(e) {\n    super(qn, \"startNode\");\n  }\n}\nclass StartPage extends IntegerObject {\n  constructor(e) {\n    super(qn, \"startPage\", 0, e => !0);\n  }\n}\nclass SubmitFormat extends OptionObject {\n  constructor(e) {\n    super(qn, \"submitFormat\", [\"html\", \"delegate\", \"fdf\", \"xml\", \"pdf\"]);\n  }\n}\nclass SubmitUrl extends StringObject {\n  constructor(e) {\n    super(qn, \"submitUrl\");\n  }\n}\nclass SubsetBelow extends IntegerObject {\n  constructor(e) {\n    super(qn, \"subsetBelow\", 100, e => e >= 0 && e <= 100);\n  }\n}\nclass SuppressBanner extends Option01 {\n  constructor(e) {\n    super(qn, \"suppressBanner\");\n  }\n}\nclass Tagged extends Option01 {\n  constructor(e) {\n    super(qn, \"tagged\");\n  }\n}\nclass config_Template extends XFAObject {\n  constructor(e) {\n    super(qn, \"template\", !0);\n    this.base = null;\n    this.relevant = null;\n    this.startPage = null;\n    this.uri = null;\n    this.xsl = null;\n  }\n}\nclass Threshold extends OptionObject {\n  constructor(e) {\n    super(qn, \"threshold\", [\"trace\", \"error\", \"information\", \"warning\"]);\n  }\n}\nclass To extends OptionObject {\n  constructor(e) {\n    super(qn, \"to\", [\"null\", \"memory\", \"stderr\", \"stdout\", \"system\", \"uri\"]);\n  }\n}\nclass TemplateCache extends XFAObject {\n  constructor(e) {\n    super(qn, \"templateCache\");\n    this.maxEntries = getInteger({\n      data: e.maxEntries,\n      defaultValue: 5,\n      validate: e => e >= 0\n    });\n  }\n}\nclass Trace extends XFAObject {\n  constructor(e) {\n    super(qn, \"trace\", !0);\n    this.area = new XFAObjectArray();\n  }\n}\nclass Transform extends XFAObject {\n  constructor(e) {\n    super(qn, \"transform\", !0);\n    this.groupParent = null;\n    this.ifEmpty = null;\n    this.nameAttr = null;\n    this.picture = null;\n    this.presence = null;\n    this.rename = null;\n    this.whitespace = null;\n  }\n}\nclass Type extends OptionObject {\n  constructor(e) {\n    super(qn, \"type\", [\"none\", \"ascii85\", \"asciiHex\", \"ccittfax\", \"flate\", \"lzw\", \"runLength\", \"native\", \"xdp\", \"mergedXDP\"]);\n  }\n}\nclass Uri extends StringObject {\n  constructor(e) {\n    super(qn, \"uri\");\n  }\n}\nclass config_Validate extends OptionObject {\n  constructor(e) {\n    super(qn, \"validate\", [\"preSubmit\", \"prePrint\", \"preExecute\", \"preSave\"]);\n  }\n}\nclass ValidateApprovalSignatures extends ContentObject {\n  constructor(e) {\n    super(qn, \"validateApprovalSignatures\");\n  }\n  [sr]() {\n    this[er] = this[er].trim().split(/\\s+/).filter(e => [\"docReady\", \"postSign\"].includes(e));\n  }\n}\nclass ValidationMessaging extends OptionObject {\n  constructor(e) {\n    super(qn, \"validationMessaging\", [\"allMessagesIndividually\", \"allMessagesTogether\", \"firstMessageOnly\", \"noMessages\"]);\n  }\n}\nclass Version extends OptionObject {\n  constructor(e) {\n    super(qn, \"version\", [\"1.7\", \"1.6\", \"1.5\", \"1.4\", \"1.3\", \"1.2\"]);\n  }\n}\nclass VersionControl extends XFAObject {\n  constructor(e) {\n    super(qn, \"VersionControl\");\n    this.outputBelow = getStringOption(e.outputBelow, [\"warn\", \"error\", \"update\"]);\n    this.sourceAbove = getStringOption(e.sourceAbove, [\"warn\", \"error\"]);\n    this.sourceBelow = getStringOption(e.sourceBelow, [\"update\", \"maintain\"]);\n  }\n}\nclass ViewerPreferences extends XFAObject {\n  constructor(e) {\n    super(qn, \"viewerPreferences\", !0);\n    this.ADBE_JSConsole = null;\n    this.ADBE_JSDebugger = null;\n    this.addViewerPreferences = null;\n    this.duplexOption = null;\n    this.enforce = null;\n    this.numberOfCopies = null;\n    this.pageRange = null;\n    this.pickTrayByPDFSize = null;\n    this.printScaling = null;\n  }\n}\nclass WebClient extends XFAObject {\n  constructor(e) {\n    super(qn, \"webClient\", !0);\n    this.name = e.name ? e.name.trim() : \"\";\n    this.fontInfo = null;\n    this.xdc = null;\n  }\n}\nclass Whitespace extends OptionObject {\n  constructor(e) {\n    super(qn, \"whitespace\", [\"preserve\", \"ltrim\", \"normalize\", \"rtrim\", \"trim\"]);\n  }\n}\nclass Window extends ContentObject {\n  constructor(e) {\n    super(qn, \"window\");\n  }\n  [sr]() {\n    const e = this[er].trim().split(/\\s*,\\s*/, 2).map(e => parseInt(e, 10));\n    if (e.some(e => isNaN(e))) this[er] = [0, 0];else {\n      1 === e.length && e.push(e[0]);\n      this[er] = e;\n    }\n  }\n}\nclass Xdc extends XFAObject {\n  constructor(e) {\n    super(qn, \"xdc\", !0);\n    this.uri = new XFAObjectArray();\n    this.xsl = new XFAObjectArray();\n  }\n}\nclass Xdp extends XFAObject {\n  constructor(e) {\n    super(qn, \"xdp\", !0);\n    this.packets = null;\n  }\n}\nclass Xsl extends XFAObject {\n  constructor(e) {\n    super(qn, \"xsl\", !0);\n    this.debug = null;\n    this.uri = null;\n  }\n}\nclass Zpl extends XFAObject {\n  constructor(e) {\n    super(qn, \"zpl\", !0);\n    this.name = e.name ? e.name.trim() : \"\";\n    this.batchOutput = null;\n    this.flipLabel = null;\n    this.fontInfo = null;\n    this.xdc = null;\n  }\n}\nclass ConfigNamespace {\n  static [gn](e, t) {\n    if (ConfigNamespace.hasOwnProperty(e)) return ConfigNamespace[e](t);\n  }\n  static acrobat(e) {\n    return new Acrobat(e);\n  }\n  static acrobat7(e) {\n    return new Acrobat7(e);\n  }\n  static ADBE_JSConsole(e) {\n    return new ADBE_JSConsole(e);\n  }\n  static ADBE_JSDebugger(e) {\n    return new ADBE_JSDebugger(e);\n  }\n  static addSilentPrint(e) {\n    return new AddSilentPrint(e);\n  }\n  static addViewerPreferences(e) {\n    return new AddViewerPreferences(e);\n  }\n  static adjustData(e) {\n    return new AdjustData(e);\n  }\n  static adobeExtensionLevel(e) {\n    return new AdobeExtensionLevel(e);\n  }\n  static agent(e) {\n    return new Agent(e);\n  }\n  static alwaysEmbed(e) {\n    return new AlwaysEmbed(e);\n  }\n  static amd(e) {\n    return new Amd(e);\n  }\n  static area(e) {\n    return new config_Area(e);\n  }\n  static attributes(e) {\n    return new Attributes(e);\n  }\n  static autoSave(e) {\n    return new AutoSave(e);\n  }\n  static base(e) {\n    return new Base(e);\n  }\n  static batchOutput(e) {\n    return new BatchOutput(e);\n  }\n  static behaviorOverride(e) {\n    return new BehaviorOverride(e);\n  }\n  static cache(e) {\n    return new Cache(e);\n  }\n  static change(e) {\n    return new Change(e);\n  }\n  static common(e) {\n    return new Common(e);\n  }\n  static compress(e) {\n    return new Compress(e);\n  }\n  static compressLogicalStructure(e) {\n    return new CompressLogicalStructure(e);\n  }\n  static compressObjectStream(e) {\n    return new CompressObjectStream(e);\n  }\n  static compression(e) {\n    return new Compression(e);\n  }\n  static config(e) {\n    return new Config(e);\n  }\n  static conformance(e) {\n    return new Conformance(e);\n  }\n  static contentCopy(e) {\n    return new ContentCopy(e);\n  }\n  static copies(e) {\n    return new Copies(e);\n  }\n  static creator(e) {\n    return new Creator(e);\n  }\n  static currentPage(e) {\n    return new CurrentPage(e);\n  }\n  static data(e) {\n    return new Data(e);\n  }\n  static debug(e) {\n    return new Debug(e);\n  }\n  static defaultTypeface(e) {\n    return new DefaultTypeface(e);\n  }\n  static destination(e) {\n    return new Destination(e);\n  }\n  static documentAssembly(e) {\n    return new DocumentAssembly(e);\n  }\n  static driver(e) {\n    return new Driver(e);\n  }\n  static duplexOption(e) {\n    return new DuplexOption(e);\n  }\n  static dynamicRender(e) {\n    return new DynamicRender(e);\n  }\n  static embed(e) {\n    return new Embed(e);\n  }\n  static encrypt(e) {\n    return new config_Encrypt(e);\n  }\n  static encryption(e) {\n    return new config_Encryption(e);\n  }\n  static encryptionLevel(e) {\n    return new EncryptionLevel(e);\n  }\n  static enforce(e) {\n    return new Enforce(e);\n  }\n  static equate(e) {\n    return new Equate(e);\n  }\n  static equateRange(e) {\n    return new EquateRange(e);\n  }\n  static exclude(e) {\n    return new Exclude(e);\n  }\n  static excludeNS(e) {\n    return new ExcludeNS(e);\n  }\n  static flipLabel(e) {\n    return new FlipLabel(e);\n  }\n  static fontInfo(e) {\n    return new config_FontInfo(e);\n  }\n  static formFieldFilling(e) {\n    return new FormFieldFilling(e);\n  }\n  static groupParent(e) {\n    return new GroupParent(e);\n  }\n  static ifEmpty(e) {\n    return new IfEmpty(e);\n  }\n  static includeXDPContent(e) {\n    return new IncludeXDPContent(e);\n  }\n  static incrementalLoad(e) {\n    return new IncrementalLoad(e);\n  }\n  static incrementalMerge(e) {\n    return new IncrementalMerge(e);\n  }\n  static interactive(e) {\n    return new Interactive(e);\n  }\n  static jog(e) {\n    return new Jog(e);\n  }\n  static labelPrinter(e) {\n    return new LabelPrinter(e);\n  }\n  static layout(e) {\n    return new Layout(e);\n  }\n  static level(e) {\n    return new Level(e);\n  }\n  static linearized(e) {\n    return new Linearized(e);\n  }\n  static locale(e) {\n    return new Locale(e);\n  }\n  static localeSet(e) {\n    return new LocaleSet(e);\n  }\n  static log(e) {\n    return new Log(e);\n  }\n  static map(e) {\n    return new MapElement(e);\n  }\n  static mediumInfo(e) {\n    return new MediumInfo(e);\n  }\n  static message(e) {\n    return new config_Message(e);\n  }\n  static messaging(e) {\n    return new Messaging(e);\n  }\n  static mode(e) {\n    return new Mode(e);\n  }\n  static modifyAnnots(e) {\n    return new ModifyAnnots(e);\n  }\n  static msgId(e) {\n    return new MsgId(e);\n  }\n  static nameAttr(e) {\n    return new NameAttr(e);\n  }\n  static neverEmbed(e) {\n    return new NeverEmbed(e);\n  }\n  static numberOfCopies(e) {\n    return new NumberOfCopies(e);\n  }\n  static openAction(e) {\n    return new OpenAction(e);\n  }\n  static output(e) {\n    return new Output(e);\n  }\n  static outputBin(e) {\n    return new OutputBin(e);\n  }\n  static outputXSL(e) {\n    return new OutputXSL(e);\n  }\n  static overprint(e) {\n    return new Overprint(e);\n  }\n  static packets(e) {\n    return new Packets(e);\n  }\n  static pageOffset(e) {\n    return new PageOffset(e);\n  }\n  static pageRange(e) {\n    return new PageRange(e);\n  }\n  static pagination(e) {\n    return new Pagination(e);\n  }\n  static paginationOverride(e) {\n    return new PaginationOverride(e);\n  }\n  static part(e) {\n    return new Part(e);\n  }\n  static pcl(e) {\n    return new Pcl(e);\n  }\n  static pdf(e) {\n    return new Pdf(e);\n  }\n  static pdfa(e) {\n    return new Pdfa(e);\n  }\n  static permissions(e) {\n    return new Permissions(e);\n  }\n  static pickTrayByPDFSize(e) {\n    return new PickTrayByPDFSize(e);\n  }\n  static picture(e) {\n    return new config_Picture(e);\n  }\n  static plaintextMetadata(e) {\n    return new PlaintextMetadata(e);\n  }\n  static presence(e) {\n    return new Presence(e);\n  }\n  static present(e) {\n    return new Present(e);\n  }\n  static print(e) {\n    return new Print(e);\n  }\n  static printHighQuality(e) {\n    return new PrintHighQuality(e);\n  }\n  static printScaling(e) {\n    return new PrintScaling(e);\n  }\n  static printerName(e) {\n    return new PrinterName(e);\n  }\n  static producer(e) {\n    return new Producer(e);\n  }\n  static ps(e) {\n    return new Ps(e);\n  }\n  static range(e) {\n    return new Range(e);\n  }\n  static record(e) {\n    return new Record(e);\n  }\n  static relevant(e) {\n    return new Relevant(e);\n  }\n  static rename(e) {\n    return new Rename(e);\n  }\n  static renderPolicy(e) {\n    return new RenderPolicy(e);\n  }\n  static runScripts(e) {\n    return new RunScripts(e);\n  }\n  static script(e) {\n    return new config_Script(e);\n  }\n  static scriptModel(e) {\n    return new ScriptModel(e);\n  }\n  static severity(e) {\n    return new Severity(e);\n  }\n  static silentPrint(e) {\n    return new SilentPrint(e);\n  }\n  static staple(e) {\n    return new Staple(e);\n  }\n  static startNode(e) {\n    return new StartNode(e);\n  }\n  static startPage(e) {\n    return new StartPage(e);\n  }\n  static submitFormat(e) {\n    return new SubmitFormat(e);\n  }\n  static submitUrl(e) {\n    return new SubmitUrl(e);\n  }\n  static subsetBelow(e) {\n    return new SubsetBelow(e);\n  }\n  static suppressBanner(e) {\n    return new SuppressBanner(e);\n  }\n  static tagged(e) {\n    return new Tagged(e);\n  }\n  static template(e) {\n    return new config_Template(e);\n  }\n  static templateCache(e) {\n    return new TemplateCache(e);\n  }\n  static threshold(e) {\n    return new Threshold(e);\n  }\n  static to(e) {\n    return new To(e);\n  }\n  static trace(e) {\n    return new Trace(e);\n  }\n  static transform(e) {\n    return new Transform(e);\n  }\n  static type(e) {\n    return new Type(e);\n  }\n  static uri(e) {\n    return new Uri(e);\n  }\n  static validate(e) {\n    return new config_Validate(e);\n  }\n  static validateApprovalSignatures(e) {\n    return new ValidateApprovalSignatures(e);\n  }\n  static validationMessaging(e) {\n    return new ValidationMessaging(e);\n  }\n  static version(e) {\n    return new Version(e);\n  }\n  static versionControl(e) {\n    return new VersionControl(e);\n  }\n  static viewerPreferences(e) {\n    return new ViewerPreferences(e);\n  }\n  static webClient(e) {\n    return new WebClient(e);\n  }\n  static whitespace(e) {\n    return new Whitespace(e);\n  }\n  static window(e) {\n    return new Window(e);\n  }\n  static xdc(e) {\n    return new Xdc(e);\n  }\n  static xdp(e) {\n    return new Xdp(e);\n  }\n  static xsl(e) {\n    return new Xsl(e);\n  }\n  static zpl(e) {\n    return new Zpl(e);\n  }\n}\nconst On = on.connectionSet.id;\nclass ConnectionSet extends XFAObject {\n  constructor(e) {\n    super(On, \"connectionSet\", !0);\n    this.wsdlConnection = new XFAObjectArray();\n    this.xmlConnection = new XFAObjectArray();\n    this.xsdConnection = new XFAObjectArray();\n  }\n}\nclass EffectiveInputPolicy extends XFAObject {\n  constructor(e) {\n    super(On, \"effectiveInputPolicy\");\n    this.id = e.id || \"\";\n    this.name = e.name || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n}\nclass EffectiveOutputPolicy extends XFAObject {\n  constructor(e) {\n    super(On, \"effectiveOutputPolicy\");\n    this.id = e.id || \"\";\n    this.name = e.name || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n}\nclass Operation extends StringObject {\n  constructor(e) {\n    super(On, \"operation\");\n    this.id = e.id || \"\";\n    this.input = e.input || \"\";\n    this.name = e.name || \"\";\n    this.output = e.output || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n}\nclass RootElement extends StringObject {\n  constructor(e) {\n    super(On, \"rootElement\");\n    this.id = e.id || \"\";\n    this.name = e.name || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n}\nclass SoapAction extends StringObject {\n  constructor(e) {\n    super(On, \"soapAction\");\n    this.id = e.id || \"\";\n    this.name = e.name || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n}\nclass SoapAddress extends StringObject {\n  constructor(e) {\n    super(On, \"soapAddress\");\n    this.id = e.id || \"\";\n    this.name = e.name || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n}\nclass connection_set_Uri extends StringObject {\n  constructor(e) {\n    super(On, \"uri\");\n    this.id = e.id || \"\";\n    this.name = e.name || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n}\nclass WsdlAddress extends StringObject {\n  constructor(e) {\n    super(On, \"wsdlAddress\");\n    this.id = e.id || \"\";\n    this.name = e.name || \"\";\n    this.use = e.use || \"\";\n    this.usehref = e.usehref || \"\";\n  }\n}\nclass WsdlConnection extends XFAObject {\n  constructor(e) {\n    super(On, \"wsdlConnection\", !0);\n    this.dataDescription = e.dataDescription || \"\";\n    this.name = e.name || \"\";\n    this.effectiveInputPolicy = null;\n    this.effectiveOutputPolicy = null;\n    this.operation = null;\n    this.soapAction = null;\n    this.soapAddress = null;\n    this.wsdlAddress = null;\n  }\n}\nclass XmlConnection extends XFAObject {\n  constructor(e) {\n    super(On, \"xmlConnection\", !0);\n    this.dataDescription = e.dataDescription || \"\";\n    this.name = e.name || \"\";\n    this.uri = null;\n  }\n}\nclass XsdConnection extends XFAObject {\n  constructor(e) {\n    super(On, \"xsdConnection\", !0);\n    this.dataDescription = e.dataDescription || \"\";\n    this.name = e.name || \"\";\n    this.rootElement = null;\n    this.uri = null;\n  }\n}\nclass ConnectionSetNamespace {\n  static [gn](e, t) {\n    if (ConnectionSetNamespace.hasOwnProperty(e)) return ConnectionSetNamespace[e](t);\n  }\n  static connectionSet(e) {\n    return new ConnectionSet(e);\n  }\n  static effectiveInputPolicy(e) {\n    return new EffectiveInputPolicy(e);\n  }\n  static effectiveOutputPolicy(e) {\n    return new EffectiveOutputPolicy(e);\n  }\n  static operation(e) {\n    return new Operation(e);\n  }\n  static rootElement(e) {\n    return new RootElement(e);\n  }\n  static soapAction(e) {\n    return new SoapAction(e);\n  }\n  static soapAddress(e) {\n    return new SoapAddress(e);\n  }\n  static uri(e) {\n    return new connection_set_Uri(e);\n  }\n  static wsdlAddress(e) {\n    return new WsdlAddress(e);\n  }\n  static wsdlConnection(e) {\n    return new WsdlConnection(e);\n  }\n  static xmlConnection(e) {\n    return new XmlConnection(e);\n  }\n  static xsdConnection(e) {\n    return new XsdConnection(e);\n  }\n}\nconst Pn = on.datasets.id;\nclass datasets_Data extends XmlObject {\n  constructor(e) {\n    super(Pn, \"data\", e);\n  }\n  [Gr]() {\n    return !0;\n  }\n}\nclass Datasets extends XFAObject {\n  constructor(e) {\n    super(Pn, \"datasets\", !0);\n    this.data = null;\n    this.Signature = null;\n  }\n  [Kr](e) {\n    const t = e[Yr];\n    (\"data\" === t && e[Jr] === Pn || \"Signature\" === t && e[Jr] === on.signature.id) && (this[t] = e);\n    this[Xs](e);\n  }\n}\nclass DatasetsNamespace {\n  static [gn](e, t) {\n    if (DatasetsNamespace.hasOwnProperty(e)) return DatasetsNamespace[e](t);\n  }\n  static datasets(e) {\n    return new Datasets(e);\n  }\n  static data(e) {\n    return new datasets_Data(e);\n  }\n}\nconst Wn = on.localeSet.id;\nclass CalendarSymbols extends XFAObject {\n  constructor(e) {\n    super(Wn, \"calendarSymbols\", !0);\n    this.name = \"gregorian\";\n    this.dayNames = new XFAObjectArray(2);\n    this.eraNames = null;\n    this.meridiemNames = null;\n    this.monthNames = new XFAObjectArray(2);\n  }\n}\nclass CurrencySymbol extends StringObject {\n  constructor(e) {\n    super(Wn, \"currencySymbol\");\n    this.name = getStringOption(e.name, [\"symbol\", \"isoname\", \"decimal\"]);\n  }\n}\nclass CurrencySymbols extends XFAObject {\n  constructor(e) {\n    super(Wn, \"currencySymbols\", !0);\n    this.currencySymbol = new XFAObjectArray(3);\n  }\n}\nclass DatePattern extends StringObject {\n  constructor(e) {\n    super(Wn, \"datePattern\");\n    this.name = getStringOption(e.name, [\"full\", \"long\", \"med\", \"short\"]);\n  }\n}\nclass DatePatterns extends XFAObject {\n  constructor(e) {\n    super(Wn, \"datePatterns\", !0);\n    this.datePattern = new XFAObjectArray(4);\n  }\n}\nclass DateTimeSymbols extends ContentObject {\n  constructor(e) {\n    super(Wn, \"dateTimeSymbols\");\n  }\n}\nclass Day extends StringObject {\n  constructor(e) {\n    super(Wn, \"day\");\n  }\n}\nclass DayNames extends XFAObject {\n  constructor(e) {\n    super(Wn, \"dayNames\", !0);\n    this.abbr = getInteger({\n      data: e.abbr,\n      defaultValue: 0,\n      validate: e => 1 === e\n    });\n    this.day = new XFAObjectArray(7);\n  }\n}\nclass Era extends StringObject {\n  constructor(e) {\n    super(Wn, \"era\");\n  }\n}\nclass EraNames extends XFAObject {\n  constructor(e) {\n    super(Wn, \"eraNames\", !0);\n    this.era = new XFAObjectArray(2);\n  }\n}\nclass locale_set_Locale extends XFAObject {\n  constructor(e) {\n    super(Wn, \"locale\", !0);\n    this.desc = e.desc || \"\";\n    this.name = \"isoname\";\n    this.calendarSymbols = null;\n    this.currencySymbols = null;\n    this.datePatterns = null;\n    this.dateTimeSymbols = null;\n    this.numberPatterns = null;\n    this.numberSymbols = null;\n    this.timePatterns = null;\n    this.typeFaces = null;\n  }\n}\nclass locale_set_LocaleSet extends XFAObject {\n  constructor(e) {\n    super(Wn, \"localeSet\", !0);\n    this.locale = new XFAObjectArray();\n  }\n}\nclass Meridiem extends StringObject {\n  constructor(e) {\n    super(Wn, \"meridiem\");\n  }\n}\nclass MeridiemNames extends XFAObject {\n  constructor(e) {\n    super(Wn, \"meridiemNames\", !0);\n    this.meridiem = new XFAObjectArray(2);\n  }\n}\nclass Month extends StringObject {\n  constructor(e) {\n    super(Wn, \"month\");\n  }\n}\nclass MonthNames extends XFAObject {\n  constructor(e) {\n    super(Wn, \"monthNames\", !0);\n    this.abbr = getInteger({\n      data: e.abbr,\n      defaultValue: 0,\n      validate: e => 1 === e\n    });\n    this.month = new XFAObjectArray(12);\n  }\n}\nclass NumberPattern extends StringObject {\n  constructor(e) {\n    super(Wn, \"numberPattern\");\n    this.name = getStringOption(e.name, [\"full\", \"long\", \"med\", \"short\"]);\n  }\n}\nclass NumberPatterns extends XFAObject {\n  constructor(e) {\n    super(Wn, \"numberPatterns\", !0);\n    this.numberPattern = new XFAObjectArray(4);\n  }\n}\nclass NumberSymbol extends StringObject {\n  constructor(e) {\n    super(Wn, \"numberSymbol\");\n    this.name = getStringOption(e.name, [\"decimal\", \"grouping\", \"percent\", \"minus\", \"zero\"]);\n  }\n}\nclass NumberSymbols extends XFAObject {\n  constructor(e) {\n    super(Wn, \"numberSymbols\", !0);\n    this.numberSymbol = new XFAObjectArray(5);\n  }\n}\nclass TimePattern extends StringObject {\n  constructor(e) {\n    super(Wn, \"timePattern\");\n    this.name = getStringOption(e.name, [\"full\", \"long\", \"med\", \"short\"]);\n  }\n}\nclass TimePatterns extends XFAObject {\n  constructor(e) {\n    super(Wn, \"timePatterns\", !0);\n    this.timePattern = new XFAObjectArray(4);\n  }\n}\nclass TypeFace extends XFAObject {\n  constructor(e) {\n    super(Wn, \"typeFace\", !0);\n    this.name = \"\" | e.name;\n  }\n}\nclass TypeFaces extends XFAObject {\n  constructor(e) {\n    super(Wn, \"typeFaces\", !0);\n    this.typeFace = new XFAObjectArray();\n  }\n}\nclass LocaleSetNamespace {\n  static [gn](e, t) {\n    if (LocaleSetNamespace.hasOwnProperty(e)) return LocaleSetNamespace[e](t);\n  }\n  static calendarSymbols(e) {\n    return new CalendarSymbols(e);\n  }\n  static currencySymbol(e) {\n    return new CurrencySymbol(e);\n  }\n  static currencySymbols(e) {\n    return new CurrencySymbols(e);\n  }\n  static datePattern(e) {\n    return new DatePattern(e);\n  }\n  static datePatterns(e) {\n    return new DatePatterns(e);\n  }\n  static dateTimeSymbols(e) {\n    return new DateTimeSymbols(e);\n  }\n  static day(e) {\n    return new Day(e);\n  }\n  static dayNames(e) {\n    return new DayNames(e);\n  }\n  static era(e) {\n    return new Era(e);\n  }\n  static eraNames(e) {\n    return new EraNames(e);\n  }\n  static locale(e) {\n    return new locale_set_Locale(e);\n  }\n  static localeSet(e) {\n    return new locale_set_LocaleSet(e);\n  }\n  static meridiem(e) {\n    return new Meridiem(e);\n  }\n  static meridiemNames(e) {\n    return new MeridiemNames(e);\n  }\n  static month(e) {\n    return new Month(e);\n  }\n  static monthNames(e) {\n    return new MonthNames(e);\n  }\n  static numberPattern(e) {\n    return new NumberPattern(e);\n  }\n  static numberPatterns(e) {\n    return new NumberPatterns(e);\n  }\n  static numberSymbol(e) {\n    return new NumberSymbol(e);\n  }\n  static numberSymbols(e) {\n    return new NumberSymbols(e);\n  }\n  static timePattern(e) {\n    return new TimePattern(e);\n  }\n  static timePatterns(e) {\n    return new TimePatterns(e);\n  }\n  static typeFace(e) {\n    return new TypeFace(e);\n  }\n  static typeFaces(e) {\n    return new TypeFaces(e);\n  }\n}\nconst jn = on.signature.id;\nclass signature_Signature extends XFAObject {\n  constructor(e) {\n    super(jn, \"signature\", !0);\n  }\n}\nclass SignatureNamespace {\n  static [gn](e, t) {\n    if (SignatureNamespace.hasOwnProperty(e)) return SignatureNamespace[e](t);\n  }\n  static signature(e) {\n    return new signature_Signature(e);\n  }\n}\nconst Xn = on.stylesheet.id;\nclass Stylesheet extends XFAObject {\n  constructor(e) {\n    super(Xn, \"stylesheet\", !0);\n  }\n}\nclass StylesheetNamespace {\n  static [gn](e, t) {\n    if (StylesheetNamespace.hasOwnProperty(e)) return StylesheetNamespace[e](t);\n  }\n  static stylesheet(e) {\n    return new Stylesheet(e);\n  }\n}\nconst Zn = on.xdp.id;\nclass xdp_Xdp extends XFAObject {\n  constructor(e) {\n    super(Zn, \"xdp\", !0);\n    this.uuid = e.uuid || \"\";\n    this.timeStamp = e.timeStamp || \"\";\n    this.config = null;\n    this.connectionSet = null;\n    this.datasets = null;\n    this.localeSet = null;\n    this.stylesheet = new XFAObjectArray();\n    this.template = null;\n  }\n  [Tr](e) {\n    const t = on[e[Yr]];\n    return t && e[Jr] === t.id;\n  }\n}\nclass XdpNamespace {\n  static [gn](e, t) {\n    if (XdpNamespace.hasOwnProperty(e)) return XdpNamespace[e](t);\n  }\n  static xdp(e) {\n    return new xdp_Xdp(e);\n  }\n}\nconst Vn = on.xhtml.id,\n  zn = Symbol(),\n  _n = new Set([\"color\", \"font\", \"font-family\", \"font-size\", \"font-stretch\", \"font-style\", \"font-weight\", \"margin\", \"margin-bottom\", \"margin-left\", \"margin-right\", \"margin-top\", \"letter-spacing\", \"line-height\", \"orphans\", \"page-break-after\", \"page-break-before\", \"page-break-inside\", \"tab-interval\", \"tab-stop\", \"text-align\", \"text-decoration\", \"text-indent\", \"vertical-align\", \"widows\", \"kerning-mode\", \"xfa-font-horizontal-scale\", \"xfa-font-vertical-scale\", \"xfa-spacerun\", \"xfa-tab-stops\"]),\n  $n = new Map([[\"page-break-after\", \"breakAfter\"], [\"page-break-before\", \"breakBefore\"], [\"page-break-inside\", \"breakInside\"], [\"kerning-mode\", e => \"none\" === e ? \"none\" : \"normal\"], [\"xfa-font-horizontal-scale\", e => `scaleX(${Math.max(0, Math.min(parseInt(e) / 100)).toFixed(2)})`], [\"xfa-font-vertical-scale\", e => `scaleY(${Math.max(0, Math.min(parseInt(e) / 100)).toFixed(2)})`], [\"xfa-spacerun\", \"\"], [\"xfa-tab-stops\", \"\"], [\"font-size\", (e, t) => measureToString(.99 * (e = t.fontSize = getMeasurement(e)))], [\"letter-spacing\", e => measureToString(getMeasurement(e))], [\"line-height\", e => measureToString(getMeasurement(e))], [\"margin\", e => measureToString(getMeasurement(e))], [\"margin-bottom\", e => measureToString(getMeasurement(e))], [\"margin-left\", e => measureToString(getMeasurement(e))], [\"margin-right\", e => measureToString(getMeasurement(e))], [\"margin-top\", e => measureToString(getMeasurement(e))], [\"text-indent\", e => measureToString(getMeasurement(e))], [\"font-family\", e => e], [\"vertical-align\", e => measureToString(getMeasurement(e))]]),\n  Ag = /\\s+/g,\n  eg = /[\\r\\n]+/g,\n  tg = /\\r\\n?/g;\nfunction mapStyle(e, t, i) {\n  const a = Object.create(null);\n  if (!e) return a;\n  const s = Object.create(null);\n  for (const [t, i] of e.split(\";\").map(e => e.split(\":\", 2))) {\n    const e = $n.get(t);\n    if (\"\" === e) continue;\n    let r = i;\n    e && (r = \"string\" == typeof e ? e : e(i, s));\n    t.endsWith(\"scale\") ? a.transform = a.transform ? `${a[t]} ${r}` : r : a[t.replaceAll(/-([a-zA-Z])/g, (e, t) => t.toUpperCase())] = r;\n  }\n  a.fontFamily && setFontFamily({\n    typeface: a.fontFamily,\n    weight: a.fontWeight || \"normal\",\n    posture: a.fontStyle || \"normal\",\n    size: s.fontSize || 0\n  }, t, t[yr].fontFinder, a);\n  if (i && a.verticalAlign && \"0px\" !== a.verticalAlign && a.fontSize) {\n    const e = .583,\n      t = .333,\n      i = getMeasurement(a.fontSize);\n    a.fontSize = measureToString(i * e);\n    a.verticalAlign = measureToString(Math.sign(getMeasurement(a.verticalAlign)) * i * t);\n  }\n  i && a.fontSize && (a.fontSize = `calc(${a.fontSize} * var(--scale-factor))`);\n  fixTextIndent(a);\n  return a;\n}\nconst ig = new Set([\"body\", \"html\"]);\nclass XhtmlObject extends XmlObject {\n  constructor(e, t) {\n    super(Vn, t);\n    this[zn] = !1;\n    this.style = e.style || \"\";\n  }\n  [Vs](e) {\n    super[Vs](e);\n    this.style = function checkStyle(e) {\n      return e.style ? e.style.trim().split(/\\s*;\\s*/).filter(e => !!e).map(e => e.split(/\\s*:\\s*/, 2)).filter(([t, i]) => {\n        \"font-family\" === t && e[yr].usedTypefaces.add(i);\n        return _n.has(t);\n      }).map(e => e.join(\":\")).join(\";\") : \"\";\n    }(this);\n  }\n  [Ws]() {\n    return !ig.has(this[Yr]);\n  }\n  [qr](e, t = !1) {\n    if (t) this[zn] = !0;else {\n      e = e.replaceAll(eg, \"\");\n      this.style.includes(\"xfa-spacerun:yes\") || (e = e.replaceAll(Ag, \" \"));\n    }\n    e && (this[er] += e);\n  }\n  [Or](e, t = !0) {\n    const i = Object.create(null),\n      a = {\n        top: NaN,\n        bottom: NaN,\n        left: NaN,\n        right: NaN\n      };\n    let s = null;\n    for (const [e, t] of this.style.split(\";\").map(e => e.split(\":\", 2))) switch (e) {\n      case \"font-family\":\n        i.typeface = stripQuotes(t);\n        break;\n      case \"font-size\":\n        i.size = getMeasurement(t);\n        break;\n      case \"font-weight\":\n        i.weight = t;\n        break;\n      case \"font-style\":\n        i.posture = t;\n        break;\n      case \"letter-spacing\":\n        i.letterSpacing = getMeasurement(t);\n        break;\n      case \"margin\":\n        const e = t.split(/ \\t/).map(e => getMeasurement(e));\n        switch (e.length) {\n          case 1:\n            a.top = a.bottom = a.left = a.right = e[0];\n            break;\n          case 2:\n            a.top = a.bottom = e[0];\n            a.left = a.right = e[1];\n            break;\n          case 3:\n            a.top = e[0];\n            a.bottom = e[2];\n            a.left = a.right = e[1];\n            break;\n          case 4:\n            a.top = e[0];\n            a.left = e[1];\n            a.bottom = e[2];\n            a.right = e[3];\n        }\n        break;\n      case \"margin-top\":\n        a.top = getMeasurement(t);\n        break;\n      case \"margin-bottom\":\n        a.bottom = getMeasurement(t);\n        break;\n      case \"margin-left\":\n        a.left = getMeasurement(t);\n        break;\n      case \"margin-right\":\n        a.right = getMeasurement(t);\n        break;\n      case \"line-height\":\n        s = getMeasurement(t);\n    }\n    e.pushData(i, a, s);\n    if (this[er]) e.addString(this[er]);else for (const t of this[Er]()) \"#text\" !== t[Yr] ? t[Or](e) : e.addString(t[er]);\n    t && e.popFont();\n  }\n  [an](e) {\n    const t = [];\n    this[ar] = {\n      children: t\n    };\n    this[Zs]({});\n    if (0 === t.length && !this[er]) return HTMLResult.EMPTY;\n    let i;\n    i = this[zn] ? this[er] ? this[er].replaceAll(tg, \"\\n\") : void 0 : this[er] || void 0;\n    return HTMLResult.success({\n      name: this[Yr],\n      attributes: {\n        href: this.href,\n        style: mapStyle(this.style, this, this[zn])\n      },\n      children: t,\n      value: i\n    });\n  }\n}\nclass A extends XhtmlObject {\n  constructor(e) {\n    super(e, \"a\");\n    this.href = fixURL(e.href) || \"\";\n  }\n}\nclass B extends XhtmlObject {\n  constructor(e) {\n    super(e, \"b\");\n  }\n  [Or](e) {\n    e.pushFont({\n      weight: \"bold\"\n    });\n    super[Or](e);\n    e.popFont();\n  }\n}\nclass Body extends XhtmlObject {\n  constructor(e) {\n    super(e, \"body\");\n  }\n  [an](e) {\n    const t = super[an](e),\n      {\n        html: i\n      } = t;\n    if (!i) return HTMLResult.EMPTY;\n    i.name = \"div\";\n    i.attributes.class = [\"xfaRich\"];\n    return t;\n  }\n}\nclass Br extends XhtmlObject {\n  constructor(e) {\n    super(e, \"br\");\n  }\n  [en]() {\n    return \"\\n\";\n  }\n  [Or](e) {\n    e.addString(\"\\n\");\n  }\n  [an](e) {\n    return HTMLResult.success({\n      name: \"br\"\n    });\n  }\n}\nclass Html extends XhtmlObject {\n  constructor(e) {\n    super(e, \"html\");\n  }\n  [an](e) {\n    const t = [];\n    this[ar] = {\n      children: t\n    };\n    this[Zs]({});\n    if (0 === t.length) return HTMLResult.success({\n      name: \"div\",\n      attributes: {\n        class: [\"xfaRich\"],\n        style: {}\n      },\n      value: this[er] || \"\"\n    });\n    if (1 === t.length) {\n      const e = t[0];\n      if (e.attributes?.class.includes(\"xfaRich\")) return HTMLResult.success(e);\n    }\n    return HTMLResult.success({\n      name: \"div\",\n      attributes: {\n        class: [\"xfaRich\"],\n        style: {}\n      },\n      children: t\n    });\n  }\n}\nclass I extends XhtmlObject {\n  constructor(e) {\n    super(e, \"i\");\n  }\n  [Or](e) {\n    e.pushFont({\n      posture: \"italic\"\n    });\n    super[Or](e);\n    e.popFont();\n  }\n}\nclass Li extends XhtmlObject {\n  constructor(e) {\n    super(e, \"li\");\n  }\n}\nclass Ol extends XhtmlObject {\n  constructor(e) {\n    super(e, \"ol\");\n  }\n}\nclass P extends XhtmlObject {\n  constructor(e) {\n    super(e, \"p\");\n  }\n  [Or](e) {\n    super[Or](e, !1);\n    e.addString(\"\\n\");\n    e.addPara();\n    e.popFont();\n  }\n  [en]() {\n    return this[pr]()[Er]().at(-1) === this ? super[en]() : super[en]() + \"\\n\";\n  }\n}\nclass Span extends XhtmlObject {\n  constructor(e) {\n    super(e, \"span\");\n  }\n}\nclass Sub extends XhtmlObject {\n  constructor(e) {\n    super(e, \"sub\");\n  }\n}\nclass Sup extends XhtmlObject {\n  constructor(e) {\n    super(e, \"sup\");\n  }\n}\nclass Ul extends XhtmlObject {\n  constructor(e) {\n    super(e, \"ul\");\n  }\n}\nclass XhtmlNamespace {\n  static [gn](e, t) {\n    if (XhtmlNamespace.hasOwnProperty(e)) return XhtmlNamespace[e](t);\n  }\n  static a(e) {\n    return new A(e);\n  }\n  static b(e) {\n    return new B(e);\n  }\n  static body(e) {\n    return new Body(e);\n  }\n  static br(e) {\n    return new Br(e);\n  }\n  static html(e) {\n    return new Html(e);\n  }\n  static i(e) {\n    return new I(e);\n  }\n  static li(e) {\n    return new Li(e);\n  }\n  static ol(e) {\n    return new Ol(e);\n  }\n  static p(e) {\n    return new P(e);\n  }\n  static span(e) {\n    return new Span(e);\n  }\n  static sub(e) {\n    return new Sub(e);\n  }\n  static sup(e) {\n    return new Sup(e);\n  }\n  static ul(e) {\n    return new Ul(e);\n  }\n}\nconst ag = {\n  config: ConfigNamespace,\n  connection: ConnectionSetNamespace,\n  datasets: DatasetsNamespace,\n  localeSet: LocaleSetNamespace,\n  signature: SignatureNamespace,\n  stylesheet: StylesheetNamespace,\n  template: TemplateNamespace,\n  xdp: XdpNamespace,\n  xhtml: XhtmlNamespace\n};\nclass UnknownNamespace {\n  constructor(e) {\n    this.namespaceId = e;\n  }\n  [gn](e, t) {\n    return new XmlObject(this.namespaceId, e, t);\n  }\n}\nclass Root extends XFAObject {\n  constructor(e) {\n    super(-1, \"root\", Object.create(null));\n    this.element = null;\n    this[Dr] = e;\n  }\n  [Kr](e) {\n    this.element = e;\n    return !0;\n  }\n  [sr]() {\n    super[sr]();\n    if (this.element.template instanceof Template) {\n      this[Dr].set(Xr, this.element);\n      this.element.template[Zr](this[Dr]);\n      this.element.template[Dr] = this[Dr];\n    }\n  }\n}\nclass Empty extends XFAObject {\n  constructor() {\n    super(-1, \"\", Object.create(null));\n  }\n  [Kr](e) {\n    return !1;\n  }\n}\nclass Builder {\n  constructor(e = null) {\n    this._namespaceStack = [];\n    this._nsAgnosticLevel = 0;\n    this._namespacePrefixes = new Map();\n    this._namespaces = new Map();\n    this._nextNsId = Math.max(...Object.values(on).map(({\n      id: e\n    }) => e));\n    this._currentNamespace = e || new UnknownNamespace(++this._nextNsId);\n  }\n  buildRoot(e) {\n    return new Root(e);\n  }\n  build({\n    nsPrefix: e,\n    name: t,\n    attributes: i,\n    namespace: a,\n    prefixes: s\n  }) {\n    const r = null !== a;\n    if (r) {\n      this._namespaceStack.push(this._currentNamespace);\n      this._currentNamespace = this._searchNamespace(a);\n    }\n    s && this._addNamespacePrefix(s);\n    if (i.hasOwnProperty(vr)) {\n      const e = ag.datasets,\n        t = i[vr];\n      let a = null;\n      for (const [i, s] of Object.entries(t)) {\n        if (this._getNamespaceToUse(i) === e) {\n          a = {\n            xfa: s\n          };\n          break;\n        }\n      }\n      a ? i[vr] = a : delete i[vr];\n    }\n    const n = this._getNamespaceToUse(e),\n      g = n?.[gn](t, i) || new Empty();\n    g[Gr]() && this._nsAgnosticLevel++;\n    (r || s || g[Gr]()) && (g[_s] = {\n      hasNamespace: r,\n      prefixes: s,\n      nsAgnostic: g[Gr]()\n    });\n    return g;\n  }\n  isNsAgnostic() {\n    return this._nsAgnosticLevel > 0;\n  }\n  _searchNamespace(e) {\n    let t = this._namespaces.get(e);\n    if (t) return t;\n    for (const [i, {\n      check: a\n    }] of Object.entries(on)) if (a(e)) {\n      t = ag[i];\n      if (t) {\n        this._namespaces.set(e, t);\n        return t;\n      }\n      break;\n    }\n    t = new UnknownNamespace(++this._nextNsId);\n    this._namespaces.set(e, t);\n    return t;\n  }\n  _addNamespacePrefix(e) {\n    for (const {\n      prefix: t,\n      value: i\n    } of e) {\n      const e = this._searchNamespace(i);\n      let a = this._namespacePrefixes.get(t);\n      if (!a) {\n        a = [];\n        this._namespacePrefixes.set(t, a);\n      }\n      a.push(e);\n    }\n  }\n  _getNamespaceToUse(e) {\n    if (!e) return this._currentNamespace;\n    const t = this._namespacePrefixes.get(e);\n    if (t?.length > 0) return t.at(-1);\n    warn(`Unknown namespace prefix: ${e}.`);\n    return null;\n  }\n  clean(e) {\n    const {\n      hasNamespace: t,\n      prefixes: i,\n      nsAgnostic: a\n    } = e;\n    t && (this._currentNamespace = this._namespaceStack.pop());\n    i && i.forEach(({\n      prefix: e\n    }) => {\n      this._namespacePrefixes.get(e).pop();\n    });\n    a && this._nsAgnosticLevel--;\n  }\n}\nclass XFAParser extends XMLParserBase {\n  constructor(e = null, t = !1) {\n    super();\n    this._builder = new Builder(e);\n    this._stack = [];\n    this._globalData = {\n      usedTypefaces: new Set()\n    };\n    this._ids = new Map();\n    this._current = this._builder.buildRoot(this._ids);\n    this._errorCode = Rs;\n    this._whiteRegex = /^\\s+$/;\n    this._nbsps = /\\xa0+/g;\n    this._richText = t;\n  }\n  parse(e) {\n    this.parseXml(e);\n    if (this._errorCode === Rs) {\n      this._current[sr]();\n      return this._current.element;\n    }\n  }\n  onText(e) {\n    e = e.replace(this._nbsps, e => e.slice(1) + \" \");\n    this._richText || this._current[Ws]() ? this._current[qr](e, this._richText) : this._whiteRegex.test(e) || this._current[qr](e.trim());\n  }\n  onCdata(e) {\n    this._current[qr](e);\n  }\n  _mkAttributes(e, t) {\n    let i = null,\n      a = null;\n    const s = Object.create({});\n    for (const {\n      name: r,\n      value: n\n    } of e) if (\"xmlns\" === r) i ? warn(`XFA - multiple namespace definition in <${t}>`) : i = n;else if (r.startsWith(\"xmlns:\")) {\n      const e = r.substring(6);\n      a || (a = []);\n      a.push({\n        prefix: e,\n        value: n\n      });\n    } else {\n      const e = r.indexOf(\":\");\n      if (-1 === e) s[r] = n;else {\n        let t = s[vr];\n        t || (t = s[vr] = Object.create(null));\n        const [i, a] = [r.slice(0, e), r.slice(e + 1)];\n        (t[i] ||= Object.create(null))[a] = n;\n      }\n    }\n    return [i, a, s];\n  }\n  _getNameAndPrefix(e, t) {\n    const i = e.indexOf(\":\");\n    return -1 === i ? [e, null] : [e.substring(i + 1), t ? \"\" : e.substring(0, i)];\n  }\n  onBeginElement(e, t, i) {\n    const [a, s, r] = this._mkAttributes(t, e),\n      [n, g] = this._getNameAndPrefix(e, this._builder.isNsAgnostic()),\n      o = this._builder.build({\n        nsPrefix: g,\n        name: n,\n        attributes: r,\n        namespace: a,\n        prefixes: s\n      });\n    o[yr] = this._globalData;\n    if (i) {\n      o[sr]();\n      this._current[Kr](o) && o[zr](this._ids);\n      o[Vs](this._builder);\n    } else {\n      this._stack.push(this._current);\n      this._current = o;\n    }\n  }\n  onEndElement(e) {\n    const t = this._current;\n    if (t[Sr]() && \"string\" == typeof t[er]) {\n      const e = new XFAParser();\n      e._globalData = this._globalData;\n      const i = e.parse(t[er]);\n      t[er] = null;\n      t[Kr](i);\n    }\n    t[sr]();\n    this._current = this._stack.pop();\n    this._current[Kr](t) && t[zr](this._ids);\n    t[Vs](this._builder);\n  }\n  onError(e) {\n    this._errorCode = e;\n  }\n}\nclass XFAFactory {\n  constructor(e) {\n    try {\n      this.root = new XFAParser().parse(XFAFactory._createDocument(e));\n      const t = new Binder(this.root);\n      this.form = t.bind();\n      this.dataHandler = new DataHandler(this.root, t.getData());\n      this.form[yr].template = this.form;\n    } catch (e) {\n      warn(`XFA - an error occurred during parsing and binding: ${e}`);\n    }\n  }\n  isValid() {\n    return this.root && this.form;\n  }\n  _createPagesHelper() {\n    const e = this.form[tn]();\n    return new Promise((t, i) => {\n      const nextIteration = () => {\n        try {\n          const i = e.next();\n          i.done ? t(i.value) : setTimeout(nextIteration, 0);\n        } catch (e) {\n          i(e);\n        }\n      };\n      setTimeout(nextIteration, 0);\n    });\n  }\n  async _createPages() {\n    try {\n      this.pages = await this._createPagesHelper();\n      this.dims = this.pages.children.map(e => {\n        const {\n          width: t,\n          height: i\n        } = e.attributes.style;\n        return [0, 0, parseInt(t), parseInt(i)];\n      });\n    } catch (e) {\n      warn(`XFA - an error occurred during layout: ${e}`);\n    }\n  }\n  getBoundingBox(e) {\n    return this.dims[e];\n  }\n  async getNumPages() {\n    this.pages || (await this._createPages());\n    return this.dims.length;\n  }\n  setImages(e) {\n    this.form[yr].images = e;\n  }\n  setFonts(e) {\n    this.form[yr].fontFinder = new FontFinder(e);\n    const t = [];\n    for (let e of this.form[yr].usedTypefaces) {\n      e = stripQuotes(e);\n      this.form[yr].fontFinder.find(e) || t.push(e);\n    }\n    return t.length > 0 ? t : null;\n  }\n  appendFonts(e, t) {\n    this.form[yr].fontFinder.add(e, t);\n  }\n  async getPages() {\n    this.pages || (await this._createPages());\n    const e = this.pages;\n    this.pages = null;\n    return e;\n  }\n  serializeData(e) {\n    return this.dataHandler.serialize(e);\n  }\n  static _createDocument(e) {\n    return e[\"/xdp:xdp\"] ? Object.values(e).join(\"\") : e[\"xdp:xdp\"];\n  }\n  static getRichTextAsHtml(e) {\n    if (!e || \"string\" != typeof e) return null;\n    try {\n      let t = new XFAParser(XhtmlNamespace, !0).parse(e);\n      if (![\"body\", \"xhtml\"].includes(t[Yr])) {\n        const e = XhtmlNamespace.body({});\n        e[Xs](t);\n        t = e;\n      }\n      const i = t[an]();\n      if (!i.success) return null;\n      const {\n          html: a\n        } = i,\n        {\n          attributes: s\n        } = a;\n      if (s) {\n        s.class && (s.class = s.class.filter(e => !e.startsWith(\"xfa\")));\n        s.dir = \"auto\";\n      }\n      return {\n        html: a,\n        str: t[en]()\n      };\n    } catch (e) {\n      warn(`XFA - an error occurred during parsing of rich text: ${e}`);\n    }\n    return null;\n  }\n}\nclass AnnotationFactory {\n  static createGlobals(e) {\n    return Promise.all([e.ensureCatalog(\"acroForm\"), e.ensureDoc(\"xfaDatasets\"), e.ensureCatalog(\"structTreeRoot\"), e.ensureCatalog(\"baseUrl\"), e.ensureCatalog(\"attachments\")]).then(([t, i, a, s, r]) => ({\n      pdfManager: e,\n      acroForm: t instanceof Dict ? t : Dict.empty,\n      xfaDatasets: i,\n      structTreeRoot: a,\n      baseUrl: s,\n      attachments: r\n    }), e => {\n      warn(`createGlobals: \"${e}\".`);\n      return null;\n    });\n  }\n  static async create(e, t, i, a, s, r) {\n    const n = s ? await this._getPageIndex(e, t, i.pdfManager) : null;\n    return i.pdfManager.ensure(this, \"_create\", [e, t, i, a, s, n, r]);\n  }\n  static _create(e, t, i, a, s = !1, r = null, n = null) {\n    const g = e.fetchIfRef(t);\n    if (!(g instanceof Dict)) return;\n    const {\n        acroForm: o,\n        pdfManager: c\n      } = i,\n      C = t instanceof Ref ? t.toString() : `annot_${a.createObjId()}`;\n    let h = g.get(\"Subtype\");\n    h = h instanceof Name ? h.name : null;\n    const l = {\n      xref: e,\n      ref: t,\n      dict: g,\n      subtype: h,\n      id: C,\n      annotationGlobals: i,\n      collectFields: s,\n      needAppearances: !s && !0 === o.get(\"NeedAppearances\"),\n      pageIndex: r,\n      evaluatorOptions: c.evaluatorOptions,\n      pageRef: n\n    };\n    switch (h) {\n      case \"Link\":\n        return new LinkAnnotation(l);\n      case \"Text\":\n        return new TextAnnotation(l);\n      case \"Widget\":\n        let e = getInheritableProperty({\n          dict: g,\n          key: \"FT\"\n        });\n        e = e instanceof Name ? e.name : null;\n        switch (e) {\n          case \"Tx\":\n            return new TextWidgetAnnotation(l);\n          case \"Btn\":\n            return new ButtonWidgetAnnotation(l);\n          case \"Ch\":\n            return new ChoiceWidgetAnnotation(l);\n          case \"Sig\":\n            return new SignatureWidgetAnnotation(l);\n        }\n        warn(`Unimplemented widget field type \"${e}\", falling back to base field type.`);\n        return new WidgetAnnotation(l);\n      case \"Popup\":\n        return new PopupAnnotation(l);\n      case \"FreeText\":\n        return new FreeTextAnnotation(l);\n      case \"Line\":\n        return new LineAnnotation(l);\n      case \"Square\":\n        return new SquareAnnotation(l);\n      case \"Circle\":\n        return new CircleAnnotation(l);\n      case \"PolyLine\":\n        return new PolylineAnnotation(l);\n      case \"Polygon\":\n        return new PolygonAnnotation(l);\n      case \"Caret\":\n        return new CaretAnnotation(l);\n      case \"Ink\":\n        return new InkAnnotation(l);\n      case \"Highlight\":\n        return new HighlightAnnotation(l);\n      case \"Underline\":\n        return new UnderlineAnnotation(l);\n      case \"Squiggly\":\n        return new SquigglyAnnotation(l);\n      case \"StrikeOut\":\n        return new StrikeOutAnnotation(l);\n      case \"Stamp\":\n        return new StampAnnotation(l);\n      case \"FileAttachment\":\n        return new FileAttachmentAnnotation(l);\n      default:\n        s || warn(h ? `Unimplemented annotation type \"${h}\", falling back to base annotation.` : \"Annotation is missing the required /Subtype.\");\n        return new Annotation(l);\n    }\n  }\n  static async _getPageIndex(e, t, i) {\n    try {\n      const a = await e.fetchIfRefAsync(t);\n      if (!(a instanceof Dict)) return -1;\n      const s = a.getRaw(\"P\");\n      if (s instanceof Ref) try {\n        return await i.ensureCatalog(\"getPageIndex\", [s]);\n      } catch (e) {\n        info(`_getPageIndex -- not a valid page reference: \"${e}\".`);\n      }\n      if (a.has(\"Kids\")) return -1;\n      const r = await i.ensureDoc(\"numPages\");\n      for (let e = 0; e < r; e++) {\n        const a = await i.getPage(e),\n          s = await i.ensure(a, \"annotations\");\n        for (const i of s) if (i instanceof Ref && isRefsEqual(i, t)) return e;\n      }\n    } catch (e) {\n      warn(`_getPageIndex: \"${e}\".`);\n    }\n    return -1;\n  }\n  static generateImages(e, t, i) {\n    if (!i) {\n      warn(\"generateImages: OffscreenCanvas is not supported, cannot save or print some annotations with images.\");\n      return null;\n    }\n    let a;\n    for (const {\n      bitmapId: i,\n      bitmap: s\n    } of e) if (s) {\n      a ||= new Map();\n      a.set(i, StampAnnotation.createImage(s, t));\n    }\n    return a;\n  }\n  static async saveNewAnnotations(e, t, i, a) {\n    const s = e.xref;\n    let r;\n    const n = [],\n      g = [],\n      {\n        isOffscreenCanvasSupported: o\n      } = e.options;\n    for (const c of i) if (!c.deleted) switch (c.annotationType) {\n      case u:\n        if (!r) {\n          const e = new Dict(s);\n          e.set(\"BaseFont\", Name.get(\"Helvetica\"));\n          e.set(\"Type\", Name.get(\"Font\"));\n          e.set(\"Subtype\", Name.get(\"Type1\"));\n          e.set(\"Encoding\", Name.get(\"WinAnsiEncoding\"));\n          const t = [];\n          r = s.getNewTemporaryRef();\n          await writeObject(r, e, t, s);\n          n.push({\n            ref: r,\n            data: t.join(\"\")\n          });\n        }\n        g.push(FreeTextAnnotation.createNewAnnotation(s, c, n, {\n          evaluator: e,\n          task: t,\n          baseFontRef: r\n        }));\n        break;\n      case d:\n        c.quadPoints ? g.push(HighlightAnnotation.createNewAnnotation(s, c, n)) : g.push(InkAnnotation.createNewAnnotation(s, c, n));\n        break;\n      case p:\n        g.push(InkAnnotation.createNewAnnotation(s, c, n));\n        break;\n      case f:\n        if (!o) break;\n        const i = await a.get(c.bitmapId);\n        if (i.imageStream) {\n          const {\n              imageStream: e,\n              smaskStream: t\n            } = i,\n            a = [];\n          if (t) {\n            const i = s.getNewTemporaryRef();\n            await writeObject(i, t, a, s);\n            n.push({\n              ref: i,\n              data: a.join(\"\")\n            });\n            e.dict.set(\"SMask\", i);\n            a.length = 0;\n          }\n          const r = i.imageRef = s.getNewTemporaryRef();\n          await writeObject(r, e, a, s);\n          n.push({\n            ref: r,\n            data: a.join(\"\")\n          });\n          i.imageStream = i.smaskStream = null;\n        }\n        g.push(StampAnnotation.createNewAnnotation(s, c, n, {\n          image: i\n        }));\n    }\n    return {\n      annotations: await Promise.all(g),\n      dependencies: n\n    };\n  }\n  static async printNewAnnotations(e, t, i, a, s) {\n    if (!a) return null;\n    const {\n        options: r,\n        xref: n\n      } = t,\n      g = [];\n    for (const o of a) if (!o.deleted) switch (o.annotationType) {\n      case u:\n        g.push(FreeTextAnnotation.createNewPrintAnnotation(e, n, o, {\n          evaluator: t,\n          task: i,\n          evaluatorOptions: r\n        }));\n        break;\n      case d:\n        o.quadPoints ? g.push(HighlightAnnotation.createNewPrintAnnotation(e, n, o, {\n          evaluatorOptions: r\n        })) : g.push(InkAnnotation.createNewPrintAnnotation(e, n, o, {\n          evaluatorOptions: r\n        }));\n        break;\n      case p:\n        g.push(InkAnnotation.createNewPrintAnnotation(e, n, o, {\n          evaluatorOptions: r\n        }));\n        break;\n      case f:\n        if (!r.isOffscreenCanvasSupported) break;\n        const a = await s.get(o.bitmapId);\n        if (a.imageStream) {\n          const {\n            imageStream: e,\n            smaskStream: t\n          } = a;\n          t && e.dict.set(\"SMask\", t);\n          a.imageRef = new JpegStream(e, e.length);\n          a.imageStream = a.smaskStream = null;\n        }\n        g.push(StampAnnotation.createNewPrintAnnotation(e, n, o, {\n          image: a,\n          evaluatorOptions: r\n        }));\n    }\n    return Promise.all(g);\n  }\n}\nfunction getRgbColor(e, t = new Uint8ClampedArray(3)) {\n  if (!Array.isArray(e)) return t;\n  const i = t || new Uint8ClampedArray(3);\n  switch (e.length) {\n    case 0:\n      return null;\n    case 1:\n      ColorSpace.singletons.gray.getRgbItem(e, 0, i, 0);\n      return i;\n    case 3:\n      ColorSpace.singletons.rgb.getRgbItem(e, 0, i, 0);\n      return i;\n    case 4:\n      ColorSpace.singletons.cmyk.getRgbItem(e, 0, i, 0);\n      return i;\n    default:\n      return t;\n  }\n}\nfunction getPdfColorArray(e) {\n  return Array.from(e, e => e / 255);\n}\nfunction getQuadPoints(e, t) {\n  const i = e.getArray(\"QuadPoints\");\n  if (!isNumberArray(i, null) || 0 === i.length || i.length % 8 > 0) return null;\n  const a = new Float32Array(i.length);\n  for (let e = 0, s = i.length; e < s; e += 8) {\n    const [s, r, n, g, o, c, C, h] = i.slice(e, e + 8),\n      l = Math.min(s, n, o, C),\n      Q = Math.max(s, n, o, C),\n      E = Math.min(r, g, c, h),\n      u = Math.max(r, g, c, h);\n    if (null !== t && (l < t[0] || Q > t[2] || E < t[1] || u > t[3])) return null;\n    a.set([l, u, Q, u, l, E, Q, E], e);\n  }\n  return a;\n}\nfunction getTransformMatrix(e, t, i) {\n  const [a, s, r, n] = Util.getAxialAlignedBoundingBox(t, i);\n  if (a === r || s === n) return [1, 0, 0, 1, e[0], e[1]];\n  const g = (e[2] - e[0]) / (r - a),\n    o = (e[3] - e[1]) / (n - s);\n  return [g, 0, 0, o, e[0] - a * g, e[1] - s * o];\n}\nclass Annotation {\n  constructor(e) {\n    const {\n      dict: t,\n      xref: i,\n      annotationGlobals: a\n    } = e;\n    this.setTitle(t.get(\"T\"));\n    this.setContents(t.get(\"Contents\"));\n    this.setModificationDate(t.get(\"M\"));\n    this.setFlags(t.get(\"F\"));\n    this.setRectangle(t.getArray(\"Rect\"));\n    this.setColor(t.getArray(\"C\"));\n    this.setBorderStyle(t);\n    this.setAppearance(t);\n    this.setOptionalContent(t);\n    const s = t.get(\"MK\");\n    this.setBorderAndBackgroundColors(s);\n    this.setRotation(s, t);\n    this.ref = e.ref instanceof Ref ? e.ref : null;\n    this._streams = [];\n    this.appearance && this._streams.push(this.appearance);\n    const r = !!(this.flags & AA),\n      n = !!(this.flags & eA);\n    if (a.structTreeRoot) {\n      let i = t.get(\"StructParent\");\n      i = Number.isInteger(i) && i >= 0 ? i : -1;\n      a.structTreeRoot.addAnnotationIdToPage(e.pageRef, i);\n    }\n    this.data = {\n      annotationFlags: this.flags,\n      borderStyle: this.borderStyle,\n      color: this.color,\n      backgroundColor: this.backgroundColor,\n      borderColor: this.borderColor,\n      rotation: this.rotation,\n      contentsObj: this._contents,\n      hasAppearance: !!this.appearance,\n      id: e.id,\n      modificationDate: this.modificationDate,\n      rect: this.rectangle,\n      subtype: e.subtype,\n      hasOwnCanvas: !1,\n      noRotate: !!(this.flags & _),\n      noHTML: r && n\n    };\n    if (e.collectFields) {\n      const a = t.get(\"Kids\");\n      if (Array.isArray(a)) {\n        const e = [];\n        for (const t of a) t instanceof Ref && e.push(t.toString());\n        0 !== e.length && (this.data.kidIds = e);\n      }\n      this.data.actions = collectActions(i, t, uA);\n      this.data.fieldName = this._constructFieldName(t);\n      this.data.pageIndex = e.pageIndex;\n    }\n    this._isOffscreenCanvasSupported = e.evaluatorOptions.isOffscreenCanvasSupported;\n    this._fallbackFontDict = null;\n    this._needAppearances = !1;\n  }\n  _hasFlag(e, t) {\n    return !!(e & t);\n  }\n  _isViewable(e) {\n    return !this._hasFlag(e, Z) && !this._hasFlag(e, $);\n  }\n  _isPrintable(e) {\n    return this._hasFlag(e, z) && !this._hasFlag(e, V) && !this._hasFlag(e, Z);\n  }\n  mustBeViewed(e, t) {\n    const i = e?.get(this.data.id)?.noView;\n    return void 0 !== i ? !i : this.viewable && !this._hasFlag(this.flags, V);\n  }\n  mustBePrinted(e) {\n    const t = e?.get(this.data.id)?.noPrint;\n    return void 0 !== t ? !t : this.printable;\n  }\n  get viewable() {\n    return null !== this.data.quadPoints && (0 === this.flags || this._isViewable(this.flags));\n  }\n  get printable() {\n    return null !== this.data.quadPoints && 0 !== this.flags && this._isPrintable(this.flags);\n  }\n  _parseStringHelper(e) {\n    const t = \"string\" == typeof e ? stringToPDFString(e) : \"\";\n    return {\n      str: t,\n      dir: t && \"rtl\" === bidi(t).dir ? \"rtl\" : \"ltr\"\n    };\n  }\n  setDefaultAppearance(e) {\n    const {\n        dict: t,\n        annotationGlobals: i\n      } = e,\n      a = getInheritableProperty({\n        dict: t,\n        key: \"DA\"\n      }) || i.acroForm.get(\"DA\");\n    this._defaultAppearance = \"string\" == typeof a ? a : \"\";\n    this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance);\n  }\n  setTitle(e) {\n    this._title = this._parseStringHelper(e);\n  }\n  setContents(e) {\n    this._contents = this._parseStringHelper(e);\n  }\n  setModificationDate(e) {\n    this.modificationDate = \"string\" == typeof e ? e : null;\n  }\n  setFlags(e) {\n    this.flags = Number.isInteger(e) && e > 0 ? e : 0;\n    this.flags & Z && \"Annotation\" !== this.constructor.name && (this.flags ^= Z);\n  }\n  hasFlag(e) {\n    return this._hasFlag(this.flags, e);\n  }\n  setRectangle(e) {\n    this.rectangle = lookupNormalRect(e, [0, 0, 0, 0]);\n  }\n  setColor(e) {\n    this.color = getRgbColor(e);\n  }\n  setLineEndings(e) {\n    this.lineEndings = [\"None\", \"None\"];\n    if (Array.isArray(e) && 2 === e.length) for (let t = 0; t < 2; t++) {\n      const i = e[t];\n      if (i instanceof Name) switch (i.name) {\n        case \"None\":\n          continue;\n        case \"Square\":\n        case \"Circle\":\n        case \"Diamond\":\n        case \"OpenArrow\":\n        case \"ClosedArrow\":\n        case \"Butt\":\n        case \"ROpenArrow\":\n        case \"RClosedArrow\":\n        case \"Slash\":\n          this.lineEndings[t] = i.name;\n          continue;\n      }\n      warn(`Ignoring invalid lineEnding: ${i}`);\n    }\n  }\n  setRotation(e, t) {\n    this.rotation = 0;\n    let i = e instanceof Dict ? e.get(\"R\") || 0 : t.get(\"Rotate\") || 0;\n    if (Number.isInteger(i) && 0 !== i) {\n      i %= 360;\n      i < 0 && (i += 360);\n      i % 90 == 0 && (this.rotation = i);\n    }\n  }\n  setBorderAndBackgroundColors(e) {\n    if (e instanceof Dict) {\n      this.borderColor = getRgbColor(e.getArray(\"BC\"), null);\n      this.backgroundColor = getRgbColor(e.getArray(\"BG\"), null);\n    } else this.borderColor = this.backgroundColor = null;\n  }\n  setBorderStyle(e) {\n    this.borderStyle = new AnnotationBorderStyle();\n    if (e instanceof Dict) if (e.has(\"BS\")) {\n      const t = e.get(\"BS\");\n      if (t instanceof Dict) {\n        const e = t.get(\"Type\");\n        if (!e || isName(e, \"Border\")) {\n          this.borderStyle.setWidth(t.get(\"W\"), this.rectangle);\n          this.borderStyle.setStyle(t.get(\"S\"));\n          this.borderStyle.setDashArray(t.getArray(\"D\"));\n        }\n      }\n    } else if (e.has(\"Border\")) {\n      const t = e.getArray(\"Border\");\n      if (Array.isArray(t) && t.length >= 3) {\n        this.borderStyle.setHorizontalCornerRadius(t[0]);\n        this.borderStyle.setVerticalCornerRadius(t[1]);\n        this.borderStyle.setWidth(t[2], this.rectangle);\n        4 === t.length && this.borderStyle.setDashArray(t[3], !0);\n      }\n    } else this.borderStyle.setWidth(0);\n  }\n  setAppearance(e) {\n    this.appearance = null;\n    const t = e.get(\"AP\");\n    if (!(t instanceof Dict)) return;\n    const i = t.get(\"N\");\n    if (i instanceof BaseStream) {\n      this.appearance = i;\n      return;\n    }\n    if (!(i instanceof Dict)) return;\n    const a = e.get(\"AS\");\n    if (!(a instanceof Name && i.has(a.name))) return;\n    const s = i.get(a.name);\n    s instanceof BaseStream && (this.appearance = s);\n  }\n  setOptionalContent(e) {\n    this.oc = null;\n    const t = e.get(\"OC\");\n    t instanceof Name ? warn(\"setOptionalContent: Support for /Name-entry is not implemented.\") : t instanceof Dict && (this.oc = t);\n  }\n  loadResources(e, t) {\n    return t.dict.getAsync(\"Resources\").then(t => {\n      if (!t) return;\n      return new ObjectLoader(t, e, t.xref).load().then(function () {\n        return t;\n      });\n    });\n  }\n  async getOperatorList(e, t, a, s, r) {\n    const {\n      hasOwnCanvas: n,\n      id: g,\n      rect: c\n    } = this.data;\n    let C = this.appearance;\n    const h = !!(n && a & o);\n    if (h && (c[0] === c[2] || c[1] === c[3])) {\n      this.data.hasOwnCanvas = !1;\n      return {\n        opList: new OperatorList(),\n        separateForm: !1,\n        separateCanvas: !1\n      };\n    }\n    if (!C) {\n      if (!h) return {\n        opList: new OperatorList(),\n        separateForm: !1,\n        separateCanvas: !1\n      };\n      C = new StringStream(\"\");\n      C.dict = new Dict();\n    }\n    const l = C.dict,\n      Q = await this.loadResources([\"ExtGState\", \"ColorSpace\", \"Pattern\", \"Shading\", \"XObject\", \"Font\"], C),\n      E = lookupRect(l.getArray(\"BBox\"), [0, 0, 1, 1]),\n      u = lookupMatrix(l.getArray(\"Matrix\"), i),\n      d = getTransformMatrix(c, E, u),\n      f = new OperatorList();\n    let p;\n    this.oc && (p = await e.parseMarkedContentProps(this.oc, null));\n    void 0 !== p && f.addOp(Je, [\"OC\", p]);\n    f.addOp(We, [g, c, d, u, h]);\n    await e.getOperatorList({\n      stream: C,\n      task: t,\n      resources: Q,\n      operatorList: f,\n      fallbackFontDict: this._fallbackFontDict\n    });\n    f.addOp(je, []);\n    void 0 !== p && f.addOp(Ye, []);\n    this.reset();\n    return {\n      opList: f,\n      separateForm: !1,\n      separateCanvas: h\n    };\n  }\n  async save(e, t, i) {\n    return null;\n  }\n  get hasTextContent() {\n    return !1;\n  }\n  async extractTextContent(e, t, i) {\n    if (!this.appearance) return;\n    const a = await this.loadResources([\"ExtGState\", \"Font\", \"Properties\", \"XObject\"], this.appearance),\n      s = [],\n      r = [];\n    let n = null;\n    const g = {\n      desiredSize: Math.Infinity,\n      ready: !0,\n      enqueue(e, t) {\n        for (const t of e.items) if (void 0 !== t.str) {\n          n ||= t.transform.slice(-2);\n          r.push(t.str);\n          if (t.hasEOL) {\n            s.push(r.join(\"\").trimEnd());\n            r.length = 0;\n          }\n        }\n      }\n    };\n    await e.getTextContent({\n      stream: this.appearance,\n      task: t,\n      resources: a,\n      includeMarkedContent: !0,\n      keepWhiteSpace: !0,\n      sink: g,\n      viewBox: i\n    });\n    this.reset();\n    r.length && s.push(r.join(\"\").trimEnd());\n    if (s.length > 1 || s[0]) {\n      const e = this.appearance.dict,\n        t = lookupRect(e.getArray(\"BBox\"), null),\n        i = lookupMatrix(e.getArray(\"Matrix\"), null);\n      this.data.textPosition = this._transformPoint(n, t, i);\n      this.data.textContent = s;\n    }\n  }\n  _transformPoint(e, t, i) {\n    const {\n      rect: a\n    } = this.data;\n    t ||= [0, 0, 1, 1];\n    i ||= [1, 0, 0, 1, 0, 0];\n    const s = getTransformMatrix(a, t, i);\n    s[4] -= a[0];\n    s[5] -= a[1];\n    e = Util.applyTransform(e, s);\n    return Util.applyTransform(e, i);\n  }\n  getFieldObject() {\n    return this.data.kidIds ? {\n      id: this.data.id,\n      actions: this.data.actions,\n      name: this.data.fieldName,\n      strokeColor: this.data.borderColor,\n      fillColor: this.data.backgroundColor,\n      type: \"\",\n      kidIds: this.data.kidIds,\n      page: this.data.pageIndex,\n      rotation: this.rotation\n    } : null;\n  }\n  reset() {\n    for (const e of this._streams) e.reset();\n  }\n  _constructFieldName(e) {\n    if (!e.has(\"T\") && !e.has(\"Parent\")) {\n      warn(\"Unknown field name, falling back to empty field name.\");\n      return \"\";\n    }\n    if (!e.has(\"Parent\")) return stringToPDFString(e.get(\"T\"));\n    const t = [];\n    e.has(\"T\") && t.unshift(stringToPDFString(e.get(\"T\")));\n    let i = e;\n    const a = new RefSet();\n    e.objId && a.put(e.objId);\n    for (; i.has(\"Parent\");) {\n      i = i.get(\"Parent\");\n      if (!(i instanceof Dict) || i.objId && a.has(i.objId)) break;\n      i.objId && a.put(i.objId);\n      i.has(\"T\") && t.unshift(stringToPDFString(i.get(\"T\")));\n    }\n    return t.join(\".\");\n  }\n}\nclass AnnotationBorderStyle {\n  constructor() {\n    this.width = 1;\n    this.style = hA;\n    this.dashArray = [3];\n    this.horizontalCornerRadius = 0;\n    this.verticalCornerRadius = 0;\n  }\n  setWidth(e, t = [0, 0, 0, 0]) {\n    if (e instanceof Name) this.width = 0;else if (\"number\" == typeof e) {\n      if (e > 0) {\n        const i = (t[2] - t[0]) / 2,\n          a = (t[3] - t[1]) / 2;\n        if (i > 0 && a > 0 && (e > i || e > a)) {\n          warn(`AnnotationBorderStyle.setWidth - ignoring width: ${e}`);\n          e = 1;\n        }\n      }\n      this.width = e;\n    }\n  }\n  setStyle(e) {\n    if (e instanceof Name) switch (e.name) {\n      case \"S\":\n        this.style = hA;\n        break;\n      case \"D\":\n        this.style = BA;\n        break;\n      case \"B\":\n        this.style = lA;\n        break;\n      case \"I\":\n        this.style = QA;\n        break;\n      case \"U\":\n        this.style = EA;\n    }\n  }\n  setDashArray(e, t = !1) {\n    if (Array.isArray(e)) {\n      let i = !0,\n        a = !0;\n      for (const t of e) {\n        if (!(+t >= 0)) {\n          i = !1;\n          break;\n        }\n        t > 0 && (a = !1);\n      }\n      if (0 === e.length || i && !a) {\n        this.dashArray = e;\n        t && this.setStyle(Name.get(\"D\"));\n      } else this.width = 0;\n    } else e && (this.width = 0);\n  }\n  setHorizontalCornerRadius(e) {\n    Number.isInteger(e) && (this.horizontalCornerRadius = e);\n  }\n  setVerticalCornerRadius(e) {\n    Number.isInteger(e) && (this.verticalCornerRadius = e);\n  }\n}\nclass MarkupAnnotation extends Annotation {\n  constructor(e) {\n    super(e);\n    const {\n      dict: t\n    } = e;\n    if (t.has(\"IRT\")) {\n      const e = t.getRaw(\"IRT\");\n      this.data.inReplyTo = e instanceof Ref ? e.toString() : null;\n      const i = t.get(\"RT\");\n      this.data.replyType = i instanceof Name ? i.name : X;\n    }\n    let i = null;\n    if (this.data.replyType === j) {\n      const e = t.get(\"IRT\");\n      this.setTitle(e.get(\"T\"));\n      this.data.titleObj = this._title;\n      this.setContents(e.get(\"Contents\"));\n      this.data.contentsObj = this._contents;\n      if (e.has(\"CreationDate\")) {\n        this.setCreationDate(e.get(\"CreationDate\"));\n        this.data.creationDate = this.creationDate;\n      } else this.data.creationDate = null;\n      if (e.has(\"M\")) {\n        this.setModificationDate(e.get(\"M\"));\n        this.data.modificationDate = this.modificationDate;\n      } else this.data.modificationDate = null;\n      i = e.getRaw(\"Popup\");\n      if (e.has(\"C\")) {\n        this.setColor(e.getArray(\"C\"));\n        this.data.color = this.color;\n      } else this.data.color = null;\n    } else {\n      this.data.titleObj = this._title;\n      this.setCreationDate(t.get(\"CreationDate\"));\n      this.data.creationDate = this.creationDate;\n      i = t.getRaw(\"Popup\");\n      t.has(\"C\") || (this.data.color = null);\n    }\n    this.data.popupRef = i instanceof Ref ? i.toString() : null;\n    t.has(\"RC\") && (this.data.richText = XFAFactory.getRichTextAsHtml(t.get(\"RC\")));\n  }\n  setCreationDate(e) {\n    this.creationDate = \"string\" == typeof e ? e : null;\n  }\n  _setDefaultAppearance({\n    xref: e,\n    extra: t,\n    strokeColor: i,\n    fillColor: a,\n    blendMode: s,\n    strokeAlpha: r,\n    fillAlpha: n,\n    pointsCallback: g\n  }) {\n    let o = Number.MAX_VALUE,\n      c = Number.MAX_VALUE,\n      C = Number.MIN_VALUE,\n      h = Number.MIN_VALUE;\n    const l = [\"q\"];\n    t && l.push(t);\n    i && l.push(`${i[0]} ${i[1]} ${i[2]} RG`);\n    a && l.push(`${a[0]} ${a[1]} ${a[2]} rg`);\n    let Q = this.data.quadPoints;\n    Q || (Q = Float32Array.from([this.rectangle[0], this.rectangle[3], this.rectangle[2], this.rectangle[3], this.rectangle[0], this.rectangle[1], this.rectangle[2], this.rectangle[1]]));\n    for (let e = 0, t = Q.length; e < t; e += 8) {\n      const [t, i, a, s] = g(l, Q.subarray(e, e + 8));\n      o = Math.min(o, t);\n      C = Math.max(C, i);\n      c = Math.min(c, a);\n      h = Math.max(h, s);\n    }\n    l.push(\"Q\");\n    const E = new Dict(e),\n      u = new Dict(e);\n    u.set(\"Subtype\", Name.get(\"Form\"));\n    const d = new StringStream(l.join(\" \"));\n    d.dict = u;\n    E.set(\"Fm0\", d);\n    const f = new Dict(e);\n    s && f.set(\"BM\", Name.get(s));\n    \"number\" == typeof r && f.set(\"CA\", r);\n    \"number\" == typeof n && f.set(\"ca\", n);\n    const p = new Dict(e);\n    p.set(\"GS0\", f);\n    const m = new Dict(e);\n    m.set(\"ExtGState\", p);\n    m.set(\"XObject\", E);\n    const y = new Dict(e);\n    y.set(\"Resources\", m);\n    const w = this.data.rect = [o, c, C, h];\n    y.set(\"BBox\", w);\n    this.appearance = new StringStream(\"/GS0 gs /Fm0 Do\");\n    this.appearance.dict = y;\n    this._streams.push(this.appearance, d);\n  }\n  static async createNewAnnotation(e, t, i, a) {\n    const s = t.ref ||= e.getNewTemporaryRef(),\n      r = await this.createNewAppearanceStream(t, e, a),\n      n = [];\n    let g;\n    if (r) {\n      const a = e.getNewTemporaryRef();\n      g = this.createNewDict(t, e, {\n        apRef: a\n      });\n      await writeObject(a, r, n, e);\n      i.push({\n        ref: a,\n        data: n.join(\"\")\n      });\n    } else g = this.createNewDict(t, e, {});\n    Number.isInteger(t.parentTreeId) && g.set(\"StructParent\", t.parentTreeId);\n    n.length = 0;\n    await writeObject(s, g, n, e);\n    return {\n      ref: s,\n      data: n.join(\"\")\n    };\n  }\n  static async createNewPrintAnnotation(e, t, i, a) {\n    const s = await this.createNewAppearanceStream(i, t, a),\n      r = this.createNewDict(i, t, {\n        ap: s\n      }),\n      n = new this.prototype.constructor({\n        dict: r,\n        xref: t,\n        annotationGlobals: e,\n        evaluatorOptions: a.evaluatorOptions\n      });\n    i.ref && (n.ref = n.refToReplace = i.ref);\n    return n;\n  }\n}\nclass WidgetAnnotation extends Annotation {\n  constructor(e) {\n    super(e);\n    const {\n        dict: t,\n        xref: i,\n        annotationGlobals: a\n      } = e,\n      s = this.data;\n    this._needAppearances = e.needAppearances;\n    s.annotationType = W;\n    void 0 === s.fieldName && (s.fieldName = this._constructFieldName(t));\n    void 0 === s.actions && (s.actions = collectActions(i, t, uA));\n    let r = getInheritableProperty({\n      dict: t,\n      key: \"V\",\n      getArray: !0\n    });\n    s.fieldValue = this._decodeFormValue(r);\n    const n = getInheritableProperty({\n      dict: t,\n      key: \"DV\",\n      getArray: !0\n    });\n    s.defaultFieldValue = this._decodeFormValue(n);\n    if (void 0 === r && a.xfaDatasets) {\n      const e = this._title.str;\n      if (e) {\n        this._hasValueFromXFA = !0;\n        s.fieldValue = r = a.xfaDatasets.getValue(e);\n      }\n    }\n    void 0 === r && null !== s.defaultFieldValue && (s.fieldValue = s.defaultFieldValue);\n    s.alternativeText = stringToPDFString(t.get(\"TU\") || \"\");\n    this.setDefaultAppearance(e);\n    s.hasAppearance ||= this._needAppearances && void 0 !== s.fieldValue && null !== s.fieldValue;\n    const g = getInheritableProperty({\n      dict: t,\n      key: \"FT\"\n    });\n    s.fieldType = g instanceof Name ? g.name : null;\n    const o = getInheritableProperty({\n        dict: t,\n        key: \"DR\"\n      }),\n      c = a.acroForm.get(\"DR\"),\n      C = this.appearance?.dict.get(\"Resources\");\n    this._fieldResources = {\n      localResources: o,\n      acroFormResources: c,\n      appearanceResources: C,\n      mergedResources: Dict.merge({\n        xref: i,\n        dictArray: [o, C, c],\n        mergeSubDicts: !0\n      })\n    };\n    s.fieldFlags = getInheritableProperty({\n      dict: t,\n      key: \"Ff\"\n    });\n    (!Number.isInteger(s.fieldFlags) || s.fieldFlags < 0) && (s.fieldFlags = 0);\n    s.readOnly = this.hasFieldFlag(tA);\n    s.required = this.hasFieldFlag(iA);\n    s.hidden = this._hasFlag(s.annotationFlags, V) || this._hasFlag(s.annotationFlags, $);\n  }\n  _decodeFormValue(e) {\n    return Array.isArray(e) ? e.filter(e => \"string\" == typeof e).map(e => stringToPDFString(e)) : e instanceof Name ? stringToPDFString(e.name) : \"string\" == typeof e ? stringToPDFString(e) : null;\n  }\n  hasFieldFlag(e) {\n    return !!(this.data.fieldFlags & e);\n  }\n  _isViewable(e) {\n    return !0;\n  }\n  mustBeViewed(e, t) {\n    return t ? this.viewable : super.mustBeViewed(e, t) && !this._hasFlag(this.flags, $);\n  }\n  getRotationMatrix(e) {\n    let t = e?.get(this.data.id)?.rotation;\n    void 0 === t && (t = this.rotation);\n    if (0 === t) return i;\n    return getRotationMatrix(t, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]);\n  }\n  getBorderAndBackgroundAppearances(e) {\n    let t = e?.get(this.data.id)?.rotation;\n    void 0 === t && (t = this.rotation);\n    if (!this.backgroundColor && !this.borderColor) return \"\";\n    const i = this.data.rect[2] - this.data.rect[0],\n      a = this.data.rect[3] - this.data.rect[1],\n      s = 0 === t || 180 === t ? `0 0 ${i} ${a} re` : `0 0 ${a} ${i} re`;\n    let r = \"\";\n    this.backgroundColor && (r = `${getPdfColor(this.backgroundColor, !0)} ${s} f `);\n    if (this.borderColor) {\n      r += `${this.borderStyle.width || 1} w ${getPdfColor(this.borderColor, !1)} ${s} S `;\n    }\n    return r;\n  }\n  async getOperatorList(e, t, i, a, s) {\n    if (a && !(this instanceof SignatureWidgetAnnotation) && !this.data.noHTML && !this.data.hasOwnCanvas) return {\n      opList: new OperatorList(),\n      separateForm: !0,\n      separateCanvas: !1\n    };\n    if (!this._hasText) return super.getOperatorList(e, t, i, a, s);\n    const r = await this._getAppearance(e, t, i, s);\n    if (this.appearance && null === r) return super.getOperatorList(e, t, i, a, s);\n    const n = new OperatorList();\n    if (!this._defaultAppearance || null === r) return {\n      opList: n,\n      separateForm: !1,\n      separateCanvas: !1\n    };\n    const g = !!(this.data.hasOwnCanvas && i & o),\n      c = [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]],\n      C = getTransformMatrix(this.data.rect, c, [1, 0, 0, 1, 0, 0]);\n    let h;\n    this.oc && (h = await e.parseMarkedContentProps(this.oc, null));\n    void 0 !== h && n.addOp(Je, [\"OC\", h]);\n    n.addOp(We, [this.data.id, this.data.rect, C, this.getRotationMatrix(s), g]);\n    const l = new StringStream(r);\n    await e.getOperatorList({\n      stream: l,\n      task: t,\n      resources: this._fieldResources.mergedResources,\n      operatorList: n\n    });\n    n.addOp(je, []);\n    void 0 !== h && n.addOp(Ye, []);\n    return {\n      opList: n,\n      separateForm: !1,\n      separateCanvas: g\n    };\n  }\n  _getMKDict(e) {\n    const t = new Dict(null);\n    e && t.set(\"R\", e);\n    this.borderColor && t.set(\"BC\", getPdfColorArray(this.borderColor));\n    this.backgroundColor && t.set(\"BG\", getPdfColorArray(this.backgroundColor));\n    return t.size > 0 ? t : null;\n  }\n  amendSavedDict(e, t) {}\n  async save(e, t, a) {\n    const s = a?.get(this.data.id);\n    let r = s?.value,\n      n = s?.rotation;\n    if (r === this.data.fieldValue || void 0 === r) {\n      if (!this._hasValueFromXFA && void 0 === n) return null;\n      r ||= this.data.fieldValue;\n    }\n    if (void 0 === n && !this._hasValueFromXFA && Array.isArray(r) && Array.isArray(this.data.fieldValue) && r.length === this.data.fieldValue.length && r.every((e, t) => e === this.data.fieldValue[t])) return null;\n    void 0 === n && (n = this.rotation);\n    let g = null;\n    if (!this._needAppearances) {\n      g = await this._getAppearance(e, t, C, a);\n      if (null === g) return null;\n    }\n    let o = !1;\n    if (g?.needAppearances) {\n      o = !0;\n      g = null;\n    }\n    const {\n        xref: c\n      } = e,\n      h = c.fetchIfRef(this.ref);\n    if (!(h instanceof Dict)) return null;\n    const l = new Dict(c);\n    for (const e of h.getKeys()) \"AP\" !== e && l.set(e, h.getRaw(e));\n    const Q = {\n        path: this.data.fieldName,\n        value: r\n      },\n      encoder = e => isAscii(e) ? e : stringToUTF16String(e, !0);\n    l.set(\"V\", Array.isArray(r) ? r.map(encoder) : encoder(r));\n    this.amendSavedDict(a, l);\n    const E = this._getMKDict(n);\n    E && l.set(\"MK\", E);\n    const u = [],\n      d = [{\n        ref: this.ref,\n        data: \"\",\n        xfa: Q,\n        needAppearances: o\n      }];\n    if (null !== g) {\n      const e = c.getNewTemporaryRef(),\n        t = new Dict(c);\n      l.set(\"AP\", t);\n      t.set(\"N\", e);\n      const s = this._getSaveFieldResources(c),\n        r = new StringStream(g),\n        n = r.dict = new Dict(c);\n      n.set(\"Subtype\", Name.get(\"Form\"));\n      n.set(\"Resources\", s);\n      n.set(\"BBox\", [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]]);\n      const o = this.getRotationMatrix(a);\n      o !== i && n.set(\"Matrix\", o);\n      await writeObject(e, r, u, c);\n      d.push({\n        ref: e,\n        data: u.join(\"\"),\n        xfa: null,\n        needAppearances: !1\n      });\n      u.length = 0;\n    }\n    l.set(\"M\", `D:${getModificationDate()}`);\n    await writeObject(this.ref, l, u, c);\n    d[0].data = u.join(\"\");\n    return d;\n  }\n  async _getAppearance(e, t, i, a) {\n    if (this.hasFieldFlag(sA)) return null;\n    const s = a?.get(this.data.id);\n    let r, g;\n    if (s) {\n      r = s.formattedValue || s.value;\n      g = s.rotation;\n    }\n    if (void 0 === g && void 0 === r && !this._needAppearances && (!this._hasValueFromXFA || this.appearance)) return null;\n    const o = this.getBorderAndBackgroundAppearances(a);\n    if (void 0 === r) {\n      r = this.data.fieldValue;\n      if (!r) return `/Tx BMC q ${o}Q EMC`;\n    }\n    Array.isArray(r) && 1 === r.length && (r = r[0]);\n    assert(\"string\" == typeof r, \"Expected `value` to be a string.\");\n    r = r.trim();\n    if (this.data.combo) {\n      const e = this.data.options.find(({\n        exportValue: e\n      }) => r === e);\n      r = e?.displayValue || r;\n    }\n    if (\"\" === r) return `/Tx BMC q ${o}Q EMC`;\n    void 0 === g && (g = this.rotation);\n    let c,\n      h = -1;\n    if (this.data.multiLine) {\n      c = r.split(/\\r\\n?|\\n/).map(e => e.normalize(\"NFC\"));\n      h = c.length;\n    } else c = [r.replace(/\\r\\n?|\\n/, \"\").normalize(\"NFC\")];\n    let l = this.data.rect[3] - this.data.rect[1],\n      Q = this.data.rect[2] - this.data.rect[0];\n    90 !== g && 270 !== g || ([Q, l] = [l, Q]);\n    this._defaultAppearance || (this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance = \"/Helvetica 0 Tf 0 g\"));\n    let E,\n      u,\n      d,\n      f = await WidgetAnnotation._getFontData(e, t, this.data.defaultAppearanceData, this._fieldResources.mergedResources);\n    const p = [];\n    let m = !1;\n    for (const e of c) {\n      const t = f.encodeString(e);\n      t.length > 1 && (m = !0);\n      p.push(t.join(\"\"));\n    }\n    if (m && i & C) return {\n      needAppearances: !0\n    };\n    if (m && this._isOffscreenCanvasSupported) {\n      const i = this.data.comb ? \"monospace\" : \"sans-serif\",\n        a = new FakeUnicodeFont(e.xref, i),\n        s = a.createFontResources(c.join(\"\")),\n        n = s.getRaw(\"Font\");\n      if (this._fieldResources.mergedResources.has(\"Font\")) {\n        const e = this._fieldResources.mergedResources.get(\"Font\");\n        for (const t of n.getKeys()) e.set(t, n.getRaw(t));\n      } else this._fieldResources.mergedResources.set(\"Font\", n);\n      const g = a.fontName.name;\n      f = await WidgetAnnotation._getFontData(e, t, {\n        fontName: g,\n        fontSize: 0\n      }, s);\n      for (let e = 0, t = p.length; e < t; e++) p[e] = stringToUTF16String(c[e]);\n      const o = Object.assign(Object.create(null), this.data.defaultAppearanceData);\n      this.data.defaultAppearanceData.fontSize = 0;\n      this.data.defaultAppearanceData.fontName = g;\n      [E, u, d] = this._computeFontSize(l - 2, Q - 4, r, f, h);\n      this.data.defaultAppearanceData = o;\n    } else {\n      this._isOffscreenCanvasSupported || warn(\"_getAppearance: OffscreenCanvas is not supported, annotation may not render correctly.\");\n      [E, u, d] = this._computeFontSize(l - 2, Q - 4, r, f, h);\n    }\n    let y = f.descent;\n    y = isNaN(y) ? n * d : Math.max(n * d, Math.abs(y) * u);\n    const w = Math.min(Math.floor((l - u) / 2), 1),\n      D = this.data.textAlignment;\n    if (this.data.multiLine) return this._getMultilineAppearance(E, p, f, u, Q, l, D, 2, w, y, d, a);\n    if (this.data.comb) return this._getCombAppearance(E, f, p[0], u, Q, l, 2, w, y, d, a);\n    const b = w + y;\n    if (0 === D || D > 2) return `/Tx BMC q ${o}BT ` + E + ` 1 0 0 1 ${numberToString(2)} ${numberToString(b)} Tm (${escapeString(p[0])}) Tj ET Q EMC`;\n    return `/Tx BMC q ${o}BT ` + E + ` 1 0 0 1 0 0 Tm ${this._renderText(p[0], f, u, Q, D, {\n      shift: 0\n    }, 2, b)} ET Q EMC`;\n  }\n  static async _getFontData(e, t, i, a) {\n    const s = new OperatorList(),\n      r = {\n        font: null,\n        clone() {\n          return this;\n        }\n      },\n      {\n        fontName: n,\n        fontSize: g\n      } = i;\n    await e.handleSetFont(a, [n && Name.get(n), g], null, s, t, r, null);\n    return r.font;\n  }\n  _getTextWidth(e, t) {\n    return t.charsToGlyphs(e).reduce((e, t) => e + t.width, 0) / 1e3;\n  }\n  _computeFontSize(e, t, i, a, r) {\n    let {\n        fontSize: n\n      } = this.data.defaultAppearanceData,\n      g = (n || 12) * s,\n      o = Math.round(e / g);\n    if (!n) {\n      const roundWithTwoDigits = e => Math.floor(100 * e) / 100;\n      if (-1 === r) {\n        const r = this._getTextWidth(i, a);\n        n = roundWithTwoDigits(Math.min(e / s, r > t ? t / r : 1 / 0));\n        o = 1;\n      } else {\n        const c = i.split(/\\r\\n?|\\n/),\n          C = [];\n        for (const e of c) {\n          const t = a.encodeString(e).join(\"\"),\n            i = a.charsToGlyphs(t),\n            s = a.getCharPositions(t);\n          C.push({\n            line: t,\n            glyphs: i,\n            positions: s\n          });\n        }\n        const isTooBig = i => {\n          let s = 0;\n          for (const r of C) {\n            s += this._splitLine(null, a, i, t, r).length * i;\n            if (s > e) return !0;\n          }\n          return !1;\n        };\n        o = Math.max(o, r);\n        for (;;) {\n          g = e / o;\n          n = roundWithTwoDigits(g / s);\n          if (!isTooBig(n)) break;\n          o++;\n        }\n      }\n      const {\n        fontName: c,\n        fontColor: C\n      } = this.data.defaultAppearanceData;\n      this._defaultAppearance = function createDefaultAppearance({\n        fontSize: e,\n        fontName: t,\n        fontColor: i\n      }) {\n        return `/${escapePDFName(t)} ${e} Tf ${getPdfColor(i, !0)}`;\n      }({\n        fontSize: n,\n        fontName: c,\n        fontColor: C\n      });\n    }\n    return [this._defaultAppearance, n, e / o];\n  }\n  _renderText(e, t, i, a, s, r, n, g) {\n    let o;\n    if (1 === s) {\n      o = (a - this._getTextWidth(e, t) * i) / 2;\n    } else if (2 === s) {\n      o = a - this._getTextWidth(e, t) * i - n;\n    } else o = n;\n    const c = numberToString(o - r.shift);\n    r.shift = o;\n    return `${c} ${g = numberToString(g)} Td (${escapeString(e)}) Tj`;\n  }\n  _getSaveFieldResources(e) {\n    const {\n        localResources: t,\n        appearanceResources: i,\n        acroFormResources: a\n      } = this._fieldResources,\n      s = this.data.defaultAppearanceData?.fontName;\n    if (!s) return t || Dict.empty;\n    for (const e of [t, i]) if (e instanceof Dict) {\n      const t = e.get(\"Font\");\n      if (t instanceof Dict && t.has(s)) return e;\n    }\n    if (a instanceof Dict) {\n      const i = a.get(\"Font\");\n      if (i instanceof Dict && i.has(s)) {\n        const a = new Dict(e);\n        a.set(s, i.getRaw(s));\n        const r = new Dict(e);\n        r.set(\"Font\", a);\n        return Dict.merge({\n          xref: e,\n          dictArray: [r, t],\n          mergeSubDicts: !0\n        });\n      }\n    }\n    return t || Dict.empty;\n  }\n  getFieldObject() {\n    return null;\n  }\n}\nclass TextWidgetAnnotation extends WidgetAnnotation {\n  constructor(e) {\n    super(e);\n    const {\n      dict: t\n    } = e;\n    if (t.has(\"PMD\")) {\n      this.flags |= V;\n      this.data.hidden = !0;\n      warn(\"Barcodes are not supported\");\n    }\n    this.data.hasOwnCanvas = this.data.readOnly && !this.data.noHTML;\n    this._hasText = !0;\n    \"string\" != typeof this.data.fieldValue && (this.data.fieldValue = \"\");\n    let i = getInheritableProperty({\n      dict: t,\n      key: \"Q\"\n    });\n    (!Number.isInteger(i) || i < 0 || i > 2) && (i = null);\n    this.data.textAlignment = i;\n    let a = getInheritableProperty({\n      dict: t,\n      key: \"MaxLen\"\n    });\n    (!Number.isInteger(a) || a < 0) && (a = 0);\n    this.data.maxLen = a;\n    this.data.multiLine = this.hasFieldFlag(aA);\n    this.data.comb = this.hasFieldFlag(CA) && !this.hasFieldFlag(aA) && !this.hasFieldFlag(sA) && !this.hasFieldFlag(oA) && 0 !== this.data.maxLen;\n    this.data.doNotScroll = this.hasFieldFlag(cA);\n  }\n  get hasTextContent() {\n    return !!this.appearance && !this._needAppearances;\n  }\n  _getCombAppearance(e, t, i, a, s, r, n, g, o, c, C) {\n    const h = s / this.data.maxLen,\n      l = this.getBorderAndBackgroundAppearances(C),\n      Q = [],\n      E = t.getCharPositions(i);\n    for (const [e, t] of E) Q.push(`(${escapeString(i.substring(e, t))}) Tj`);\n    const u = Q.join(` ${numberToString(h)} 0 Td `);\n    return `/Tx BMC q ${l}BT ` + e + ` 1 0 0 1 ${numberToString(n)} ${numberToString(g + o)} Tm ${u} ET Q EMC`;\n  }\n  _getMultilineAppearance(e, t, i, a, s, r, n, g, o, c, C, h) {\n    const l = [],\n      Q = s - 2 * g,\n      E = {\n        shift: 0\n      };\n    for (let e = 0, r = t.length; e < r; e++) {\n      const r = t[e],\n        h = this._splitLine(r, i, a, Q);\n      for (let t = 0, r = h.length; t < r; t++) {\n        const r = h[t],\n          Q = 0 === e && 0 === t ? -o - (C - c) : -C;\n        l.push(this._renderText(r, i, a, s, n, E, g, Q));\n      }\n    }\n    const u = this.getBorderAndBackgroundAppearances(h),\n      d = l.join(\"\\n\");\n    return `/Tx BMC q ${u}BT ` + e + ` 1 0 0 1 0 ${numberToString(r)} Tm ${d} ET Q EMC`;\n  }\n  _splitLine(e, t, i, a, s = {}) {\n    e = s.line || e;\n    const r = s.glyphs || t.charsToGlyphs(e);\n    if (r.length <= 1) return [e];\n    const n = s.positions || t.getCharPositions(e),\n      g = i / 1e3,\n      o = [];\n    let c = -1,\n      C = -1,\n      h = -1,\n      l = 0,\n      Q = 0;\n    for (let t = 0, i = r.length; t < i; t++) {\n      const [i, s] = n[t],\n        E = r[t],\n        u = E.width * g;\n      if (\" \" === E.unicode) {\n        if (Q + u > a) {\n          o.push(e.substring(l, i));\n          l = i;\n          Q = u;\n          c = -1;\n          h = -1;\n        } else {\n          Q += u;\n          c = i;\n          C = s;\n          h = t;\n        }\n      } else if (Q + u > a) {\n        if (-1 !== c) {\n          o.push(e.substring(l, C));\n          l = C;\n          t = h + 1;\n          c = -1;\n          Q = 0;\n        } else {\n          o.push(e.substring(l, i));\n          l = i;\n          Q = u;\n        }\n      } else Q += u;\n    }\n    l < e.length && o.push(e.substring(l, e.length));\n    return o;\n  }\n  getFieldObject() {\n    return {\n      id: this.data.id,\n      value: this.data.fieldValue,\n      defaultValue: this.data.defaultFieldValue || \"\",\n      multiline: this.data.multiLine,\n      password: this.hasFieldFlag(sA),\n      charLimit: this.data.maxLen,\n      comb: this.data.comb,\n      editable: !this.data.readOnly,\n      hidden: this.data.hidden,\n      name: this.data.fieldName,\n      rect: this.data.rect,\n      actions: this.data.actions,\n      page: this.data.pageIndex,\n      strokeColor: this.data.borderColor,\n      fillColor: this.data.backgroundColor,\n      rotation: this.rotation,\n      type: \"text\"\n    };\n  }\n}\nclass ButtonWidgetAnnotation extends WidgetAnnotation {\n  constructor(e) {\n    super(e);\n    this.checkedAppearance = null;\n    this.uncheckedAppearance = null;\n    this.data.checkBox = !this.hasFieldFlag(rA) && !this.hasFieldFlag(nA);\n    this.data.radioButton = this.hasFieldFlag(rA) && !this.hasFieldFlag(nA);\n    this.data.pushButton = this.hasFieldFlag(nA);\n    this.data.isTooltipOnly = !1;\n    if (this.data.checkBox) this._processCheckBox(e);else if (this.data.radioButton) this._processRadioButton(e);else if (this.data.pushButton) {\n      this.data.hasOwnCanvas = !0;\n      this.data.noHTML = !1;\n      this._processPushButton(e);\n    } else warn(\"Invalid field flags for button widget annotation\");\n  }\n  async getOperatorList(e, t, a, s, r) {\n    if (this.data.pushButton) return super.getOperatorList(e, t, a, !1, r);\n    let n = null,\n      g = null;\n    if (r) {\n      const e = r.get(this.data.id);\n      n = e ? e.value : null;\n      g = e ? e.rotation : null;\n    }\n    if (null === n && this.appearance) return super.getOperatorList(e, t, a, s, r);\n    null == n && (n = this.data.checkBox ? this.data.fieldValue === this.data.exportValue : this.data.fieldValue === this.data.buttonValue);\n    const o = n ? this.checkedAppearance : this.uncheckedAppearance;\n    if (o) {\n      const n = this.appearance,\n        c = lookupMatrix(o.dict.getArray(\"Matrix\"), i);\n      g && o.dict.set(\"Matrix\", this.getRotationMatrix(r));\n      this.appearance = o;\n      const C = super.getOperatorList(e, t, a, s, r);\n      this.appearance = n;\n      o.dict.set(\"Matrix\", c);\n      return C;\n    }\n    return {\n      opList: new OperatorList(),\n      separateForm: !1,\n      separateCanvas: !1\n    };\n  }\n  async save(e, t, i) {\n    return this.data.checkBox ? this._saveCheckbox(e, t, i) : this.data.radioButton ? this._saveRadioButton(e, t, i) : null;\n  }\n  async _saveCheckbox(e, t, i) {\n    if (!i) return null;\n    const a = i.get(this.data.id);\n    let s = a?.rotation,\n      r = a?.value;\n    if (void 0 === s) {\n      if (void 0 === r) return null;\n      if (this.data.fieldValue === this.data.exportValue === r) return null;\n    }\n    const n = e.xref.fetchIfRef(this.ref);\n    if (!(n instanceof Dict)) return null;\n    void 0 === s && (s = this.rotation);\n    void 0 === r && (r = this.data.fieldValue === this.data.exportValue);\n    const g = {\n        path: this.data.fieldName,\n        value: r ? this.data.exportValue : \"\"\n      },\n      o = Name.get(r ? this.data.exportValue : \"Off\");\n    n.set(\"V\", o);\n    n.set(\"AS\", o);\n    n.set(\"M\", `D:${getModificationDate()}`);\n    const c = this._getMKDict(s);\n    c && n.set(\"MK\", c);\n    const C = [];\n    await writeObject(this.ref, n, C, e.xref);\n    return [{\n      ref: this.ref,\n      data: C.join(\"\"),\n      xfa: g\n    }];\n  }\n  async _saveRadioButton(e, t, i) {\n    if (!i) return null;\n    const a = i.get(this.data.id);\n    let s = a?.rotation,\n      r = a?.value;\n    if (void 0 === s) {\n      if (void 0 === r) return null;\n      if (this.data.fieldValue === this.data.buttonValue === r) return null;\n    }\n    const n = e.xref.fetchIfRef(this.ref);\n    if (!(n instanceof Dict)) return null;\n    void 0 === r && (r = this.data.fieldValue === this.data.buttonValue);\n    void 0 === s && (s = this.rotation);\n    const g = {\n        path: this.data.fieldName,\n        value: r ? this.data.buttonValue : \"\"\n      },\n      o = Name.get(r ? this.data.buttonValue : \"Off\"),\n      c = [];\n    let C = null;\n    if (r) if (this.parent instanceof Ref) {\n      const t = e.xref.fetch(this.parent);\n      t.set(\"V\", o);\n      await writeObject(this.parent, t, c, e.xref);\n      C = c.join(\"\");\n      c.length = 0;\n    } else this.parent instanceof Dict && this.parent.set(\"V\", o);\n    n.set(\"AS\", o);\n    n.set(\"M\", `D:${getModificationDate()}`);\n    const h = this._getMKDict(s);\n    h && n.set(\"MK\", h);\n    await writeObject(this.ref, n, c, e.xref);\n    const l = [{\n      ref: this.ref,\n      data: c.join(\"\"),\n      xfa: g\n    }];\n    C && l.push({\n      ref: this.parent,\n      data: C,\n      xfa: null\n    });\n    return l;\n  }\n  _getDefaultCheckedAppearance(e, t) {\n    const i = this.data.rect[2] - this.data.rect[0],\n      a = this.data.rect[3] - this.data.rect[1],\n      s = [0, 0, i, a],\n      r = .8 * Math.min(i, a);\n    let n, g;\n    if (\"check\" === t) {\n      n = {\n        width: .755 * r,\n        height: .705 * r\n      };\n      g = \"3\";\n    } else if (\"disc\" === t) {\n      n = {\n        width: .791 * r,\n        height: .705 * r\n      };\n      g = \"l\";\n    } else unreachable(`_getDefaultCheckedAppearance - unsupported type: ${t}`);\n    const o = `q BT /PdfJsZaDb ${r} Tf 0 g ${numberToString((i - n.width) / 2)} ${numberToString((a - n.height) / 2)} Td (${g}) Tj ET Q`,\n      c = new Dict(e.xref);\n    c.set(\"FormType\", 1);\n    c.set(\"Subtype\", Name.get(\"Form\"));\n    c.set(\"Type\", Name.get(\"XObject\"));\n    c.set(\"BBox\", s);\n    c.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n    c.set(\"Length\", o.length);\n    const C = new Dict(e.xref),\n      h = new Dict(e.xref);\n    h.set(\"PdfJsZaDb\", this.fallbackFontDict);\n    C.set(\"Font\", h);\n    c.set(\"Resources\", C);\n    this.checkedAppearance = new StringStream(o);\n    this.checkedAppearance.dict = c;\n    this._streams.push(this.checkedAppearance);\n  }\n  _processCheckBox(e) {\n    const t = e.dict.get(\"AP\");\n    if (!(t instanceof Dict)) return;\n    const i = t.get(\"N\");\n    if (!(i instanceof Dict)) return;\n    const a = this._decodeFormValue(e.dict.get(\"AS\"));\n    \"string\" == typeof a && (this.data.fieldValue = a);\n    const s = null !== this.data.fieldValue && \"Off\" !== this.data.fieldValue ? this.data.fieldValue : \"Yes\",\n      r = i.getKeys();\n    if (0 === r.length) r.push(\"Off\", s);else if (1 === r.length) \"Off\" === r[0] ? r.push(s) : r.unshift(\"Off\");else if (r.includes(s)) {\n      r.length = 0;\n      r.push(\"Off\", s);\n    } else {\n      const e = r.find(e => \"Off\" !== e);\n      r.length = 0;\n      r.push(\"Off\", e);\n    }\n    r.includes(this.data.fieldValue) || (this.data.fieldValue = \"Off\");\n    this.data.exportValue = r[1];\n    const n = i.get(this.data.exportValue);\n    this.checkedAppearance = n instanceof BaseStream ? n : null;\n    const g = i.get(\"Off\");\n    this.uncheckedAppearance = g instanceof BaseStream ? g : null;\n    this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(e, \"check\");\n    this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance);\n    this._fallbackFontDict = this.fallbackFontDict;\n    null === this.data.defaultFieldValue && (this.data.defaultFieldValue = \"Off\");\n  }\n  _processRadioButton(e) {\n    this.data.buttonValue = null;\n    const t = e.dict.get(\"Parent\");\n    if (t instanceof Dict) {\n      this.parent = e.dict.getRaw(\"Parent\");\n      const i = t.get(\"V\");\n      i instanceof Name && (this.data.fieldValue = this._decodeFormValue(i));\n    }\n    const i = e.dict.get(\"AP\");\n    if (!(i instanceof Dict)) return;\n    const a = i.get(\"N\");\n    if (!(a instanceof Dict)) return;\n    for (const e of a.getKeys()) if (\"Off\" !== e) {\n      this.data.buttonValue = this._decodeFormValue(e);\n      break;\n    }\n    const s = a.get(this.data.buttonValue);\n    this.checkedAppearance = s instanceof BaseStream ? s : null;\n    const r = a.get(\"Off\");\n    this.uncheckedAppearance = r instanceof BaseStream ? r : null;\n    this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(e, \"disc\");\n    this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance);\n    this._fallbackFontDict = this.fallbackFontDict;\n    null === this.data.defaultFieldValue && (this.data.defaultFieldValue = \"Off\");\n  }\n  _processPushButton(e) {\n    const {\n      dict: t,\n      annotationGlobals: i\n    } = e;\n    if (t.has(\"A\") || t.has(\"AA\") || this.data.alternativeText) {\n      this.data.isTooltipOnly = !t.has(\"A\") && !t.has(\"AA\");\n      Catalog.parseDestDictionary({\n        destDict: t,\n        resultObj: this.data,\n        docBaseUrl: i.baseUrl,\n        docAttachments: i.attachments\n      });\n    } else warn(\"Push buttons without action dictionaries are not supported\");\n  }\n  getFieldObject() {\n    let e,\n      t = \"button\";\n    if (this.data.checkBox) {\n      t = \"checkbox\";\n      e = this.data.exportValue;\n    } else if (this.data.radioButton) {\n      t = \"radiobutton\";\n      e = this.data.buttonValue;\n    }\n    return {\n      id: this.data.id,\n      value: this.data.fieldValue || \"Off\",\n      defaultValue: this.data.defaultFieldValue,\n      exportValues: e,\n      editable: !this.data.readOnly,\n      name: this.data.fieldName,\n      rect: this.data.rect,\n      hidden: this.data.hidden,\n      actions: this.data.actions,\n      page: this.data.pageIndex,\n      strokeColor: this.data.borderColor,\n      fillColor: this.data.backgroundColor,\n      rotation: this.rotation,\n      type: t\n    };\n  }\n  get fallbackFontDict() {\n    const e = new Dict();\n    e.set(\"BaseFont\", Name.get(\"ZapfDingbats\"));\n    e.set(\"Type\", Name.get(\"FallbackType\"));\n    e.set(\"Subtype\", Name.get(\"FallbackType\"));\n    e.set(\"Encoding\", Name.get(\"ZapfDingbatsEncoding\"));\n    return shadow(this, \"fallbackFontDict\", e);\n  }\n}\nclass ChoiceWidgetAnnotation extends WidgetAnnotation {\n  constructor(e) {\n    super(e);\n    const {\n      dict: t,\n      xref: i\n    } = e;\n    this.indices = t.getArray(\"I\");\n    this.hasIndices = Array.isArray(this.indices) && this.indices.length > 0;\n    this.data.options = [];\n    const a = getInheritableProperty({\n      dict: t,\n      key: \"Opt\"\n    });\n    if (Array.isArray(a)) for (let e = 0, t = a.length; e < t; e++) {\n      const t = i.fetchIfRef(a[e]),\n        s = Array.isArray(t);\n      this.data.options[e] = {\n        exportValue: this._decodeFormValue(s ? i.fetchIfRef(t[0]) : t),\n        displayValue: this._decodeFormValue(s ? i.fetchIfRef(t[1]) : t)\n      };\n    }\n    if (this.hasIndices) {\n      this.data.fieldValue = [];\n      const e = this.data.options.length;\n      for (const t of this.indices) Number.isInteger(t) && t >= 0 && t < e && this.data.fieldValue.push(this.data.options[t].exportValue);\n    } else \"string\" == typeof this.data.fieldValue ? this.data.fieldValue = [this.data.fieldValue] : this.data.fieldValue || (this.data.fieldValue = []);\n    this.data.combo = this.hasFieldFlag(gA);\n    this.data.multiSelect = this.hasFieldFlag(IA);\n    this._hasText = !0;\n  }\n  getFieldObject() {\n    const e = this.data.combo ? \"combobox\" : \"listbox\",\n      t = this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;\n    return {\n      id: this.data.id,\n      value: t,\n      defaultValue: this.data.defaultFieldValue,\n      editable: !this.data.readOnly,\n      name: this.data.fieldName,\n      rect: this.data.rect,\n      numItems: this.data.fieldValue.length,\n      multipleSelection: this.data.multiSelect,\n      hidden: this.data.hidden,\n      actions: this.data.actions,\n      items: this.data.options,\n      page: this.data.pageIndex,\n      strokeColor: this.data.borderColor,\n      fillColor: this.data.backgroundColor,\n      rotation: this.rotation,\n      type: e\n    };\n  }\n  amendSavedDict(e, t) {\n    if (!this.hasIndices) return;\n    let i = e?.get(this.data.id)?.value;\n    Array.isArray(i) || (i = [i]);\n    const a = [],\n      {\n        options: s\n      } = this.data;\n    for (let e = 0, t = 0, r = s.length; e < r; e++) if (s[e].exportValue === i[t]) {\n      a.push(e);\n      t += 1;\n    }\n    t.set(\"I\", a);\n  }\n  async _getAppearance(e, t, i, a) {\n    if (this.data.combo) return super._getAppearance(e, t, i, a);\n    let r, n;\n    const g = a?.get(this.data.id);\n    if (g) {\n      n = g.rotation;\n      r = g.value;\n    }\n    if (void 0 === n && void 0 === r && !this._needAppearances) return null;\n    void 0 === r ? r = this.data.fieldValue : Array.isArray(r) || (r = [r]);\n    let o = this.data.rect[3] - this.data.rect[1],\n      c = this.data.rect[2] - this.data.rect[0];\n    90 !== n && 270 !== n || ([c, o] = [o, c]);\n    const C = this.data.options.length,\n      h = [];\n    for (let e = 0; e < C; e++) {\n      const {\n        exportValue: t\n      } = this.data.options[e];\n      r.includes(t) && h.push(e);\n    }\n    this._defaultAppearance || (this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance = \"/Helvetica 0 Tf 0 g\"));\n    const l = await WidgetAnnotation._getFontData(e, t, this.data.defaultAppearanceData, this._fieldResources.mergedResources);\n    let Q,\n      {\n        fontSize: E\n      } = this.data.defaultAppearanceData;\n    if (E) Q = this._defaultAppearance;else {\n      const e = (o - 1) / C;\n      let t,\n        i = -1;\n      for (const {\n        displayValue: e\n      } of this.data.options) {\n        const a = this._getTextWidth(e, l);\n        if (a > i) {\n          i = a;\n          t = e;\n        }\n      }\n      [Q, E] = this._computeFontSize(e, c - 4, t, l, -1);\n    }\n    const u = E * s,\n      d = (u - E) / 2,\n      f = Math.floor(o / u);\n    let p = 0;\n    if (h.length > 0) {\n      const e = Math.min(...h),\n        t = Math.max(...h);\n      p = Math.max(0, t - f + 1);\n      p > e && (p = e);\n    }\n    const m = Math.min(p + f + 1, C),\n      y = [\"/Tx BMC q\", `1 1 ${c} ${o} re W n`];\n    if (h.length) {\n      y.push(\"0.600006 0.756866 0.854904 rg\");\n      for (const e of h) p <= e && e < m && y.push(`1 ${o - (e - p + 1) * u} ${c} ${u} re f`);\n    }\n    y.push(\"BT\", Q, `1 0 0 1 0 ${o} Tm`);\n    const w = {\n      shift: 0\n    };\n    for (let e = p; e < m; e++) {\n      const {\n          displayValue: t\n        } = this.data.options[e],\n        i = e === p ? d : 0;\n      y.push(this._renderText(t, l, E, c, 0, w, 2, -u + i));\n    }\n    y.push(\"ET Q EMC\");\n    return y.join(\"\\n\");\n  }\n}\nclass SignatureWidgetAnnotation extends WidgetAnnotation {\n  constructor(e) {\n    super(e);\n    this.data.fieldValue = null;\n    this.data.hasOwnCanvas = this.data.noRotate;\n    this.data.noHTML = !this.data.hasOwnCanvas;\n  }\n  getFieldObject() {\n    return {\n      id: this.data.id,\n      value: null,\n      page: this.data.pageIndex,\n      type: \"signature\"\n    };\n  }\n}\nclass TextAnnotation extends MarkupAnnotation {\n  constructor(e) {\n    super(e);\n    this.data.noRotate = !0;\n    this.data.hasOwnCanvas = this.data.noRotate;\n    this.data.noHTML = !1;\n    const {\n      dict: t\n    } = e;\n    this.data.annotationType = S;\n    if (this.data.hasAppearance) this.data.name = \"NoIcon\";else {\n      this.data.rect[1] = this.data.rect[3] - 22;\n      this.data.rect[2] = this.data.rect[0] + 22;\n      this.data.name = t.has(\"Name\") ? t.get(\"Name\").name : \"Note\";\n    }\n    if (t.has(\"State\")) {\n      this.data.state = t.get(\"State\") || null;\n      this.data.stateModel = t.get(\"StateModel\") || null;\n    } else {\n      this.data.state = null;\n      this.data.stateModel = null;\n    }\n  }\n}\nclass LinkAnnotation extends Annotation {\n  constructor(e) {\n    super(e);\n    const {\n      dict: t,\n      annotationGlobals: i\n    } = e;\n    this.data.annotationType = k;\n    this.data.noHTML = !1;\n    const a = getQuadPoints(t, this.rectangle);\n    a && (this.data.quadPoints = a);\n    this.data.borderColor ||= this.data.color;\n    Catalog.parseDestDictionary({\n      destDict: t,\n      resultObj: this.data,\n      docBaseUrl: i.baseUrl,\n      docAttachments: i.attachments\n    });\n  }\n}\nclass PopupAnnotation extends Annotation {\n  constructor(e) {\n    super(e);\n    const {\n      dict: t\n    } = e;\n    this.data.annotationType = q;\n    this.data.noHTML = !1;\n    this.data.rect[0] !== this.data.rect[2] && this.data.rect[1] !== this.data.rect[3] || (this.data.rect = null);\n    let i = t.get(\"Parent\");\n    if (!i) {\n      warn(\"Popup annotation has a missing or invalid parent annotation.\");\n      return;\n    }\n    this.data.parentRect = lookupNormalRect(i.getArray(\"Rect\"), null);\n    isName(i.get(\"RT\"), j) && (i = i.get(\"IRT\"));\n    if (i.has(\"M\")) {\n      this.setModificationDate(i.get(\"M\"));\n      this.data.modificationDate = this.modificationDate;\n    } else this.data.modificationDate = null;\n    if (i.has(\"C\")) {\n      this.setColor(i.getArray(\"C\"));\n      this.data.color = this.color;\n    } else this.data.color = null;\n    if (!this.viewable) {\n      const e = i.get(\"F\");\n      this._isViewable(e) && this.setFlags(e);\n    }\n    this.setTitle(i.get(\"T\"));\n    this.data.titleObj = this._title;\n    this.setContents(i.get(\"Contents\"));\n    this.data.contentsObj = this._contents;\n    i.has(\"RC\") && (this.data.richText = XFAFactory.getRichTextAsHtml(i.get(\"RC\")));\n    this.data.open = !!t.get(\"Open\");\n  }\n}\nclass FreeTextAnnotation extends MarkupAnnotation {\n  constructor(e) {\n    super(e);\n    this.data.hasOwnCanvas = !this.data.noHTML;\n    this.data.noHTML = !1;\n    const {\n      evaluatorOptions: t,\n      xref: i\n    } = e;\n    this.data.annotationType = R;\n    this.setDefaultAppearance(e);\n    this._hasAppearance = !!this.appearance;\n    if (this._hasAppearance) {\n      const {\n        fontColor: e,\n        fontSize: a\n      } = function parseAppearanceStream(e, t, i) {\n        return new AppearanceStreamEvaluator(e, t, i).parse();\n      }(this.appearance, t, i);\n      this.data.defaultAppearanceData.fontColor = e;\n      this.data.defaultAppearanceData.fontSize = a || 10;\n    } else {\n      this.data.defaultAppearanceData.fontSize ||= 10;\n      const {\n        fontColor: t,\n        fontSize: a\n      } = this.data.defaultAppearanceData;\n      if (this._contents.str) {\n        this.data.textContent = this._contents.str.split(/\\r\\n?|\\n/).map(e => e.trimEnd());\n        const {\n          coords: e,\n          bbox: t,\n          matrix: i\n        } = FakeUnicodeFont.getFirstPositionInfo(this.rectangle, this.rotation, a);\n        this.data.textPosition = this._transformPoint(e, t, i);\n      }\n      if (this._isOffscreenCanvasSupported) {\n        const s = e.dict.get(\"CA\"),\n          r = new FakeUnicodeFont(i, \"sans-serif\");\n        this.appearance = r.createAppearance(this._contents.str, this.rectangle, this.rotation, a, t, s);\n        this._streams.push(this.appearance);\n      } else warn(\"FreeTextAnnotation: OffscreenCanvas is not supported, annotation may not render correctly.\");\n    }\n  }\n  get hasTextContent() {\n    return this._hasAppearance;\n  }\n  static createNewDict(e, t, {\n    apRef: i,\n    ap: a\n  }) {\n    const {\n        color: s,\n        fontSize: r,\n        rect: n,\n        rotation: g,\n        user: o,\n        value: c\n      } = e,\n      C = new Dict(t);\n    C.set(\"Type\", Name.get(\"Annot\"));\n    C.set(\"Subtype\", Name.get(\"FreeText\"));\n    C.set(\"CreationDate\", `D:${getModificationDate()}`);\n    C.set(\"Rect\", n);\n    const h = `/Helv ${r} Tf ${getPdfColor(s, !0)}`;\n    C.set(\"DA\", h);\n    C.set(\"Contents\", isAscii(c) ? c : stringToUTF16String(c, !0));\n    C.set(\"F\", 4);\n    C.set(\"Border\", [0, 0, 0]);\n    C.set(\"Rotate\", g);\n    o && C.set(\"T\", isAscii(o) ? o : stringToUTF16String(o, !0));\n    if (i || a) {\n      const e = new Dict(t);\n      C.set(\"AP\", e);\n      i ? e.set(\"N\", i) : e.set(\"N\", a);\n    }\n    return C;\n  }\n  static async createNewAppearanceStream(e, t, i) {\n    const {\n        baseFontRef: a,\n        evaluator: r,\n        task: n\n      } = i,\n      {\n        color: g,\n        fontSize: o,\n        rect: c,\n        rotation: C,\n        value: h\n      } = e,\n      l = new Dict(t),\n      Q = new Dict(t);\n    if (a) Q.set(\"Helv\", a);else {\n      const e = new Dict(t);\n      e.set(\"BaseFont\", Name.get(\"Helvetica\"));\n      e.set(\"Type\", Name.get(\"Font\"));\n      e.set(\"Subtype\", Name.get(\"Type1\"));\n      e.set(\"Encoding\", Name.get(\"WinAnsiEncoding\"));\n      Q.set(\"Helv\", e);\n    }\n    l.set(\"Font\", Q);\n    const E = await WidgetAnnotation._getFontData(r, n, {\n        fontName: \"Helv\",\n        fontSize: o\n      }, l),\n      [u, d, f, p] = c;\n    let m = f - u,\n      y = p - d;\n    C % 180 != 0 && ([m, y] = [y, m]);\n    const w = h.split(\"\\n\"),\n      D = o / 1e3;\n    let b = -1 / 0;\n    const F = [];\n    for (let e of w) {\n      const t = E.encodeString(e);\n      if (t.length > 1) return null;\n      e = t.join(\"\");\n      F.push(e);\n      let i = 0;\n      const a = E.charsToGlyphs(e);\n      for (const e of a) i += e.width * D;\n      b = Math.max(b, i);\n    }\n    let S = 1;\n    b > m && (S = m / b);\n    let k = 1;\n    const R = s * o,\n      N = 1 * o,\n      G = R * w.length;\n    G > y && (k = y / G);\n    const x = o * Math.min(S, k);\n    let U, M, L;\n    switch (C) {\n      case 0:\n        L = [1, 0, 0, 1];\n        M = [c[0], c[1], m, y];\n        U = [c[0], c[3] - N];\n        break;\n      case 90:\n        L = [0, 1, -1, 0];\n        M = [c[1], -c[2], m, y];\n        U = [c[1], -c[0] - N];\n        break;\n      case 180:\n        L = [-1, 0, 0, -1];\n        M = [-c[2], -c[3], m, y];\n        U = [-c[2], -c[1] - N];\n        break;\n      case 270:\n        L = [0, -1, 1, 0];\n        M = [-c[3], c[0], m, y];\n        U = [-c[3], c[2] - N];\n    }\n    const H = [\"q\", `${L.join(\" \")} 0 0 cm`, `${M.join(\" \")} re W n`, \"BT\", `${getPdfColor(g, !0)}`, `0 Tc /Helv ${numberToString(x)} Tf`];\n    H.push(`${U.join(\" \")} Td (${escapeString(F[0])}) Tj`);\n    const J = numberToString(R);\n    for (let e = 1, t = F.length; e < t; e++) {\n      const t = F[e];\n      H.push(`0 -${J} Td (${escapeString(t)}) Tj`);\n    }\n    H.push(\"ET\", \"Q\");\n    const Y = H.join(\"\\n\"),\n      v = new Dict(t);\n    v.set(\"FormType\", 1);\n    v.set(\"Subtype\", Name.get(\"Form\"));\n    v.set(\"Type\", Name.get(\"XObject\"));\n    v.set(\"BBox\", c);\n    v.set(\"Resources\", l);\n    v.set(\"Matrix\", [1, 0, 0, 1, -c[0], -c[1]]);\n    const K = new StringStream(Y);\n    K.dict = v;\n    return K;\n  }\n}\nclass LineAnnotation extends MarkupAnnotation {\n  constructor(e) {\n    super(e);\n    const {\n      dict: t,\n      xref: i\n    } = e;\n    this.data.annotationType = N;\n    this.data.hasOwnCanvas = this.data.noRotate;\n    this.data.noHTML = !1;\n    const a = lookupRect(t.getArray(\"L\"), [0, 0, 0, 0]);\n    this.data.lineCoordinates = Util.normalizeRect(a);\n    this.setLineEndings(t.getArray(\"LE\"));\n    this.data.lineEndings = this.lineEndings;\n    if (!this.appearance) {\n      const e = this.color ? getPdfColorArray(this.color) : [0, 0, 0],\n        s = t.get(\"CA\"),\n        r = getRgbColor(t.getArray(\"IC\"), null),\n        n = r ? getPdfColorArray(r) : null,\n        g = n ? s : null,\n        o = this.borderStyle.width || 1,\n        c = 2 * o,\n        C = [this.data.lineCoordinates[0] - c, this.data.lineCoordinates[1] - c, this.data.lineCoordinates[2] + c, this.data.lineCoordinates[3] + c];\n      Util.intersect(this.rectangle, C) || (this.rectangle = C);\n      this._setDefaultAppearance({\n        xref: i,\n        extra: `${o} w`,\n        strokeColor: e,\n        fillColor: n,\n        strokeAlpha: s,\n        fillAlpha: g,\n        pointsCallback: (e, t) => {\n          e.push(`${a[0]} ${a[1]} m`, `${a[2]} ${a[3]} l`, \"S\");\n          return [t[0] - o, t[2] + o, t[7] - o, t[3] + o];\n        }\n      });\n    }\n  }\n}\nclass SquareAnnotation extends MarkupAnnotation {\n  constructor(e) {\n    super(e);\n    const {\n      dict: t,\n      xref: i\n    } = e;\n    this.data.annotationType = G;\n    this.data.hasOwnCanvas = this.data.noRotate;\n    this.data.noHTML = !1;\n    if (!this.appearance) {\n      const e = this.color ? getPdfColorArray(this.color) : [0, 0, 0],\n        a = t.get(\"CA\"),\n        s = getRgbColor(t.getArray(\"IC\"), null),\n        r = s ? getPdfColorArray(s) : null,\n        n = r ? a : null;\n      if (0 === this.borderStyle.width && !r) return;\n      this._setDefaultAppearance({\n        xref: i,\n        extra: `${this.borderStyle.width} w`,\n        strokeColor: e,\n        fillColor: r,\n        strokeAlpha: a,\n        fillAlpha: n,\n        pointsCallback: (e, t) => {\n          const i = t[4] + this.borderStyle.width / 2,\n            a = t[5] + this.borderStyle.width / 2,\n            s = t[6] - t[4] - this.borderStyle.width,\n            n = t[3] - t[7] - this.borderStyle.width;\n          e.push(`${i} ${a} ${s} ${n} re`);\n          r ? e.push(\"B\") : e.push(\"S\");\n          return [t[0], t[2], t[7], t[3]];\n        }\n      });\n    }\n  }\n}\nclass CircleAnnotation extends MarkupAnnotation {\n  constructor(e) {\n    super(e);\n    const {\n      dict: t,\n      xref: i\n    } = e;\n    this.data.annotationType = x;\n    if (!this.appearance) {\n      const e = this.color ? getPdfColorArray(this.color) : [0, 0, 0],\n        a = t.get(\"CA\"),\n        s = getRgbColor(t.getArray(\"IC\"), null),\n        r = s ? getPdfColorArray(s) : null,\n        n = r ? a : null;\n      if (0 === this.borderStyle.width && !r) return;\n      const g = 4 / 3 * Math.tan(Math.PI / 8);\n      this._setDefaultAppearance({\n        xref: i,\n        extra: `${this.borderStyle.width} w`,\n        strokeColor: e,\n        fillColor: r,\n        strokeAlpha: a,\n        fillAlpha: n,\n        pointsCallback: (e, t) => {\n          const i = t[0] + this.borderStyle.width / 2,\n            a = t[1] - this.borderStyle.width / 2,\n            s = t[6] - this.borderStyle.width / 2,\n            n = t[7] + this.borderStyle.width / 2,\n            o = i + (s - i) / 2,\n            c = a + (n - a) / 2,\n            C = (s - i) / 2 * g,\n            h = (n - a) / 2 * g;\n          e.push(`${o} ${n} m`, `${o + C} ${n} ${s} ${c + h} ${s} ${c} c`, `${s} ${c - h} ${o + C} ${a} ${o} ${a} c`, `${o - C} ${a} ${i} ${c - h} ${i} ${c} c`, `${i} ${c + h} ${o - C} ${n} ${o} ${n} c`, \"h\");\n          r ? e.push(\"B\") : e.push(\"S\");\n          return [t[0], t[2], t[7], t[3]];\n        }\n      });\n    }\n  }\n}\nclass PolylineAnnotation extends MarkupAnnotation {\n  constructor(e) {\n    super(e);\n    const {\n      dict: t,\n      xref: i\n    } = e;\n    this.data.annotationType = M;\n    this.data.hasOwnCanvas = this.data.noRotate;\n    this.data.noHTML = !1;\n    this.data.vertices = null;\n    if (!(this instanceof PolygonAnnotation)) {\n      this.setLineEndings(t.getArray(\"LE\"));\n      this.data.lineEndings = this.lineEndings;\n    }\n    const a = t.getArray(\"Vertices\");\n    if (!isNumberArray(a, null)) return;\n    const s = this.data.vertices = Float32Array.from(a);\n    if (!this.appearance) {\n      const e = this.color ? getPdfColorArray(this.color) : [0, 0, 0],\n        a = t.get(\"CA\"),\n        r = this.borderStyle.width || 1,\n        n = 2 * r,\n        g = [1 / 0, 1 / 0, -1 / 0, -1 / 0];\n      for (let e = 0, t = s.length; e < t; e += 2) {\n        g[0] = Math.min(g[0], s[e] - n);\n        g[1] = Math.min(g[1], s[e + 1] - n);\n        g[2] = Math.max(g[2], s[e] + n);\n        g[3] = Math.max(g[3], s[e + 1] + n);\n      }\n      Util.intersect(this.rectangle, g) || (this.rectangle = g);\n      this._setDefaultAppearance({\n        xref: i,\n        extra: `${r} w`,\n        strokeColor: e,\n        strokeAlpha: a,\n        pointsCallback: (e, t) => {\n          for (let t = 0, i = s.length; t < i; t += 2) e.push(`${s[t]} ${s[t + 1]} ${0 === t ? \"m\" : \"l\"}`);\n          e.push(\"S\");\n          return [t[0], t[2], t[7], t[3]];\n        }\n      });\n    }\n  }\n}\nclass PolygonAnnotation extends PolylineAnnotation {\n  constructor(e) {\n    super(e);\n    this.data.annotationType = U;\n  }\n}\nclass CaretAnnotation extends MarkupAnnotation {\n  constructor(e) {\n    super(e);\n    this.data.annotationType = K;\n  }\n}\nclass InkAnnotation extends MarkupAnnotation {\n  constructor(e) {\n    super(e);\n    this.data.hasOwnCanvas = this.data.noRotate;\n    this.data.noHTML = !1;\n    const {\n      dict: t,\n      xref: i\n    } = e;\n    this.data.annotationType = T;\n    this.data.inkLists = [];\n    const a = t.getArray(\"InkList\");\n    if (Array.isArray(a)) {\n      for (let e = 0, t = a.length; e < t; ++e) {\n        if (!Array.isArray(a[e])) continue;\n        const t = new Float32Array(a[e].length);\n        this.data.inkLists.push(t);\n        for (let s = 0, r = a[e].length; s < r; s += 2) {\n          const r = i.fetchIfRef(a[e][s]),\n            n = i.fetchIfRef(a[e][s + 1]);\n          if (\"number\" == typeof r && \"number\" == typeof n) {\n            t[s] = r;\n            t[s + 1] = n;\n          }\n        }\n      }\n      if (!this.appearance) {\n        const e = this.color ? getPdfColorArray(this.color) : [0, 0, 0],\n          a = t.get(\"CA\"),\n          s = this.borderStyle.width || 1,\n          r = 2 * s,\n          n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];\n        for (const e of this.data.inkLists) for (let t = 0, i = e.length; t < i; t += 2) {\n          n[0] = Math.min(n[0], e[t] - r);\n          n[1] = Math.min(n[1], e[t + 1] - r);\n          n[2] = Math.max(n[2], e[t] + r);\n          n[3] = Math.max(n[3], e[t + 1] + r);\n        }\n        Util.intersect(this.rectangle, n) || (this.rectangle = n);\n        this._setDefaultAppearance({\n          xref: i,\n          extra: `${s} w`,\n          strokeColor: e,\n          strokeAlpha: a,\n          pointsCallback: (e, t) => {\n            for (const t of this.data.inkLists) {\n              for (let i = 0, a = t.length; i < a; i += 2) e.push(`${t[i]} ${t[i + 1]} ${0 === i ? \"m\" : \"l\"}`);\n              e.push(\"S\");\n            }\n            return [t[0], t[2], t[7], t[3]];\n          }\n        });\n      }\n    }\n  }\n  static createNewDict(e, t, {\n    apRef: i,\n    ap: a\n  }) {\n    const {\n        color: s,\n        opacity: r,\n        paths: n,\n        outlines: g,\n        rect: o,\n        rotation: c,\n        thickness: C\n      } = e,\n      h = new Dict(t);\n    h.set(\"Type\", Name.get(\"Annot\"));\n    h.set(\"Subtype\", Name.get(\"Ink\"));\n    h.set(\"CreationDate\", `D:${getModificationDate()}`);\n    h.set(\"Rect\", o);\n    h.set(\"InkList\", g?.points || n.map(e => e.points));\n    h.set(\"F\", 4);\n    h.set(\"Rotate\", c);\n    g && h.set(\"IT\", Name.get(\"InkHighlight\"));\n    const l = new Dict(t);\n    h.set(\"BS\", l);\n    l.set(\"W\", C);\n    h.set(\"C\", Array.from(s, e => e / 255));\n    h.set(\"CA\", r);\n    const Q = new Dict(t);\n    h.set(\"AP\", Q);\n    i ? Q.set(\"N\", i) : Q.set(\"N\", a);\n    return h;\n  }\n  static async createNewAppearanceStream(e, t, i) {\n    if (e.outlines) return this.createNewAppearanceStreamForHighlight(e, t, i);\n    const {\n        color: a,\n        rect: s,\n        paths: r,\n        thickness: n,\n        opacity: g\n      } = e,\n      o = [`${n} w 1 J 1 j`, `${getPdfColor(a, !1)}`];\n    1 !== g && o.push(\"/R0 gs\");\n    const c = [];\n    for (const {\n      bezier: e\n    } of r) {\n      c.length = 0;\n      c.push(`${numberToString(e[0])} ${numberToString(e[1])} m`);\n      if (2 === e.length) c.push(`${numberToString(e[0])} ${numberToString(e[1])} l S`);else {\n        for (let t = 2, i = e.length; t < i; t += 6) {\n          const i = e.slice(t, t + 6).map(numberToString).join(\" \");\n          c.push(`${i} c`);\n        }\n        c.push(\"S\");\n      }\n      o.push(c.join(\"\\n\"));\n    }\n    const C = o.join(\"\\n\"),\n      h = new Dict(t);\n    h.set(\"FormType\", 1);\n    h.set(\"Subtype\", Name.get(\"Form\"));\n    h.set(\"Type\", Name.get(\"XObject\"));\n    h.set(\"BBox\", s);\n    h.set(\"Length\", C.length);\n    if (1 !== g) {\n      const e = new Dict(t),\n        i = new Dict(t),\n        a = new Dict(t);\n      a.set(\"CA\", g);\n      a.set(\"Type\", Name.get(\"ExtGState\"));\n      i.set(\"R0\", a);\n      e.set(\"ExtGState\", i);\n      h.set(\"Resources\", e);\n    }\n    const l = new StringStream(C);\n    l.dict = h;\n    return l;\n  }\n  static async createNewAppearanceStreamForHighlight(e, t, i) {\n    const {\n        color: a,\n        rect: s,\n        outlines: {\n          outline: r\n        },\n        opacity: n\n      } = e,\n      g = [`${getPdfColor(a, !0)}`, \"/R0 gs\"];\n    g.push(`${numberToString(r[4])} ${numberToString(r[5])} m`);\n    for (let e = 6, t = r.length; e < t; e += 6) if (isNaN(r[e]) || null === r[e]) g.push(`${numberToString(r[e + 4])} ${numberToString(r[e + 5])} l`);else {\n      const t = r.slice(e, e + 6).map(numberToString).join(\" \");\n      g.push(`${t} c`);\n    }\n    g.push(\"h f\");\n    const o = g.join(\"\\n\"),\n      c = new Dict(t);\n    c.set(\"FormType\", 1);\n    c.set(\"Subtype\", Name.get(\"Form\"));\n    c.set(\"Type\", Name.get(\"XObject\"));\n    c.set(\"BBox\", s);\n    c.set(\"Length\", o.length);\n    const C = new Dict(t),\n      h = new Dict(t);\n    C.set(\"ExtGState\", h);\n    c.set(\"Resources\", C);\n    const l = new Dict(t);\n    h.set(\"R0\", l);\n    l.set(\"BM\", Name.get(\"Multiply\"));\n    if (1 !== n) {\n      l.set(\"ca\", n);\n      l.set(\"Type\", Name.get(\"ExtGState\"));\n    }\n    const Q = new StringStream(o);\n    Q.dict = c;\n    return Q;\n  }\n}\nclass HighlightAnnotation extends MarkupAnnotation {\n  constructor(e) {\n    super(e);\n    const {\n      dict: t,\n      xref: i\n    } = e;\n    this.data.annotationType = L;\n    if (this.data.quadPoints = getQuadPoints(t, null)) {\n      const e = this.appearance?.dict.get(\"Resources\");\n      if (!this.appearance || !e?.has(\"ExtGState\")) {\n        this.appearance && warn(\"HighlightAnnotation - ignoring built-in appearance stream.\");\n        const e = this.color ? getPdfColorArray(this.color) : [1, 1, 0],\n          a = t.get(\"CA\");\n        this._setDefaultAppearance({\n          xref: i,\n          fillColor: e,\n          blendMode: \"Multiply\",\n          fillAlpha: a,\n          pointsCallback: (e, t) => {\n            e.push(`${t[0]} ${t[1]} m`, `${t[2]} ${t[3]} l`, `${t[6]} ${t[7]} l`, `${t[4]} ${t[5]} l`, \"f\");\n            return [t[0], t[2], t[7], t[3]];\n          }\n        });\n      }\n    } else this.data.popupRef = null;\n  }\n  static createNewDict(e, t, {\n    apRef: i,\n    ap: a\n  }) {\n    const {\n        color: s,\n        opacity: r,\n        rect: n,\n        rotation: g,\n        user: o,\n        quadPoints: c\n      } = e,\n      C = new Dict(t);\n    C.set(\"Type\", Name.get(\"Annot\"));\n    C.set(\"Subtype\", Name.get(\"Highlight\"));\n    C.set(\"CreationDate\", `D:${getModificationDate()}`);\n    C.set(\"Rect\", n);\n    C.set(\"F\", 4);\n    C.set(\"Border\", [0, 0, 0]);\n    C.set(\"Rotate\", g);\n    C.set(\"QuadPoints\", c);\n    C.set(\"C\", Array.from(s, e => e / 255));\n    C.set(\"CA\", r);\n    o && C.set(\"T\", isAscii(o) ? o : stringToUTF16String(o, !0));\n    if (i || a) {\n      const e = new Dict(t);\n      C.set(\"AP\", e);\n      e.set(\"N\", i || a);\n    }\n    return C;\n  }\n  static async createNewAppearanceStream(e, t, i) {\n    const {\n        color: a,\n        rect: s,\n        outlines: r,\n        opacity: n\n      } = e,\n      g = [`${getPdfColor(a, !0)}`, \"/R0 gs\"],\n      o = [];\n    for (const e of r) {\n      o.length = 0;\n      o.push(`${numberToString(e[0])} ${numberToString(e[1])} m`);\n      for (let t = 2, i = e.length; t < i; t += 2) o.push(`${numberToString(e[t])} ${numberToString(e[t + 1])} l`);\n      o.push(\"h\");\n      g.push(o.join(\"\\n\"));\n    }\n    g.push(\"f*\");\n    const c = g.join(\"\\n\"),\n      C = new Dict(t);\n    C.set(\"FormType\", 1);\n    C.set(\"Subtype\", Name.get(\"Form\"));\n    C.set(\"Type\", Name.get(\"XObject\"));\n    C.set(\"BBox\", s);\n    C.set(\"Length\", c.length);\n    const h = new Dict(t),\n      l = new Dict(t);\n    h.set(\"ExtGState\", l);\n    C.set(\"Resources\", h);\n    const Q = new Dict(t);\n    l.set(\"R0\", Q);\n    Q.set(\"BM\", Name.get(\"Multiply\"));\n    if (1 !== n) {\n      Q.set(\"ca\", n);\n      Q.set(\"Type\", Name.get(\"ExtGState\"));\n    }\n    const E = new StringStream(c);\n    E.dict = C;\n    return E;\n  }\n}\nclass UnderlineAnnotation extends MarkupAnnotation {\n  constructor(e) {\n    super(e);\n    const {\n      dict: t,\n      xref: i\n    } = e;\n    this.data.annotationType = H;\n    if (this.data.quadPoints = getQuadPoints(t, null)) {\n      if (!this.appearance) {\n        const e = this.color ? getPdfColorArray(this.color) : [0, 0, 0],\n          a = t.get(\"CA\");\n        this._setDefaultAppearance({\n          xref: i,\n          extra: \"[] 0 d 0.571 w\",\n          strokeColor: e,\n          strokeAlpha: a,\n          pointsCallback: (e, t) => {\n            e.push(`${t[4]} ${t[5] + 1.3} m`, `${t[6]} ${t[7] + 1.3} l`, \"S\");\n            return [t[0], t[2], t[7], t[3]];\n          }\n        });\n      }\n    } else this.data.popupRef = null;\n  }\n}\nclass SquigglyAnnotation extends MarkupAnnotation {\n  constructor(e) {\n    super(e);\n    const {\n      dict: t,\n      xref: i\n    } = e;\n    this.data.annotationType = J;\n    if (this.data.quadPoints = getQuadPoints(t, null)) {\n      if (!this.appearance) {\n        const e = this.color ? getPdfColorArray(this.color) : [0, 0, 0],\n          a = t.get(\"CA\");\n        this._setDefaultAppearance({\n          xref: i,\n          extra: \"[] 0 d 1 w\",\n          strokeColor: e,\n          strokeAlpha: a,\n          pointsCallback: (e, t) => {\n            const i = (t[1] - t[5]) / 6;\n            let a = i,\n              s = t[4];\n            const r = t[5],\n              n = t[6];\n            e.push(`${s} ${r + a} m`);\n            do {\n              s += 2;\n              a = 0 === a ? i : 0;\n              e.push(`${s} ${r + a} l`);\n            } while (s < n);\n            e.push(\"S\");\n            return [t[4], n, r - 2 * i, r + 2 * i];\n          }\n        });\n      }\n    } else this.data.popupRef = null;\n  }\n}\nclass StrikeOutAnnotation extends MarkupAnnotation {\n  constructor(e) {\n    super(e);\n    const {\n      dict: t,\n      xref: i\n    } = e;\n    this.data.annotationType = Y;\n    if (this.data.quadPoints = getQuadPoints(t, null)) {\n      if (!this.appearance) {\n        const e = this.color ? getPdfColorArray(this.color) : [0, 0, 0],\n          a = t.get(\"CA\");\n        this._setDefaultAppearance({\n          xref: i,\n          extra: \"[] 0 d 1 w\",\n          strokeColor: e,\n          strokeAlpha: a,\n          pointsCallback: (e, t) => {\n            e.push((t[0] + t[4]) / 2 + \" \" + (t[1] + t[5]) / 2 + \" m\", (t[2] + t[6]) / 2 + \" \" + (t[3] + t[7]) / 2 + \" l\", \"S\");\n            return [t[0], t[2], t[7], t[3]];\n          }\n        });\n      }\n    } else this.data.popupRef = null;\n  }\n}\nclass StampAnnotation extends MarkupAnnotation {\n  constructor(e) {\n    super(e);\n    this.data.annotationType = v;\n    this.data.hasOwnCanvas = this.data.noRotate;\n    this.data.noHTML = !1;\n  }\n  static async createImage(e, t) {\n    const {\n        width: i,\n        height: a\n      } = e,\n      s = new OffscreenCanvas(i, a),\n      r = s.getContext(\"2d\", {\n        alpha: !0\n      });\n    r.drawImage(e, 0, 0);\n    const n = r.getImageData(0, 0, i, a).data,\n      g = new Uint32Array(n.buffer),\n      o = g.some(FeatureTest.isLittleEndian ? e => e >>> 24 != 255 : e => 255 != (255 & e));\n    if (o) {\n      r.fillStyle = \"white\";\n      r.fillRect(0, 0, i, a);\n      r.drawImage(e, 0, 0);\n    }\n    const c = s.convertToBlob({\n        type: \"image/jpeg\",\n        quality: 1\n      }).then(e => e.arrayBuffer()),\n      C = Name.get(\"XObject\"),\n      h = Name.get(\"Image\"),\n      l = new Dict(t);\n    l.set(\"Type\", C);\n    l.set(\"Subtype\", h);\n    l.set(\"BitsPerComponent\", 8);\n    l.set(\"ColorSpace\", Name.get(\"DeviceRGB\"));\n    l.set(\"Filter\", Name.get(\"DCTDecode\"));\n    l.set(\"BBox\", [0, 0, i, a]);\n    l.set(\"Width\", i);\n    l.set(\"Height\", a);\n    let Q = null;\n    if (o) {\n      const e = new Uint8Array(g.length);\n      if (FeatureTest.isLittleEndian) for (let t = 0, i = g.length; t < i; t++) e[t] = g[t] >>> 24;else for (let t = 0, i = g.length; t < i; t++) e[t] = 255 & g[t];\n      const s = new Dict(t);\n      s.set(\"Type\", C);\n      s.set(\"Subtype\", h);\n      s.set(\"BitsPerComponent\", 8);\n      s.set(\"ColorSpace\", Name.get(\"DeviceGray\"));\n      s.set(\"Width\", i);\n      s.set(\"Height\", a);\n      Q = new Stream(e, 0, 0, s);\n    }\n    return {\n      imageStream: new Stream(await c, 0, 0, l),\n      smaskStream: Q,\n      width: i,\n      height: a\n    };\n  }\n  static createNewDict(e, t, {\n    apRef: i,\n    ap: a\n  }) {\n    const {\n        rect: s,\n        rotation: r,\n        user: n\n      } = e,\n      g = new Dict(t);\n    g.set(\"Type\", Name.get(\"Annot\"));\n    g.set(\"Subtype\", Name.get(\"Stamp\"));\n    g.set(\"CreationDate\", `D:${getModificationDate()}`);\n    g.set(\"Rect\", s);\n    g.set(\"F\", 4);\n    g.set(\"Border\", [0, 0, 0]);\n    g.set(\"Rotate\", r);\n    n && g.set(\"T\", isAscii(n) ? n : stringToUTF16String(n, !0));\n    if (i || a) {\n      const e = new Dict(t);\n      g.set(\"AP\", e);\n      i ? e.set(\"N\", i) : e.set(\"N\", a);\n    }\n    return g;\n  }\n  static async createNewAppearanceStream(e, t, i) {\n    const {\n        rotation: a\n      } = e,\n      {\n        imageRef: s,\n        width: r,\n        height: n\n      } = i.image,\n      g = new Dict(t),\n      o = new Dict(t);\n    g.set(\"XObject\", o);\n    o.set(\"Im0\", s);\n    const c = `q ${r} 0 0 ${n} 0 0 cm /Im0 Do Q`,\n      C = new Dict(t);\n    C.set(\"FormType\", 1);\n    C.set(\"Subtype\", Name.get(\"Form\"));\n    C.set(\"Type\", Name.get(\"XObject\"));\n    C.set(\"BBox\", [0, 0, r, n]);\n    C.set(\"Resources\", g);\n    if (a) {\n      const e = getRotationMatrix(a, r, n);\n      C.set(\"Matrix\", e);\n    }\n    const h = new StringStream(c);\n    h.dict = C;\n    return h;\n  }\n}\nclass FileAttachmentAnnotation extends MarkupAnnotation {\n  constructor(e) {\n    super(e);\n    const {\n        dict: t,\n        xref: i\n      } = e,\n      a = new FileSpec(t.get(\"FS\"), i);\n    this.data.annotationType = O;\n    this.data.hasOwnCanvas = this.data.noRotate;\n    this.data.noHTML = !1;\n    this.data.file = a.serializable;\n    const s = t.get(\"Name\");\n    this.data.name = s instanceof Name ? stringToPDFString(s.name) : \"PushPin\";\n    const r = t.get(\"ca\");\n    this.data.fillAlpha = \"number\" == typeof r && r >= 0 && r <= 1 ? r : null;\n  }\n}\nfunction decodeString(e) {\n  try {\n    return stringToUTF8String(e);\n  } catch (t) {\n    warn(`UTF-8 decoding failed: \"${t}\".`);\n    return e;\n  }\n}\nclass DatasetXMLParser extends SimpleXMLParser {\n  constructor(e) {\n    super(e);\n    this.node = null;\n  }\n  onEndElement(e) {\n    const t = super.onEndElement(e);\n    if (t && \"xfa:datasets\" === e) {\n      this.node = t;\n      throw new Error(\"Aborting DatasetXMLParser.\");\n    }\n  }\n}\nclass DatasetReader {\n  constructor(e) {\n    if (e.datasets) this.node = new SimpleXMLParser({\n      hasAttributes: !0\n    }).parseFromString(e.datasets).documentElement;else {\n      const t = new DatasetXMLParser({\n        hasAttributes: !0\n      });\n      try {\n        t.parseFromString(e[\"xdp:xdp\"]);\n      } catch {}\n      this.node = t.node;\n    }\n  }\n  getValue(e) {\n    if (!this.node || !e) return \"\";\n    const t = this.node.searchNode(parseXFAPath(e), 0);\n    if (!t) return \"\";\n    const i = t.firstChild;\n    return \"value\" === i?.nodeName ? t.children.map(e => decodeString(e.textContent)) : decodeString(t.textContent);\n  }\n}\nclass XRef {\n  #K = null;\n  constructor(e, t) {\n    this.stream = e;\n    this.pdfManager = t;\n    this.entries = [];\n    this._xrefStms = new Set();\n    this._cacheMap = new Map();\n    this._pendingRefs = new RefSet();\n    this._newPersistentRefNum = null;\n    this._newTemporaryRefNum = null;\n    this._persistentRefsCache = null;\n  }\n  getNewPersistentRef(e) {\n    null === this._newPersistentRefNum && (this._newPersistentRefNum = this.entries.length || 1);\n    const t = this._newPersistentRefNum++;\n    this._cacheMap.set(t, e);\n    return Ref.get(t, 0);\n  }\n  getNewTemporaryRef() {\n    if (null === this._newTemporaryRefNum) {\n      this._newTemporaryRefNum = this.entries.length || 1;\n      if (this._newPersistentRefNum) {\n        this._persistentRefsCache = new Map();\n        for (let e = this._newTemporaryRefNum; e < this._newPersistentRefNum; e++) {\n          this._persistentRefsCache.set(e, this._cacheMap.get(e));\n          this._cacheMap.delete(e);\n        }\n      }\n    }\n    return Ref.get(this._newTemporaryRefNum++, 0);\n  }\n  resetNewTemporaryRef() {\n    this._newTemporaryRefNum = null;\n    if (this._persistentRefsCache) for (const [e, t] of this._persistentRefsCache) this._cacheMap.set(e, t);\n    this._persistentRefsCache = null;\n  }\n  setStartXRef(e) {\n    this.startXRefQueue = [e];\n  }\n  parse(e = !1) {\n    let t, i, a;\n    if (e) {\n      warn(\"Indexing all PDF objects\");\n      t = this.indexObjects();\n    } else t = this.readXRef();\n    t.assignXref(this);\n    this.trailer = t;\n    try {\n      i = t.get(\"Encrypt\");\n    } catch (e) {\n      if (e instanceof MissingDataException) throw e;\n      warn(`XRef.parse - Invalid \"Encrypt\" reference: \"${e}\".`);\n    }\n    if (i instanceof Dict) {\n      const e = t.get(\"ID\"),\n        a = e?.length ? e[0] : \"\";\n      i.suppressEncryption = !0;\n      this.encrypt = new CipherTransformFactory(i, a, this.pdfManager.password);\n    }\n    try {\n      a = t.get(\"Root\");\n    } catch (e) {\n      if (e instanceof MissingDataException) throw e;\n      warn(`XRef.parse - Invalid \"Root\" reference: \"${e}\".`);\n    }\n    if (a instanceof Dict) try {\n      if (a.get(\"Pages\") instanceof Dict) {\n        this.root = a;\n        return;\n      }\n    } catch (e) {\n      if (e instanceof MissingDataException) throw e;\n      warn(`XRef.parse - Invalid \"Pages\" reference: \"${e}\".`);\n    }\n    if (!e) throw new XRefParseException();\n    throw new InvalidPDFException(\"Invalid Root reference.\");\n  }\n  processXRefTable(e) {\n    \"tableState\" in this || (this.tableState = {\n      entryNum: 0,\n      streamPos: e.lexer.stream.pos,\n      parserBuf1: e.buf1,\n      parserBuf2: e.buf2\n    });\n    if (!isCmd(this.readXRefTable(e), \"trailer\")) throw new FormatError(\"Invalid XRef table: could not find trailer dictionary\");\n    let t = e.getObj();\n    t instanceof Dict || !t.dict || (t = t.dict);\n    if (!(t instanceof Dict)) throw new FormatError(\"Invalid XRef table: could not parse trailer dictionary\");\n    delete this.tableState;\n    return t;\n  }\n  readXRefTable(e) {\n    const t = e.lexer.stream,\n      i = this.tableState;\n    t.pos = i.streamPos;\n    e.buf1 = i.parserBuf1;\n    e.buf2 = i.parserBuf2;\n    let a;\n    for (;;) {\n      if (!(\"firstEntryNum\" in i) || !(\"entryCount\" in i)) {\n        if (isCmd(a = e.getObj(), \"trailer\")) break;\n        i.firstEntryNum = a;\n        i.entryCount = e.getObj();\n      }\n      let s = i.firstEntryNum;\n      const r = i.entryCount;\n      if (!Number.isInteger(s) || !Number.isInteger(r)) throw new FormatError(\"Invalid XRef table: wrong types in subsection header\");\n      for (let a = i.entryNum; a < r; a++) {\n        i.streamPos = t.pos;\n        i.entryNum = a;\n        i.parserBuf1 = e.buf1;\n        i.parserBuf2 = e.buf2;\n        const n = {};\n        n.offset = e.getObj();\n        n.gen = e.getObj();\n        const g = e.getObj();\n        if (g instanceof Cmd) switch (g.cmd) {\n          case \"f\":\n            n.free = !0;\n            break;\n          case \"n\":\n            n.uncompressed = !0;\n        }\n        if (!Number.isInteger(n.offset) || !Number.isInteger(n.gen) || !n.free && !n.uncompressed) throw new FormatError(`Invalid entry in XRef subsection: ${s}, ${r}`);\n        0 === a && n.free && 1 === s && (s = 0);\n        this.entries[a + s] || (this.entries[a + s] = n);\n      }\n      i.entryNum = 0;\n      i.streamPos = t.pos;\n      i.parserBuf1 = e.buf1;\n      i.parserBuf2 = e.buf2;\n      delete i.firstEntryNum;\n      delete i.entryCount;\n    }\n    if (this.entries[0] && !this.entries[0].free) throw new FormatError(\"Invalid XRef table: unexpected first object\");\n    return a;\n  }\n  processXRefStream(e) {\n    if (!(\"streamState\" in this)) {\n      const t = e.dict,\n        i = t.get(\"W\");\n      let a = t.get(\"Index\");\n      a || (a = [0, t.get(\"Size\")]);\n      this.streamState = {\n        entryRanges: a,\n        byteWidths: i,\n        entryNum: 0,\n        streamPos: e.pos\n      };\n    }\n    this.readXRefStream(e);\n    delete this.streamState;\n    return e.dict;\n  }\n  readXRefStream(e) {\n    const t = this.streamState;\n    e.pos = t.streamPos;\n    const [i, a, s] = t.byteWidths,\n      r = t.entryRanges;\n    for (; r.length > 0;) {\n      const [n, g] = r;\n      if (!Number.isInteger(n) || !Number.isInteger(g)) throw new FormatError(`Invalid XRef range fields: ${n}, ${g}`);\n      if (!Number.isInteger(i) || !Number.isInteger(a) || !Number.isInteger(s)) throw new FormatError(`Invalid XRef entry fields length: ${n}, ${g}`);\n      for (let r = t.entryNum; r < g; ++r) {\n        t.entryNum = r;\n        t.streamPos = e.pos;\n        let g = 0,\n          o = 0,\n          c = 0;\n        for (let t = 0; t < i; ++t) {\n          const t = e.getByte();\n          if (-1 === t) throw new FormatError(\"Invalid XRef byteWidths 'type'.\");\n          g = g << 8 | t;\n        }\n        0 === i && (g = 1);\n        for (let t = 0; t < a; ++t) {\n          const t = e.getByte();\n          if (-1 === t) throw new FormatError(\"Invalid XRef byteWidths 'offset'.\");\n          o = o << 8 | t;\n        }\n        for (let t = 0; t < s; ++t) {\n          const t = e.getByte();\n          if (-1 === t) throw new FormatError(\"Invalid XRef byteWidths 'generation'.\");\n          c = c << 8 | t;\n        }\n        const C = {};\n        C.offset = o;\n        C.gen = c;\n        switch (g) {\n          case 0:\n            C.free = !0;\n            break;\n          case 1:\n            C.uncompressed = !0;\n            break;\n          case 2:\n            break;\n          default:\n            throw new FormatError(`Invalid XRef entry type: ${g}`);\n        }\n        this.entries[n + r] || (this.entries[n + r] = C);\n      }\n      t.entryNum = 0;\n      t.streamPos = e.pos;\n      r.splice(0, 2);\n    }\n  }\n  indexObjects() {\n    function readToken(e, t) {\n      let i = \"\",\n        a = e[t];\n      for (; 10 !== a && 13 !== a && 60 !== a && !(++t >= e.length);) {\n        i += String.fromCharCode(a);\n        a = e[t];\n      }\n      return i;\n    }\n    function skipUntil(e, t, i) {\n      const a = i.length,\n        s = e.length;\n      let r = 0;\n      for (; t < s;) {\n        let s = 0;\n        for (; s < a && e[t + s] === i[s];) ++s;\n        if (s >= a) break;\n        t++;\n        r++;\n      }\n      return r;\n    }\n    const e = /\\b(endobj|\\d+\\s+\\d+\\s+obj|xref|trailer\\s*<<)\\b/g,\n      t = /\\b(startxref|\\d+\\s+\\d+\\s+obj)\\b/g,\n      i = /^(\\d+)\\s+(\\d+)\\s+obj\\b/,\n      a = new Uint8Array([116, 114, 97, 105, 108, 101, 114]),\n      s = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]),\n      r = new Uint8Array([47, 88, 82, 101, 102]);\n    this.entries.length = 0;\n    this._cacheMap.clear();\n    const n = this.stream;\n    n.pos = 0;\n    const g = n.getBytes(),\n      o = bytesToString(g),\n      c = g.length;\n    let C = n.start;\n    const h = [],\n      l = [];\n    for (; C < c;) {\n      let Q = g[C];\n      if (9 === Q || 10 === Q || 13 === Q || 32 === Q) {\n        ++C;\n        continue;\n      }\n      if (37 === Q) {\n        do {\n          ++C;\n          if (C >= c) break;\n          Q = g[C];\n        } while (10 !== Q && 13 !== Q);\n        continue;\n      }\n      const E = readToken(g, C);\n      let u;\n      if (E.startsWith(\"xref\") && (4 === E.length || /\\s/.test(E[4]))) {\n        C += skipUntil(g, C, a);\n        h.push(C);\n        C += skipUntil(g, C, s);\n      } else if (u = i.exec(E)) {\n        const t = 0 | u[1],\n          i = 0 | u[2],\n          a = C + E.length;\n        let s,\n          h = !1;\n        if (this.entries[t]) {\n          if (this.entries[t].gen === i) try {\n            new Parser({\n              lexer: new Lexer(n.makeSubStream(a))\n            }).getObj();\n            h = !0;\n          } catch (e) {\n            e instanceof ParserEOFException ? warn(`indexObjects -- checking object (${E}): \"${e}\".`) : h = !0;\n          }\n        } else h = !0;\n        h && (this.entries[t] = {\n          offset: C - n.start,\n          gen: i,\n          uncompressed: !0\n        });\n        e.lastIndex = a;\n        const Q = e.exec(o);\n        if (Q) {\n          s = e.lastIndex + 1 - C;\n          if (\"endobj\" !== Q[1]) {\n            warn(`indexObjects: Found \"${Q[1]}\" inside of another \"obj\", caused by missing \"endobj\" -- trying to recover.`);\n            s -= Q[1].length + 1;\n          }\n        } else s = c - C;\n        const d = g.subarray(C, C + s),\n          f = skipUntil(d, 0, r);\n        if (f < s && d[f + 5] < 64) {\n          l.push(C - n.start);\n          this._xrefStms.add(C - n.start);\n        }\n        C += s;\n      } else if (E.startsWith(\"trailer\") && (7 === E.length || /\\s/.test(E[7]))) {\n        h.push(C);\n        const e = C + E.length;\n        let i;\n        t.lastIndex = e;\n        const a = t.exec(o);\n        if (a) {\n          i = t.lastIndex + 1 - C;\n          if (\"startxref\" !== a[1]) {\n            warn(`indexObjects: Found \"${a[1]}\" after \"trailer\", caused by missing \"startxref\" -- trying to recover.`);\n            i -= a[1].length + 1;\n          }\n        } else i = c - C;\n        C += i;\n      } else C += E.length + 1;\n    }\n    for (const e of l) {\n      this.startXRefQueue.push(e);\n      this.readXRef(!0);\n    }\n    const Q = [];\n    let E,\n      u,\n      d = !1;\n    for (const e of h) {\n      n.pos = e;\n      const t = new Parser({\n        lexer: new Lexer(n),\n        xref: this,\n        allowStreams: !0,\n        recoveryMode: !0\n      });\n      if (!isCmd(t.getObj(), \"trailer\")) continue;\n      const i = t.getObj();\n      if (i instanceof Dict) {\n        Q.push(i);\n        i.has(\"Encrypt\") && (d = !0);\n      }\n    }\n    for (const e of [...Q, \"genFallback\", ...Q]) {\n      if (\"genFallback\" === e) {\n        if (!u) break;\n        this._generationFallback = !0;\n        continue;\n      }\n      let t = !1;\n      try {\n        const i = e.get(\"Root\");\n        if (!(i instanceof Dict)) continue;\n        const a = i.get(\"Pages\");\n        if (!(a instanceof Dict)) continue;\n        const s = a.get(\"Count\");\n        Number.isInteger(s) && (t = !0);\n      } catch (e) {\n        u = e;\n        continue;\n      }\n      if (t && (!d || e.has(\"Encrypt\")) && e.has(\"ID\")) return e;\n      E = e;\n    }\n    if (E) return E;\n    if (this.topDict) return this.topDict;\n    throw new InvalidPDFException(\"Invalid PDF structure.\");\n  }\n  readXRef(e = !1) {\n    const t = this.stream,\n      i = new Set();\n    for (; this.startXRefQueue.length;) {\n      try {\n        const e = this.startXRefQueue[0];\n        if (i.has(e)) {\n          warn(\"readXRef - skipping XRef table since it was already parsed.\");\n          this.startXRefQueue.shift();\n          continue;\n        }\n        i.add(e);\n        t.pos = e + t.start;\n        const a = new Parser({\n          lexer: new Lexer(t),\n          xref: this,\n          allowStreams: !0\n        });\n        let s,\n          r = a.getObj();\n        if (isCmd(r, \"xref\")) {\n          s = this.processXRefTable(a);\n          this.topDict || (this.topDict = s);\n          r = s.get(\"XRefStm\");\n          if (Number.isInteger(r) && !this._xrefStms.has(r)) {\n            this._xrefStms.add(r);\n            this.startXRefQueue.push(r);\n            this.#K ??= r;\n          }\n        } else {\n          if (!Number.isInteger(r)) throw new FormatError(\"Invalid XRef stream header\");\n          if (!(Number.isInteger(a.getObj()) && isCmd(a.getObj(), \"obj\") && (r = a.getObj()) instanceof BaseStream)) throw new FormatError(\"Invalid XRef stream\");\n          s = this.processXRefStream(r);\n          this.topDict || (this.topDict = s);\n          if (!s) throw new FormatError(\"Failed to read XRef stream\");\n        }\n        r = s.get(\"Prev\");\n        Number.isInteger(r) ? this.startXRefQueue.push(r) : r instanceof Ref && this.startXRefQueue.push(r.num);\n      } catch (e) {\n        if (e instanceof MissingDataException) throw e;\n        info(\"(while reading XRef): \" + e);\n      }\n      this.startXRefQueue.shift();\n    }\n    if (this.topDict) return this.topDict;\n    if (!e) throw new XRefParseException();\n  }\n  get lastXRefStreamPos() {\n    return this.#K ?? (this._xrefStms.size > 0 ? Math.max(...this._xrefStms) : null);\n  }\n  getEntry(e) {\n    const t = this.entries[e];\n    return t && !t.free && t.offset ? t : null;\n  }\n  fetchIfRef(e, t = !1) {\n    return e instanceof Ref ? this.fetch(e, t) : e;\n  }\n  fetch(e, t = !1) {\n    if (!(e instanceof Ref)) throw new Error(\"ref object is not a reference\");\n    const i = e.num,\n      a = this._cacheMap.get(i);\n    if (void 0 !== a) {\n      a instanceof Dict && !a.objId && (a.objId = e.toString());\n      return a;\n    }\n    let s = this.getEntry(i);\n    if (null === s) {\n      this._cacheMap.set(i, s);\n      return s;\n    }\n    if (this._pendingRefs.has(e)) {\n      this._pendingRefs.remove(e);\n      warn(`Ignoring circular reference: ${e}.`);\n      return ft;\n    }\n    this._pendingRefs.put(e);\n    try {\n      s = s.uncompressed ? this.fetchUncompressed(e, s, t) : this.fetchCompressed(e, s, t);\n      this._pendingRefs.remove(e);\n    } catch (t) {\n      this._pendingRefs.remove(e);\n      throw t;\n    }\n    s instanceof Dict ? s.objId = e.toString() : s instanceof BaseStream && (s.dict.objId = e.toString());\n    return s;\n  }\n  fetchUncompressed(e, t, i = !1) {\n    const a = e.gen;\n    let s = e.num;\n    if (t.gen !== a) {\n      const r = `Inconsistent generation in XRef: ${e}`;\n      if (this._generationFallback && t.gen < a) {\n        warn(r);\n        return this.fetchUncompressed(Ref.get(s, t.gen), t, i);\n      }\n      throw new XRefEntryException(r);\n    }\n    const r = this.stream.makeSubStream(t.offset + this.stream.start),\n      n = new Parser({\n        lexer: new Lexer(r),\n        xref: this,\n        allowStreams: !0\n      }),\n      g = n.getObj(),\n      o = n.getObj(),\n      c = n.getObj();\n    if (g !== s || o !== a || !(c instanceof Cmd)) throw new XRefEntryException(`Bad (uncompressed) XRef entry: ${e}`);\n    if (\"obj\" !== c.cmd) {\n      if (c.cmd.startsWith(\"obj\")) {\n        s = parseInt(c.cmd.substring(3), 10);\n        if (!Number.isNaN(s)) return s;\n      }\n      throw new XRefEntryException(`Bad (uncompressed) XRef entry: ${e}`);\n    }\n    (t = this.encrypt && !i ? n.getObj(this.encrypt.createCipherTransform(s, a)) : n.getObj()) instanceof BaseStream || this._cacheMap.set(s, t);\n    return t;\n  }\n  fetchCompressed(e, t, i = !1) {\n    const a = t.offset,\n      s = this.fetch(Ref.get(a, 0));\n    if (!(s instanceof BaseStream)) throw new FormatError(\"bad ObjStm stream\");\n    const r = s.dict.get(\"First\"),\n      n = s.dict.get(\"N\");\n    if (!Number.isInteger(r) || !Number.isInteger(n)) throw new FormatError(\"invalid first and n parameters for ObjStm stream\");\n    let g = new Parser({\n      lexer: new Lexer(s),\n      xref: this,\n      allowStreams: !0\n    });\n    const o = new Array(n),\n      c = new Array(n);\n    for (let e = 0; e < n; ++e) {\n      const t = g.getObj();\n      if (!Number.isInteger(t)) throw new FormatError(`invalid object number in the ObjStm stream: ${t}`);\n      const i = g.getObj();\n      if (!Number.isInteger(i)) throw new FormatError(`invalid object offset in the ObjStm stream: ${i}`);\n      o[e] = t;\n      c[e] = i;\n    }\n    const C = (s.start || 0) + r,\n      h = new Array(n);\n    for (let e = 0; e < n; ++e) {\n      const t = e < n - 1 ? c[e + 1] - c[e] : void 0;\n      if (t < 0) throw new FormatError(\"Invalid offset in the ObjStm stream.\");\n      g = new Parser({\n        lexer: new Lexer(s.makeSubStream(C + c[e], t, s.dict)),\n        xref: this,\n        allowStreams: !0\n      });\n      const i = g.getObj();\n      h[e] = i;\n      if (i instanceof BaseStream) continue;\n      const r = o[e],\n        l = this.entries[r];\n      l && l.offset === a && l.gen === e && this._cacheMap.set(r, i);\n    }\n    if (void 0 === (t = h[t.gen])) throw new XRefEntryException(`Bad (compressed) XRef entry: ${e}`);\n    return t;\n  }\n  async fetchIfRefAsync(e, t) {\n    return e instanceof Ref ? this.fetchAsync(e, t) : e;\n  }\n  async fetchAsync(e, t) {\n    try {\n      return this.fetch(e, t);\n    } catch (i) {\n      if (!(i instanceof MissingDataException)) throw i;\n      await this.pdfManager.requestRange(i.begin, i.end);\n      return this.fetchAsync(e, t);\n    }\n  }\n  getCatalogObj() {\n    return this.root;\n  }\n}\nconst sg = [0, 0, 612, 792];\nclass Page {\n  constructor({\n    pdfManager: e,\n    xref: t,\n    pageIndex: i,\n    pageDict: a,\n    ref: s,\n    globalIdFactory: r,\n    fontCache: n,\n    builtInCMapCache: g,\n    standardFontDataCache: o,\n    globalImageCache: c,\n    systemFontCache: C,\n    nonBlendModesSet: h,\n    xfaFactory: l\n  }) {\n    this.pdfManager = e;\n    this.pageIndex = i;\n    this.pageDict = a;\n    this.xref = t;\n    this.ref = s;\n    this.fontCache = n;\n    this.builtInCMapCache = g;\n    this.standardFontDataCache = o;\n    this.globalImageCache = c;\n    this.systemFontCache = C;\n    this.nonBlendModesSet = h;\n    this.evaluatorOptions = e.evaluatorOptions;\n    this.resourcesPromise = null;\n    this.xfaFactory = l;\n    const Q = {\n      obj: 0\n    };\n    this._localIdFactory = class extends r {\n      static createObjId() {\n        return `p${i}_${++Q.obj}`;\n      }\n      static getPageObjId() {\n        return `p${s.toString()}`;\n      }\n    };\n  }\n  _getInheritableProperty(e, t = !1) {\n    const i = getInheritableProperty({\n      dict: this.pageDict,\n      key: e,\n      getArray: t,\n      stopWhenFound: !1\n    });\n    return Array.isArray(i) ? 1 !== i.length && i[0] instanceof Dict ? Dict.merge({\n      xref: this.xref,\n      dictArray: i\n    }) : i[0] : i;\n  }\n  get content() {\n    return this.pageDict.getArray(\"Contents\");\n  }\n  get resources() {\n    const e = this._getInheritableProperty(\"Resources\");\n    return shadow(this, \"resources\", e instanceof Dict ? e : Dict.empty);\n  }\n  _getBoundingBox(e) {\n    if (this.xfaData) return this.xfaData.bbox;\n    const t = lookupNormalRect(this._getInheritableProperty(e, !0), null);\n    if (t) {\n      if (t[2] - t[0] > 0 && t[3] - t[1] > 0) return t;\n      warn(`Empty, or invalid, /${e} entry.`);\n    }\n    return null;\n  }\n  get mediaBox() {\n    return shadow(this, \"mediaBox\", this._getBoundingBox(\"MediaBox\") || sg);\n  }\n  get cropBox() {\n    return shadow(this, \"cropBox\", this._getBoundingBox(\"CropBox\") || this.mediaBox);\n  }\n  get userUnit() {\n    let e = this.pageDict.get(\"UserUnit\");\n    (\"number\" != typeof e || e <= 0) && (e = 1);\n    return shadow(this, \"userUnit\", e);\n  }\n  get view() {\n    const {\n      cropBox: e,\n      mediaBox: t\n    } = this;\n    if (e !== t && !isArrayEqual(e, t)) {\n      const i = Util.intersect(e, t);\n      if (i && i[2] - i[0] > 0 && i[3] - i[1] > 0) return shadow(this, \"view\", i);\n      warn(\"Empty /CropBox and /MediaBox intersection.\");\n    }\n    return shadow(this, \"view\", t);\n  }\n  get rotate() {\n    let e = this._getInheritableProperty(\"Rotate\") || 0;\n    e % 90 != 0 ? e = 0 : e >= 360 ? e %= 360 : e < 0 && (e = (e % 360 + 360) % 360);\n    return shadow(this, \"rotate\", e);\n  }\n  _onSubStreamError(e, t) {\n    if (!this.evaluatorOptions.ignoreErrors) throw e;\n    warn(`getContentStream - ignoring sub-stream (${t}): \"${e}\".`);\n  }\n  getContentStream() {\n    return this.pdfManager.ensure(this, \"content\").then(e => e instanceof BaseStream ? e : Array.isArray(e) ? new StreamsSequenceStream(e, this._onSubStreamError.bind(this)) : new NullStream());\n  }\n  get xfaData() {\n    return shadow(this, \"xfaData\", this.xfaFactory ? {\n      bbox: this.xfaFactory.getBoundingBox(this.pageIndex)\n    } : null);\n  }\n  #T(e, t, i) {\n    for (const a of e) if (a.id) {\n      const e = Ref.fromString(a.id);\n      if (!e) {\n        warn(`A non-linked annotation cannot be modified: ${a.id}`);\n        continue;\n      }\n      if (a.deleted) {\n        t.put(e, e);\n        continue;\n      }\n      i?.put(e);\n      a.ref = e;\n      delete a.id;\n    }\n  }\n  async saveNewAnnotations(e, t, i, a) {\n    if (this.xfaFactory) throw new Error(\"XFA: Cannot save new annotations.\");\n    const s = new PartialEvaluator({\n        xref: this.xref,\n        handler: e,\n        pageIndex: this.pageIndex,\n        idFactory: this._localIdFactory,\n        fontCache: this.fontCache,\n        builtInCMapCache: this.builtInCMapCache,\n        standardFontDataCache: this.standardFontDataCache,\n        globalImageCache: this.globalImageCache,\n        systemFontCache: this.systemFontCache,\n        options: this.evaluatorOptions\n      }),\n      r = new RefSetCache(),\n      n = new RefSet();\n    this.#T(i, r, n);\n    const g = this.pageDict,\n      o = this.annotations.filter(e => !(e instanceof Ref && r.has(e))),\n      c = await AnnotationFactory.saveNewAnnotations(s, t, i, a);\n    for (const {\n      ref: e\n    } of c.annotations) e instanceof Ref && !n.has(e) && o.push(e);\n    const C = g.get(\"Annots\");\n    g.set(\"Annots\", o);\n    const h = [];\n    await writeObject(this.ref, g, h, this.xref);\n    C && g.set(\"Annots\", C);\n    const l = c.dependencies;\n    l.push({\n      ref: this.ref,\n      data: h.join(\"\")\n    }, ...c.annotations);\n    for (const e of r) l.push({\n      ref: e,\n      data: null\n    });\n    return l;\n  }\n  save(e, t, i) {\n    const a = new PartialEvaluator({\n      xref: this.xref,\n      handler: e,\n      pageIndex: this.pageIndex,\n      idFactory: this._localIdFactory,\n      fontCache: this.fontCache,\n      builtInCMapCache: this.builtInCMapCache,\n      standardFontDataCache: this.standardFontDataCache,\n      globalImageCache: this.globalImageCache,\n      systemFontCache: this.systemFontCache,\n      options: this.evaluatorOptions\n    });\n    return this._parsedAnnotations.then(function (e) {\n      const s = [];\n      for (const r of e) r.mustBePrinted(i) && s.push(r.save(a, t, i).catch(function (e) {\n        warn(`save - ignoring annotation data during \"${t.name}\" task: \"${e}\".`);\n        return null;\n      }));\n      return Promise.all(s).then(function (e) {\n        return e.filter(e => !!e);\n      });\n    });\n  }\n  loadResources(e) {\n    this.resourcesPromise ||= this.pdfManager.ensure(this, \"resources\");\n    return this.resourcesPromise.then(() => new ObjectLoader(this.resources, e, this.xref).load());\n  }\n  getOperatorList({\n    handler: e,\n    sink: t,\n    task: i,\n    intent: a,\n    cacheKey: s,\n    annotationStorage: r = null\n  }) {\n    const n = this.getContentStream(),\n      C = this.loadResources([\"ColorSpace\", \"ExtGState\", \"Font\", \"Pattern\", \"Properties\", \"Shading\", \"XObject\"]),\n      Q = new PartialEvaluator({\n        xref: this.xref,\n        handler: e,\n        pageIndex: this.pageIndex,\n        idFactory: this._localIdFactory,\n        fontCache: this.fontCache,\n        builtInCMapCache: this.builtInCMapCache,\n        standardFontDataCache: this.standardFontDataCache,\n        globalImageCache: this.globalImageCache,\n        systemFontCache: this.systemFontCache,\n        options: this.evaluatorOptions\n      }),\n      u = this.xfaFactory ? null : getNewAnnotationsMap(r),\n      d = u?.get(this.pageIndex);\n    let f = Promise.resolve(null),\n      p = null;\n    if (d) {\n      const e = this.pdfManager.ensureDoc(\"annotationGlobals\");\n      let t;\n      const a = new Set();\n      for (const {\n        bitmapId: e,\n        bitmap: t\n      } of d) !e || t || a.has(e) || a.add(e);\n      const {\n        isOffscreenCanvasSupported: s\n      } = this.evaluatorOptions;\n      if (a.size > 0) {\n        const e = d.slice();\n        for (const [t, i] of r) t.startsWith(E) && i.bitmap && a.has(i.bitmapId) && e.push(i);\n        t = AnnotationFactory.generateImages(e, this.xref, s);\n      } else t = AnnotationFactory.generateImages(d, this.xref, s);\n      p = new RefSet();\n      this.#T(d, p, null);\n      f = e.then(e => e ? AnnotationFactory.printNewAnnotations(e, Q, i, d, t) : null);\n    }\n    const m = Promise.all([n, C]).then(([r]) => {\n      const n = new OperatorList(a, t);\n      e.send(\"StartRenderPage\", {\n        transparency: Q.hasBlendModes(this.resources, this.nonBlendModesSet),\n        pageIndex: this.pageIndex,\n        cacheKey: s\n      });\n      return Q.getOperatorList({\n        stream: r,\n        task: i,\n        resources: this.resources,\n        operatorList: n\n      }).then(function () {\n        return n;\n      });\n    });\n    return Promise.all([m, this._parsedAnnotations, f]).then(function ([e, t, s]) {\n      if (s) {\n        t = t.filter(e => !(e.ref && p.has(e.ref)));\n        for (let e = 0, i = s.length; e < i; e++) {\n          const a = s[e];\n          if (a.refToReplace) {\n            const r = t.findIndex(e => e.ref && isRefsEqual(e.ref, a.refToReplace));\n            if (r >= 0) {\n              t.splice(r, 1, a);\n              s.splice(e--, 1);\n              i--;\n            }\n          }\n        }\n        t = t.concat(s);\n      }\n      if (0 === t.length || a & l) {\n        e.flush(!0);\n        return {\n          length: e.totalLength\n        };\n      }\n      const n = !!(a & h),\n        C = !!(a & g),\n        E = !!(a & o),\n        u = !!(a & c),\n        d = [];\n      for (const e of t) (C || E && e.mustBeViewed(r, n) || u && e.mustBePrinted(r)) && d.push(e.getOperatorList(Q, i, a, n, r).catch(function (e) {\n        warn(`getOperatorList - ignoring annotation data during \"${i.name}\" task: \"${e}\".`);\n        return {\n          opList: null,\n          separateForm: !1,\n          separateCanvas: !1\n        };\n      }));\n      return Promise.all(d).then(function (t) {\n        let i = !1,\n          a = !1;\n        for (const {\n          opList: s,\n          separateForm: r,\n          separateCanvas: n\n        } of t) {\n          e.addOpList(s);\n          i ||= r;\n          a ||= n;\n        }\n        e.flush(!0, {\n          form: i,\n          canvas: a\n        });\n        return {\n          length: e.totalLength\n        };\n      });\n    });\n  }\n  async extractTextContent({\n    handler: e,\n    task: t,\n    includeMarkedContent: i,\n    disableNormalization: a,\n    sink: s\n  }) {\n    const r = this.getContentStream(),\n      n = this.loadResources([\"ExtGState\", \"Font\", \"Properties\", \"XObject\"]),\n      g = this.pdfManager.ensureCatalog(\"lang\"),\n      [o,, c] = await Promise.all([r, n, g]);\n    return new PartialEvaluator({\n      xref: this.xref,\n      handler: e,\n      pageIndex: this.pageIndex,\n      idFactory: this._localIdFactory,\n      fontCache: this.fontCache,\n      builtInCMapCache: this.builtInCMapCache,\n      standardFontDataCache: this.standardFontDataCache,\n      globalImageCache: this.globalImageCache,\n      systemFontCache: this.systemFontCache,\n      options: this.evaluatorOptions\n    }).getTextContent({\n      stream: o,\n      task: t,\n      resources: this.resources,\n      includeMarkedContent: i,\n      disableNormalization: a,\n      sink: s,\n      viewBox: this.view,\n      lang: c\n    });\n  }\n  async getStructTree() {\n    const e = await this.pdfManager.ensureCatalog(\"structTreeRoot\");\n    if (!e) return null;\n    await this._parsedAnnotations;\n    return (await this.pdfManager.ensure(this, \"_parseStructTree\", [e])).serializable;\n  }\n  _parseStructTree(e) {\n    const t = new StructTreePage(e, this.pageDict);\n    t.parse(this.ref);\n    return t;\n  }\n  async getAnnotationsData(e, t, i) {\n    const a = await this._parsedAnnotations;\n    if (0 === a.length) return a;\n    const s = [],\n      r = [];\n    let n;\n    const C = !!(i & g),\n      h = !!(i & o),\n      l = !!(i & c);\n    for (const i of a) {\n      const a = C || h && i.viewable;\n      (a || l && i.printable) && s.push(i.data);\n      if (i.hasTextContent && a) {\n        n ||= new PartialEvaluator({\n          xref: this.xref,\n          handler: e,\n          pageIndex: this.pageIndex,\n          idFactory: this._localIdFactory,\n          fontCache: this.fontCache,\n          builtInCMapCache: this.builtInCMapCache,\n          standardFontDataCache: this.standardFontDataCache,\n          globalImageCache: this.globalImageCache,\n          systemFontCache: this.systemFontCache,\n          options: this.evaluatorOptions\n        });\n        r.push(i.extractTextContent(n, t, [-1 / 0, -1 / 0, 1 / 0, 1 / 0]).catch(function (e) {\n          warn(`getAnnotationsData - ignoring textContent during \"${t.name}\" task: \"${e}\".`);\n        }));\n      }\n    }\n    await Promise.all(r);\n    return s;\n  }\n  get annotations() {\n    const e = this._getInheritableProperty(\"Annots\");\n    return shadow(this, \"annotations\", Array.isArray(e) ? e : []);\n  }\n  get _parsedAnnotations() {\n    return shadow(this, \"_parsedAnnotations\", this.pdfManager.ensure(this, \"annotations\").then(async e => {\n      if (0 === e.length) return e;\n      const t = await this.pdfManager.ensureDoc(\"annotationGlobals\");\n      if (!t) return [];\n      const i = [];\n      for (const a of e) i.push(AnnotationFactory.create(this.xref, a, t, this._localIdFactory, !1, this.ref).catch(function (e) {\n        warn(`_parsedAnnotations: \"${e}\".`);\n        return null;\n      }));\n      const a = [];\n      let s, r;\n      for (const e of await Promise.all(i)) e && (e instanceof WidgetAnnotation ? (r ||= []).push(e) : e instanceof PopupAnnotation ? (s ||= []).push(e) : a.push(e));\n      r && a.push(...r);\n      s && a.push(...s);\n      return a;\n    }));\n  }\n  get jsActions() {\n    return shadow(this, \"jsActions\", collectActions(this.xref, this.pageDict, fA));\n  }\n}\nconst rg = new Uint8Array([37, 80, 68, 70, 45]),\n  ng = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]),\n  gg = new Uint8Array([101, 110, 100, 111, 98, 106]);\nfunction find(e, t, i = 1024, a = !1) {\n  const s = t.length,\n    r = e.peekBytes(i),\n    n = r.length - s;\n  if (n <= 0) return !1;\n  if (a) {\n    const i = s - 1;\n    let a = r.length - 1;\n    for (; a >= i;) {\n      let n = 0;\n      for (; n < s && r[a - n] === t[i - n];) n++;\n      if (n >= s) {\n        e.pos += a - i;\n        return !0;\n      }\n      a--;\n    }\n  } else {\n    let i = 0;\n    for (; i <= n;) {\n      let a = 0;\n      for (; a < s && r[i + a] === t[a];) a++;\n      if (a >= s) {\n        e.pos += i;\n        return !0;\n      }\n      i++;\n    }\n  }\n  return !1;\n}\nclass PDFDocument {\n  constructor(e, t) {\n    if (t.length <= 0) throw new InvalidPDFException(\"The PDF file is empty, i.e. its size is zero bytes.\");\n    this.pdfManager = e;\n    this.stream = t;\n    this.xref = new XRef(t, e);\n    this._pagePromises = new Map();\n    this._version = null;\n    const i = {\n      font: 0\n    };\n    this._globalIdFactory = class {\n      static getDocId() {\n        return `g_${e.docId}`;\n      }\n      static createFontId() {\n        return \"f\" + ++i.font;\n      }\n      static createObjId() {\n        unreachable(\"Abstract method `createObjId` called.\");\n      }\n      static getPageObjId() {\n        unreachable(\"Abstract method `getPageObjId` called.\");\n      }\n    };\n  }\n  parse(e) {\n    this.xref.parse(e);\n    this.catalog = new Catalog(this.pdfManager, this.xref);\n  }\n  get linearization() {\n    let e = null;\n    try {\n      e = Linearization.create(this.stream);\n    } catch (e) {\n      if (e instanceof MissingDataException) throw e;\n      info(e);\n    }\n    return shadow(this, \"linearization\", e);\n  }\n  get startXRef() {\n    const e = this.stream;\n    let t = 0;\n    if (this.linearization) {\n      e.reset();\n      if (find(e, gg)) {\n        e.skip(6);\n        let i = e.peekByte();\n        for (; isWhiteSpace(i);) {\n          e.pos++;\n          i = e.peekByte();\n        }\n        t = e.pos - e.start;\n      }\n    } else {\n      const i = 1024,\n        a = ng.length;\n      let s = !1,\n        r = e.end;\n      for (; !s && r > 0;) {\n        r -= i - a;\n        r < 0 && (r = 0);\n        e.pos = r;\n        s = find(e, ng, i, !0);\n      }\n      if (s) {\n        e.skip(9);\n        let i;\n        do {\n          i = e.getByte();\n        } while (isWhiteSpace(i));\n        let a = \"\";\n        for (; i >= 32 && i <= 57;) {\n          a += String.fromCharCode(i);\n          i = e.getByte();\n        }\n        t = parseInt(a, 10);\n        isNaN(t) && (t = 0);\n      }\n    }\n    return shadow(this, \"startXRef\", t);\n  }\n  checkHeader() {\n    const e = this.stream;\n    e.reset();\n    if (!find(e, rg)) return;\n    e.moveStart();\n    e.skip(rg.length);\n    let t,\n      i = \"\";\n    for (; (t = e.getByte()) > 32 && i.length < 7;) i += String.fromCharCode(t);\n    bt.test(i) ? this._version = i : warn(`Invalid PDF header version: ${i}`);\n  }\n  parseStartXRef() {\n    this.xref.setStartXRef(this.startXRef);\n  }\n  get numPages() {\n    let e = 0;\n    e = this.catalog.hasActualNumPages ? this.catalog.numPages : this.xfaFactory ? this.xfaFactory.getNumPages() : this.linearization ? this.linearization.numPages : this.catalog.numPages;\n    return shadow(this, \"numPages\", e);\n  }\n  _hasOnlyDocumentSignatures(e, t = 0) {\n    return !!Array.isArray(e) && e.every(e => {\n      if (!((e = this.xref.fetchIfRef(e)) instanceof Dict)) return !1;\n      if (e.has(\"Kids\")) {\n        if (++t > 10) {\n          warn(\"_hasOnlyDocumentSignatures: maximum recursion depth reached\");\n          return !1;\n        }\n        return this._hasOnlyDocumentSignatures(e.get(\"Kids\"), t);\n      }\n      const i = isName(e.get(\"FT\"), \"Sig\"),\n        a = e.get(\"Rect\"),\n        s = Array.isArray(a) && a.every(e => 0 === e);\n      return i && s;\n    });\n  }\n  get _xfaStreams() {\n    const e = this.catalog.acroForm;\n    if (!e) return null;\n    const t = e.get(\"XFA\"),\n      i = {\n        \"xdp:xdp\": \"\",\n        template: \"\",\n        datasets: \"\",\n        config: \"\",\n        connectionSet: \"\",\n        localeSet: \"\",\n        stylesheet: \"\",\n        \"/xdp:xdp\": \"\"\n      };\n    if (t instanceof BaseStream && !t.isEmpty) {\n      i[\"xdp:xdp\"] = t;\n      return i;\n    }\n    if (!Array.isArray(t) || 0 === t.length) return null;\n    for (let e = 0, a = t.length; e < a; e += 2) {\n      let s;\n      s = 0 === e ? \"xdp:xdp\" : e === a - 2 ? \"/xdp:xdp\" : t[e];\n      if (!i.hasOwnProperty(s)) continue;\n      const r = this.xref.fetchIfRef(t[e + 1]);\n      r instanceof BaseStream && !r.isEmpty && (i[s] = r);\n    }\n    return i;\n  }\n  get xfaDatasets() {\n    const e = this._xfaStreams;\n    if (!e) return shadow(this, \"xfaDatasets\", null);\n    for (const t of [\"datasets\", \"xdp:xdp\"]) {\n      const i = e[t];\n      if (i) try {\n        const e = stringToUTF8String(i.getString());\n        return shadow(this, \"xfaDatasets\", new DatasetReader({\n          [t]: e\n        }));\n      } catch {\n        warn(\"XFA - Invalid utf-8 string.\");\n        break;\n      }\n    }\n    return shadow(this, \"xfaDatasets\", null);\n  }\n  get xfaData() {\n    const e = this._xfaStreams;\n    if (!e) return null;\n    const t = Object.create(null);\n    for (const [i, a] of Object.entries(e)) if (a) try {\n      t[i] = stringToUTF8String(a.getString());\n    } catch {\n      warn(\"XFA - Invalid utf-8 string.\");\n      return null;\n    }\n    return t;\n  }\n  get xfaFactory() {\n    let e;\n    this.pdfManager.enableXfa && this.catalog.needsRendering && this.formInfo.hasXfa && !this.formInfo.hasAcroForm && (e = this.xfaData);\n    return shadow(this, \"xfaFactory\", e ? new XFAFactory(e) : null);\n  }\n  get isPureXfa() {\n    return !!this.xfaFactory && this.xfaFactory.isValid();\n  }\n  get htmlForXfa() {\n    return this.xfaFactory ? this.xfaFactory.getPages() : null;\n  }\n  async loadXfaImages() {\n    const e = await this.pdfManager.ensureCatalog(\"xfaImages\");\n    if (!e) return;\n    const t = e.getKeys(),\n      i = new ObjectLoader(e, t, this.xref);\n    await i.load();\n    const a = new Map();\n    for (const i of t) {\n      const t = e.get(i);\n      t instanceof BaseStream && a.set(i, t.getBytes());\n    }\n    this.xfaFactory.setImages(a);\n  }\n  async loadXfaFonts(e, t) {\n    const i = await this.pdfManager.ensureCatalog(\"acroForm\");\n    if (!i) return;\n    const a = await i.getAsync(\"DR\");\n    if (!(a instanceof Dict)) return;\n    const s = new ObjectLoader(a, [\"Font\"], this.xref);\n    await s.load();\n    const r = a.get(\"Font\");\n    if (!(r instanceof Dict)) return;\n    const n = Object.assign(Object.create(null), this.pdfManager.evaluatorOptions);\n    n.useSystemFonts = !1;\n    const g = new PartialEvaluator({\n        xref: this.xref,\n        handler: e,\n        pageIndex: -1,\n        idFactory: this._globalIdFactory,\n        fontCache: this.catalog.fontCache,\n        builtInCMapCache: this.catalog.builtInCMapCache,\n        standardFontDataCache: this.catalog.standardFontDataCache,\n        options: n\n      }),\n      o = new OperatorList(),\n      c = [],\n      C = {\n        get font() {\n          return c.at(-1);\n        },\n        set font(e) {\n          c.push(e);\n        },\n        clone() {\n          return this;\n        }\n      },\n      h = new Map();\n    r.forEach((e, t) => {\n      h.set(e, t);\n    });\n    const l = [];\n    for (const [e, i] of h) {\n      const s = i.get(\"FontDescriptor\");\n      if (!(s instanceof Dict)) continue;\n      let r = s.get(\"FontFamily\");\n      r = r.replaceAll(/[ ]+(\\d)/g, \"$1\");\n      const n = {\n        fontFamily: r,\n        fontWeight: s.get(\"FontWeight\"),\n        italicAngle: -s.get(\"ItalicAngle\")\n      };\n      validateCSSFont(n) && l.push(g.handleSetFont(a, [Name.get(e), 1], null, o, t, C, null, n).catch(function (e) {\n        warn(`loadXfaFonts: \"${e}\".`);\n        return null;\n      }));\n    }\n    await Promise.all(l);\n    const Q = this.xfaFactory.setFonts(c);\n    if (!Q) return;\n    n.ignoreErrors = !0;\n    l.length = 0;\n    c.length = 0;\n    const E = new Set();\n    for (const e of Q) getXfaFontName(`${e}-Regular`) || E.add(e);\n    E.size && Q.push(\"PdfJS-Fallback\");\n    for (const e of Q) if (!E.has(e)) for (const i of [{\n      name: \"Regular\",\n      fontWeight: 400,\n      italicAngle: 0\n    }, {\n      name: \"Bold\",\n      fontWeight: 700,\n      italicAngle: 0\n    }, {\n      name: \"Italic\",\n      fontWeight: 400,\n      italicAngle: 12\n    }, {\n      name: \"BoldItalic\",\n      fontWeight: 700,\n      italicAngle: 12\n    }]) {\n      const s = `${e}-${i.name}`,\n        r = getXfaFontDict(s);\n      l.push(g.handleSetFont(a, [Name.get(s), 1], null, o, t, C, r, {\n        fontFamily: e,\n        fontWeight: i.fontWeight,\n        italicAngle: i.italicAngle\n      }).catch(function (e) {\n        warn(`loadXfaFonts: \"${e}\".`);\n        return null;\n      }));\n    }\n    await Promise.all(l);\n    this.xfaFactory.appendFonts(c, E);\n  }\n  async serializeXfaData(e) {\n    return this.xfaFactory ? this.xfaFactory.serializeData(e) : null;\n  }\n  get version() {\n    return this.catalog.version || this._version;\n  }\n  get formInfo() {\n    const e = {\n        hasFields: !1,\n        hasAcroForm: !1,\n        hasXfa: !1,\n        hasSignatures: !1\n      },\n      t = this.catalog.acroForm;\n    if (!t) return shadow(this, \"formInfo\", e);\n    try {\n      const i = t.get(\"Fields\"),\n        a = Array.isArray(i) && i.length > 0;\n      e.hasFields = a;\n      const s = t.get(\"XFA\");\n      e.hasXfa = Array.isArray(s) && s.length > 0 || s instanceof BaseStream && !s.isEmpty;\n      const r = !!(1 & t.get(\"SigFlags\")),\n        n = r && this._hasOnlyDocumentSignatures(i);\n      e.hasAcroForm = a && !n;\n      e.hasSignatures = r;\n    } catch (e) {\n      if (e instanceof MissingDataException) throw e;\n      warn(`Cannot fetch form information: \"${e}\".`);\n    }\n    return shadow(this, \"formInfo\", e);\n  }\n  get documentInfo() {\n    const e = {\n      PDFFormatVersion: this.version,\n      Language: this.catalog.lang,\n      EncryptFilterName: this.xref.encrypt ? this.xref.encrypt.filterName : null,\n      IsLinearized: !!this.linearization,\n      IsAcroFormPresent: this.formInfo.hasAcroForm,\n      IsXFAPresent: this.formInfo.hasXfa,\n      IsCollectionPresent: !!this.catalog.collection,\n      IsSignaturesPresent: this.formInfo.hasSignatures\n    };\n    let t;\n    try {\n      t = this.xref.trailer.get(\"Info\");\n    } catch (e) {\n      if (e instanceof MissingDataException) throw e;\n      info(\"The document information dictionary is invalid.\");\n    }\n    if (!(t instanceof Dict)) return shadow(this, \"documentInfo\", e);\n    for (const i of t.getKeys()) {\n      const a = t.get(i);\n      switch (i) {\n        case \"Title\":\n        case \"Author\":\n        case \"Subject\":\n        case \"Keywords\":\n        case \"Creator\":\n        case \"Producer\":\n        case \"CreationDate\":\n        case \"ModDate\":\n          if (\"string\" == typeof a) {\n            e[i] = stringToPDFString(a);\n            continue;\n          }\n          break;\n        case \"Trapped\":\n          if (a instanceof Name) {\n            e[i] = a;\n            continue;\n          }\n          break;\n        default:\n          let t;\n          switch (typeof a) {\n            case \"string\":\n              t = stringToPDFString(a);\n              break;\n            case \"number\":\n            case \"boolean\":\n              t = a;\n              break;\n            default:\n              a instanceof Name && (t = a);\n          }\n          if (void 0 === t) {\n            warn(`Bad value, for custom key \"${i}\", in Info: ${a}.`);\n            continue;\n          }\n          e.Custom || (e.Custom = Object.create(null));\n          e.Custom[i] = t;\n          continue;\n      }\n      warn(`Bad value, for key \"${i}\", in Info: ${a}.`);\n    }\n    return shadow(this, \"documentInfo\", e);\n  }\n  get fingerprints() {\n    function validate(e) {\n      return \"string\" == typeof e && e.length > 0 && \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" !== e;\n    }\n    function hexString(e) {\n      const t = [];\n      for (const i of e) {\n        const e = i.toString(16);\n        t.push(e.padStart(2, \"0\"));\n      }\n      return t.join(\"\");\n    }\n    const e = this.xref.trailer.get(\"ID\");\n    let t, i;\n    if (Array.isArray(e) && validate(e[0])) {\n      t = stringToBytes(e[0]);\n      e[1] !== e[0] && validate(e[1]) && (i = stringToBytes(e[1]));\n    } else t = Hs(this.stream.getByteRange(0, 1024), 0, 1024);\n    return shadow(this, \"fingerprints\", [hexString(t), i ? hexString(i) : null]);\n  }\n  async _getLinearizationPage(e) {\n    const {\n        catalog: t,\n        linearization: i,\n        xref: a\n      } = this,\n      s = Ref.get(i.objectNumberFirst, 0);\n    try {\n      const e = await a.fetchAsync(s);\n      if (e instanceof Dict) {\n        let i = e.getRaw(\"Type\");\n        i instanceof Ref && (i = await a.fetchAsync(i));\n        if (isName(i, \"Page\") || !e.has(\"Type\") && !e.has(\"Kids\") && e.has(\"Contents\")) {\n          t.pageKidsCountCache.has(s) || t.pageKidsCountCache.put(s, 1);\n          t.pageIndexCache.has(s) || t.pageIndexCache.put(s, 0);\n          return [e, s];\n        }\n      }\n      throw new FormatError(\"The Linearization dictionary doesn't point to a valid Page dictionary.\");\n    } catch (i) {\n      warn(`_getLinearizationPage: \"${i.message}\".`);\n      return t.getPageDict(e);\n    }\n  }\n  getPage(e) {\n    const t = this._pagePromises.get(e);\n    if (t) return t;\n    const {\n      catalog: i,\n      linearization: a,\n      xfaFactory: s\n    } = this;\n    let r;\n    r = s ? Promise.resolve([Dict.empty, null]) : a?.pageFirst === e ? this._getLinearizationPage(e) : i.getPageDict(e);\n    r = r.then(([t, a]) => new Page({\n      pdfManager: this.pdfManager,\n      xref: this.xref,\n      pageIndex: e,\n      pageDict: t,\n      ref: a,\n      globalIdFactory: this._globalIdFactory,\n      fontCache: i.fontCache,\n      builtInCMapCache: i.builtInCMapCache,\n      standardFontDataCache: i.standardFontDataCache,\n      globalImageCache: i.globalImageCache,\n      systemFontCache: i.systemFontCache,\n      nonBlendModesSet: i.nonBlendModesSet,\n      xfaFactory: s\n    }));\n    this._pagePromises.set(e, r);\n    return r;\n  }\n  async checkFirstPage(e = !1) {\n    if (!e) try {\n      await this.getPage(0);\n    } catch (e) {\n      if (e instanceof XRefEntryException) {\n        this._pagePromises.delete(0);\n        await this.cleanup();\n        throw new XRefParseException();\n      }\n    }\n  }\n  async checkLastPage(e = !1) {\n    const {\n      catalog: t,\n      pdfManager: i\n    } = this;\n    t.setActualNumPages();\n    let a;\n    try {\n      await Promise.all([i.ensureDoc(\"xfaFactory\"), i.ensureDoc(\"linearization\"), i.ensureCatalog(\"numPages\")]);\n      if (this.xfaFactory) return;\n      a = this.linearization ? this.linearization.numPages : t.numPages;\n      if (!Number.isInteger(a)) throw new FormatError(\"Page count is not an integer.\");\n      if (a <= 1) return;\n      await this.getPage(a - 1);\n    } catch (s) {\n      this._pagePromises.delete(a - 1);\n      await this.cleanup();\n      if (s instanceof XRefEntryException && !e) throw new XRefParseException();\n      warn(`checkLastPage - invalid /Pages tree /Count: ${a}.`);\n      let r;\n      try {\n        r = await t.getAllPageDicts(e);\n      } catch (i) {\n        if (i instanceof XRefEntryException && !e) throw new XRefParseException();\n        t.setActualNumPages(1);\n        return;\n      }\n      for (const [e, [a, s]] of r) {\n        let r;\n        if (a instanceof Error) {\n          r = Promise.reject(a);\n          r.catch(() => {});\n        } else r = Promise.resolve(new Page({\n          pdfManager: i,\n          xref: this.xref,\n          pageIndex: e,\n          pageDict: a,\n          ref: s,\n          globalIdFactory: this._globalIdFactory,\n          fontCache: t.fontCache,\n          builtInCMapCache: t.builtInCMapCache,\n          standardFontDataCache: t.standardFontDataCache,\n          globalImageCache: t.globalImageCache,\n          systemFontCache: t.systemFontCache,\n          nonBlendModesSet: t.nonBlendModesSet,\n          xfaFactory: null\n        }));\n        this._pagePromises.set(e, r);\n      }\n      t.setActualNumPages(r.size);\n    }\n  }\n  fontFallback(e, t) {\n    return this.catalog.fontFallback(e, t);\n  }\n  async cleanup(e = !1) {\n    return this.catalog ? this.catalog.cleanup(e) : clearGlobalCaches();\n  }\n  async #q(e, t, i, a, s) {\n    const {\n      xref: r\n    } = this;\n    if (!(t instanceof Ref) || s.has(t)) return;\n    s.put(t);\n    const n = await r.fetchAsync(t);\n    if (!(n instanceof Dict)) return;\n    if (n.has(\"T\")) {\n      const t = stringToPDFString(await n.getAsync(\"T\"));\n      e = \"\" === e ? t : `${e}.${t}`;\n    } else {\n      let t = n;\n      for (;;) {\n        t = t.getRaw(\"Parent\");\n        if (t instanceof Ref) {\n          if (s.has(t)) break;\n          t = await r.fetchAsync(t);\n        }\n        if (!(t instanceof Dict)) break;\n        if (t.has(\"T\")) {\n          const i = stringToPDFString(await t.getAsync(\"T\"));\n          e = \"\" === e ? i : `${e}.${i}`;\n          break;\n        }\n      }\n    }\n    i.has(e) || i.set(e, []);\n    i.get(e).push(AnnotationFactory.create(r, t, a, null, !0, null).then(e => e?.getFieldObject()).catch(function (e) {\n      warn(`#collectFieldObjects: \"${e}\".`);\n      return null;\n    }));\n    if (!n.has(\"Kids\")) return;\n    const g = await n.getAsync(\"Kids\");\n    if (Array.isArray(g)) for (const t of g) await this.#q(e, t, i, a, s);\n  }\n  get fieldObjects() {\n    if (!this.formInfo.hasFields) return shadow(this, \"fieldObjects\", Promise.resolve(null));\n    return shadow(this, \"fieldObjects\", Promise.all([this.pdfManager.ensureDoc(\"annotationGlobals\"), this.pdfManager.ensureCatalog(\"acroForm\")]).then(async ([e, t]) => {\n      if (!e) return null;\n      const i = new RefSet(),\n        a = Object.create(null),\n        s = new Map();\n      for (const a of await t.getAsync(\"Fields\")) await this.#q(\"\", a, s, e, i);\n      const r = [];\n      for (const [e, t] of s) r.push(Promise.all(t).then(t => {\n        (t = t.filter(e => !!e)).length > 0 && (a[e] = t);\n      }));\n      await Promise.all(r);\n      return a;\n    }));\n  }\n  get hasJSActions() {\n    return shadow(this, \"hasJSActions\", this.pdfManager.ensureDoc(\"_parseHasJSActions\"));\n  }\n  async _parseHasJSActions() {\n    const [e, t] = await Promise.all([this.pdfManager.ensureCatalog(\"jsActions\"), this.pdfManager.ensureDoc(\"fieldObjects\")]);\n    return !!e || !!t && Object.values(t).some(e => e.some(e => null !== e.actions));\n  }\n  get calculationOrderIds() {\n    const e = this.catalog.acroForm;\n    if (!e?.has(\"CO\")) return shadow(this, \"calculationOrderIds\", null);\n    const t = e.get(\"CO\");\n    if (!Array.isArray(t) || 0 === t.length) return shadow(this, \"calculationOrderIds\", null);\n    const i = [];\n    for (const e of t) e instanceof Ref && i.push(e.toString());\n    return 0 === i.length ? shadow(this, \"calculationOrderIds\", null) : shadow(this, \"calculationOrderIds\", i);\n  }\n  get annotationGlobals() {\n    return shadow(this, \"annotationGlobals\", AnnotationFactory.createGlobals(this.pdfManager));\n  }\n}\nclass BasePdfManager {\n  constructor(e) {\n    this.constructor === BasePdfManager && unreachable(\"Cannot initialize BasePdfManager.\");\n    this._docBaseUrl = function parseDocBaseUrl(e) {\n      if (e) {\n        const t = createValidAbsoluteUrl(e);\n        if (t) return t.href;\n        warn(`Invalid absolute docBaseUrl: \"${e}\".`);\n      }\n      return null;\n    }(e.docBaseUrl);\n    this._docId = e.docId;\n    this._password = e.password;\n    this.enableXfa = e.enableXfa;\n    e.evaluatorOptions.isOffscreenCanvasSupported &&= FeatureTest.isOffscreenCanvasSupported;\n    this.evaluatorOptions = Object.freeze(e.evaluatorOptions);\n  }\n  get docId() {\n    return this._docId;\n  }\n  get password() {\n    return this._password;\n  }\n  get docBaseUrl() {\n    return this._docBaseUrl;\n  }\n  get catalog() {\n    return this.pdfDocument.catalog;\n  }\n  ensureDoc(e, t) {\n    return this.ensure(this.pdfDocument, e, t);\n  }\n  ensureXRef(e, t) {\n    return this.ensure(this.pdfDocument.xref, e, t);\n  }\n  ensureCatalog(e, t) {\n    return this.ensure(this.pdfDocument.catalog, e, t);\n  }\n  getPage(e) {\n    return this.pdfDocument.getPage(e);\n  }\n  fontFallback(e, t) {\n    return this.pdfDocument.fontFallback(e, t);\n  }\n  loadXfaFonts(e, t) {\n    return this.pdfDocument.loadXfaFonts(e, t);\n  }\n  loadXfaImages() {\n    return this.pdfDocument.loadXfaImages();\n  }\n  serializeXfaData(e) {\n    return this.pdfDocument.serializeXfaData(e);\n  }\n  cleanup(e = !1) {\n    return this.pdfDocument.cleanup(e);\n  }\n  async ensure(e, t, i) {\n    unreachable(\"Abstract method `ensure` called\");\n  }\n  requestRange(e, t) {\n    unreachable(\"Abstract method `requestRange` called\");\n  }\n  requestLoadedStream(e = !1) {\n    unreachable(\"Abstract method `requestLoadedStream` called\");\n  }\n  sendProgressiveData(e) {\n    unreachable(\"Abstract method `sendProgressiveData` called\");\n  }\n  updatePassword(e) {\n    this._password = e;\n  }\n  terminate(e) {\n    unreachable(\"Abstract method `terminate` called\");\n  }\n}\nclass LocalPdfManager extends BasePdfManager {\n  constructor(e) {\n    super(e);\n    const t = new Stream(e.source);\n    this.pdfDocument = new PDFDocument(this, t);\n    this._loadedStreamPromise = Promise.resolve(t);\n  }\n  async ensure(e, t, i) {\n    const a = e[t];\n    return \"function\" == typeof a ? a.apply(e, i) : a;\n  }\n  requestRange(e, t) {\n    return Promise.resolve();\n  }\n  requestLoadedStream(e = !1) {\n    return this._loadedStreamPromise;\n  }\n  terminate(e) {}\n}\nclass NetworkPdfManager extends BasePdfManager {\n  constructor(e) {\n    super(e);\n    this.streamManager = new ChunkedStreamManager(e.source, {\n      msgHandler: e.handler,\n      length: e.length,\n      disableAutoFetch: e.disableAutoFetch,\n      rangeChunkSize: e.rangeChunkSize\n    });\n    this.pdfDocument = new PDFDocument(this, this.streamManager.getStream());\n  }\n  async ensure(e, t, i) {\n    try {\n      const a = e[t];\n      return \"function\" == typeof a ? a.apply(e, i) : a;\n    } catch (a) {\n      if (!(a instanceof MissingDataException)) throw a;\n      await this.requestRange(a.begin, a.end);\n      return this.ensure(e, t, i);\n    }\n  }\n  requestRange(e, t) {\n    return this.streamManager.requestRange(e, t);\n  }\n  requestLoadedStream(e = !1) {\n    return this.streamManager.requestAllChunks(e);\n  }\n  sendProgressiveData(e) {\n    this.streamManager.onReceiveData({\n      chunk: e\n    });\n  }\n  terminate(e) {\n    this.streamManager.abort(e);\n  }\n}\nconst og = 1,\n  Ig = 2,\n  cg = 1,\n  Cg = 2,\n  hg = 3,\n  Bg = 4,\n  lg = 5,\n  Qg = 6,\n  Eg = 7,\n  ug = 8;\nfunction wrapReason(e) {\n  e instanceof Error || \"object\" == typeof e && null !== e || unreachable('wrapReason: Expected \"reason\" to be a (possibly cloned) Error.');\n  switch (e.name) {\n    case \"AbortException\":\n      return new AbortException(e.message);\n    case \"MissingPDFException\":\n      return new MissingPDFException(e.message);\n    case \"PasswordException\":\n      return new PasswordException(e.message, e.code);\n    case \"UnexpectedResponseException\":\n      return new UnexpectedResponseException(e.message, e.status);\n    case \"UnknownErrorException\":\n      return new UnknownErrorException(e.message, e.details);\n    default:\n      return new UnknownErrorException(e.message, e.toString());\n  }\n}\nclass MessageHandler {\n  constructor(e, t, i) {\n    this.sourceName = e;\n    this.targetName = t;\n    this.comObj = i;\n    this.callbackId = 1;\n    this.streamId = 1;\n    this.streamSinks = Object.create(null);\n    this.streamControllers = Object.create(null);\n    this.callbackCapabilities = Object.create(null);\n    this.actionHandler = Object.create(null);\n    this._onComObjOnMessage = e => {\n      const t = e.data;\n      if (t.targetName !== this.sourceName) return;\n      if (t.stream) {\n        this.#O(t);\n        return;\n      }\n      if (t.callback) {\n        const e = t.callbackId,\n          i = this.callbackCapabilities[e];\n        if (!i) throw new Error(`Cannot resolve callback ${e}`);\n        delete this.callbackCapabilities[e];\n        if (t.callback === og) i.resolve(t.data);else {\n          if (t.callback !== Ig) throw new Error(\"Unexpected callback case\");\n          i.reject(wrapReason(t.reason));\n        }\n        return;\n      }\n      const a = this.actionHandler[t.action];\n      if (!a) throw new Error(`Unknown action from worker: ${t.action}`);\n      if (t.callbackId) {\n        const e = this.sourceName,\n          s = t.sourceName;\n        new Promise(function (e) {\n          e(a(t.data));\n        }).then(function (a) {\n          i.postMessage({\n            sourceName: e,\n            targetName: s,\n            callback: og,\n            callbackId: t.callbackId,\n            data: a\n          });\n        }, function (a) {\n          i.postMessage({\n            sourceName: e,\n            targetName: s,\n            callback: Ig,\n            callbackId: t.callbackId,\n            reason: wrapReason(a)\n          });\n        });\n      } else t.streamId ? this.#P(t) : a(t.data);\n    };\n    i.addEventListener(\"message\", this._onComObjOnMessage);\n  }\n  on(e, t) {\n    const i = this.actionHandler;\n    if (i[e]) throw new Error(`There is already an actionName called \"${e}\"`);\n    i[e] = t;\n  }\n  send(e, t, i) {\n    this.comObj.postMessage({\n      sourceName: this.sourceName,\n      targetName: this.targetName,\n      action: e,\n      data: t\n    }, i);\n  }\n  sendWithPromise(e, t, i) {\n    const a = this.callbackId++,\n      s = Promise.withResolvers();\n    this.callbackCapabilities[a] = s;\n    try {\n      this.comObj.postMessage({\n        sourceName: this.sourceName,\n        targetName: this.targetName,\n        action: e,\n        callbackId: a,\n        data: t\n      }, i);\n    } catch (e) {\n      s.reject(e);\n    }\n    return s.promise;\n  }\n  sendWithStream(e, t, i, a) {\n    const s = this.streamId++,\n      r = this.sourceName,\n      n = this.targetName,\n      g = this.comObj;\n    return new ReadableStream({\n      start: i => {\n        const o = Promise.withResolvers();\n        this.streamControllers[s] = {\n          controller: i,\n          startCall: o,\n          pullCall: null,\n          cancelCall: null,\n          isClosed: !1\n        };\n        g.postMessage({\n          sourceName: r,\n          targetName: n,\n          action: e,\n          streamId: s,\n          data: t,\n          desiredSize: i.desiredSize\n        }, a);\n        return o.promise;\n      },\n      pull: e => {\n        const t = Promise.withResolvers();\n        this.streamControllers[s].pullCall = t;\n        g.postMessage({\n          sourceName: r,\n          targetName: n,\n          stream: Qg,\n          streamId: s,\n          desiredSize: e.desiredSize\n        });\n        return t.promise;\n      },\n      cancel: e => {\n        assert(e instanceof Error, \"cancel must have a valid reason\");\n        const t = Promise.withResolvers();\n        this.streamControllers[s].cancelCall = t;\n        this.streamControllers[s].isClosed = !0;\n        g.postMessage({\n          sourceName: r,\n          targetName: n,\n          stream: cg,\n          streamId: s,\n          reason: wrapReason(e)\n        });\n        return t.promise;\n      }\n    }, i);\n  }\n  #P(e) {\n    const t = e.streamId,\n      i = this.sourceName,\n      a = e.sourceName,\n      s = this.comObj,\n      r = this,\n      n = this.actionHandler[e.action],\n      g = {\n        enqueue(e, r = 1, n) {\n          if (this.isCancelled) return;\n          const g = this.desiredSize;\n          this.desiredSize -= r;\n          if (g > 0 && this.desiredSize <= 0) {\n            this.sinkCapability = Promise.withResolvers();\n            this.ready = this.sinkCapability.promise;\n          }\n          s.postMessage({\n            sourceName: i,\n            targetName: a,\n            stream: Bg,\n            streamId: t,\n            chunk: e\n          }, n);\n        },\n        close() {\n          if (!this.isCancelled) {\n            this.isCancelled = !0;\n            s.postMessage({\n              sourceName: i,\n              targetName: a,\n              stream: hg,\n              streamId: t\n            });\n            delete r.streamSinks[t];\n          }\n        },\n        error(e) {\n          assert(e instanceof Error, \"error must have a valid reason\");\n          if (!this.isCancelled) {\n            this.isCancelled = !0;\n            s.postMessage({\n              sourceName: i,\n              targetName: a,\n              stream: lg,\n              streamId: t,\n              reason: wrapReason(e)\n            });\n          }\n        },\n        sinkCapability: Promise.withResolvers(),\n        onPull: null,\n        onCancel: null,\n        isCancelled: !1,\n        desiredSize: e.desiredSize,\n        ready: null\n      };\n    g.sinkCapability.resolve();\n    g.ready = g.sinkCapability.promise;\n    this.streamSinks[t] = g;\n    new Promise(function (t) {\n      t(n(e.data, g));\n    }).then(function () {\n      s.postMessage({\n        sourceName: i,\n        targetName: a,\n        stream: ug,\n        streamId: t,\n        success: !0\n      });\n    }, function (e) {\n      s.postMessage({\n        sourceName: i,\n        targetName: a,\n        stream: ug,\n        streamId: t,\n        reason: wrapReason(e)\n      });\n    });\n  }\n  #O(e) {\n    const t = e.streamId,\n      i = this.sourceName,\n      a = e.sourceName,\n      s = this.comObj,\n      r = this.streamControllers[t],\n      n = this.streamSinks[t];\n    switch (e.stream) {\n      case ug:\n        e.success ? r.startCall.resolve() : r.startCall.reject(wrapReason(e.reason));\n        break;\n      case Eg:\n        e.success ? r.pullCall.resolve() : r.pullCall.reject(wrapReason(e.reason));\n        break;\n      case Qg:\n        if (!n) {\n          s.postMessage({\n            sourceName: i,\n            targetName: a,\n            stream: Eg,\n            streamId: t,\n            success: !0\n          });\n          break;\n        }\n        n.desiredSize <= 0 && e.desiredSize > 0 && n.sinkCapability.resolve();\n        n.desiredSize = e.desiredSize;\n        new Promise(function (e) {\n          e(n.onPull?.());\n        }).then(function () {\n          s.postMessage({\n            sourceName: i,\n            targetName: a,\n            stream: Eg,\n            streamId: t,\n            success: !0\n          });\n        }, function (e) {\n          s.postMessage({\n            sourceName: i,\n            targetName: a,\n            stream: Eg,\n            streamId: t,\n            reason: wrapReason(e)\n          });\n        });\n        break;\n      case Bg:\n        assert(r, \"enqueue should have stream controller\");\n        if (r.isClosed) break;\n        r.controller.enqueue(e.chunk);\n        break;\n      case hg:\n        assert(r, \"close should have stream controller\");\n        if (r.isClosed) break;\n        r.isClosed = !0;\n        r.controller.close();\n        this.#W(r, t);\n        break;\n      case lg:\n        assert(r, \"error should have stream controller\");\n        r.controller.error(wrapReason(e.reason));\n        this.#W(r, t);\n        break;\n      case Cg:\n        e.success ? r.cancelCall.resolve() : r.cancelCall.reject(wrapReason(e.reason));\n        this.#W(r, t);\n        break;\n      case cg:\n        if (!n) break;\n        new Promise(function (t) {\n          t(n.onCancel?.(wrapReason(e.reason)));\n        }).then(function () {\n          s.postMessage({\n            sourceName: i,\n            targetName: a,\n            stream: Cg,\n            streamId: t,\n            success: !0\n          });\n        }, function (e) {\n          s.postMessage({\n            sourceName: i,\n            targetName: a,\n            stream: Cg,\n            streamId: t,\n            reason: wrapReason(e)\n          });\n        });\n        n.sinkCapability.reject(wrapReason(e.reason));\n        n.isCancelled = !0;\n        delete this.streamSinks[t];\n        break;\n      default:\n        throw new Error(\"Unexpected stream case\");\n    }\n  }\n  async #W(e, t) {\n    await Promise.allSettled([e.startCall?.promise, e.pullCall?.promise, e.cancelCall?.promise]);\n    delete this.streamControllers[t];\n  }\n  destroy() {\n    this.comObj.removeEventListener(\"message\", this._onComObjOnMessage);\n  }\n}\nclass PDFWorkerStream {\n  constructor(e) {\n    this._msgHandler = e;\n    this._contentLength = null;\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n  getFullReader() {\n    assert(!this._fullRequestReader, \"PDFWorkerStream.getFullReader can only be called once.\");\n    this._fullRequestReader = new PDFWorkerStreamReader(this._msgHandler);\n    return this._fullRequestReader;\n  }\n  getRangeReader(e, t) {\n    const i = new PDFWorkerStreamRangeReader(e, t, this._msgHandler);\n    this._rangeRequestReaders.push(i);\n    return i;\n  }\n  cancelAllRequests(e) {\n    this._fullRequestReader?.cancel(e);\n    for (const t of this._rangeRequestReaders.slice(0)) t.cancel(e);\n  }\n}\nclass PDFWorkerStreamReader {\n  constructor(e) {\n    this._msgHandler = e;\n    this.onProgress = null;\n    this._contentLength = null;\n    this._isRangeSupported = !1;\n    this._isStreamingSupported = !1;\n    const t = this._msgHandler.sendWithStream(\"GetReader\");\n    this._reader = t.getReader();\n    this._headersReady = this._msgHandler.sendWithPromise(\"ReaderHeadersReady\").then(e => {\n      this._isStreamingSupported = e.isStreamingSupported;\n      this._isRangeSupported = e.isRangeSupported;\n      this._contentLength = e.contentLength;\n    });\n  }\n  get headersReady() {\n    return this._headersReady;\n  }\n  get contentLength() {\n    return this._contentLength;\n  }\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n  get isRangeSupported() {\n    return this._isRangeSupported;\n  }\n  async read() {\n    const {\n      value: e,\n      done: t\n    } = await this._reader.read();\n    return t ? {\n      value: void 0,\n      done: !0\n    } : {\n      value: e.buffer,\n      done: !1\n    };\n  }\n  cancel(e) {\n    this._reader.cancel(e);\n  }\n}\nclass PDFWorkerStreamRangeReader {\n  constructor(e, t, i) {\n    this._msgHandler = i;\n    this.onProgress = null;\n    const a = this._msgHandler.sendWithStream(\"GetRangeReader\", {\n      begin: e,\n      end: t\n    });\n    this._reader = a.getReader();\n  }\n  get isStreamingSupported() {\n    return !1;\n  }\n  async read() {\n    const {\n      value: e,\n      done: t\n    } = await this._reader.read();\n    return t ? {\n      value: void 0,\n      done: !0\n    } : {\n      value: e.buffer,\n      done: !1\n    };\n  }\n  cancel(e) {\n    this._reader.cancel(e);\n  }\n}\nclass WorkerTask {\n  constructor(e) {\n    this.name = e;\n    this.terminated = !1;\n    this._capability = Promise.withResolvers();\n  }\n  get finished() {\n    return this._capability.promise;\n  }\n  finish() {\n    this._capability.resolve();\n  }\n  terminate() {\n    this.terminated = !0;\n  }\n  ensureNotTerminated() {\n    if (this.terminated) throw new Error(\"Worker task was terminated\");\n  }\n}\nclass WorkerMessageHandler {\n  static setup(e, t) {\n    let i = !1;\n    e.on(\"test\", function (t) {\n      if (!i) {\n        i = !0;\n        e.send(\"test\", t instanceof Uint8Array);\n      }\n    });\n    e.on(\"configure\", function (e) {\n      !function setVerbosityLevel(e) {\n        Number.isInteger(e) && (st = e);\n      }(e.verbosity);\n    });\n    e.on(\"GetDocRequest\", function (e) {\n      return WorkerMessageHandler.createDocumentHandler(e, t);\n    });\n  }\n  static createDocumentHandler(e, t) {\n    let i,\n      a = !1,\n      s = null;\n    const r = new Set(),\n      n = getVerbosityLevel(),\n      {\n        docId: g,\n        apiVersion: o\n      } = e,\n      c = \"4.4.168\";\n    if (o !== c) throw new Error(`The API version \"${o}\" does not match the Worker version \"${c}\".`);\n    const C = [];\n    for (const e in []) C.push(e);\n    if (C.length) throw new Error(\"The `Array.prototype` contains unexpected enumerable properties: \" + C.join(\", \") + \"; thus breaking e.g. `for...in` iteration of `Array`s.\");\n    const h = g + \"_worker\";\n    let l = new MessageHandler(h, g, t);\n    function ensureNotTerminated() {\n      if (a) throw new Error(\"Worker was terminated\");\n    }\n    function startWorkerTask(e) {\n      r.add(e);\n    }\n    function finishWorkerTask(e) {\n      e.finish();\n      r.delete(e);\n    }\n    async function loadDocument(e) {\n      await i.ensureDoc(\"checkHeader\");\n      await i.ensureDoc(\"parseStartXRef\");\n      await i.ensureDoc(\"parse\", [e]);\n      await i.ensureDoc(\"checkFirstPage\", [e]);\n      await i.ensureDoc(\"checkLastPage\", [e]);\n      const t = await i.ensureDoc(\"isPureXfa\");\n      if (t) {\n        const e = new WorkerTask(\"loadXfaFonts\");\n        startWorkerTask(e);\n        await Promise.all([i.loadXfaFonts(l, e).catch(e => {}).then(() => finishWorkerTask(e)), i.loadXfaImages()]);\n      }\n      const [a, s] = await Promise.all([i.ensureDoc(\"numPages\"), i.ensureDoc(\"fingerprints\")]);\n      return {\n        numPages: a,\n        fingerprints: s,\n        htmlForXfa: t ? await i.ensureDoc(\"htmlForXfa\") : null\n      };\n    }\n    function getPdfManager({\n      data: e,\n      password: t,\n      disableAutoFetch: i,\n      rangeChunkSize: a,\n      length: r,\n      docBaseUrl: n,\n      enableXfa: o,\n      evaluatorOptions: c\n    }) {\n      const C = {\n          source: null,\n          disableAutoFetch: i,\n          docBaseUrl: n,\n          docId: g,\n          enableXfa: o,\n          evaluatorOptions: c,\n          handler: l,\n          length: r,\n          password: t,\n          rangeChunkSize: a\n        },\n        h = Promise.withResolvers();\n      let Q;\n      if (e) {\n        try {\n          C.source = e;\n          Q = new LocalPdfManager(C);\n          h.resolve(Q);\n        } catch (e) {\n          h.reject(e);\n        }\n        return h.promise;\n      }\n      let E,\n        u = [];\n      try {\n        E = new PDFWorkerStream(l);\n      } catch (e) {\n        h.reject(e);\n        return h.promise;\n      }\n      const d = E.getFullReader();\n      d.headersReady.then(function () {\n        if (d.isRangeSupported) {\n          C.source = E;\n          C.length = d.contentLength;\n          C.disableAutoFetch ||= d.isStreamingSupported;\n          Q = new NetworkPdfManager(C);\n          for (const e of u) Q.sendProgressiveData(e);\n          u = [];\n          h.resolve(Q);\n          s = null;\n        }\n      }).catch(function (e) {\n        h.reject(e);\n        s = null;\n      });\n      let f = 0;\n      new Promise(function (e, t) {\n        const readChunk = function ({\n          value: e,\n          done: i\n        }) {\n          try {\n            ensureNotTerminated();\n            if (i) {\n              Q || function () {\n                const e = arrayBuffersToBytes(u);\n                r && e.length !== r && warn(\"reported HTTP length is different from actual\");\n                try {\n                  C.source = e;\n                  Q = new LocalPdfManager(C);\n                  h.resolve(Q);\n                } catch (e) {\n                  h.reject(e);\n                }\n                u = [];\n              }();\n              s = null;\n              return;\n            }\n            f += e.byteLength;\n            d.isStreamingSupported || l.send(\"DocProgress\", {\n              loaded: f,\n              total: Math.max(f, d.contentLength || 0)\n            });\n            Q ? Q.sendProgressiveData(e) : u.push(e);\n            d.read().then(readChunk, t);\n          } catch (e) {\n            t(e);\n          }\n        };\n        d.read().then(readChunk, t);\n      }).catch(function (e) {\n        h.reject(e);\n        s = null;\n      });\n      s = function (e) {\n        E.cancelAllRequests(e);\n      };\n      return h.promise;\n    }\n    l.on(\"GetPage\", function (e) {\n      return i.getPage(e.pageIndex).then(function (e) {\n        return Promise.all([i.ensure(e, \"rotate\"), i.ensure(e, \"ref\"), i.ensure(e, \"userUnit\"), i.ensure(e, \"view\")]).then(function ([e, t, i, a]) {\n          return {\n            rotate: e,\n            ref: t,\n            refStr: t?.toString() ?? null,\n            userUnit: i,\n            view: a\n          };\n        });\n      });\n    });\n    l.on(\"GetPageIndex\", function (e) {\n      const t = Ref.get(e.num, e.gen);\n      return i.ensureCatalog(\"getPageIndex\", [t]);\n    });\n    l.on(\"GetDestinations\", function (e) {\n      return i.ensureCatalog(\"destinations\");\n    });\n    l.on(\"GetDestination\", function (e) {\n      return i.ensureCatalog(\"getDestination\", [e.id]);\n    });\n    l.on(\"GetPageLabels\", function (e) {\n      return i.ensureCatalog(\"pageLabels\");\n    });\n    l.on(\"GetPageLayout\", function (e) {\n      return i.ensureCatalog(\"pageLayout\");\n    });\n    l.on(\"GetPageMode\", function (e) {\n      return i.ensureCatalog(\"pageMode\");\n    });\n    l.on(\"GetViewerPreferences\", function (e) {\n      return i.ensureCatalog(\"viewerPreferences\");\n    });\n    l.on(\"GetOpenAction\", function (e) {\n      return i.ensureCatalog(\"openAction\");\n    });\n    l.on(\"GetAttachments\", function (e) {\n      return i.ensureCatalog(\"attachments\");\n    });\n    l.on(\"GetDocJSActions\", function (e) {\n      return i.ensureCatalog(\"jsActions\");\n    });\n    l.on(\"GetPageJSActions\", function ({\n      pageIndex: e\n    }) {\n      return i.getPage(e).then(function (e) {\n        return i.ensure(e, \"jsActions\");\n      });\n    });\n    l.on(\"GetOutline\", function (e) {\n      return i.ensureCatalog(\"documentOutline\");\n    });\n    l.on(\"GetOptionalContentConfig\", function (e) {\n      return i.ensureCatalog(\"optionalContentConfig\");\n    });\n    l.on(\"GetPermissions\", function (e) {\n      return i.ensureCatalog(\"permissions\");\n    });\n    l.on(\"GetMetadata\", function (e) {\n      return Promise.all([i.ensureDoc(\"documentInfo\"), i.ensureCatalog(\"metadata\")]);\n    });\n    l.on(\"GetMarkInfo\", function (e) {\n      return i.ensureCatalog(\"markInfo\");\n    });\n    l.on(\"GetData\", function (e) {\n      return i.requestLoadedStream().then(function (e) {\n        return e.bytes;\n      });\n    });\n    l.on(\"GetAnnotations\", function ({\n      pageIndex: e,\n      intent: t\n    }) {\n      return i.getPage(e).then(function (i) {\n        const a = new WorkerTask(`GetAnnotations: page ${e}`);\n        startWorkerTask(a);\n        return i.getAnnotationsData(l, a, t).then(e => {\n          finishWorkerTask(a);\n          return e;\n        }, e => {\n          finishWorkerTask(a);\n          throw e;\n        });\n      });\n    });\n    l.on(\"GetFieldObjects\", function (e) {\n      return i.ensureDoc(\"fieldObjects\");\n    });\n    l.on(\"HasJSActions\", function (e) {\n      return i.ensureDoc(\"hasJSActions\");\n    });\n    l.on(\"GetCalculationOrderIds\", function (e) {\n      return i.ensureDoc(\"calculationOrderIds\");\n    });\n    l.on(\"SaveDocument\", async function ({\n      isPureXfa: e,\n      numPages: t,\n      annotationStorage: a,\n      filename: s\n    }) {\n      const r = [i.requestLoadedStream(), i.ensureCatalog(\"acroForm\"), i.ensureCatalog(\"acroFormRef\"), i.ensureDoc(\"startXRef\"), i.ensureDoc(\"xref\"), i.ensureDoc(\"linearization\"), i.ensureCatalog(\"structTreeRoot\")],\n        n = [],\n        g = e ? null : getNewAnnotationsMap(a),\n        [o, c, C, h, Q, E, u] = await Promise.all(r),\n        d = Q.trailer.getRaw(\"Root\") || null;\n      let f;\n      if (g) {\n        u ? (await u.canUpdateStructTree({\n          pdfManager: i,\n          xref: Q,\n          newAnnotationsByPage: g\n        })) && (f = u) : (await StructTreeRoot.canCreateStructureTree({\n          catalogRef: d,\n          pdfManager: i,\n          newAnnotationsByPage: g\n        })) && (f = null);\n        const e = AnnotationFactory.generateImages(a.values(), Q, i.evaluatorOptions.isOffscreenCanvasSupported),\n          t = void 0 === f ? n : [];\n        for (const [a, s] of g) t.push(i.getPage(a).then(t => {\n          const i = new WorkerTask(`Save (editor): page ${a}`);\n          return t.saveNewAnnotations(l, i, s, e).finally(function () {\n            finishWorkerTask(i);\n          });\n        }));\n        null === f ? n.push(Promise.all(t).then(async e => {\n          await StructTreeRoot.createStructureTree({\n            newAnnotationsByPage: g,\n            xref: Q,\n            catalogRef: d,\n            pdfManager: i,\n            newRefs: e\n          });\n          return e;\n        })) : f && n.push(Promise.all(t).then(async e => {\n          await f.updateStructureTree({\n            newAnnotationsByPage: g,\n            pdfManager: i,\n            newRefs: e\n          });\n          return e;\n        }));\n      }\n      if (e) n.push(i.serializeXfaData(a));else for (let e = 0; e < t; e++) n.push(i.getPage(e).then(function (t) {\n        const i = new WorkerTask(`Save: page ${e}`);\n        return t.save(l, i, a).finally(function () {\n          finishWorkerTask(i);\n        });\n      }));\n      const p = await Promise.all(n);\n      let m = [],\n        y = null;\n      if (e) {\n        y = p[0];\n        if (!y) return o.bytes;\n      } else {\n        m = p.flat(2);\n        if (0 === m.length) return o.bytes;\n      }\n      const w = C && c instanceof Dict && m.some(e => e.needAppearances),\n        D = c instanceof Dict && c.get(\"XFA\") || null;\n      let b = null,\n        F = !1;\n      if (Array.isArray(D)) {\n        for (let e = 0, t = D.length; e < t; e += 2) if (\"datasets\" === D[e]) {\n          b = D[e + 1];\n          F = !0;\n        }\n        null === b && (b = Q.getNewTemporaryRef());\n      } else D && warn(\"Unsupported XFA type.\");\n      let S = Object.create(null);\n      if (Q.trailer) {\n        const e = Object.create(null),\n          t = Q.trailer.get(\"Info\") || null;\n        t instanceof Dict && t.forEach((t, i) => {\n          \"string\" == typeof i && (e[t] = stringToPDFString(i));\n        });\n        S = {\n          rootRef: d,\n          encryptRef: Q.trailer.getRaw(\"Encrypt\") || null,\n          newRef: Q.getNewTemporaryRef(),\n          infoRef: Q.trailer.getRaw(\"Info\") || null,\n          info: e,\n          fileIds: Q.trailer.get(\"ID\") || null,\n          startXRef: E ? h : Q.lastXRefStreamPos ?? h,\n          filename: s\n        };\n      }\n      return incrementalUpdate({\n        originalData: o.bytes,\n        xrefInfo: S,\n        newRefs: m,\n        xref: Q,\n        hasXfa: !!D,\n        xfaDatasetsRef: b,\n        hasXfaDatasetsEntry: F,\n        needAppearances: w,\n        acroFormRef: C,\n        acroForm: c,\n        xfaData: y,\n        useXrefStream: isDict(Q.topDict, \"XRef\")\n      }).finally(() => {\n        Q.resetNewTemporaryRef();\n      });\n    });\n    l.on(\"GetOperatorList\", function (e, t) {\n      const a = e.pageIndex;\n      i.getPage(a).then(function (i) {\n        const s = new WorkerTask(`GetOperatorList: page ${a}`);\n        startWorkerTask(s);\n        const r = n >= pA.INFOS ? Date.now() : 0;\n        i.getOperatorList({\n          handler: l,\n          sink: t,\n          task: s,\n          intent: e.intent,\n          cacheKey: e.cacheKey,\n          annotationStorage: e.annotationStorage\n        }).then(function (e) {\n          finishWorkerTask(s);\n          r && info(`page=${a + 1} - getOperatorList: time=${Date.now() - r}ms, len=${e.length}`);\n          t.close();\n        }, function (e) {\n          finishWorkerTask(s);\n          s.terminated || t.error(e);\n        });\n      });\n    });\n    l.on(\"GetTextContent\", function (e, t) {\n      const {\n        pageIndex: a,\n        includeMarkedContent: s,\n        disableNormalization: r\n      } = e;\n      i.getPage(a).then(function (e) {\n        const i = new WorkerTask(\"GetTextContent: page \" + a);\n        startWorkerTask(i);\n        const g = n >= pA.INFOS ? Date.now() : 0;\n        e.extractTextContent({\n          handler: l,\n          task: i,\n          sink: t,\n          includeMarkedContent: s,\n          disableNormalization: r\n        }).then(function () {\n          finishWorkerTask(i);\n          g && info(`page=${a + 1} - getTextContent: time=` + (Date.now() - g) + \"ms\");\n          t.close();\n        }, function (e) {\n          finishWorkerTask(i);\n          i.terminated || t.error(e);\n        });\n      });\n    });\n    l.on(\"GetStructTree\", function (e) {\n      return i.getPage(e.pageIndex).then(function (e) {\n        return i.ensure(e, \"getStructTree\");\n      });\n    });\n    l.on(\"FontFallback\", function (e) {\n      return i.fontFallback(e.id, l);\n    });\n    l.on(\"Cleanup\", function (e) {\n      return i.cleanup(!0);\n    });\n    l.on(\"Terminate\", function (e) {\n      a = !0;\n      const t = [];\n      if (i) {\n        i.terminate(new AbortException(\"Worker was terminated.\"));\n        const e = i.cleanup();\n        t.push(e);\n        i = null;\n      } else clearGlobalCaches();\n      s && s(new AbortException(\"Worker was terminated.\"));\n      for (const e of r) {\n        t.push(e.finished);\n        e.terminate();\n      }\n      return Promise.all(t).then(function () {\n        l.destroy();\n        l = null;\n      });\n    });\n    l.on(\"Ready\", function (t) {\n      !function setupDoc(e) {\n        function onSuccess(e) {\n          ensureNotTerminated();\n          l.send(\"GetDoc\", {\n            pdfInfo: e\n          });\n        }\n        function onFailure(e) {\n          ensureNotTerminated();\n          if (e instanceof PasswordException) {\n            const t = new WorkerTask(`PasswordException: response ${e.code}`);\n            startWorkerTask(t);\n            l.sendWithPromise(\"PasswordRequest\", e).then(function ({\n              password: e\n            }) {\n              finishWorkerTask(t);\n              i.updatePassword(e);\n              pdfManagerReady();\n            }).catch(function () {\n              finishWorkerTask(t);\n              l.send(\"DocException\", e);\n            });\n          } else e instanceof InvalidPDFException || e instanceof MissingPDFException || e instanceof UnexpectedResponseException || e instanceof UnknownErrorException ? l.send(\"DocException\", e) : l.send(\"DocException\", new UnknownErrorException(e.message, e.toString()));\n        }\n        function pdfManagerReady() {\n          ensureNotTerminated();\n          loadDocument(!1).then(onSuccess, function (e) {\n            ensureNotTerminated();\n            e instanceof XRefParseException ? i.requestLoadedStream().then(function () {\n              ensureNotTerminated();\n              loadDocument(!0).then(onSuccess, onFailure);\n            }) : onFailure(e);\n          });\n        }\n        ensureNotTerminated();\n        getPdfManager(e).then(function (e) {\n          if (a) {\n            e.terminate(new AbortException(\"Worker was terminated.\"));\n            throw new Error(\"Worker was terminated\");\n          }\n          i = e;\n          i.requestLoadedStream(!0).then(e => {\n            l.send(\"DataLoaded\", {\n              length: e.bytes.byteLength\n            });\n          });\n        }).then(pdfManagerReady, onFailure);\n      }(e);\n      e = null;\n    });\n    return h;\n  }\n  static initializeFromPort(e) {\n    const t = new MessageHandler(\"worker\", \"main\", e);\n    WorkerMessageHandler.setup(t, e);\n    t.send(\"ready\", null);\n  }\n}\n\"undefined\" == typeof window && !t && \"undefined\" != typeof self && function isMessagePort(e) {\n  return \"function\" == typeof e.postMessage && \"onmessage\" in e;\n}(self) && WorkerMessageHandler.initializeFromPort(self);\nvar dg = __webpack_exports__.WorkerMessageHandler;\nexport { dg as WorkerMessageHandler };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}